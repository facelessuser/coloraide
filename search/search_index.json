{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Setup Currently in Alpha While ColorAide is very usable, it is currently in an alpha stage. While that doesn't necessarily mean buggy, it does mean the API could be unstable. Overview ColorAide is a color library for Python with the intent to provide an easy to use interface to work with colors. While ColorAide is not just for CSS colors, there is a focus on supporting modern CSS color syntax as it is a format that is very commonly used. In addition to being able to parse almost all colors as specified in the CSS specifications, ColorAide also supports a number of colors and formats for colors that are not in the CSS specifications. ColorAide is built on the idea of having a general color object in which you can easily manipulate a color, convert between colors in different spaces, and perform color related functions: interpolation, color distancing, color contrast, etc. In the process of developing ColorAide, we also stumbled upon the JavaScript library Color.js which is created/maintained by the co-authors of some of the recent CSS color specifications. This project became heavily influenced by Color.js as it adopted a model we were already interested in. While our aim was not to port that library and be a 1:1 copy of it, it provided much clarity on the CSS specification and, in the end, left a clear impression on our API. With ColorAide, you can create colors: >>> from coloraide import Color >>> c = Color ( 'red' ) >>> c . to_string () rgb(255 0 0) Convert colors: >>> from coloraide import Color >>> Color ( 'red' ) . convert ( 'hsl' ) . to_string () hsl(0 100% 50%) Modify colors: >>> from coloraide import Color >>> Color ( 'red' ) . set ( \"lch.chroma\" , 30 ) . to_string () rgb(173.81 114.29 97.218) Mix colors: >>> from coloraide import Color >>> Color ( \"blue\" ) . mix ( \"yellow\" , space = \"lch\" ) . to_string () rgb(255 65.751 107.47) And much more! Installation ColorAide can be installed via Python's pip : $ pip install coloraide","title":"Setup"},{"location":"#setup","text":"Currently in Alpha While ColorAide is very usable, it is currently in an alpha stage. While that doesn't necessarily mean buggy, it does mean the API could be unstable.","title":"Setup"},{"location":"#overview","text":"ColorAide is a color library for Python with the intent to provide an easy to use interface to work with colors. While ColorAide is not just for CSS colors, there is a focus on supporting modern CSS color syntax as it is a format that is very commonly used. In addition to being able to parse almost all colors as specified in the CSS specifications, ColorAide also supports a number of colors and formats for colors that are not in the CSS specifications. ColorAide is built on the idea of having a general color object in which you can easily manipulate a color, convert between colors in different spaces, and perform color related functions: interpolation, color distancing, color contrast, etc. In the process of developing ColorAide, we also stumbled upon the JavaScript library Color.js which is created/maintained by the co-authors of some of the recent CSS color specifications. This project became heavily influenced by Color.js as it adopted a model we were already interested in. While our aim was not to port that library and be a 1:1 copy of it, it provided much clarity on the CSS specification and, in the end, left a clear impression on our API. With ColorAide, you can create colors: >>> from coloraide import Color >>> c = Color ( 'red' ) >>> c . to_string () rgb(255 0 0) Convert colors: >>> from coloraide import Color >>> Color ( 'red' ) . convert ( 'hsl' ) . to_string () hsl(0 100% 50%) Modify colors: >>> from coloraide import Color >>> Color ( 'red' ) . set ( \"lch.chroma\" , 30 ) . to_string () rgb(173.81 114.29 97.218) Mix colors: >>> from coloraide import Color >>> Color ( \"blue\" ) . mix ( \"yellow\" , space = \"lch\" ) . to_string () rgb(255 65.751 107.47) And much more!","title":"Overview"},{"location":"#installation","text":"ColorAide can be installed via Python's pip : $ pip install coloraide","title":"Installation"},{"location":"color/","text":"The Color Object Creating Colors The Color object can be imported from coloraide . from coloraide import Color Afterwards, colors can be created using various, valid CSS syntax: >>> Color ( \"red\" ), (color(srgb 1 0 0 / 1),) >>> Color ( \"#00ff00\" ), (color(srgb 0 1 0 / 1),) >>> Color ( \"rgb(0 0 255 / 1)\" ) color(srgb 0 0 1 / 1) In general, each color space can be recognized using valid CSS syntax as specified in the CSS level 4 spec. All colors, even colors not officially supported in the CSS spec, can be specified using the generic CSS color function: color ( space coord1 , coord2 , ... / alpha ) . While the color () function in CSS does not explicitly support color spaces with angular channels (hues), it has been adapted to support cylindrical colors, and is generally used as a generic, input and default for string representation of colors. >>> Color ( 'color(hsl 130 40 % 75% / 0.5)' ) color(hsl 130 40% 75% / 0.5) While CSS input is useful, we can also insert raw data points directly. When doing things this way, we must be mindful of the actual accepted input range. For instance, RGB colors are not specified in ranges from 0 - 255, but from 0 - 1. Raw inputs are always accepted exactly as they are specified and are treated as the user directly setting the channels. >>> Color ( \"srgb\" , [ 0.5 , 0 , 1 ], 0.3 ) color(srgb 0.5 0 1 / 0.3) If another color instance is passed as the input, a new color will be created, essentially cloning the passed object. >>> c1 = Color ( 'red' ) >>> c2 = Color ( c1 ) >>> c1 , c2 (color(srgb 1 0 0 / 1), color(srgb 1 0 0 / 1)) You can also use the new method to generate new colors from already instantiated colors. >>> color1 = Color ( \"red\" ) >>> color1 color(srgb 1 0 0 / 1) >>> color1 . new ( \"blue\" ) color(srgb 0 0 1 / 1) Cloning The clone method is an easy way to duplicate the current color object. Here we clone the green object so we have two. >>> c1 = Color ( \"green\" ) >>> c1 color(srgb 0 0.50196 0 / 1) >>> c1 . clone () color(srgb 0 0.50196 0 / 1) Updating A color can be \"updated\" using another color object. When an update occurs, the current color space is updated with the data from the second color, but the color space does not change. It is basically the equivalent of converting the second color to the color space of the first and then updating all the coordinates (including alpha). The input parameters are identical to the new method, so we can use a color object, a color string, or even raw data points. Here we update the color red to the color blue : >>> Color ( \"red\" ) color(srgb 1 0 0 / 1) >>> Color ( \"red\" ) . update ( Color ( \"blue\" )) color(srgb 0 0 1 / 1) Here we update the sRGB red with the color lch ( 80 % 50 130 ) . >>> Color ( \"red\" ) . update ( \"lch(80% 50 130)\" ) color(srgb 0.60398 0.83979 0.48395 / 1) Mutating \"Mutating\" is similar to updating except that it will update the color and the color space from another color. The input parameters are identical to the new method, so we can use a color object, a color string, or even raw data points. Here the red color object literally becomes an CIELCH color object with the new color lch ( 80 % 50 130 ) . >>> Color ( \"red\" ) . mutate ( \"lch(80% 50 130)\" ) color(lch 80% 50 130 / 1) Converting Colors can be converted to other color spaces as needed. Converting will always return a new color unless in_place is set True , in which case the current color will be mutated to the new converted color. For instance, if we had a color yellow , and we needed to work with it in another color space, such as CIELAB, we could simply call the convert method with the desired color space. >>> Color ( 'yellow' ) . convert ( \"lab\" ) color(lab 97.607% -15.753 93.388 / 1) Color Matching Color objects can take in raw data points or a CSS style string input. The string matching logic is exposed via the match method. By default, we can just give it a string, and it will return a ColorMatch object. The ColorMatch object will have the matched color as a Color object, and the start and end points it was located at. >>> Color . match ( \"red\" ) ColorMatch(color=color(srgb 1 0 0 / 1), start=0, end=3) By default it matches at the start of the buffer and returns a color if it finds one. If desired, we can do a fullmatch which requires the entire buffer to match the color. >>> Color . match ( \"red and yellow\" ) ColorMatch(color=color(srgb 1 0 0 / 1), start=0, end=3) >>> Color . match ( \"red and yellow\" , fullmatch = True ) We can also adjust the start position of the search. In this case, by adjusting the start position to 8 characters later, we will match yellow instead of red . >>> Color . match ( \"red and yellow\" , start = 8 ) ColorMatch(color=color(srgb 1 1 0 / 1), start=8, end=14) If desired, we can also filter out the CSS syntax of certain color spaces. In the following example, we will only target HSL colors. >>> Color . match ( \"red and yellow\" , filters = [ \"hsl\" ]) >>> Color . match ( \"hsl(130 30 % 75% )\" , filters = [ \"hsl\" ]) ColorMatch(color=color(hsl 130 30% 75% / 1), start=0, end=16) A method to find all colors in a buffer is not provided as looping through all the color spaces and matching all potential colors on every character is not really efficient. What is recommended would be to apply this with some logic to find potential places in the buffer to test, and only test those places. In this example, we construct a regex to find places within the buffer that potentially have a valid color, but we also try and filter out cases that are unfavorable, particularly in HTML or CSS. We don't want to match hex in HTML entities or color names that are part of color variables ( var ( --color-red ) ). >>> import re >>> from coloraide import Color >>> RE_COLOR_START = re . compile ( r \"(?i)(?:\\b(?<![-#&$])(?:color|hsla?|lch|lab|hwb|rgba?)\\(|\\b(?<![-#&$])[\\w]{3,}(?![(-])\\b|(?<![&])#)\" ) >>> text = \"\"\"Red and yellow are colors. So are #000088 and lch(75% 50 50).\"\"\" >>> colors = [] >>> for m in RE_COLOR_START . finditer ( text ): ... start = m . start () ... mcolor = Color . match ( text , start = start ) ... if mcolor is not None : ... colors . append ( mcolor . color ) ... >>> [ x . to_string () for x in colors ] ['rgb(255 0 0)', 'rgb(255 255 0)', 'rgb(0 0 136)', 'lch(75% 50 50)'] Override Default Settings ColorAide has a couple of default settings, such as the default precision for string outputs, default gamut mapping mode, etc. All of these options can be set on-demand when calling certain functions. When not explicitly set, some default is used. If needed, the defaults can be changed for an entire application or library. To do so, simply subclass the Color object and override the defaults. Then the new derived class can be used throughout an application or library. >>> class Color2 ( Color ): ... PRECISION = 3 ... >>> Color ( 'rgb(128.12345 0 128.12345)' ) . to_string () rgb(128.12 0 128.12) >>> Color2 ( 'rgb(128.12345 0 128.12345)' ) . to_string () rgb(128 0 128) Properties Description FIT The default gamut mapping method used by the Color object. DELTA_E The default delta E algorithm used for gamut distancing calls internally. PRECISION The default precision for string outputs.","title":"The Color Object"},{"location":"color/#the-color-object","text":"","title":"The Color Object"},{"location":"color/#creating-colors","text":"The Color object can be imported from coloraide . from coloraide import Color Afterwards, colors can be created using various, valid CSS syntax: >>> Color ( \"red\" ), (color(srgb 1 0 0 / 1),) >>> Color ( \"#00ff00\" ), (color(srgb 0 1 0 / 1),) >>> Color ( \"rgb(0 0 255 / 1)\" ) color(srgb 0 0 1 / 1) In general, each color space can be recognized using valid CSS syntax as specified in the CSS level 4 spec. All colors, even colors not officially supported in the CSS spec, can be specified using the generic CSS color function: color ( space coord1 , coord2 , ... / alpha ) . While the color () function in CSS does not explicitly support color spaces with angular channels (hues), it has been adapted to support cylindrical colors, and is generally used as a generic, input and default for string representation of colors. >>> Color ( 'color(hsl 130 40 % 75% / 0.5)' ) color(hsl 130 40% 75% / 0.5) While CSS input is useful, we can also insert raw data points directly. When doing things this way, we must be mindful of the actual accepted input range. For instance, RGB colors are not specified in ranges from 0 - 255, but from 0 - 1. Raw inputs are always accepted exactly as they are specified and are treated as the user directly setting the channels. >>> Color ( \"srgb\" , [ 0.5 , 0 , 1 ], 0.3 ) color(srgb 0.5 0 1 / 0.3) If another color instance is passed as the input, a new color will be created, essentially cloning the passed object. >>> c1 = Color ( 'red' ) >>> c2 = Color ( c1 ) >>> c1 , c2 (color(srgb 1 0 0 / 1), color(srgb 1 0 0 / 1)) You can also use the new method to generate new colors from already instantiated colors. >>> color1 = Color ( \"red\" ) >>> color1 color(srgb 1 0 0 / 1) >>> color1 . new ( \"blue\" ) color(srgb 0 0 1 / 1)","title":"Creating Colors"},{"location":"color/#cloning","text":"The clone method is an easy way to duplicate the current color object. Here we clone the green object so we have two. >>> c1 = Color ( \"green\" ) >>> c1 color(srgb 0 0.50196 0 / 1) >>> c1 . clone () color(srgb 0 0.50196 0 / 1)","title":"Cloning"},{"location":"color/#updating","text":"A color can be \"updated\" using another color object. When an update occurs, the current color space is updated with the data from the second color, but the color space does not change. It is basically the equivalent of converting the second color to the color space of the first and then updating all the coordinates (including alpha). The input parameters are identical to the new method, so we can use a color object, a color string, or even raw data points. Here we update the color red to the color blue : >>> Color ( \"red\" ) color(srgb 1 0 0 / 1) >>> Color ( \"red\" ) . update ( Color ( \"blue\" )) color(srgb 0 0 1 / 1) Here we update the sRGB red with the color lch ( 80 % 50 130 ) . >>> Color ( \"red\" ) . update ( \"lch(80% 50 130)\" ) color(srgb 0.60398 0.83979 0.48395 / 1)","title":"Updating"},{"location":"color/#mutating","text":"\"Mutating\" is similar to updating except that it will update the color and the color space from another color. The input parameters are identical to the new method, so we can use a color object, a color string, or even raw data points. Here the red color object literally becomes an CIELCH color object with the new color lch ( 80 % 50 130 ) . >>> Color ( \"red\" ) . mutate ( \"lch(80% 50 130)\" ) color(lch 80% 50 130 / 1)","title":"Mutating"},{"location":"color/#converting","text":"Colors can be converted to other color spaces as needed. Converting will always return a new color unless in_place is set True , in which case the current color will be mutated to the new converted color. For instance, if we had a color yellow , and we needed to work with it in another color space, such as CIELAB, we could simply call the convert method with the desired color space. >>> Color ( 'yellow' ) . convert ( \"lab\" ) color(lab 97.607% -15.753 93.388 / 1)","title":"Converting"},{"location":"color/#color-matching","text":"Color objects can take in raw data points or a CSS style string input. The string matching logic is exposed via the match method. By default, we can just give it a string, and it will return a ColorMatch object. The ColorMatch object will have the matched color as a Color object, and the start and end points it was located at. >>> Color . match ( \"red\" ) ColorMatch(color=color(srgb 1 0 0 / 1), start=0, end=3) By default it matches at the start of the buffer and returns a color if it finds one. If desired, we can do a fullmatch which requires the entire buffer to match the color. >>> Color . match ( \"red and yellow\" ) ColorMatch(color=color(srgb 1 0 0 / 1), start=0, end=3) >>> Color . match ( \"red and yellow\" , fullmatch = True ) We can also adjust the start position of the search. In this case, by adjusting the start position to 8 characters later, we will match yellow instead of red . >>> Color . match ( \"red and yellow\" , start = 8 ) ColorMatch(color=color(srgb 1 1 0 / 1), start=8, end=14) If desired, we can also filter out the CSS syntax of certain color spaces. In the following example, we will only target HSL colors. >>> Color . match ( \"red and yellow\" , filters = [ \"hsl\" ]) >>> Color . match ( \"hsl(130 30 % 75% )\" , filters = [ \"hsl\" ]) ColorMatch(color=color(hsl 130 30% 75% / 1), start=0, end=16) A method to find all colors in a buffer is not provided as looping through all the color spaces and matching all potential colors on every character is not really efficient. What is recommended would be to apply this with some logic to find potential places in the buffer to test, and only test those places. In this example, we construct a regex to find places within the buffer that potentially have a valid color, but we also try and filter out cases that are unfavorable, particularly in HTML or CSS. We don't want to match hex in HTML entities or color names that are part of color variables ( var ( --color-red ) ). >>> import re >>> from coloraide import Color >>> RE_COLOR_START = re . compile ( r \"(?i)(?:\\b(?<![-#&$])(?:color|hsla?|lch|lab|hwb|rgba?)\\(|\\b(?<![-#&$])[\\w]{3,}(?![(-])\\b|(?<![&])#)\" ) >>> text = \"\"\"Red and yellow are colors. So are #000088 and lch(75% 50 50).\"\"\" >>> colors = [] >>> for m in RE_COLOR_START . finditer ( text ): ... start = m . start () ... mcolor = Color . match ( text , start = start ) ... if mcolor is not None : ... colors . append ( mcolor . color ) ... >>> [ x . to_string () for x in colors ] ['rgb(255 0 0)', 'rgb(255 255 0)', 'rgb(0 0 136)', 'lch(75% 50 50)']","title":"Color Matching"},{"location":"color/#override-default-settings","text":"ColorAide has a couple of default settings, such as the default precision for string outputs, default gamut mapping mode, etc. All of these options can be set on-demand when calling certain functions. When not explicitly set, some default is used. If needed, the defaults can be changed for an entire application or library. To do so, simply subclass the Color object and override the defaults. Then the new derived class can be used throughout an application or library. >>> class Color2 ( Color ): ... PRECISION = 3 ... >>> Color ( 'rgb(128.12345 0 128.12345)' ) . to_string () rgb(128.12 0 128.12) >>> Color2 ( 'rgb(128.12345 0 128.12345)' ) . to_string () rgb(128 0 128) Properties Description FIT The default gamut mapping method used by the Color object. DELTA_E The default delta E algorithm used for gamut distancing calls internally. PRECISION The default precision for string outputs.","title":"Override Default Settings"},{"location":"compositing/","text":"Compositing and Blending Compositing Alpha compositing and blending are tied together under the umbrella of compositing. Each is just an aspect of the overall compositing of colors. Blend is run first, followed by alpha compositing. ColorAide implements both alpha compositing and blending as described in the Compositing and Blending Level 1 specification. Alpha composting is based on Porter Duff compositing . By default, the compose method uses the normal blend mode and the source-over Porter Duff operator. Blending Blending is the aspect of compositing that calculates the mixing of colors where the source element and backdrop overlap. Conceptually, the colors in the source element (top layer) are blended in place with the backdrop (bottom layer). There are various blend modes, the most common is the normal blend mode which is the default blending mode for browsers when a layer is placed over another layer. The normal mode simply returns the top layer's color when two are overlaid. Some weighting of colors can occur if top layer is semi-transparent. But there are many blend modes that could be used, all of which yield different results. If we were to apply a multiply blend mode, we would get something very different: When composing, the blend mode can be controlled separately in ColorAide. Here, we again use the multiply example and replicate it in ColorAide. Display Differences As some browsers apply compositing based on the display's current color space, we've provided examples in both sRGB and Display P3 so that the examples can be compared on different displays. Which of the below matches your browser? Display P3 >>> Color ( '#07c7ed' ) . compose ( '#fc3d99' , blend = 'multiply' , space = \"display-p3\" ) color(srgb 0.33864 0.23261 0.55966 / 1) sRGB >>> Color ( '#07c7ed' ) . compose ( '#fc3d99' , blend = 'multiply' , space = \"srgb\" ) color(srgb 0.02713 0.18668 0.55765 / 1) You can even blend multiple colors. Simply send in a list, and the colors will be blended from right to left with the right most color being on the bottom of the stack, and the base color being on the very top. Display P3 >>> Color ( '#07c7ed' ) . compose ([ '#fc3d99' , '#f5d311' ], blend = 'multiply' , space = \"display-p3\" ) color(srgb 0.32149 0.19137 0.14795 / 1) sRGB >>> Color ( '#07c7ed' ) . compose ([ '#fc3d99' , '#f5d311' ], blend = 'multiply' , space = \"srgb\" ) color(srgb 0.02606 0.15447 0.03718 / 1) Lastly, if for any reason, it is desired to compose with blending disabled (e.g. just run alpha compositing), then you can simply set operator to False . multiply is just one of many blend modes that are offered in ColorAide, check out Blend Modes to learn about other blend modes. Alpha Compositing Alpha compositing or alpha blending is the process of combining one image with a background to create the appearance of partial or full transparency. When dealing with layers, there are many possible ways to handle them: Porter Duff compositing covers all possible configurations of layers. Many of these configurations can be useful for all sorts of operations, such as masking. While this library supports all of them , the most commonly used one is source-over which is used to implement simple alpha compositing to simulate semi-transparent layers on top of each other. Given two colors, ColorAide can replicate this behavior and determine the resultant color by applying compositing. We will use the demonstration above and replicate the result in the example below. Below we set the source color to rgb ( 7 199 237 / 0 . 5 ) and the backdrop color to # fc3d99 and run it through the compose method. Display Differences As some browsers apply compositing based on the display's current color space, we've provided examples in both sRGB and Display P3 so that the examples can be compared on different displays. Which of the below matches your browser? Display P3 >>> Color ( '#07c7ed' ) . set ( 'alpha' , 0.5 ) . compose ( '#fc3d99' , space = \"display-p3\" ) color(srgb 0.6514 0.53412 0.76834 / 1) sRGB >>> Color ( '#07c7ed' ) . set ( 'alpha' , 0.5 ) . compose ( '#fc3d99' , space = \"srgb\" ) color(srgb 0.50784 0.5098 0.76471 / 1) While the average user will be content with the default alpha compositing, Porter Duff offers many other configurations. If desired, we can change the Porter Duff operator used and apply different composite logic. For instance, in this case we can get the resultant of the backdrop over the source color by setting the operator to destination-over . As the backdrop is fully opaque, we just get the backdrop color unaltered. Display P3 >>> Color ( '#07c7ed' ) . set ( 'alpha' , 0.5 ) . compose ( '#fc3d99' , operator = 'destination-over' , space = \"display-p3\" ) color(srgb 0.98824 0.23922 0.6 / 1) sRGB >>> Color ( '#07c7ed' ) . set ( 'alpha' , 0.5 ) . compose ( '#fc3d99' , operator = 'destination-over' , space = \"srgb\" ) color(srgb 0.98824 0.23922 0.6 / 1) You can also apply alpha compositing to multiple layers at once. Simply send in a list, and the colors will be composed from right to left with the right most color being on the bottom of the stack and the base color being on the very top. Here we are using the normal blend mode and 50% transparency on all the circles with an opaque white background. We will calculate the center color where all three layers overlap. Display P3 >>> Color ( '#07c7ed' ) . set ( 'alpha' , 0.5 ) . compose ( ... [ Color ( '#fc3d99' ) . set ( 'alpha' , 0.5 ), Color ( '#f5d311' ) . set ( 'alpha' , 0.5 ), 'white' ], ... blend = 'normal' , ... space = \"display-p3\" ... ) color(srgb 0.63702 0.69225 0.77313 / 1) sRGB >>> Color ( '#07c7ed' ) . set ( 'alpha' , 0.5 ) . compose ( ... [ Color ( '#fc3d99' ) . set ( 'alpha' , 0.5 ), Color ( '#f5d311' ) . set ( 'alpha' , 0.5 ), 'white' ], ... blend = 'normal' , ... space = \"srgb\" ... ) color(srgb 0.50588 0.67843 0.74804 / 1) Lastly, if for any reason, it is desired to run compose with alpha compositing disabled (e.g. just run blending), then you can simply set operator to False . Check out Compositing Operators to learn about the many variations that are supported. Complex Compositing We've covered alpha compositing and blending and have demonstrated their use with simple two color examples and multi-layered examples layers, but what about different blend modes mixed with alpha compositing? In this example, we will consider three circles, each with a unique color: # 07c7ed , # fc3d99 , and # f5d311 . We apply 50% transparency to all the circles and place them on a white background. We then perform a multiply blend on all the circles but isolate them so the multiply blend does not apply to the background. The circles are all represented with CSS. We will now try and replicate the colors with ColorAide. So in the code below, we work our way from the bottom of the stack to the top. Since the background is isolated from the multiply blending, in each region, we start by performing a normal blend on the bottom circle against the background. We then apply multiply blending on each color that is stacked on top. We've provided both the P3 and sRGB outputs to make it easy to compare in case your browser blends in one instead of the other. Display P3 >>> c1 = Color ( '#07c7ed' ) . set ( 'alpha' , 0.5 ) >>> c2 = Color ( '#fc3d99' ) . set ( 'alpha' , 0.5 ) >>> c3 = Color ( '#f5d311' ) . set ( 'alpha' , 0.5 ) >>> cw2 = c2 . compose ( 'white' , blend = 'normal' , space = 'display-p3' ) >>> cw3 = c3 . compose ( 'white' , blend = 'normal' , space = 'display-p3' ) >>> r1 = c2 . compose ( cw3 , blend = 'multiply' , space = 'display-p3' ) >>> r2 = c1 . compose ( cw2 , blend = 'multiply' , space = 'display-p3' ) >>> r3 = c1 . compose ( cw3 , blend = 'multiply' , space = 'display-p3' ) >>> r1 , r2 , r3 (color(srgb 0.98122 0.58007 0.49257 / 1), color(srgb 0.66116 0.57542 0.77558 / 1), color(srgb 0.61489 0.8159 0.5966 / 1)) >>> c1 . compose ([ c2 , cw3 ], blend = 'multiply' , space = 'display-p3' ) color(srgb 0.64658 0.52544 0.4843 / 1) sRGB >>> c1 = Color ( '#07c7ed' ) . set ( 'alpha' , 0.5 ) >>> c2 = Color ( '#fc3d99' ) . set ( 'alpha' , 0.5 ) >>> c3 = Color ( '#f5d311' ) . set ( 'alpha' , 0.5 ) >>> cw2 = c2 . compose ( 'white' , blend = 'normal' , space = 'srgb' ) >>> cw3 = c3 . compose ( 'white' , blend = 'normal' , space = 'srgb' ) >>> r1 = c2 . compose ( cw3 , blend = 'multiply' , space = 'srgb' ) >>> r2 = c1 . compose ( cw2 , blend = 'multiply' , space = 'srgb' ) >>> r3 = c1 . compose ( cw3 , blend = 'multiply' , space = 'srgb' ) >>> r1 , r2 , r3 (color(srgb 0.97463 0.56615 0.42667 / 1), color(srgb 0.5107 0.55157 0.77176 / 1), color(srgb 0.50365 0.81339 0.51451 / 1)) >>> c1 . compose ([ c2 , cw3 ], blend = 'multiply' , space = 'srgb' ) color(srgb 0.50069 0.50399 0.41161 / 1) Results may vary depending on the browser, but we can see (ignoring rounding differences) that the colors match up. This was performed on Chrome in macOS using a display that uses display-p3 . Blend Modes Normal The blending formula simply selects the source color. Specified as 'normal' . Multiply The source color is multiplied by the destination color and replaces the destination. The resultant color is always at least as dark as either the source or destination color. Multiplying any color with black results in black. Multiplying any color with white preserves the original color. Specified as 'multiply' . Screen Multiplies the complements of the backdrop and source color values, then complements the result. The result color is always at least as light as either of the two constituent colors. Screening any color with white produces white; screening with black leaves the original color unchanged. The effect is similar to projecting multiple photographic slides simultaneously onto a single screen. Specified as 'screen' . Overlay Multiplies or screens the colors, depending on the backdrop color value. Source colors overlay the backdrop while preserving its highlights and shadows. The backdrop color is not replaced but is mixed with the source color to reflect the lightness or darkness of the backdrop. Specified as 'overlay' . Darken Selects the darker of the backdrop and source colors. The backdrop is replaced with the source where the source is darker; otherwise, it is left unchanged. Specified as 'darken' . Lighten Selects the lighter of the backdrop and source colors. The backdrop is replaced with the source where the source is lighter; otherwise, it is left unchanged. Specified as 'lighten' . Color Dodge Brightens the backdrop color to reflect the source color. Painting with black produces no changes. Specified as 'color-dodge' . Color Burn Darkens the backdrop color to reflect the source color. Painting with white produces no change. Specified as 'color-burn' . Hard Light Multiplies or screens the colors, depending on the source color value. The effect is similar to shining a harsh spotlight on the backdrop. Specified as 'hard-light' . Soft Light Darkens or lightens the colors, depending on the source color value. The effect is similar to shining a diffused spotlight on the backdrop. Specified as 'soft-light' . Difference Subtracts the darker of the two constituent colors from the lighter color. Painting with white inverts the backdrop color; painting with black produces no change. Specified as 'difference' . Exclusion Produces an effect similar to that of the Difference mode but lower in contrast. Painting with white inverts the backdrop color; painting with black produces no change. Specified as 'exclusion' . Hue Creates a color with the hue of the source color and the saturation and luminosity of the backdrop color. Specified as 'hue' . Saturation Creates a color with the saturation of the source color and the hue and luminosity of the backdrop color. Painting with this mode in an area of the backdrop that is a pure gray (no saturation) produces no change. Specified as 'saturation' . Luminosity Creates a color with the luminosity of the source color and the hue and saturation of the backdrop color. This produces an inverse effect to that of the Color mode. This mode is the one you can use to create monochrome \"tinted\" image effects like the ones you can see in different website headers. Specified as 'luminosity' . Color Creates a color with the hue and saturation of the source color and the luminosity of the backdrop color. This preserves the gray levels of the backdrop and is useful for coloring monochrome images or tinting color images. Specified as 'color' . Compositing Operators Clear No regions are enabled. Specified as 'clear' . Copy Only the source will be present. Specified as 'copy' . Destination Only the destination will be present. Specified as 'destination' . Source Over Source is placed over the destination. Specified as 'source-over' . Destination Over Destination is placed over the source. Specified as 'destination-over' . Source In The source that overlaps the destination, replaces the destination. Specified as 'source-in' . Destination In Destination which overlaps the source, replaces the source. Specified as 'destination-in' . Source Out Source is placed, where it falls outside of the destination. Specified as 'source-out' . Destination Out Destination is placed, where it falls outside of the source. Specified as 'destination-out' . Source Atop Source which overlaps the destination, replaces the destination. Destination is placed elsewhere. Specified as 'source-atop' . Destination Atop Destination which overlaps the source replaces the source. Source is placed elsewhere. Specified as 'destination-atop' . XOR Destination which overlaps the source replaces the source. Source is placed elsewhere. Specified as 'xor' . Lighter Display the sum of the source image and destination image. Specified as 'lighter' . img { background: white; } .circle { display: block; width: 80px; height: 80px; border-radius: 50%; position: absolute; transition: all 0.5s ease; z-index: 10; } .isolate label { position: absolute; bottom: 0; width: 100%; text-align: center; } .circle-1 { background: #f5d311; } .dual .circle-1 { background: #fc3d99; } .isolate:not(.dual):hover .circle-1 { transform: translateX(-10px) translateY(-7.5px); } .isolate.dual:hover .circle-1 { transform: translateX(-10px); } .circle-2 { background: #fc3d99; left: 40px; } .dual .circle-2 { background: #07c7ed; } .isolate:not(.dual):hover .circle-2 { transform: translateX(10px) translateY(-7.5px); } .isolate.dual:hover .circle-2 { transform: translateX(20px); } .circle-3 { background: #07c7ed; left: 20px; top: 40px; } .isolate:not(.dual):hover .circle-3 { transform: translateY(7.5px); } .isolate { display: block; height: 120px; width: 120px; isolation: isolate; position: relative; margin: 0 10px; } .isolate.dual { height: 80px; } div.blend-wrap { display: flex; min-height: calc(120px + 0.8em); width: 100%; } div.blend-wrap > :not(.blend-content) { order: 0; } div.blend-wrap .isolate { margin-top: 0.8em; } div.blend-wrap > .blend-content { order: 1; } .blend-normal .circle { mix-blend-mode: normal; } .blend-multiply .circle { mix-blend-mode: multiply; } .blend-screen .circle { mix-blend-mode: screen; } .blend-overlay .circle { mix-blend-mode: overlay; } .blend-color-burn .circle { mix-blend-mode: color-burn; } .blend-color-dodge .circle { mix-blend-mode: color-dodge; } .blend-exclusion .circle { mix-blend-mode: exclusion; } .blend-difference .circle { mix-blend-mode: difference; } .blend-darken .circle { mix-blend-mode: darken; } .blend-lighten .circle { mix-blend-mode: lighten; } .blend-soft-light .circle { mix-blend-mode: soft-light; } .blend-hard-light .circle { mix-blend-mode: hard-light; } .blend-hue .circle { mix-blend-mode: hue; } .blend-saturation .circle { mix-blend-mode: saturation; } .blend-luminosity .circle { mix-blend-mode: luminosity; } .blend-color .circle { mix-blend-mode: color; }","title":"Compositing and Blending"},{"location":"compositing/#compositing-and-blending","text":"","title":"Compositing and Blending"},{"location":"compositing/#compositing","text":"Alpha compositing and blending are tied together under the umbrella of compositing. Each is just an aspect of the overall compositing of colors. Blend is run first, followed by alpha compositing. ColorAide implements both alpha compositing and blending as described in the Compositing and Blending Level 1 specification. Alpha composting is based on Porter Duff compositing . By default, the compose method uses the normal blend mode and the source-over Porter Duff operator.","title":"Compositing"},{"location":"compositing/#blending","text":"Blending is the aspect of compositing that calculates the mixing of colors where the source element and backdrop overlap. Conceptually, the colors in the source element (top layer) are blended in place with the backdrop (bottom layer). There are various blend modes, the most common is the normal blend mode which is the default blending mode for browsers when a layer is placed over another layer. The normal mode simply returns the top layer's color when two are overlaid. Some weighting of colors can occur if top layer is semi-transparent. But there are many blend modes that could be used, all of which yield different results. If we were to apply a multiply blend mode, we would get something very different: When composing, the blend mode can be controlled separately in ColorAide. Here, we again use the multiply example and replicate it in ColorAide. Display Differences As some browsers apply compositing based on the display's current color space, we've provided examples in both sRGB and Display P3 so that the examples can be compared on different displays. Which of the below matches your browser? Display P3 >>> Color ( '#07c7ed' ) . compose ( '#fc3d99' , blend = 'multiply' , space = \"display-p3\" ) color(srgb 0.33864 0.23261 0.55966 / 1) sRGB >>> Color ( '#07c7ed' ) . compose ( '#fc3d99' , blend = 'multiply' , space = \"srgb\" ) color(srgb 0.02713 0.18668 0.55765 / 1) You can even blend multiple colors. Simply send in a list, and the colors will be blended from right to left with the right most color being on the bottom of the stack, and the base color being on the very top. Display P3 >>> Color ( '#07c7ed' ) . compose ([ '#fc3d99' , '#f5d311' ], blend = 'multiply' , space = \"display-p3\" ) color(srgb 0.32149 0.19137 0.14795 / 1) sRGB >>> Color ( '#07c7ed' ) . compose ([ '#fc3d99' , '#f5d311' ], blend = 'multiply' , space = \"srgb\" ) color(srgb 0.02606 0.15447 0.03718 / 1) Lastly, if for any reason, it is desired to compose with blending disabled (e.g. just run alpha compositing), then you can simply set operator to False . multiply is just one of many blend modes that are offered in ColorAide, check out Blend Modes to learn about other blend modes.","title":"Blending"},{"location":"compositing/#alpha-compositing","text":"Alpha compositing or alpha blending is the process of combining one image with a background to create the appearance of partial or full transparency. When dealing with layers, there are many possible ways to handle them: Porter Duff compositing covers all possible configurations of layers. Many of these configurations can be useful for all sorts of operations, such as masking. While this library supports all of them , the most commonly used one is source-over which is used to implement simple alpha compositing to simulate semi-transparent layers on top of each other. Given two colors, ColorAide can replicate this behavior and determine the resultant color by applying compositing. We will use the demonstration above and replicate the result in the example below. Below we set the source color to rgb ( 7 199 237 / 0 . 5 ) and the backdrop color to # fc3d99 and run it through the compose method. Display Differences As some browsers apply compositing based on the display's current color space, we've provided examples in both sRGB and Display P3 so that the examples can be compared on different displays. Which of the below matches your browser? Display P3 >>> Color ( '#07c7ed' ) . set ( 'alpha' , 0.5 ) . compose ( '#fc3d99' , space = \"display-p3\" ) color(srgb 0.6514 0.53412 0.76834 / 1) sRGB >>> Color ( '#07c7ed' ) . set ( 'alpha' , 0.5 ) . compose ( '#fc3d99' , space = \"srgb\" ) color(srgb 0.50784 0.5098 0.76471 / 1) While the average user will be content with the default alpha compositing, Porter Duff offers many other configurations. If desired, we can change the Porter Duff operator used and apply different composite logic. For instance, in this case we can get the resultant of the backdrop over the source color by setting the operator to destination-over . As the backdrop is fully opaque, we just get the backdrop color unaltered. Display P3 >>> Color ( '#07c7ed' ) . set ( 'alpha' , 0.5 ) . compose ( '#fc3d99' , operator = 'destination-over' , space = \"display-p3\" ) color(srgb 0.98824 0.23922 0.6 / 1) sRGB >>> Color ( '#07c7ed' ) . set ( 'alpha' , 0.5 ) . compose ( '#fc3d99' , operator = 'destination-over' , space = \"srgb\" ) color(srgb 0.98824 0.23922 0.6 / 1) You can also apply alpha compositing to multiple layers at once. Simply send in a list, and the colors will be composed from right to left with the right most color being on the bottom of the stack and the base color being on the very top. Here we are using the normal blend mode and 50% transparency on all the circles with an opaque white background. We will calculate the center color where all three layers overlap. Display P3 >>> Color ( '#07c7ed' ) . set ( 'alpha' , 0.5 ) . compose ( ... [ Color ( '#fc3d99' ) . set ( 'alpha' , 0.5 ), Color ( '#f5d311' ) . set ( 'alpha' , 0.5 ), 'white' ], ... blend = 'normal' , ... space = \"display-p3\" ... ) color(srgb 0.63702 0.69225 0.77313 / 1) sRGB >>> Color ( '#07c7ed' ) . set ( 'alpha' , 0.5 ) . compose ( ... [ Color ( '#fc3d99' ) . set ( 'alpha' , 0.5 ), Color ( '#f5d311' ) . set ( 'alpha' , 0.5 ), 'white' ], ... blend = 'normal' , ... space = \"srgb\" ... ) color(srgb 0.50588 0.67843 0.74804 / 1) Lastly, if for any reason, it is desired to run compose with alpha compositing disabled (e.g. just run blending), then you can simply set operator to False . Check out Compositing Operators to learn about the many variations that are supported.","title":"Alpha Compositing"},{"location":"compositing/#complex-compositing","text":"We've covered alpha compositing and blending and have demonstrated their use with simple two color examples and multi-layered examples layers, but what about different blend modes mixed with alpha compositing? In this example, we will consider three circles, each with a unique color: # 07c7ed , # fc3d99 , and # f5d311 . We apply 50% transparency to all the circles and place them on a white background. We then perform a multiply blend on all the circles but isolate them so the multiply blend does not apply to the background. The circles are all represented with CSS. We will now try and replicate the colors with ColorAide. So in the code below, we work our way from the bottom of the stack to the top. Since the background is isolated from the multiply blending, in each region, we start by performing a normal blend on the bottom circle against the background. We then apply multiply blending on each color that is stacked on top. We've provided both the P3 and sRGB outputs to make it easy to compare in case your browser blends in one instead of the other. Display P3 >>> c1 = Color ( '#07c7ed' ) . set ( 'alpha' , 0.5 ) >>> c2 = Color ( '#fc3d99' ) . set ( 'alpha' , 0.5 ) >>> c3 = Color ( '#f5d311' ) . set ( 'alpha' , 0.5 ) >>> cw2 = c2 . compose ( 'white' , blend = 'normal' , space = 'display-p3' ) >>> cw3 = c3 . compose ( 'white' , blend = 'normal' , space = 'display-p3' ) >>> r1 = c2 . compose ( cw3 , blend = 'multiply' , space = 'display-p3' ) >>> r2 = c1 . compose ( cw2 , blend = 'multiply' , space = 'display-p3' ) >>> r3 = c1 . compose ( cw3 , blend = 'multiply' , space = 'display-p3' ) >>> r1 , r2 , r3 (color(srgb 0.98122 0.58007 0.49257 / 1), color(srgb 0.66116 0.57542 0.77558 / 1), color(srgb 0.61489 0.8159 0.5966 / 1)) >>> c1 . compose ([ c2 , cw3 ], blend = 'multiply' , space = 'display-p3' ) color(srgb 0.64658 0.52544 0.4843 / 1) sRGB >>> c1 = Color ( '#07c7ed' ) . set ( 'alpha' , 0.5 ) >>> c2 = Color ( '#fc3d99' ) . set ( 'alpha' , 0.5 ) >>> c3 = Color ( '#f5d311' ) . set ( 'alpha' , 0.5 ) >>> cw2 = c2 . compose ( 'white' , blend = 'normal' , space = 'srgb' ) >>> cw3 = c3 . compose ( 'white' , blend = 'normal' , space = 'srgb' ) >>> r1 = c2 . compose ( cw3 , blend = 'multiply' , space = 'srgb' ) >>> r2 = c1 . compose ( cw2 , blend = 'multiply' , space = 'srgb' ) >>> r3 = c1 . compose ( cw3 , blend = 'multiply' , space = 'srgb' ) >>> r1 , r2 , r3 (color(srgb 0.97463 0.56615 0.42667 / 1), color(srgb 0.5107 0.55157 0.77176 / 1), color(srgb 0.50365 0.81339 0.51451 / 1)) >>> c1 . compose ([ c2 , cw3 ], blend = 'multiply' , space = 'srgb' ) color(srgb 0.50069 0.50399 0.41161 / 1) Results may vary depending on the browser, but we can see (ignoring rounding differences) that the colors match up. This was performed on Chrome in macOS using a display that uses display-p3 .","title":"Complex Compositing"},{"location":"compositing/#blend-modes","text":"","title":"Blend Modes"},{"location":"compositing/#normal","text":"The blending formula simply selects the source color. Specified as 'normal' .","title":"Normal"},{"location":"compositing/#multiply","text":"The source color is multiplied by the destination color and replaces the destination. The resultant color is always at least as dark as either the source or destination color. Multiplying any color with black results in black. Multiplying any color with white preserves the original color. Specified as 'multiply' .","title":"Multiply"},{"location":"compositing/#screen","text":"Multiplies the complements of the backdrop and source color values, then complements the result. The result color is always at least as light as either of the two constituent colors. Screening any color with white produces white; screening with black leaves the original color unchanged. The effect is similar to projecting multiple photographic slides simultaneously onto a single screen. Specified as 'screen' .","title":"Screen"},{"location":"compositing/#overlay","text":"Multiplies or screens the colors, depending on the backdrop color value. Source colors overlay the backdrop while preserving its highlights and shadows. The backdrop color is not replaced but is mixed with the source color to reflect the lightness or darkness of the backdrop. Specified as 'overlay' .","title":"Overlay"},{"location":"compositing/#darken","text":"Selects the darker of the backdrop and source colors. The backdrop is replaced with the source where the source is darker; otherwise, it is left unchanged. Specified as 'darken' .","title":"Darken"},{"location":"compositing/#lighten","text":"Selects the lighter of the backdrop and source colors. The backdrop is replaced with the source where the source is lighter; otherwise, it is left unchanged. Specified as 'lighten' .","title":"Lighten"},{"location":"compositing/#color-dodge","text":"Brightens the backdrop color to reflect the source color. Painting with black produces no changes. Specified as 'color-dodge' .","title":"Color Dodge"},{"location":"compositing/#color-burn","text":"Darkens the backdrop color to reflect the source color. Painting with white produces no change. Specified as 'color-burn' .","title":"Color Burn"},{"location":"compositing/#hard-light","text":"Multiplies or screens the colors, depending on the source color value. The effect is similar to shining a harsh spotlight on the backdrop. Specified as 'hard-light' .","title":"Hard Light"},{"location":"compositing/#soft-light","text":"Darkens or lightens the colors, depending on the source color value. The effect is similar to shining a diffused spotlight on the backdrop. Specified as 'soft-light' .","title":"Soft Light"},{"location":"compositing/#difference","text":"Subtracts the darker of the two constituent colors from the lighter color. Painting with white inverts the backdrop color; painting with black produces no change. Specified as 'difference' .","title":"Difference"},{"location":"compositing/#exclusion","text":"Produces an effect similar to that of the Difference mode but lower in contrast. Painting with white inverts the backdrop color; painting with black produces no change. Specified as 'exclusion' .","title":"Exclusion"},{"location":"compositing/#hue","text":"Creates a color with the hue of the source color and the saturation and luminosity of the backdrop color. Specified as 'hue' .","title":"Hue"},{"location":"compositing/#saturation","text":"Creates a color with the saturation of the source color and the hue and luminosity of the backdrop color. Painting with this mode in an area of the backdrop that is a pure gray (no saturation) produces no change. Specified as 'saturation' .","title":"Saturation"},{"location":"compositing/#luminosity","text":"Creates a color with the luminosity of the source color and the hue and saturation of the backdrop color. This produces an inverse effect to that of the Color mode. This mode is the one you can use to create monochrome \"tinted\" image effects like the ones you can see in different website headers. Specified as 'luminosity' .","title":"Luminosity"},{"location":"compositing/#color","text":"Creates a color with the hue and saturation of the source color and the luminosity of the backdrop color. This preserves the gray levels of the backdrop and is useful for coloring monochrome images or tinting color images. Specified as 'color' .","title":"Color"},{"location":"compositing/#compositing-operators","text":"","title":"Compositing Operators"},{"location":"compositing/#clear","text":"No regions are enabled. Specified as 'clear' .","title":"Clear"},{"location":"compositing/#copy","text":"Only the source will be present. Specified as 'copy' .","title":"Copy"},{"location":"compositing/#destination","text":"Only the destination will be present. Specified as 'destination' .","title":"Destination"},{"location":"compositing/#source-over","text":"Source is placed over the destination. Specified as 'source-over' .","title":"Source Over"},{"location":"compositing/#destination-over","text":"Destination is placed over the source. Specified as 'destination-over' .","title":"Destination Over"},{"location":"compositing/#source-in","text":"The source that overlaps the destination, replaces the destination. Specified as 'source-in' .","title":"Source In"},{"location":"compositing/#destination-in","text":"Destination which overlaps the source, replaces the source. Specified as 'destination-in' .","title":"Destination In"},{"location":"compositing/#source-out","text":"Source is placed, where it falls outside of the destination. Specified as 'source-out' .","title":"Source Out"},{"location":"compositing/#destination-out","text":"Destination is placed, where it falls outside of the source. Specified as 'destination-out' .","title":"Destination Out"},{"location":"compositing/#source-atop","text":"Source which overlaps the destination, replaces the destination. Destination is placed elsewhere. Specified as 'source-atop' .","title":"Source Atop"},{"location":"compositing/#destination-atop","text":"Destination which overlaps the source replaces the source. Source is placed elsewhere. Specified as 'destination-atop' .","title":"Destination Atop"},{"location":"compositing/#xor","text":"Destination which overlaps the source replaces the source. Source is placed elsewhere. Specified as 'xor' .","title":"XOR"},{"location":"compositing/#lighter","text":"Display the sum of the source image and destination image. Specified as 'lighter' . img { background: white; } .circle { display: block; width: 80px; height: 80px; border-radius: 50%; position: absolute; transition: all 0.5s ease; z-index: 10; } .isolate label { position: absolute; bottom: 0; width: 100%; text-align: center; } .circle-1 { background: #f5d311; } .dual .circle-1 { background: #fc3d99; } .isolate:not(.dual):hover .circle-1 { transform: translateX(-10px) translateY(-7.5px); } .isolate.dual:hover .circle-1 { transform: translateX(-10px); } .circle-2 { background: #fc3d99; left: 40px; } .dual .circle-2 { background: #07c7ed; } .isolate:not(.dual):hover .circle-2 { transform: translateX(10px) translateY(-7.5px); } .isolate.dual:hover .circle-2 { transform: translateX(20px); } .circle-3 { background: #07c7ed; left: 20px; top: 40px; } .isolate:not(.dual):hover .circle-3 { transform: translateY(7.5px); } .isolate { display: block; height: 120px; width: 120px; isolation: isolate; position: relative; margin: 0 10px; } .isolate.dual { height: 80px; } div.blend-wrap { display: flex; min-height: calc(120px + 0.8em); width: 100%; } div.blend-wrap > :not(.blend-content) { order: 0; } div.blend-wrap .isolate { margin-top: 0.8em; } div.blend-wrap > .blend-content { order: 1; } .blend-normal .circle { mix-blend-mode: normal; } .blend-multiply .circle { mix-blend-mode: multiply; } .blend-screen .circle { mix-blend-mode: screen; } .blend-overlay .circle { mix-blend-mode: overlay; } .blend-color-burn .circle { mix-blend-mode: color-burn; } .blend-color-dodge .circle { mix-blend-mode: color-dodge; } .blend-exclusion .circle { mix-blend-mode: exclusion; } .blend-difference .circle { mix-blend-mode: difference; } .blend-darken .circle { mix-blend-mode: darken; } .blend-lighten .circle { mix-blend-mode: lighten; } .blend-soft-light .circle { mix-blend-mode: soft-light; } .blend-hard-light .circle { mix-blend-mode: hard-light; } .blend-hue .circle { mix-blend-mode: hue; } .blend-saturation .circle { mix-blend-mode: saturation; } .blend-luminosity .circle { mix-blend-mode: luminosity; } .blend-color .circle { mix-blend-mode: color; }","title":"Lighter"},{"location":"contrast/","text":"Contrast Relative Luminance Relative luminance is used to calculate the contrast ratio. To get the luminance, simply call the luminance method: >>> Color ( \"black\" ) . luminance () 0.0 >>> Color ( \"white\" ) . luminance () 1.0 >>> Color ( \"blue\" ) . luminance () 0.07217499330655952 Contrast Ratio To get the contrast ratio between two colors, simply pass in the second color: >>> Color ( \"blue\" ) . contrast ( \"red\" ) 2.149972300358782","title":"Contrast"},{"location":"contrast/#contrast","text":"","title":"Contrast"},{"location":"contrast/#relative-luminance","text":"Relative luminance is used to calculate the contrast ratio. To get the luminance, simply call the luminance method: >>> Color ( \"black\" ) . luminance () 0.0 >>> Color ( \"white\" ) . luminance () 1.0 >>> Color ( \"blue\" ) . luminance () 0.07217499330655952","title":"Relative Luminance"},{"location":"contrast/#contrast-ratio","text":"To get the contrast ratio between two colors, simply pass in the second color: >>> Color ( \"blue\" ) . contrast ( \"red\" ) 2.149972300358782","title":"Contrast Ratio"},{"location":"distance/","text":"Color Distance and Delta E Color Distance ColorAide provides a simple euclidean color distance function. By default, it evaluates the distance in the CIELAB color space, but it can be configured to evaluate in any color space. It may be less useful in some color spaces compared to others: >>> Color ( \"red\" ) . distance ( \"blue\" , space = \"srgb\" ) 1.4142135623730951 >>> Color ( \"red\" ) . distance ( \"blue\" , space = \"lab\" ) 184.01292363920496 Delta E The delta_e function gives access to various delta E implementations. >>> Color ( \"red\" ) . delta_e ( \"blue\" ) 184.01292363920496 >>> Color ( \"red\" ) . delta_e ( \"blue\" , method = \"2000\" ) 55.79761273834862 The default implementation is Delta E 1976. Originally, when the CIELAB color space was created, it was thought that it was more perceptually uniform than it actually was. At first, the distance algorithm was a simple euclidean implementation (Delta E 1976), but over time it has been tweaked to make corrections to account for the fact that it is not perfectly uniform. There are areas and industries that still use many of these for different reasons. Additionally, there are other implementations that use different color spaces, such as Delta E ITP which uses ICtCp. ColorAide implements the following delta E methods: Name Parameter Name Weighted Parameters CIE76 76 CMC l:c (1984) cmc l=2, c=1 CIE94 94 kl=1, k1=0.045, k2=0.015 CIEDE2000 2000 kl=1, kc=1, kh=1 ICtCp itp scalar=470","title":"Color Distance and Delta E"},{"location":"distance/#color-distance-and-delta-e","text":"","title":"Color Distance and Delta E"},{"location":"distance/#color-distance","text":"ColorAide provides a simple euclidean color distance function. By default, it evaluates the distance in the CIELAB color space, but it can be configured to evaluate in any color space. It may be less useful in some color spaces compared to others: >>> Color ( \"red\" ) . distance ( \"blue\" , space = \"srgb\" ) 1.4142135623730951 >>> Color ( \"red\" ) . distance ( \"blue\" , space = \"lab\" ) 184.01292363920496","title":"Color Distance"},{"location":"distance/#delta-e","text":"The delta_e function gives access to various delta E implementations. >>> Color ( \"red\" ) . delta_e ( \"blue\" ) 184.01292363920496 >>> Color ( \"red\" ) . delta_e ( \"blue\" , method = \"2000\" ) 55.79761273834862 The default implementation is Delta E 1976. Originally, when the CIELAB color space was created, it was thought that it was more perceptually uniform than it actually was. At first, the distance algorithm was a simple euclidean implementation (Delta E 1976), but over time it has been tweaked to make corrections to account for the fact that it is not perfectly uniform. There are areas and industries that still use many of these for different reasons. Additionally, there are other implementations that use different color spaces, such as Delta E ITP which uses ICtCp. ColorAide implements the following delta E methods: Name Parameter Name Weighted Parameters CIE76 76 CMC l:c (1984) cmc l=2, c=1 CIE94 94 kl=1, k1=0.045, k2=0.015 CIEDE2000 2000 kl=1, kc=1, kh=1 ICtCp itp scalar=470","title":"Delta E"},{"location":"gamut/","text":"Gamut Mapping Overview Many color spaces have limits the colors they can accurately represent. This is the color gamut. The bounds represent the limits in which a color space can represent a color. Some color spaces are theoretically unbounded, but past a point, the eye can't see them. When moving from a large color space like CIELCH to a small color space like sRGB, many CIELAB colors will not fit without mapping the color to one that does fit. This \"fitting\" of the color from one gamut into another is called gamut mapping. Checking Gamut A color can be checked to see if it fits in its own gamut or the gamut of another color space. Some color spaces may have suggested limits for usability purposes, but may not have actual limits. Let's assume we have a color rgb ( 30 % 105 % 0 % ) which is not in its own gamut as the green channel exceeds the sRGB limit of 100% . We can check this via the in_gamut method, and we can see that it is not in gamut. >>> Color ( \"rgb(30 % 105% 0%)\" ) . in_gamut () False We can also test if a color from one color space fits in a completely different color space. In the example below, we can see that the LCH color of lch ( 100 % 50 75 ) is outside the narrow gamut of sRGB. >>> Color ( \"lch(100% 50 75)\" ) . in_gamut ( \"srgb\" ) False Mapping Colors The recommended approach for fitting/mapping a color is to compress the chroma while in the CIELCH color space (overly simplified). This is the approach that our reference ( colorjs ) chose, so we ported it over here as well. In this example, we will take the color lch ( 100 % 50 75 ) . CIELCH's gamut is technically unbounded, but if we try to fit it in the sRGB gamut, as noted earlier, it is outside the narrow gamut of sRGB. So, using the fit method, and specifying srgb as the target color space, we can fit it in the sRGB gamut. >>> Color ( \"lch(100% 50 75)\" ) . fit ( \"srgb\" ) color(lch 99.438% 5.2201 99.658 / 1) If desired, simple clipping can be used instead of the default gamut fitting. Generally this is not recommended, but there are times and places for everything. In this example, we can change the fitting method parameter to clip . Notice the difference when compared to the previous fitting result: >>> Color ( \"lch(100% 50 75)\" ) . fit ( \"srgb\" , method = \"clip\" ) color(lch 95.817% 42.313 96.905 / 1) >>> Color ( \"lch(100% 50 75)\" ) . fit ( \"srgb\" ) color(lch 99.438% 5.2201 99.658 / 1) Gamut fitting will always return a new color unless in_place is set True .","title":"Gamut Mapping"},{"location":"gamut/#gamut-mapping","text":"","title":"Gamut Mapping"},{"location":"gamut/#overview","text":"Many color spaces have limits the colors they can accurately represent. This is the color gamut. The bounds represent the limits in which a color space can represent a color. Some color spaces are theoretically unbounded, but past a point, the eye can't see them. When moving from a large color space like CIELCH to a small color space like sRGB, many CIELAB colors will not fit without mapping the color to one that does fit. This \"fitting\" of the color from one gamut into another is called gamut mapping.","title":"Overview"},{"location":"gamut/#checking-gamut","text":"A color can be checked to see if it fits in its own gamut or the gamut of another color space. Some color spaces may have suggested limits for usability purposes, but may not have actual limits. Let's assume we have a color rgb ( 30 % 105 % 0 % ) which is not in its own gamut as the green channel exceeds the sRGB limit of 100% . We can check this via the in_gamut method, and we can see that it is not in gamut. >>> Color ( \"rgb(30 % 105% 0%)\" ) . in_gamut () False We can also test if a color from one color space fits in a completely different color space. In the example below, we can see that the LCH color of lch ( 100 % 50 75 ) is outside the narrow gamut of sRGB. >>> Color ( \"lch(100% 50 75)\" ) . in_gamut ( \"srgb\" ) False","title":"Checking Gamut"},{"location":"gamut/#mapping-colors","text":"The recommended approach for fitting/mapping a color is to compress the chroma while in the CIELCH color space (overly simplified). This is the approach that our reference ( colorjs ) chose, so we ported it over here as well. In this example, we will take the color lch ( 100 % 50 75 ) . CIELCH's gamut is technically unbounded, but if we try to fit it in the sRGB gamut, as noted earlier, it is outside the narrow gamut of sRGB. So, using the fit method, and specifying srgb as the target color space, we can fit it in the sRGB gamut. >>> Color ( \"lch(100% 50 75)\" ) . fit ( \"srgb\" ) color(lch 99.438% 5.2201 99.658 / 1) If desired, simple clipping can be used instead of the default gamut fitting. Generally this is not recommended, but there are times and places for everything. In this example, we can change the fitting method parameter to clip . Notice the difference when compared to the previous fitting result: >>> Color ( \"lch(100% 50 75)\" ) . fit ( \"srgb\" , method = \"clip\" ) color(lch 95.817% 42.313 96.905 / 1) >>> Color ( \"lch(100% 50 75)\" ) . fit ( \"srgb\" ) color(lch 99.438% 5.2201 99.658 / 1) Gamut fitting will always return a new color unless in_place is set True .","title":"Mapping Colors"},{"location":"interpolation/","text":"Color Interpolation Interpolating The interpolate method allows a user to create an interpolation function. This can be used to create a list of gradient colors, or whatever is needed. This function is used to drive all the features under the interpolation umbrella. A returned interpolation function accepts an input between 0 - 1, if values are provided out of this range, the color will be extrapolated and the results may be surprising. In this example, we create an interpolation between rebeccapurple and lch ( 85 % 100 85 ) (color previews are fit to the sRGB gamut). We then step through values of 0.1 , 0.2 , 0.3 , etc. >>> i = Color ( \"rebeccapurple\" ) . interpolate ( \"lch(85% 100 85)\" , space = 'lch' ) >>> [ i ( x / 20 ) . to_string () for x in range ( 20 )] ['rgb(102 51 153)', 'rgb(122.45 48.665 154.44)', 'rgb(142.01 45.343 154.31)', 'rgb(160.74 41.154 152.65)', 'rgb(178.56 36.401 149.51)', 'rgb(195.39 31.744 144.97)', 'rgb(211.09 28.47 139.17)', 'rgb(225.54 28.451 132.21)', 'rgb(238.59 32.984 124.24)', 'rgb(250.14 41.637 115.39)', 'rgb(255 53.098 105.75)', 'rgb(242.3 98.778 107.91)', 'rgb(249.19 108.42 101.41)', 'rgb(254.67 118.96 94.665)', 'rgb(255 130.24 87.784)', 'rgb(255 142.11 80.888)', 'rgb(255 154.43 74.138)', 'rgb(255 167.07 67.77)', 'rgb(255 179.93 62.157)', 'rgb(255 192.91 57.878)'] This allows us to create a range of colors that we can use in a gradient. >>> Color ( \"rebeccapurple\" ) . interpolate ( ... \"lch(85% 100 85)\" , ... space = 'lch' ... ) <coloraide.color.interpolate.InterpolateSingle object at 0x1221199a0> Interpolation can also be done across multiple colors. The function, just like when interpolating between two colors, takes a range of 0 - 1. When interpolating multiple colors, piecewise interpolation is used (which is covered in more detail later). >>> Color ( 'black' ) . interpolate ([ 'red' , 'white' ]) <coloraide.color.interpolate.InterpolatePiecewise object at 0x122119eb0> If desired, we can target one or more specific channels for mixing which will keep all the other channels constant on the base color. Channels can be any channel associated with the color space in which the interpolation is taking place (including alpha ). In the following example, we have a base color of lch ( 52 % 58 . 1 22 . 7 ) which we mix with lch ( 56 % 49 . 1 257 . 1 ) . We also specify that we want to only mix the hue channel by applying a mask to all the other channels except hue . Applying this logic, we will end up with a range of colors that maintain the same lightness and chroma, but with different hues. To learn more about masking and null hues, check out Null Handling . We can see as we step through the colors that only the hue is interpolated. >>> Color ( \"lch(52% 58.1 22.7)\" ) . interpolate ( ... Color ( \"lch(56% 49.1 257.1)\" ) . mask ( \"hue\" , invert = True ), ... space = \"lch\" ... ) <coloraide.color.interpolate.InterpolateSingle object at 0x122119cd0> Additionally, hues are special, and we can control the way the interpolation is evaluated. The hue parameter accepts such values as shorter , longer , increasing , decreasing , and specified ( shorter being the default). Below, we can see how the interpolation varies using shorter vs longer . >>> i = Color ( \"lch(52% 58.1 22.7)\" ) . interpolate ( ... Color ( \"lch(56% 49.1 257.1)\" ) . mask ( \"hue\" , invert = True ), ... space = \"lch\" ... ) >>> i ( 0.2477 ) . to_string () lch(52% 58.1 351.59) >>> i = Color ( \"lch(52% 58.1 22.7)\" ) . interpolate ( ... Color ( \"lch(56% 49.1 257.1)\" ) . mask ( \"hue\" , invert = True ), ... space = \"lch\" , ... hue = \"longer\" ... ) >>> i ( 0.2477 ) . to_string () lch(52% 58.1 80.761) To help visualize the different hue methods, consider the following evaluation between rebeccapurple and lch ( 85 % 85 805 ) in the table below. Check out the CSS level 4 specification to learn more about each one. shorter : >>> Color ( \"rebeccapurple\" ) . interpolate ( ... \"lch(85% 100 805)\" , ... space = 'lch' , ... hue = \"shorter\" ... ) <coloraide.color.interpolate.InterpolateSingle object at 0x1220eba00> longer : >>> Color ( \"rebeccapurple\" ) . interpolate ( ... \"lch(85% 100 805)\" , ... space = 'lch' , ... hue = \"longer\" ... ) <coloraide.color.interpolate.InterpolateSingle object at 0x1220eb9a0> increasing : >>> Color ( \"rebeccapurple\" ) . interpolate ( ... \"lch(85% 100 805)\" , ... space = 'lch' , ... hue = \"increasing\" ... ) <coloraide.color.interpolate.InterpolateSingle object at 0x1220ebe20> decreasing : >>> Color ( \"rebeccapurple\" ) . interpolate ( ... \"lch(85% 100 805)\" , ... space = 'lch' , ... hue = \"decreasing\" ... ) <coloraide.color.interpolate.InterpolateSingle object at 0x1220eb9a0> specified : >>> Color ( \"rebeccapurple\" ) . interpolate ( ... \"lch(85% 100 805)\" , ... space = 'lch' , ... hue = \"specified\" ... ) <coloraide.color.interpolate.InterpolateSingle object at 0x1220eb1c0> We can also apply easing functions by providing a function via progress . Here we use a function that returns t ** 3 for the period when interpolating each channel: >>> Color ( \"lch(50% 50 0)\" ) . interpolate ( ... \"lch(90% 50 20)\" , ... progress = lambda t : t ** 3 ... ) <coloraide.color.interpolate.InterpolateSingle object at 0x1220eb340> We can even apply a specific easing functions to a specific channels. You can specify one or more channels, all with different functions. >>> Color ( \"lch(50% 50 0)\" ) . interpolate ( ... \"lch(90% 50 20 / 0)\" , ... progress = { ... 'alpha' : lambda t : t ** 3 ... } ... ) <coloraide.color.interpolate.InterpolateSingle object at 0x1220eb760> You can also set all the channels to a function via all and then override specific channels. >>> Color ( \"lch(50% 50 0)\" ) . interpolate ( ... \"lch(90% 50 20 / 0)\" , ... progress = { ... 'all' : lambda t : 1 - t , ... 'alpha' : lambda t : t ** 3 ... } ... ) <coloraide.color.interpolate.InterpolateSingle object at 0x1220eb790> Mixing Colors can be mixed together to create new colors. Mixing is built on top of the interpolate function and will return a color between the current and specified color. If colors are requested to be interpolated within a color space smaller than the original, the colors will be gamut mapped into the desired color space. Tip Mix, just like interpolation, also accepts the accept and hue parameters. As an example, if we had the color red and the color blue , and we wanted to mix them, we can just call the mix method, and we'll get: >>> Color ( \"red\" ) . mix ( Color ( \"blue\" )) color(srgb 0.75682 -0.11573 0.53401 / 1) The mix method will mix the two colors in the CIELAB color space by default. If needed, a different color space can be specified with the space parameter. Notice below that this creates a different color. The results of mixing in a different color space may be more desirable as color mixing may be more natural. >>> Color ( \"red\" ) . mix ( Color ( \"blue\" ), space = \"lch\" ) color(srgb 0.96059 -0.39549 0.52588 / 1) By default, colors are mixed at 50%, but the percentage can be controlled. Here we mix the color blue into the color red at 20%. This gives us the color of rgb ( 204 0 51 ) (after fitting). >>> Color ( \"red\" ) . mix ( Color ( \"blue\" ), 0.2 ) color(srgb 0.91305 -0.08551 0.26448 / 1) Mix can also accept a string and will create the color for us which is great if we don't need to work with the second color afterwards. >>> Color ( \"red\" ) . mix ( \"blue\" , 0.2 ) color(srgb 0.91305 -0.08551 0.26448 / 1) Mixing will always return a new color unless in_place is set True . Steps The steps method creates a list of discrete colors. Like mixing, it is also built on interpolate . Just provide two colors, and specify how many steps are wanted. The steps parameter essentially acts as a minimum steps requirement. >>> Color ( \"red\" ) . steps ( \"blue\" , steps = 10 ) [color(srgb 1 0 0 / 1), color(srgb 0.95272 -0.05962 0.17634 / 1), color(srgb 0.9028 -0.0902 0.28513 / 1), color(srgb 0.84897 -0.10676 0.38544 / 1), color(srgb 0.78947 -0.11457 0.48435 / 1), color(srgb 0.72167 -0.11512 0.58398 / 1), color(srgb 0.64126 -0.10833 0.68514 / 1), color(srgb 0.54001 -0.09256 0.78814 / 1), color(srgb 0.39653 -0.06224 0.89308 / 1), color(srgb 0 0 1 / 1)] If desired, multiple colors can be provided, and steps will be returned for all the interpolation regions. When interpolating multiple colors, piecewise interpolation is used (which is covered in more detail later). >>> Color ( \"red\" ) . steps ([ \"orange\" , \"yellow\" , \"green\" ], steps = 10 ) [color(srgb 1 0 0 / 1), color(srgb 1.0074 0.34698 -0.01706 / 1), color(srgb 1.0078 0.50984 -0.01862 / 1), color(srgb 1 0.64706 0 / 1), color(srgb 1.0072 0.76726 -0.00616 / 1), color(srgb 1.0075 0.88437 -0.00657 / 1), color(srgb 1 1 0 / 1), color(srgb 0.71125 0.83172 -0.00637 / 1), color(srgb 0.42248 0.66583 -0.00518 / 1), color(srgb 0 0.50196 0 / 1)] Steps can also be configured to return colors based on a maximum Delta E distance. This means you can ensure the distance between all colors is no greater than a certain value. In this example, we specify the color color ( display-p3 0 1 0 ) and interpolate steps between red . The result gives us an array of colors, where the distance between any two colors should be no greater than the Delta E result of 10. >>> Color ( \"display-p3\" , [ 0 , 1 , 0 ]) . steps ( ... \"red\" , ... space = \"lch\" , ... out_space = \"srgb\" , ... max_delta_e = 10 ... ) [color(srgb -0.51156 1.0183 -0.31071 / 1), color(srgb -0.46342 1.0029 -0.32408 / 1), color(srgb -0.40804 0.98732 -0.33348 / 1), color(srgb -0.34135 0.9715 -0.33979 / 1), color(srgb -0.25327 0.95543 -0.34367 / 1), color(srgb -0.09278 0.93911 -0.34558 / 1), color(srgb 0.204 0.92253 -0.34591 / 1), color(srgb 0.30884 0.90568 -0.34494 / 1), color(srgb 0.38263 0.88855 -0.34292 / 1), color(srgb 0.44217 0.87114 -0.34034 / 1), color(srgb 0.49309 0.85344 -0.33749 / 1), color(srgb 0.53801 0.83543 -0.33436 / 1), color(srgb 0.57844 0.81712 -0.33094 / 1), color(srgb 0.6153 0.79849 -0.32724 / 1), color(srgb 0.64921 0.77954 -0.32324 / 1), color(srgb 0.6806 0.76026 -0.31894 / 1), color(srgb 0.70981 0.74065 -0.31434 / 1), color(srgb 0.73705 0.72069 -0.30943 / 1), color(srgb 0.76252 0.70037 -0.30419 / 1), color(srgb 0.78635 0.6797 -0.29864 / 1), color(srgb 0.80865 0.65865 -0.29275 / 1), color(srgb 0.82952 0.63722 -0.28651 / 1), color(srgb 0.84901 0.6154 -0.27992 / 1), color(srgb 0.8672 0.59316 -0.27296 / 1), color(srgb 0.88411 0.57049 -0.26561 / 1), color(srgb 0.89979 0.54736 -0.25785 / 1), color(srgb 0.91428 0.52375 -0.24967 / 1), color(srgb 0.92759 0.49962 -0.24103 / 1), color(srgb 0.93974 0.47492 -0.2319 / 1), color(srgb 0.95076 0.44961 -0.22224 / 1), color(srgb 0.96065 0.42359 -0.21199 / 1), color(srgb 0.96943 0.39678 -0.20109 / 1), color(srgb 0.97712 0.36903 -0.18944 / 1), color(srgb 0.98372 0.34016 -0.17692 / 1), color(srgb 0.98924 0.30988 -0.16338 / 1), color(srgb 0.9937 0.27778 -0.14857 / 1), color(srgb 0.9971 0.2432 -0.13215 / 1), color(srgb 0.99943 0.20494 -0.11295 / 1), color(srgb 1.0007 0.16059 -0.0886 / 1), color(srgb 1.0009 0.10349 -0.05397 / 1), color(srgb 1 0 0 / 1)] max_steps can be used to limit the results of max_delta_e . Obviously, this affects the Delta E between the colors inversely. >>> Color ( \"display-p3\" , [ 0 , 1 , 0 ]) . steps ( ... \"red\" , ... space = \"lch\" , ... out_space = \"srgb\" , ... max_delta_e = 10 , ... max_steps = 10 ... ) [color(srgb -0.51156 1.0183 -0.31071 / 1), color(srgb -0.19959 0.94821 -0.34473 / 1), color(srgb 0.43605 0.87309 -0.34064 / 1), color(srgb 0.6269 0.79221 -0.32594 / 1), color(srgb 0.757 0.70492 -0.30538 / 1), color(srgb 0.85317 0.61049 -0.2784 / 1), color(srgb 0.92328 0.50772 -0.24397 / 1), color(srgb 0.97034 0.39374 -0.19983 / 1), color(srgb 0.99572 0.25894 -0.13968 / 1), color(srgb 1 0 0 / 1)] While steps (which functions as a minimum required steps) will push the delta even smaller if the required steps is greater than the calculated maximum Delta E. >>> Color ( \"display-p3\" , [ 0 , 1 , 0 ]) . steps ( ... \"red\" , ... space = \"lch\" , ... out_space = \"srgb\" , ... max_delta_e = 10 , ... steps = 50 ... ) [color(srgb -0.51156 1.0183 -0.31071 / 1), color(srgb -0.47272 1.0057 -0.32196 / 1), color(srgb -0.42942 0.99307 -0.33042 / 1), color(srgb -0.37987 0.98025 -0.33665 / 1), color(srgb -0.32077 0.96726 -0.34104 / 1), color(srgb -0.24441 0.95411 -0.34389 / 1), color(srgb -0.11969 0.94079 -0.34546 / 1), color(srgb 0.16003 0.92729 -0.34596 / 1), color(srgb 0.26562 0.91362 -0.34554 / 1), color(srgb 0.33667 0.89977 -0.34435 / 1), color(srgb 0.39311 0.88573 -0.34252 / 1), color(srgb 0.44105 0.8715 -0.3404 / 1), color(srgb 0.48325 0.85708 -0.3381 / 1), color(srgb 0.52119 0.84245 -0.33561 / 1), color(srgb 0.55583 0.82762 -0.33293 / 1), color(srgb 0.58777 0.81259 -0.33006 / 1), color(srgb 0.61745 0.79734 -0.327 / 1), color(srgb 0.6452 0.78188 -0.32375 / 1), color(srgb 0.67124 0.7662 -0.32029 / 1), color(srgb 0.69576 0.7503 -0.31663 / 1), color(srgb 0.71891 0.73417 -0.31277 / 1), color(srgb 0.74079 0.71781 -0.3087 / 1), color(srgb 0.76151 0.70121 -0.30441 / 1), color(srgb 0.78114 0.68437 -0.29991 / 1), color(srgb 0.79973 0.66729 -0.29519 / 1), color(srgb 0.81734 0.64995 -0.29024 / 1), color(srgb 0.83401 0.63236 -0.28506 / 1), color(srgb 0.84978 0.6145 -0.27964 / 1), color(srgb 0.86468 0.59636 -0.27397 / 1), color(srgb 0.87872 0.57794 -0.26805 / 1), color(srgb 0.89194 0.55922 -0.26186 / 1), color(srgb 0.90435 0.54018 -0.2554 / 1), color(srgb 0.91597 0.52082 -0.24864 / 1), color(srgb 0.9268 0.50111 -0.24158 / 1), color(srgb 0.93687 0.48103 -0.23419 / 1), color(srgb 0.94617 0.46054 -0.22645 / 1), color(srgb 0.95472 0.43961 -0.21834 / 1), color(srgb 0.96253 0.41819 -0.20982 / 1), color(srgb 0.9696 0.39622 -0.20086 / 1), color(srgb 0.97594 0.37363 -0.19139 / 1), color(srgb 0.98155 0.35032 -0.18137 / 1), color(srgb 0.98645 0.32614 -0.17071 / 1), color(srgb 0.99063 0.30092 -0.15929 / 1), color(srgb 0.99409 0.27438 -0.14698 / 1), color(srgb 0.99686 0.24614 -0.13356 / 1), color(srgb 0.99891 0.21555 -0.11844 / 1), color(srgb 1.0003 0.18151 -0.10037 / 1), color(srgb 1.0009 0.14176 -0.07757 / 1), color(srgb 1.0008 0.09013 -0.04537 / 1), color(srgb 1 0 0 / 1)] The default delta E method is delta E 76, which is a simple euclidean distancing in the CIELAB color space. Piecewise Interpolation The interploate and steps method allows for piecewise interpolation across multiple color ranges. Anytime, multiple colors are provided via a list, the piecewise logic will be applied to the various segments. >>> Color ( 'red' ) . interpolate ([ 'white' , 'black' , 'blue' ]) <coloraide.color.interpolate.InterpolatePiecewise object at 0x1220ebdc0> The interpolation between each pair of colors defaults to using the options provided via the interpolate parameters, but you can change them for a given range by using the Piecewise object. For instance, we could apply an easing between just the white and black . Notice that Piecewise is applied to the second color in the range, and the options will only apply to the interpolation of that color and the color immediately before it. >>> Color ( 'red' ) . interpolate ([ 'white' , Piecewise ( 'black' , progress = lambda t : t * ( 2 - t )), 'blue' ]) <coloraide.color.interpolate.InterpolatePiecewise object at 0x1220eb220> Additionally, you can set color stops using the stop parameter. To set the stop on the base color, simply set the stop parameter in the interploate method. >>> Color ( 'red' ) . interpolate ([ Piecewise ( 'white' , 0.6 ), Piecewise ( 'black' , 0.8 ), 'blue' ], stop = 0.4 ) <coloraide.color.interpolate.InterpolatePiecewise object at 0x1220eb670> As previously mentioned, this can also be applied to steps as well. >>> Color ( 'red' ) . steps ([ Piecewise ( 'white' , 0.6 ), Piecewise ( 'black' , 0.8 ), 'blue' ], stop = 0.4 , steps = 15 ) [color(srgb 1 0 0 / 1), color(srgb 1 0 0 / 1), color(srgb 1 0 0 / 1), color(srgb 1 0 0 / 1), color(srgb 1 0 0 / 1), color(srgb 1 0 0 / 1), color(srgb 1.0271 0.29999 0.1698 / 1), color(srgb 1.0626 0.62412 0.50308 / 1), color(srgb 1.0355 0.89488 0.85334 / 1), color(srgb 0.7623 0.7623 0.7623 / 1), color(srgb 0.39678 0.39678 0.39678 / 1), color(srgb 0.08542 0.08542 0.08542 / 1), color(srgb 0.10804 0.05743 0.26725 / 1), color(srgb 0.13751 0.05966 0.61311 / 1), color(srgb 0 0 1 / 1)] Null Handling Color spaces that have hue coordinates often have rules about when the hue is considered relevant. For instance, in the HSL color space, if saturation is zero, the hue is considered null. This is because the color is \"without color\" or achromatic; therefore, it has no hue, or the hue is undefined. Many libraries, like d3-color , chroma.js , and color.js , represent null hues with NaN (not a number). This is usually done to make color interpolation easier. Some, like d3-color, are a bit more liberal with NaN and will target special cases that are above and beyond the normal rules to help ensure good interpolation. For instance, they not only mark hue null on HSL colors when saturation is zero, but also when lightness is zero or one hundred (essentially appearing black or white). In fact, they'll mark saturation as NaN when lightness indicates \"black\" or \"white\". ColorAide also uses NaN , or in Python float ( 'nan' ) . In certain situations, when a hue is deemed undefined, the hue value will be set to coloraide.NaN , which is just a constant containing float ( 'nan' ) . When interpolating, if one color's channel has a NaN , the other color's channel will be used as the result. If both colors have a NaN for the same channel, then 0 will be returned. Notice that in this example, because white's saturation is zero, the hue is undefined. Because the hue is undefined, when the color is mixed with a second color ( purple ), the hue of the second color is used. >>> color = Color ( 'white' ) . convert ( 'hsl' ) >>> color . coords () [nan, 0.0, 100.0] >>> color2 = Color ( 'purple' ) . convert ( 'hsl' ) >>> color2 . coords () [300.0, 100.0, 25.098039215686274] >>> color . mix ( color2 , space = \"hsl\" ) color(hsl 300 50% 62.549% / 1) Technically, any channel can be set to NaN . This is basically what the mask method is used for. It can set any and all specified channels to NaN for the purpose of restricting channels when interpolating: >>> Color ( 'white' ) . mask ([ 'red' , 'green' ]) . coords () [nan, nan, 1.0] Channels can also be set directly to NaN , but it must be done by instantiating a Color object with raw data or by manually setting it via a channel property or accessor. CSS input string do not allow the NaN values at this time. >>> from coloraide import NaN >>> Color ( \"srgb\" , [ 1 , NaN , 1 ]) . coords () [1.0, nan, 1.0] >>> Color ( \"red\" ) . set ( 'green' , NaN ) . coords () [1.0, nan, 0.0] When printing to a string, NaN s are always converted to 0 : >>> from coloraide import NaN >>> Color ( \"srgb\" , [ 1 , NaN , 1 ]) color(srgb 1 0 1 / 1) At any time, a channel can be checked for whether it is NaN by using the is_nan method: >>> Color ( \"white\" ) . convert ( 'hsl' ) . is_nan ( 'hue' ) True It can be useful to check whether a channel is NaN as NaN values can't be added, subtracted, multiplied, etc. They will always return NaN unless you directly replace them. >>> color = Color ( \"white\" ) . convert ( 'hsl' ) >>> color . hue = color . hue + 3 >>> color . is_nan ( 'hue' ) True >>> color . hue = 3 >>> color . is_nan ( 'hue' ) False","title":"Color Interpolation"},{"location":"interpolation/#color-interpolation","text":"","title":"Color Interpolation"},{"location":"interpolation/#interpolating","text":"The interpolate method allows a user to create an interpolation function. This can be used to create a list of gradient colors, or whatever is needed. This function is used to drive all the features under the interpolation umbrella. A returned interpolation function accepts an input between 0 - 1, if values are provided out of this range, the color will be extrapolated and the results may be surprising. In this example, we create an interpolation between rebeccapurple and lch ( 85 % 100 85 ) (color previews are fit to the sRGB gamut). We then step through values of 0.1 , 0.2 , 0.3 , etc. >>> i = Color ( \"rebeccapurple\" ) . interpolate ( \"lch(85% 100 85)\" , space = 'lch' ) >>> [ i ( x / 20 ) . to_string () for x in range ( 20 )] ['rgb(102 51 153)', 'rgb(122.45 48.665 154.44)', 'rgb(142.01 45.343 154.31)', 'rgb(160.74 41.154 152.65)', 'rgb(178.56 36.401 149.51)', 'rgb(195.39 31.744 144.97)', 'rgb(211.09 28.47 139.17)', 'rgb(225.54 28.451 132.21)', 'rgb(238.59 32.984 124.24)', 'rgb(250.14 41.637 115.39)', 'rgb(255 53.098 105.75)', 'rgb(242.3 98.778 107.91)', 'rgb(249.19 108.42 101.41)', 'rgb(254.67 118.96 94.665)', 'rgb(255 130.24 87.784)', 'rgb(255 142.11 80.888)', 'rgb(255 154.43 74.138)', 'rgb(255 167.07 67.77)', 'rgb(255 179.93 62.157)', 'rgb(255 192.91 57.878)'] This allows us to create a range of colors that we can use in a gradient. >>> Color ( \"rebeccapurple\" ) . interpolate ( ... \"lch(85% 100 85)\" , ... space = 'lch' ... ) <coloraide.color.interpolate.InterpolateSingle object at 0x1221199a0> Interpolation can also be done across multiple colors. The function, just like when interpolating between two colors, takes a range of 0 - 1. When interpolating multiple colors, piecewise interpolation is used (which is covered in more detail later). >>> Color ( 'black' ) . interpolate ([ 'red' , 'white' ]) <coloraide.color.interpolate.InterpolatePiecewise object at 0x122119eb0> If desired, we can target one or more specific channels for mixing which will keep all the other channels constant on the base color. Channels can be any channel associated with the color space in which the interpolation is taking place (including alpha ). In the following example, we have a base color of lch ( 52 % 58 . 1 22 . 7 ) which we mix with lch ( 56 % 49 . 1 257 . 1 ) . We also specify that we want to only mix the hue channel by applying a mask to all the other channels except hue . Applying this logic, we will end up with a range of colors that maintain the same lightness and chroma, but with different hues. To learn more about masking and null hues, check out Null Handling . We can see as we step through the colors that only the hue is interpolated. >>> Color ( \"lch(52% 58.1 22.7)\" ) . interpolate ( ... Color ( \"lch(56% 49.1 257.1)\" ) . mask ( \"hue\" , invert = True ), ... space = \"lch\" ... ) <coloraide.color.interpolate.InterpolateSingle object at 0x122119cd0> Additionally, hues are special, and we can control the way the interpolation is evaluated. The hue parameter accepts such values as shorter , longer , increasing , decreasing , and specified ( shorter being the default). Below, we can see how the interpolation varies using shorter vs longer . >>> i = Color ( \"lch(52% 58.1 22.7)\" ) . interpolate ( ... Color ( \"lch(56% 49.1 257.1)\" ) . mask ( \"hue\" , invert = True ), ... space = \"lch\" ... ) >>> i ( 0.2477 ) . to_string () lch(52% 58.1 351.59) >>> i = Color ( \"lch(52% 58.1 22.7)\" ) . interpolate ( ... Color ( \"lch(56% 49.1 257.1)\" ) . mask ( \"hue\" , invert = True ), ... space = \"lch\" , ... hue = \"longer\" ... ) >>> i ( 0.2477 ) . to_string () lch(52% 58.1 80.761) To help visualize the different hue methods, consider the following evaluation between rebeccapurple and lch ( 85 % 85 805 ) in the table below. Check out the CSS level 4 specification to learn more about each one. shorter : >>> Color ( \"rebeccapurple\" ) . interpolate ( ... \"lch(85% 100 805)\" , ... space = 'lch' , ... hue = \"shorter\" ... ) <coloraide.color.interpolate.InterpolateSingle object at 0x1220eba00> longer : >>> Color ( \"rebeccapurple\" ) . interpolate ( ... \"lch(85% 100 805)\" , ... space = 'lch' , ... hue = \"longer\" ... ) <coloraide.color.interpolate.InterpolateSingle object at 0x1220eb9a0> increasing : >>> Color ( \"rebeccapurple\" ) . interpolate ( ... \"lch(85% 100 805)\" , ... space = 'lch' , ... hue = \"increasing\" ... ) <coloraide.color.interpolate.InterpolateSingle object at 0x1220ebe20> decreasing : >>> Color ( \"rebeccapurple\" ) . interpolate ( ... \"lch(85% 100 805)\" , ... space = 'lch' , ... hue = \"decreasing\" ... ) <coloraide.color.interpolate.InterpolateSingle object at 0x1220eb9a0> specified : >>> Color ( \"rebeccapurple\" ) . interpolate ( ... \"lch(85% 100 805)\" , ... space = 'lch' , ... hue = \"specified\" ... ) <coloraide.color.interpolate.InterpolateSingle object at 0x1220eb1c0> We can also apply easing functions by providing a function via progress . Here we use a function that returns t ** 3 for the period when interpolating each channel: >>> Color ( \"lch(50% 50 0)\" ) . interpolate ( ... \"lch(90% 50 20)\" , ... progress = lambda t : t ** 3 ... ) <coloraide.color.interpolate.InterpolateSingle object at 0x1220eb340> We can even apply a specific easing functions to a specific channels. You can specify one or more channels, all with different functions. >>> Color ( \"lch(50% 50 0)\" ) . interpolate ( ... \"lch(90% 50 20 / 0)\" , ... progress = { ... 'alpha' : lambda t : t ** 3 ... } ... ) <coloraide.color.interpolate.InterpolateSingle object at 0x1220eb760> You can also set all the channels to a function via all and then override specific channels. >>> Color ( \"lch(50% 50 0)\" ) . interpolate ( ... \"lch(90% 50 20 / 0)\" , ... progress = { ... 'all' : lambda t : 1 - t , ... 'alpha' : lambda t : t ** 3 ... } ... ) <coloraide.color.interpolate.InterpolateSingle object at 0x1220eb790>","title":"Interpolating"},{"location":"interpolation/#mixing","text":"Colors can be mixed together to create new colors. Mixing is built on top of the interpolate function and will return a color between the current and specified color. If colors are requested to be interpolated within a color space smaller than the original, the colors will be gamut mapped into the desired color space. Tip Mix, just like interpolation, also accepts the accept and hue parameters. As an example, if we had the color red and the color blue , and we wanted to mix them, we can just call the mix method, and we'll get: >>> Color ( \"red\" ) . mix ( Color ( \"blue\" )) color(srgb 0.75682 -0.11573 0.53401 / 1) The mix method will mix the two colors in the CIELAB color space by default. If needed, a different color space can be specified with the space parameter. Notice below that this creates a different color. The results of mixing in a different color space may be more desirable as color mixing may be more natural. >>> Color ( \"red\" ) . mix ( Color ( \"blue\" ), space = \"lch\" ) color(srgb 0.96059 -0.39549 0.52588 / 1) By default, colors are mixed at 50%, but the percentage can be controlled. Here we mix the color blue into the color red at 20%. This gives us the color of rgb ( 204 0 51 ) (after fitting). >>> Color ( \"red\" ) . mix ( Color ( \"blue\" ), 0.2 ) color(srgb 0.91305 -0.08551 0.26448 / 1) Mix can also accept a string and will create the color for us which is great if we don't need to work with the second color afterwards. >>> Color ( \"red\" ) . mix ( \"blue\" , 0.2 ) color(srgb 0.91305 -0.08551 0.26448 / 1) Mixing will always return a new color unless in_place is set True .","title":"Mixing"},{"location":"interpolation/#steps","text":"The steps method creates a list of discrete colors. Like mixing, it is also built on interpolate . Just provide two colors, and specify how many steps are wanted. The steps parameter essentially acts as a minimum steps requirement. >>> Color ( \"red\" ) . steps ( \"blue\" , steps = 10 ) [color(srgb 1 0 0 / 1), color(srgb 0.95272 -0.05962 0.17634 / 1), color(srgb 0.9028 -0.0902 0.28513 / 1), color(srgb 0.84897 -0.10676 0.38544 / 1), color(srgb 0.78947 -0.11457 0.48435 / 1), color(srgb 0.72167 -0.11512 0.58398 / 1), color(srgb 0.64126 -0.10833 0.68514 / 1), color(srgb 0.54001 -0.09256 0.78814 / 1), color(srgb 0.39653 -0.06224 0.89308 / 1), color(srgb 0 0 1 / 1)] If desired, multiple colors can be provided, and steps will be returned for all the interpolation regions. When interpolating multiple colors, piecewise interpolation is used (which is covered in more detail later). >>> Color ( \"red\" ) . steps ([ \"orange\" , \"yellow\" , \"green\" ], steps = 10 ) [color(srgb 1 0 0 / 1), color(srgb 1.0074 0.34698 -0.01706 / 1), color(srgb 1.0078 0.50984 -0.01862 / 1), color(srgb 1 0.64706 0 / 1), color(srgb 1.0072 0.76726 -0.00616 / 1), color(srgb 1.0075 0.88437 -0.00657 / 1), color(srgb 1 1 0 / 1), color(srgb 0.71125 0.83172 -0.00637 / 1), color(srgb 0.42248 0.66583 -0.00518 / 1), color(srgb 0 0.50196 0 / 1)] Steps can also be configured to return colors based on a maximum Delta E distance. This means you can ensure the distance between all colors is no greater than a certain value. In this example, we specify the color color ( display-p3 0 1 0 ) and interpolate steps between red . The result gives us an array of colors, where the distance between any two colors should be no greater than the Delta E result of 10. >>> Color ( \"display-p3\" , [ 0 , 1 , 0 ]) . steps ( ... \"red\" , ... space = \"lch\" , ... out_space = \"srgb\" , ... max_delta_e = 10 ... ) [color(srgb -0.51156 1.0183 -0.31071 / 1), color(srgb -0.46342 1.0029 -0.32408 / 1), color(srgb -0.40804 0.98732 -0.33348 / 1), color(srgb -0.34135 0.9715 -0.33979 / 1), color(srgb -0.25327 0.95543 -0.34367 / 1), color(srgb -0.09278 0.93911 -0.34558 / 1), color(srgb 0.204 0.92253 -0.34591 / 1), color(srgb 0.30884 0.90568 -0.34494 / 1), color(srgb 0.38263 0.88855 -0.34292 / 1), color(srgb 0.44217 0.87114 -0.34034 / 1), color(srgb 0.49309 0.85344 -0.33749 / 1), color(srgb 0.53801 0.83543 -0.33436 / 1), color(srgb 0.57844 0.81712 -0.33094 / 1), color(srgb 0.6153 0.79849 -0.32724 / 1), color(srgb 0.64921 0.77954 -0.32324 / 1), color(srgb 0.6806 0.76026 -0.31894 / 1), color(srgb 0.70981 0.74065 -0.31434 / 1), color(srgb 0.73705 0.72069 -0.30943 / 1), color(srgb 0.76252 0.70037 -0.30419 / 1), color(srgb 0.78635 0.6797 -0.29864 / 1), color(srgb 0.80865 0.65865 -0.29275 / 1), color(srgb 0.82952 0.63722 -0.28651 / 1), color(srgb 0.84901 0.6154 -0.27992 / 1), color(srgb 0.8672 0.59316 -0.27296 / 1), color(srgb 0.88411 0.57049 -0.26561 / 1), color(srgb 0.89979 0.54736 -0.25785 / 1), color(srgb 0.91428 0.52375 -0.24967 / 1), color(srgb 0.92759 0.49962 -0.24103 / 1), color(srgb 0.93974 0.47492 -0.2319 / 1), color(srgb 0.95076 0.44961 -0.22224 / 1), color(srgb 0.96065 0.42359 -0.21199 / 1), color(srgb 0.96943 0.39678 -0.20109 / 1), color(srgb 0.97712 0.36903 -0.18944 / 1), color(srgb 0.98372 0.34016 -0.17692 / 1), color(srgb 0.98924 0.30988 -0.16338 / 1), color(srgb 0.9937 0.27778 -0.14857 / 1), color(srgb 0.9971 0.2432 -0.13215 / 1), color(srgb 0.99943 0.20494 -0.11295 / 1), color(srgb 1.0007 0.16059 -0.0886 / 1), color(srgb 1.0009 0.10349 -0.05397 / 1), color(srgb 1 0 0 / 1)] max_steps can be used to limit the results of max_delta_e . Obviously, this affects the Delta E between the colors inversely. >>> Color ( \"display-p3\" , [ 0 , 1 , 0 ]) . steps ( ... \"red\" , ... space = \"lch\" , ... out_space = \"srgb\" , ... max_delta_e = 10 , ... max_steps = 10 ... ) [color(srgb -0.51156 1.0183 -0.31071 / 1), color(srgb -0.19959 0.94821 -0.34473 / 1), color(srgb 0.43605 0.87309 -0.34064 / 1), color(srgb 0.6269 0.79221 -0.32594 / 1), color(srgb 0.757 0.70492 -0.30538 / 1), color(srgb 0.85317 0.61049 -0.2784 / 1), color(srgb 0.92328 0.50772 -0.24397 / 1), color(srgb 0.97034 0.39374 -0.19983 / 1), color(srgb 0.99572 0.25894 -0.13968 / 1), color(srgb 1 0 0 / 1)] While steps (which functions as a minimum required steps) will push the delta even smaller if the required steps is greater than the calculated maximum Delta E. >>> Color ( \"display-p3\" , [ 0 , 1 , 0 ]) . steps ( ... \"red\" , ... space = \"lch\" , ... out_space = \"srgb\" , ... max_delta_e = 10 , ... steps = 50 ... ) [color(srgb -0.51156 1.0183 -0.31071 / 1), color(srgb -0.47272 1.0057 -0.32196 / 1), color(srgb -0.42942 0.99307 -0.33042 / 1), color(srgb -0.37987 0.98025 -0.33665 / 1), color(srgb -0.32077 0.96726 -0.34104 / 1), color(srgb -0.24441 0.95411 -0.34389 / 1), color(srgb -0.11969 0.94079 -0.34546 / 1), color(srgb 0.16003 0.92729 -0.34596 / 1), color(srgb 0.26562 0.91362 -0.34554 / 1), color(srgb 0.33667 0.89977 -0.34435 / 1), color(srgb 0.39311 0.88573 -0.34252 / 1), color(srgb 0.44105 0.8715 -0.3404 / 1), color(srgb 0.48325 0.85708 -0.3381 / 1), color(srgb 0.52119 0.84245 -0.33561 / 1), color(srgb 0.55583 0.82762 -0.33293 / 1), color(srgb 0.58777 0.81259 -0.33006 / 1), color(srgb 0.61745 0.79734 -0.327 / 1), color(srgb 0.6452 0.78188 -0.32375 / 1), color(srgb 0.67124 0.7662 -0.32029 / 1), color(srgb 0.69576 0.7503 -0.31663 / 1), color(srgb 0.71891 0.73417 -0.31277 / 1), color(srgb 0.74079 0.71781 -0.3087 / 1), color(srgb 0.76151 0.70121 -0.30441 / 1), color(srgb 0.78114 0.68437 -0.29991 / 1), color(srgb 0.79973 0.66729 -0.29519 / 1), color(srgb 0.81734 0.64995 -0.29024 / 1), color(srgb 0.83401 0.63236 -0.28506 / 1), color(srgb 0.84978 0.6145 -0.27964 / 1), color(srgb 0.86468 0.59636 -0.27397 / 1), color(srgb 0.87872 0.57794 -0.26805 / 1), color(srgb 0.89194 0.55922 -0.26186 / 1), color(srgb 0.90435 0.54018 -0.2554 / 1), color(srgb 0.91597 0.52082 -0.24864 / 1), color(srgb 0.9268 0.50111 -0.24158 / 1), color(srgb 0.93687 0.48103 -0.23419 / 1), color(srgb 0.94617 0.46054 -0.22645 / 1), color(srgb 0.95472 0.43961 -0.21834 / 1), color(srgb 0.96253 0.41819 -0.20982 / 1), color(srgb 0.9696 0.39622 -0.20086 / 1), color(srgb 0.97594 0.37363 -0.19139 / 1), color(srgb 0.98155 0.35032 -0.18137 / 1), color(srgb 0.98645 0.32614 -0.17071 / 1), color(srgb 0.99063 0.30092 -0.15929 / 1), color(srgb 0.99409 0.27438 -0.14698 / 1), color(srgb 0.99686 0.24614 -0.13356 / 1), color(srgb 0.99891 0.21555 -0.11844 / 1), color(srgb 1.0003 0.18151 -0.10037 / 1), color(srgb 1.0009 0.14176 -0.07757 / 1), color(srgb 1.0008 0.09013 -0.04537 / 1), color(srgb 1 0 0 / 1)] The default delta E method is delta E 76, which is a simple euclidean distancing in the CIELAB color space.","title":"Steps"},{"location":"interpolation/#piecewise-interpolation","text":"The interploate and steps method allows for piecewise interpolation across multiple color ranges. Anytime, multiple colors are provided via a list, the piecewise logic will be applied to the various segments. >>> Color ( 'red' ) . interpolate ([ 'white' , 'black' , 'blue' ]) <coloraide.color.interpolate.InterpolatePiecewise object at 0x1220ebdc0> The interpolation between each pair of colors defaults to using the options provided via the interpolate parameters, but you can change them for a given range by using the Piecewise object. For instance, we could apply an easing between just the white and black . Notice that Piecewise is applied to the second color in the range, and the options will only apply to the interpolation of that color and the color immediately before it. >>> Color ( 'red' ) . interpolate ([ 'white' , Piecewise ( 'black' , progress = lambda t : t * ( 2 - t )), 'blue' ]) <coloraide.color.interpolate.InterpolatePiecewise object at 0x1220eb220> Additionally, you can set color stops using the stop parameter. To set the stop on the base color, simply set the stop parameter in the interploate method. >>> Color ( 'red' ) . interpolate ([ Piecewise ( 'white' , 0.6 ), Piecewise ( 'black' , 0.8 ), 'blue' ], stop = 0.4 ) <coloraide.color.interpolate.InterpolatePiecewise object at 0x1220eb670> As previously mentioned, this can also be applied to steps as well. >>> Color ( 'red' ) . steps ([ Piecewise ( 'white' , 0.6 ), Piecewise ( 'black' , 0.8 ), 'blue' ], stop = 0.4 , steps = 15 ) [color(srgb 1 0 0 / 1), color(srgb 1 0 0 / 1), color(srgb 1 0 0 / 1), color(srgb 1 0 0 / 1), color(srgb 1 0 0 / 1), color(srgb 1 0 0 / 1), color(srgb 1.0271 0.29999 0.1698 / 1), color(srgb 1.0626 0.62412 0.50308 / 1), color(srgb 1.0355 0.89488 0.85334 / 1), color(srgb 0.7623 0.7623 0.7623 / 1), color(srgb 0.39678 0.39678 0.39678 / 1), color(srgb 0.08542 0.08542 0.08542 / 1), color(srgb 0.10804 0.05743 0.26725 / 1), color(srgb 0.13751 0.05966 0.61311 / 1), color(srgb 0 0 1 / 1)]","title":"Piecewise Interpolation"},{"location":"interpolation/#null-handling","text":"Color spaces that have hue coordinates often have rules about when the hue is considered relevant. For instance, in the HSL color space, if saturation is zero, the hue is considered null. This is because the color is \"without color\" or achromatic; therefore, it has no hue, or the hue is undefined. Many libraries, like d3-color , chroma.js , and color.js , represent null hues with NaN (not a number). This is usually done to make color interpolation easier. Some, like d3-color, are a bit more liberal with NaN and will target special cases that are above and beyond the normal rules to help ensure good interpolation. For instance, they not only mark hue null on HSL colors when saturation is zero, but also when lightness is zero or one hundred (essentially appearing black or white). In fact, they'll mark saturation as NaN when lightness indicates \"black\" or \"white\". ColorAide also uses NaN , or in Python float ( 'nan' ) . In certain situations, when a hue is deemed undefined, the hue value will be set to coloraide.NaN , which is just a constant containing float ( 'nan' ) . When interpolating, if one color's channel has a NaN , the other color's channel will be used as the result. If both colors have a NaN for the same channel, then 0 will be returned. Notice that in this example, because white's saturation is zero, the hue is undefined. Because the hue is undefined, when the color is mixed with a second color ( purple ), the hue of the second color is used. >>> color = Color ( 'white' ) . convert ( 'hsl' ) >>> color . coords () [nan, 0.0, 100.0] >>> color2 = Color ( 'purple' ) . convert ( 'hsl' ) >>> color2 . coords () [300.0, 100.0, 25.098039215686274] >>> color . mix ( color2 , space = \"hsl\" ) color(hsl 300 50% 62.549% / 1) Technically, any channel can be set to NaN . This is basically what the mask method is used for. It can set any and all specified channels to NaN for the purpose of restricting channels when interpolating: >>> Color ( 'white' ) . mask ([ 'red' , 'green' ]) . coords () [nan, nan, 1.0] Channels can also be set directly to NaN , but it must be done by instantiating a Color object with raw data or by manually setting it via a channel property or accessor. CSS input string do not allow the NaN values at this time. >>> from coloraide import NaN >>> Color ( \"srgb\" , [ 1 , NaN , 1 ]) . coords () [1.0, nan, 1.0] >>> Color ( \"red\" ) . set ( 'green' , NaN ) . coords () [1.0, nan, 0.0] When printing to a string, NaN s are always converted to 0 : >>> from coloraide import NaN >>> Color ( \"srgb\" , [ 1 , NaN , 1 ]) color(srgb 1 0 1 / 1) At any time, a channel can be checked for whether it is NaN by using the is_nan method: >>> Color ( \"white\" ) . convert ( 'hsl' ) . is_nan ( 'hue' ) True It can be useful to check whether a channel is NaN as NaN values can't be added, subtracted, multiplied, etc. They will always return NaN unless you directly replace them. >>> color = Color ( \"white\" ) . convert ( 'hsl' ) >>> color . hue = color . hue + 3 >>> color . is_nan ( 'hue' ) True >>> color . hue = 3 >>> color . is_nan ( 'hue' ) False","title":"Null Handling"},{"location":"manipulation/","text":"Manipulating Colors Reading Coordinates There are various ways to read the current values of color coordinates. Channel properties can be read directly: >>> color = Color ( \"orange\" ) >>> color . red 1.0 Channel values can also be read by using the get method and providing the name of desired channel. >>> color = Color ( \"orange\" ) >>> color . get ( \"green\" ) 0.6470588235294118 All non-alpha coordinates can be read simultaneously by using the coords function. >>> color = Color ( \"orange\" ) >>> color . coords () [1.0, 0.6470588235294118, 0.0] >>> color . alpha 1.0 If a color coordinate is needed from another color space, it can be accessed by passing in the color space followed by the name of the desired coordinate. The necessary conversions will happen behind the scenes and the desired value will be returned. >>> Color ( \"blue\" ) . get ( \"lch.chroma\" ) 131.2070487171167 Modifying Coordinates Channel properties can be modified directly by using the named property. Here we modify red by adjusting its green property: >>> color = Color ( \"red\" ) >>> color . green = 0.5 >>> color . to_string () rgb(255 127.5 0) When doing so, keep in mind, the internal coordinates are being adjusted, and so they must be modified within the range in which the values are stored, and for sRGB, it is in the range of [0, 1]. If desired, the values can be modified with the set method. As these methods return a reference to the class, multiple set operations can be chained together. Chaining the operations together, we can transform white to rgb ( 0 127 . 5 255 ) . >>> Color ( \"white\" ) . set ( \"red\" , 0 ) . set ( \"green\" , 0.5 ) color(srgb 0 0.5 1 / 1) Channels in other color spaces can also be modified with the set function. Here we alter the color blue in the CIELCH color space and get rgb ( 19 . 403 81 . 154 0 ) . >>> Color ( \"blue\" ) . set ( 'lch.hue' , 130 ) color(srgb -0.25057 0.35691 -0.24775 / 1) Functions can also be used to modify a channel property. Here we do a relative adjustment of the green channel and transform the color pink to rgb ( 255 249 . 6 203 ) . >>> Color ( \"pink\" ) . set ( 'green' , lambda g : g * 1.3 ) color(srgb 1 0.97882 0.79608 / 1) Masking Channels Colors in general can use NaN to represent undefined color channels. This currently only happens by default for hue channels when the color is achromatic and has no defined hue. When interpolating, undefined channels will not be interpolated. Users may want to mask channels on their own to control which channels get interpolated, using the mask function can allow for a user to quickly and easily mask one or more channels: >>> Color ( 'white' ) . coords () [1.0, 1.0, 1.0] >>> Color ( 'white' ) . mask ([ 'red' , 'green' ]) . coords () [nan, nan, 1.0] The alpha channel can also be masked: >>> Color ( 'white' ) . mask ( 'alpha' ) . alpha nan Additionally, you can do inverse masks, or masks to that apply to every channel not specified. >>> c = Color ( 'white' ) . mask ( 'blue' , invert = True ) >>> c . coords () [nan, nan, 1.0] >>> c . alpha nan Checking Null Hues Cylindrical colors that offer a hue property can sometimes return NaN for a hue. This is usually because the hue is undefined. For example, the color hsl ( 360 0 % 100 % ) , while assigned a hue, does not actually exhibit any real hue since saturation is 0. Essentially, hue could be set to anything, and it would still have no affect on the actual color. So, ColorAide will actually set hue to NaN (or \"not a number\"). NaN is treated as a zero on output. >>> color = Color ( 'hsl(360 0 % 100% )' ) >>> color color(hsl 0 0% 100% / 1) >>> color . coords () [nan, 0.0, 100.0] Because NaN are not numbers, these values will not be included in color interpolation, and these values cannot be added, multiplied, or take part in any real math operations. All math operations performed on NaN simply return NaN . For this reason, it is useful to check if a hue is NaN . This can be done with the is_nan function. You can simply give is_nan the property you wish to check, and it will return either True or False . >>> Color ( 'hsl(360 0 % 100% )' ) . is_nan ( 'hue' ) True This is equivalent to using the math library and comparing the value directly: >>> import math >>> math . isnan ( Color ( 'hsl(360 0 % 100% )' ) . hue ) True","title":"Manipulating Colors"},{"location":"manipulation/#manipulating-colors","text":"","title":"Manipulating Colors"},{"location":"manipulation/#reading-coordinates","text":"There are various ways to read the current values of color coordinates. Channel properties can be read directly: >>> color = Color ( \"orange\" ) >>> color . red 1.0 Channel values can also be read by using the get method and providing the name of desired channel. >>> color = Color ( \"orange\" ) >>> color . get ( \"green\" ) 0.6470588235294118 All non-alpha coordinates can be read simultaneously by using the coords function. >>> color = Color ( \"orange\" ) >>> color . coords () [1.0, 0.6470588235294118, 0.0] >>> color . alpha 1.0 If a color coordinate is needed from another color space, it can be accessed by passing in the color space followed by the name of the desired coordinate. The necessary conversions will happen behind the scenes and the desired value will be returned. >>> Color ( \"blue\" ) . get ( \"lch.chroma\" ) 131.2070487171167","title":"Reading Coordinates"},{"location":"manipulation/#modifying-coordinates","text":"Channel properties can be modified directly by using the named property. Here we modify red by adjusting its green property: >>> color = Color ( \"red\" ) >>> color . green = 0.5 >>> color . to_string () rgb(255 127.5 0) When doing so, keep in mind, the internal coordinates are being adjusted, and so they must be modified within the range in which the values are stored, and for sRGB, it is in the range of [0, 1]. If desired, the values can be modified with the set method. As these methods return a reference to the class, multiple set operations can be chained together. Chaining the operations together, we can transform white to rgb ( 0 127 . 5 255 ) . >>> Color ( \"white\" ) . set ( \"red\" , 0 ) . set ( \"green\" , 0.5 ) color(srgb 0 0.5 1 / 1) Channels in other color spaces can also be modified with the set function. Here we alter the color blue in the CIELCH color space and get rgb ( 19 . 403 81 . 154 0 ) . >>> Color ( \"blue\" ) . set ( 'lch.hue' , 130 ) color(srgb -0.25057 0.35691 -0.24775 / 1) Functions can also be used to modify a channel property. Here we do a relative adjustment of the green channel and transform the color pink to rgb ( 255 249 . 6 203 ) . >>> Color ( \"pink\" ) . set ( 'green' , lambda g : g * 1.3 ) color(srgb 1 0.97882 0.79608 / 1)","title":"Modifying Coordinates"},{"location":"manipulation/#masking-channels","text":"Colors in general can use NaN to represent undefined color channels. This currently only happens by default for hue channels when the color is achromatic and has no defined hue. When interpolating, undefined channels will not be interpolated. Users may want to mask channels on their own to control which channels get interpolated, using the mask function can allow for a user to quickly and easily mask one or more channels: >>> Color ( 'white' ) . coords () [1.0, 1.0, 1.0] >>> Color ( 'white' ) . mask ([ 'red' , 'green' ]) . coords () [nan, nan, 1.0] The alpha channel can also be masked: >>> Color ( 'white' ) . mask ( 'alpha' ) . alpha nan Additionally, you can do inverse masks, or masks to that apply to every channel not specified. >>> c = Color ( 'white' ) . mask ( 'blue' , invert = True ) >>> c . coords () [nan, nan, 1.0] >>> c . alpha nan","title":"Masking Channels"},{"location":"manipulation/#checking-null-hues","text":"Cylindrical colors that offer a hue property can sometimes return NaN for a hue. This is usually because the hue is undefined. For example, the color hsl ( 360 0 % 100 % ) , while assigned a hue, does not actually exhibit any real hue since saturation is 0. Essentially, hue could be set to anything, and it would still have no affect on the actual color. So, ColorAide will actually set hue to NaN (or \"not a number\"). NaN is treated as a zero on output. >>> color = Color ( 'hsl(360 0 % 100% )' ) >>> color color(hsl 0 0% 100% / 1) >>> color . coords () [nan, 0.0, 100.0] Because NaN are not numbers, these values will not be included in color interpolation, and these values cannot be added, multiplied, or take part in any real math operations. All math operations performed on NaN simply return NaN . For this reason, it is useful to check if a hue is NaN . This can be done with the is_nan function. You can simply give is_nan the property you wish to check, and it will return either True or False . >>> Color ( 'hsl(360 0 % 100% )' ) . is_nan ( 'hue' ) True This is equivalent to using the math library and comparing the value directly: >>> import math >>> math . isnan ( Color ( 'hsl(360 0 % 100% )' ) . hue ) True","title":"Checking Null Hues"},{"location":"playground/","text":"This sandbox is powered by Pyodide . Preview, convert, interpolate, and explore! Loading coloraide... Edit Run Cancel #playground-inputs { -webkit-appearance: textarea; position: absolute; margin: 0; top: 0; left: 0; display: block; width: 100%; min-height: 15em; height: calc(100% + 0.2rem); border: none; padding: .7720588235em 1.1764705882em; outline: none; cursor: text; overflow-x: auto; overflow-y: hidden; caret-color: var(--md-code-fg-color); color: transparent; background-color: transparent; font-feature-settings: \"kern\"; font-family: var(--md-code-font-family,_),SFMono-Regular,Consolas,Menlo,monospace; line-height: 1.4; font-size: .85em; z-index: 1; resize: none; word-wrap: unset; white-space: pre; } #playground-inputs::selection { color: var(--md-code-bg-color); background: var(--md-code-fg-color); font-weight: bold; } #playground-code { margin-top: 2px; width: 100%; height: 100%; position: relative; overlow: hidden; } #playground-code .highlight code { min-height: 15em; } #playground-code .highlight, #playground-code .highlight code { margin: 0; overflow: hidden; } #playground-code pre { margin: 0; pointer-events: none; height: calc(100% + 0.2rem); } #playground-results code { min-height: 15em; } #playground-results pre { margin-bottom: 0; } #playground-results .swatch-bar { min-height: calc(3em + 4px); } #playground-results .color-command { margin-bottom: 0; } .hidden .highlight, .hidden #playground-inputs, button.hidden { display: none; } button:not(.md-clipboard) { padding: 0.25em 1em; background: var(--md-primary-fg-color); color: var(--md-primary-bg-color); border-radius: .1rem; } button:not(.md-clipboard):hover { cursor: pointer; } /* Enabling custom scroll bar causes issues with Safari. Safari renders `textarea` content in a shadow DOM, and the content is smaller than the text area with scrollbar. This can cause the overlay text to not be aligned with the underlying code highlighted content. */ /*.md-typeset textarea::-webkit-scrollbar { width: 0.2rem; height: 0.2rem; } .md-typeset textarea::-webkit-scrollbar-corner { background-color: transparent; } .md-typeset textarea::-webkit-scrollbar-thumb { background-color: var(--md-default-fg-color--lighter); } .md-typeset textarea::-webkit-scrollbar-thumb:hover { background-color: var(--md-accent-fg-color); } .md-typeset textarea { scrollbar-color: var(--md-default-fg-color--lighter) transparent; scrollbar-width: thin; } .md-typeset textarea:hover { scrollbar-color: var(--md-accent-fg-color) transparent; }*/ const inputs = document.getElementById(\"playground-inputs\"); const results = document.getElementById(\"playground-results\"); const pgcode = document.getElementById(\"playground-code\"); const button_edit = document.querySelector(\"button#playground-edit\"); const button_run = document.querySelector(\"button#playground-run\"); const button_cancel = document.querySelector(\"button#playground-cancel\"); const default_text = \"# Insert your code here!\\ncoloraide.__version__\\nColor('red')\"; let busy = false; let requests = 0; let last_text = ''; async function main() { // Setup input highlighting and events to run Python code blocks. // Load Piodide and related packages. await loadPyodide({indexURL : \"https://cdn.jsdelivr.net/pyodide/v0.17.0/full/\" }); await pyodide.loadPackage(['micropip', 'Pygments']); async function pyexecute() { // Execute Python code let pycode = ` \"\"\" Special Python color code blocks. Transform Python code by executing it, transforming to a Python console output, and finding and outputting color previews. \"\"\" import micropip from js import document from collections.abc import Sequence from collections import namedtuple import ast from io import StringIO import contextlib import sys import re from pygments import highlight from pygments.lexers import get_lexer_by_name from pygments.formatters import find_formatter_class HtmlFormatter = find_formatter_class('html') inputs = document.getElementById(\"playground-inputs\") results = document.getElementById(\"playground-results\") pgcode = document.getElementById(\"playground-code\") AST_BLOCKS = (ast.If, ast.For, ast.While, ast.Try, ast.With, ast.FunctionDef, ast.ClassDef) RE_COLOR_START = re.compile( r\"(?i)(?:\\\\b(?<![-#&$])(?:color|hsla?|lch|lab|hwb|rgba?)\\\\(|\\\\b(?<![-#&$])[\\\\w]{3,}(?![(-])\\\\b|(?<![&])#)\" ) class ColorInterpolate(list): \"\"\"Color interpolate.\"\"\" class ColorTuple(namedtuple('ColorTuple', ['string', 'color'])): \"\"\"Color tuple.\"\"\" @contextlib.contextmanager def std_output(stdout=None): \"\"\"Capture standard out.\"\"\" old = sys.stdout if stdout is None: stdout = StringIO() sys.stdout = stdout yield stdout sys.stdout = old def get_colors(result): \"\"\"Get color from results.\"\"\" from coloraide import Color from coloraide.color.interpolate import Interpolator colors = [] if isinstance(result, Color): colors.append(ColorTuple(result.to_string(), result)) elif isinstance(result, Interpolator): colors = ColorInterpolate() for x in range(20): c = result(x / 20) colors.append(ColorTuple(c.to_string(), c)) elif isinstance(result, str): try: colors.append(ColorTuple(result, Color(result))) except Exception: pass elif isinstance(result, Sequence): for x in result: if isinstance(x, Color): colors.append(ColorTuple(x.to_string(), x)) return colors def find_colors(text): \"\"\"Find colors in text buffer.\"\"\" from coloraide import Color colors = [] for m in RE_COLOR_START.finditer(text): start = m.start() mcolor = Color.match(text, start=start) if mcolor is not None: colors.append(ColorTuple(text[mcolor.start:mcolor.end], mcolor.color)) return colors def execute(cmd): \"\"\"Execute color commands.\"\"\" import coloraide from coloraide import Color, NaN, Piecewise g = {'Color': Color, 'coloraide': coloraide, 'NaN': NaN, 'Piecewise': Piecewise} console = '' colors = [] # Build AST tree src = cmd.strip() lines = src.split('\\\\n') tree = ast.parse(src) for node in tree.body: result = None # Format source as Python console statements start = node.lineno end = node.end_lineno stmt = lines[start - 1: end] command = '' for i, line in enumerate(stmt, 0): if i == 0: stmt[i] = '>>> ' + line else: stmt[i] = '... ' + line command += '\\\\n'.join(stmt) if isinstance(node, AST_BLOCKS): command += '\\\\n... ' try: # Capture anything sent to standard out text = '' with std_output() as s: # Execute code if isinstance(node, ast.Expr): _eval = ast.Expression(node.value) result = eval(compile(_eval, '<string>', 'eval'), g) else: _exec = ast.Module([node], []) exec(compile(_exec, '<string>', 'exec'), g) # Execution went well, so append command console += command # Output captured standard out after statements text = s.getvalue() if text: clist = find_colors(text) if clist: colors.extend(clist) console += '\\\\n{}'.format(text) s.flush() except Exception: # Failed for some reason, so quit break # If we got a result, output it as well if result is not None: clist = get_colors(result) if clist: colors.append(clist) console += '{}{}'.format('\\\\n' if not text else '', str(result)) console += '\\\\n' return console, colors def colorize(src, lang, **options): \"\"\"Colorize.\"\"\" lexer = get_lexer_by_name(lang, **options) formatter = HtmlFormatter(cssclass=\"highlight\", wrapcode=True) return highlight(src, lexer, formatter).strip() def color_command_formatter(src): \"\"\"Formatter wrapper.\"\"\" from coloraide import Color try: fit = True console, colors = execute(src.strip()) el = '' bar = False values = [] for item in colors: if isinstance(item, ColorInterpolate): if bar: el += '<div class=\"swatch-bar\">{}</div>'.format(' '.join(values)) values = [] sub_el1 = '<div class=\"swatch-bar\"><span class=\"swatch swatch-gradient\">{}</span></div>' style = \"--swatch-stops: \" stops = [] for color in item: color.color.fit(\"srgb\", in_place=True) stops.append(color.color.convert(\"srgb\").to_string(hex=True)) if not stops: stops.extend(['transparent'] * 2) if len(stops) == 1: stops.append(stops[0]) style += ','.join(stops) sub_el2 = '<span class=\"swatch-color\" style=\"{}\"></span>'.format(style) el += sub_el1.format(sub_el2) bar = False else: bar = True base_classes = \"swatch\" for color in item: if not color.color.in_gamut('srgb') and not fit: c = '<span class=\"swatch-color\"></span>' classes = base_classes + \" out-of-gamut\" title = \"Out of Gamut&#10;{}\".format(color.string) else: color.color.fit('srgb', in_place=True) srgb = color.color.convert('srgb') value1 = srgb.to_string(hex=True, alpha=False) value2 = srgb.to_string(hex=True) style = \"--swatch-stops: {} 50%, {} 50%\".format(value1, value2) title = color.string classes = base_classes c = '<span class=\"swatch-color\" style=\"{style}\"></span>'.format(style=style) c = '<span class=\"{classes}\" title=\"{title}\">{color}</span>'.format( classes=classes, color=c, title=title ) values.append(c) if bar: el += '<div class=\"swatch-bar\">{}</div>'.format(' '.join(values)) values = [] if not colors: el += '<div class=\"swatch-bar\"></div>' el += colorize(console, 'pycon', **{'python3': True, 'stripnl': False}) el = '<div class=\"color-command\">{}</div>'.format(el) except Exception: return '<div class=\"color-command\"><div class=\"swatch-bar\"></div>{}</div>'.format(colorize('', 'text')) return el def process_code(*args): \"\"\"Process code.\"\"\" try: # Run code results.innerHTML = color_command_formatter(inputs.value) scrollingElement = results.querySelector('code') scrollingElement.scrollTop = scrollingElement.scrollHeight except Exception as e: print(e) wheel = '/playground/coloraide-0.1.0a19-py3-none-any.whl' micropip.install(wheel).add_done_callback(process_code) ` inputs.setAttribute('readonly', ''); await pyodide.runPythonAsync(pycode); inputs.removeAttribute('readonly'); } async function pyhighlight(str) { // Highlight current input code let pycode = ` from js import document from pygments import highlight from pygments.lexers import get_lexer_by_name from pygments.formatters import find_formatter_class HtmlFormatter = find_formatter_class('html') def colorize(src, lang, **options): \"\"\"Colorize.\"\"\" lexer = get_lexer_by_name(lang, **options) formatter = HtmlFormatter(cssclass=\"highlight\", wrapcode=True) return highlight(src, lexer, formatter).strip() inputs = document.getElementById(\"playground-inputs\") pgcode = document.getElementById(\"playground-code\") div = pgcode.querySelector(\".highlight\") template = document.createElement('template') html = colorize(inputs.value + '\\\\n', 'py3', **{'python3': True, 'stripnl': False}) template.innerHTML = html; pgcode.replaceChild(template.content.firstChild, div) code = pgcode.querySelector('code') code.scrollLeft = inputs.scrollLeft code.scrollTop = inputs.scrollTop ` await pyodide.runPythonAsync(pycode); busy = false; if (requests) { setTimeout(pyhighlight, 100); } } function highlight () { // Manage incoming highlight requests. // Throttle requests if (busy) { return; } // Execute if (requests) { requests = 0; busy = true; pyhighlight(inputs.value); } }; inputs.addEventListener(\"input\", (e) => { // Handle highlighting as input changes. requests++; highlight(); }); inputs.addEventListener(\"scroll\", (e) => { // Sync overlay textarea scrolling with highlighted code block underneath. const code = pgcode.querySelector(\"code\"); code.scrollLeft = e.target.scrollLeft; code.scrollTop = e.target.scrollTop; }); document.addEventListener(\"keydown\", (e) => { // Ctrl + Enter in textarea will execute the code. if (event.defaultPrevented) { return; // Do nothing if the event was already processed } if (e.ctrlKey && e.key === \"Enter\") { if (button_edit.classList.contains('hidden')) { button_run.click(); } else { button_edit.click(); } } else if ( e.key === \"Escape\" && button_edit.classList.contains('hidden') && document.querySelector('input.md-search__input') !== document.activeElement ) { button_cancel.click(); } }); inputs.addEventListener('touchmove', (e) => { // Stop propogation on \"touchmove\". e.stopPropagation(); }); button_edit.addEventListener(\"click\", (e) => { // Handle the button click: show source or execute source. if (busy) { return; } busy = true; last_text = inputs.value; pgcode.classList.toggle('hidden'); results.classList.toggle('hidden'); button_run.classList.toggle('hidden'); button_cancel.classList.toggle('hidden'); button_edit.classList.toggle('hidden'); inputs.focus(); busy = false; }); button_run.addEventListener(\"click\", async function(e) { // Handle the button click: show source or execute source. if (busy) { return; } busy = true; results.querySelector('code').innerHTML = ''; pyexecute(); pgcode.classList.toggle('hidden'); results.classList.toggle('hidden'); button_edit.classList.toggle('hidden'); button_run.classList.toggle('hidden'); button_cancel.classList.toggle('hidden'); busy = false; }); button_cancel.addEventListener(\"click\", (e) => { // Cancel edit. if (busy) { return; } busy = true; inputs.value = last_text; pgcode.classList.toggle('hidden'); results.classList.toggle('hidden'); button_edit.classList.toggle('hidden'); button_run.classList.toggle('hidden'); button_cancel.classList.toggle('hidden'); busy = false; requests++; highlight(); }); inputs.focus(); requests = 1; let params = new URLSearchParams(window.location.search); if (params.has('source')) { // A source was specified, so load it. try { const uri = decodeURI(params.get('source')).replace('gist.github.com', 'gist.githubusercontent.com') + '/raw'; console.log(uri); let xhr = new XMLHttpRequest(); xhr.open(\"GET\", uri, true); xhr.onload = function (e) { // Try and load the requested content if (xhr.readyState === 4) { if (xhr.status === 200) { inputs.value = xhr.responseText; } } highlight(); pyexecute(); }; xhr.send(); } catch (err) { // Failed, so just load the default content inputs.value = default_text; highlight(); pyexecute(); } } else { // No gist specified, so just load default content inputs.value = default_text; highlight(); pyexecute(); } } // Run main main();","title":"Playground"},{"location":"strings/","text":"String Output Convert to Strings Colors can be translated to strings by using the to_string method. The color class will convert the current color into one of many of the color's CSS formats. >>> Color ( \"srgb\" , [ 0.5 , 0 , 1 ], 0.3 ) . to_string () rgb(127.5 0 255 / 0.3) All color spaces support the following parameters: alpha : set to None by default, alpha will only be shown if less than 100%, but if set to True , alpha will always be shown. Setting to False will cause alpha to be ignored in the output. precision : precision controls the precision of the output values. The name is a little misleading as it will actually adjust the precision and scale of the values. The default is 5. In some cases, like sRGB hex output, precision may not really come into play as hex values are rounded to the nearest whole number anyways. >>> Color ( \"rgb(30.3456 % 75% 100%)\" ) . to_string ( precision = 5 , percent = True ) rgb(30.346% 75% 100%) >>> Color ( \"rgb(30.3456 % 75% 100%)\" ) . to_string ( precision = 4 , percent = True ) rgb(30.35% 75% 100%) >>> Color ( \"rgb(30.3456 % 75% 100%)\" ) . to_string ( precision = 3 , percent = True ) rgb(30.3% 75% 100%) >>> Color ( \"rgb(30.3456 % 75% 100%)\" ) . to_string ( precision = 2 , percent = True ) rgb(30% 75% 100%) >>> Color ( \"rgb(30.3456 % 75% 100%)\" ) . to_string ( precision = 1 , percent = True ) rgb(30% 80% 100%) Providing a precision of 0 will simply enable simple rounding to the nearest whole number. >>> Color ( \"rgb(30.3456 % 75% 100%)\" ) . to_string ( precision = 0 , percent = True ) rgb(30% 75% 100%) Providing a precision of -1 is a special input that will give the highest precision that can be given. Not particularly helpful except to look at the raw decimal number. >>> Color ( \"rgb(30.3456 % 75% 100%)\" ) . to_string ( precision =- 1 , percent = True ) rgb(30.345600000000001017497197608463466167449951171875% 75% 100%) One note though, format of the value matters. Here we output in the range of 0 - 255. We can see that a precision of 1 , in this case, can throw the color out of gamut. So remember to use a sufficient precision for what you are doing and the values you are working in. >>> Color ( \"rgb(30.3456 % 75% 100%)\" ) . to_string ( precision = 1 ) rgb(80 200 300) fit : set to True by default, fit controls whether colors are fit to their gamut or not. Some color spaces are technically unbounded, so no fitting may occur in those color spaces. Additionally, some color formats, like sRGB hex, are always fitted (regardless of the this setting) as they must fit into the gamut or they cannot be translated. >>> Color ( \"rgb(30 % 105% 0%)\" ) . to_string (), ('rgb(138 255 98.203)',) >>> Color ( \"rgb(30 % 105% 0%)\" ) . to_string ( fit = False ) rgb(76.5 267.75 0) color : for some color spaces, this is the default output, but for others this format can be explicitly requested by setting color to True . If set to True , this will take priority over other format options. >>> Color ( \"rebeccapurple\" ) . to_string ( color = True ) color(srgb 0.4 0.2 0.6) In general, a color in a given color space may share the same options as listed above, but a given color space may also have options unique to itself. sRGB Specific sRGB can output colors to a hex format which is unique compared to HSL and others. Simply enable hex . >>> Color ( \"rebeccapurple\" ) . to_string ( hex = True ) #663399 You can force hex to output in uppercase. >>> Color ( \"red\" ) . to_string ( hex = True ) #ff0000 >>> Color ( \"red\" ) . to_string ( hex = True , upper = True ) #FF0000 When converting to the hex color format, a color can be compressed in certain cases. Enabling compress will compress a hex color if possible. >>> Color ( \"#11223388\" ) . to_string ( hex = True ) #11223388 >>> Color ( \"#11223388\" ) . to_string ( hex = True , compress = True ) #1238 sRGB also can output colors in an optional percent format. This will output the channels in the range of [0%,100%] instead of using the range [0,255]. >>> Color ( \"rebeccapurple\" ) . to_string ( percent = True ) rgb(40% 20% 60%) sRGB can also output color names. If a color evaluates to a hex code which also evaluates to a color name in the internal CSS color name mapping, then a color name will be returned. If the color does not match a color name, it will fallback to whatever the other options dictate. Simply enable names . >>> Color ( \"#663399\" ) . to_string ( names = True ) rebeccapurple Comma Format In CSS, there are a number of color spaces that allow a comma format: srgb , hsl , and hwb . ColorAide allows these colors to be output in their legacy comma format. Even though lch and lab technically do not have a comma format, they can also have commas enabled. The one format that ColorAide will not allow commas on is color() . color() is the common serialization format that ColorAide uses and is strict about its format. If we want commas, we can force the comma syntax by setting comma to True . This can alter some color space output in other subtle ways. As the comma format is the old legacy approach, when sRGB has commas enabled, it will use rgba instead of the rgb . If using the default space syntax, rgb is always used, even when the color has transparency. >>> Color ( \"rgb(30 75 100 / 20%)\" ) . to_string ( comma = True ) rgba(30, 75, 100, 0.2)","title":"String Output"},{"location":"strings/#string-output","text":"","title":"String Output"},{"location":"strings/#convert-to-strings","text":"Colors can be translated to strings by using the to_string method. The color class will convert the current color into one of many of the color's CSS formats. >>> Color ( \"srgb\" , [ 0.5 , 0 , 1 ], 0.3 ) . to_string () rgb(127.5 0 255 / 0.3) All color spaces support the following parameters: alpha : set to None by default, alpha will only be shown if less than 100%, but if set to True , alpha will always be shown. Setting to False will cause alpha to be ignored in the output. precision : precision controls the precision of the output values. The name is a little misleading as it will actually adjust the precision and scale of the values. The default is 5. In some cases, like sRGB hex output, precision may not really come into play as hex values are rounded to the nearest whole number anyways. >>> Color ( \"rgb(30.3456 % 75% 100%)\" ) . to_string ( precision = 5 , percent = True ) rgb(30.346% 75% 100%) >>> Color ( \"rgb(30.3456 % 75% 100%)\" ) . to_string ( precision = 4 , percent = True ) rgb(30.35% 75% 100%) >>> Color ( \"rgb(30.3456 % 75% 100%)\" ) . to_string ( precision = 3 , percent = True ) rgb(30.3% 75% 100%) >>> Color ( \"rgb(30.3456 % 75% 100%)\" ) . to_string ( precision = 2 , percent = True ) rgb(30% 75% 100%) >>> Color ( \"rgb(30.3456 % 75% 100%)\" ) . to_string ( precision = 1 , percent = True ) rgb(30% 80% 100%) Providing a precision of 0 will simply enable simple rounding to the nearest whole number. >>> Color ( \"rgb(30.3456 % 75% 100%)\" ) . to_string ( precision = 0 , percent = True ) rgb(30% 75% 100%) Providing a precision of -1 is a special input that will give the highest precision that can be given. Not particularly helpful except to look at the raw decimal number. >>> Color ( \"rgb(30.3456 % 75% 100%)\" ) . to_string ( precision =- 1 , percent = True ) rgb(30.345600000000001017497197608463466167449951171875% 75% 100%) One note though, format of the value matters. Here we output in the range of 0 - 255. We can see that a precision of 1 , in this case, can throw the color out of gamut. So remember to use a sufficient precision for what you are doing and the values you are working in. >>> Color ( \"rgb(30.3456 % 75% 100%)\" ) . to_string ( precision = 1 ) rgb(80 200 300) fit : set to True by default, fit controls whether colors are fit to their gamut or not. Some color spaces are technically unbounded, so no fitting may occur in those color spaces. Additionally, some color formats, like sRGB hex, are always fitted (regardless of the this setting) as they must fit into the gamut or they cannot be translated. >>> Color ( \"rgb(30 % 105% 0%)\" ) . to_string (), ('rgb(138 255 98.203)',) >>> Color ( \"rgb(30 % 105% 0%)\" ) . to_string ( fit = False ) rgb(76.5 267.75 0) color : for some color spaces, this is the default output, but for others this format can be explicitly requested by setting color to True . If set to True , this will take priority over other format options. >>> Color ( \"rebeccapurple\" ) . to_string ( color = True ) color(srgb 0.4 0.2 0.6) In general, a color in a given color space may share the same options as listed above, but a given color space may also have options unique to itself.","title":"Convert to Strings"},{"location":"strings/#srgb-specific","text":"sRGB can output colors to a hex format which is unique compared to HSL and others. Simply enable hex . >>> Color ( \"rebeccapurple\" ) . to_string ( hex = True ) #663399 You can force hex to output in uppercase. >>> Color ( \"red\" ) . to_string ( hex = True ) #ff0000 >>> Color ( \"red\" ) . to_string ( hex = True , upper = True ) #FF0000 When converting to the hex color format, a color can be compressed in certain cases. Enabling compress will compress a hex color if possible. >>> Color ( \"#11223388\" ) . to_string ( hex = True ) #11223388 >>> Color ( \"#11223388\" ) . to_string ( hex = True , compress = True ) #1238 sRGB also can output colors in an optional percent format. This will output the channels in the range of [0%,100%] instead of using the range [0,255]. >>> Color ( \"rebeccapurple\" ) . to_string ( percent = True ) rgb(40% 20% 60%) sRGB can also output color names. If a color evaluates to a hex code which also evaluates to a color name in the internal CSS color name mapping, then a color name will be returned. If the color does not match a color name, it will fallback to whatever the other options dictate. Simply enable names . >>> Color ( \"#663399\" ) . to_string ( names = True ) rebeccapurple","title":"sRGB Specific"},{"location":"strings/#comma-format","text":"In CSS, there are a number of color spaces that allow a comma format: srgb , hsl , and hwb . ColorAide allows these colors to be output in their legacy comma format. Even though lch and lab technically do not have a comma format, they can also have commas enabled. The one format that ColorAide will not allow commas on is color() . color() is the common serialization format that ColorAide uses and is strict about its format. If we want commas, we can force the comma syntax by setting comma to True . This can alter some color space output in other subtle ways. As the comma format is the old legacy approach, when sRGB has commas enabled, it will use rgba instead of the rgb . If using the default space syntax, rgb is always used, even when the color has transparency. >>> Color ( \"rgb(30 75 100 / 20%)\" ) . to_string ( comma = True ) rgba(30, 75, 100, 0.2)","title":"Comma Format"},{"location":"about/changelog/","text":"Changelog 0.10a19 FIX : Ensure that subclassed Color objects are normalized when performing operations with more than one color to prevent issues in case one subclassed object has overridden important functions. FIX : Spaces like lab , lch , etc., which specify certain channels as percent only should require the color() format to only accept percentages for those channels and output those channels as percentages when converting to a string. 0.10a18 NEW : Refactor of internals. NEW : interpolate and steps can now accept multiple colors and will return an interpolation function that spans all specified colors via the range of [0..1] . NEW : Better control over piecewise interpolation: setting stops, adjusting options per segment, etc. NEW : compose can now accept multiple colors and will return a result where all colors are layered on top of each other. NEW : new method does not need to be a classmethod . Make it a normal method on the instance. NEW : Add Jzazbz and JzCzhz color spaces. NEW : Add D65 variants of CIELAB, CIELCH, and XYZ. NEW : Add ICtCp color space and Delta E ITP method. FIX : Actually make mix default to lab like interpolate and friends do. 0.1.0a17 FIX : Ensure that both the Bradford CAT and the XYZ transformation matrix all use ASTM E308-01 white points. This fixes a number of conversion issues when going to and from D65 to D50 color spaces. 0.1.0a16 NEW : Make mix use the same space logic as interpolate and step . Colors are mixed in CIELAB unless space is set to a different color space. NEW : Add support for blend modes as specified in Compositing and Blending Level 1 . NEW : Rename overlay to compose as all compositing (including blend modes) is done through compose now. overlay is still present and is deprecated and will be removed at some future point before a stable release. compose will assume sRGB space unless a different space is specified, but overlay will function as it always did. FIX : Fix some small internal issues with in_place logic. 0.1.0a15 NEW : The adjust parameter on interpolate , steps , and mix has been dropped. Instead, a general purpose method has been added to the Color object to mask one or more channels at a time. This can be used to create a temporary color with masked channels for the purpose of interpolation. FIX : Ensure that when alpha is NaN that it is handled in overlay . FIX : When using raw data in the color() function, and there is too little data, fill data with NaN . FIX : Fix issue where API interpolate method does not pass out_space parameter down. FIX : Disabling or forcing alpha did not work properly for HSL colors via to_string . FIX : contrast and luminance should use XYZ with a D65 white point, not the default XYZ space which uses a D50 white point. FIX : Fix bug in Delta E 2000 algorithm. 0.1.0a14 NEW : sRGB string output parameter hex_upper has been renamed to just upper . Expose it in documentation as well. 0.1.0a13 FIX : More efficient calculation of CIELAB, following CIE 15.3:2004. Results are still the same, but it makes the math a little simpler. FIX : HSV did not always set hue to NaN when saturation was 0 . FIX : Give better conversion results by having HWB colors pass through HSV instead of sRGB. FIX : Fix slight issue with REC.2020 and ProPhoto color space conversion. Small issue when using <= when < was desired. 0.1.0a12 FIX : More stable saturation calculation for HSL to ensure divide by zero doesn't occur. 2(V - L) / (1 - abs(2 * L - 1)) is likely to yield zero in the denominator when L is very small, while the equivalent (V - L) / min(L, 1 - L) is not. 0.1.0a11 FIX : Ensure that when hex , compress , and names is enabled in to_string for srgb that colors will still match the color name if the color can be compressed. 0.1.0a10 FIX : Address two divide by zero cases in HSL algorithm. Was missing some special cases when luminance equals 1 or 0 . 0.1.0a9 FIX : Ensure all cases of hue handling, in regards to gamut mapping, are done the same. 0.1.0a8 NEW : Remove workaround to force cylindrical colors to overlay in non-cylindrical spaces. Allow colors to be overlaid in any color space. Original issues related to allowing cylindrical spaces as been fixed. Overlaying in cylindrical spaces may not make sense, but it is no longer prohibited. FIX : Ensure color comparison will yield true if two channels have NaN . 0.1.0a7 FIX : Fix issue with translation of an input that is compressed hex with a specified alpha. 0.1.0a6 FIX : Don't return detached color spaces from steps . Ensure they are wrapped with a Color object on return. 0.1.0a5 FIX : Fix an issue where update can fail due to a color space detached from a parent. FIX : Adjust fit tolerance to be a little more forgiving, but make an adjustment for in_gmaut in relation to HSL as saturation can be wildly out of range for an sRGB color that is only slightly out of gamut. FIX : Ensure in_gamut handles NaN properly. 0.1.0a4 NEW : Use NaN to track undefined hues. NEW : Remove is_hue_null and add new API function is_nan to test if any channel is currently set to NaN . NEW : Remove get_default from the Color class and instead allow properties that can be overridden when subclassing the Color object. 0.1.0a3 FIX : Color object API was missing the ability to receive the premultiplied argument. 0.1.0a2 NEW : Expose access to srgb-linear color space. This is mainly for development and testing and not listed in docs currently. FIX : Cylindrical spaces, when calling overlay can now request to be overlaid in a different space. This is because alpha composition does not work well in cylindrical spaces. HSL, HSV, and HWB will now request overlay to be done in sRGB, and CIELCH will request overlay to be done in CIELAB. FIX : Add support for premultiplied alpha when interpolating via premultiplied option. 0.1.0a1 NEW : Initial alpha release. Library is experimental and API is unstable.","title":"Changelog"},{"location":"about/changelog/#changelog","text":"","title":"Changelog"},{"location":"about/changelog/#010a19","text":"FIX : Ensure that subclassed Color objects are normalized when performing operations with more than one color to prevent issues in case one subclassed object has overridden important functions. FIX : Spaces like lab , lch , etc., which specify certain channels as percent only should require the color() format to only accept percentages for those channels and output those channels as percentages when converting to a string.","title":"0.10a19"},{"location":"about/changelog/#010a18","text":"NEW : Refactor of internals. NEW : interpolate and steps can now accept multiple colors and will return an interpolation function that spans all specified colors via the range of [0..1] . NEW : Better control over piecewise interpolation: setting stops, adjusting options per segment, etc. NEW : compose can now accept multiple colors and will return a result where all colors are layered on top of each other. NEW : new method does not need to be a classmethod . Make it a normal method on the instance. NEW : Add Jzazbz and JzCzhz color spaces. NEW : Add D65 variants of CIELAB, CIELCH, and XYZ. NEW : Add ICtCp color space and Delta E ITP method. FIX : Actually make mix default to lab like interpolate and friends do.","title":"0.10a18"},{"location":"about/changelog/#010a17","text":"FIX : Ensure that both the Bradford CAT and the XYZ transformation matrix all use ASTM E308-01 white points. This fixes a number of conversion issues when going to and from D65 to D50 color spaces.","title":"0.1.0a17"},{"location":"about/changelog/#010a16","text":"NEW : Make mix use the same space logic as interpolate and step . Colors are mixed in CIELAB unless space is set to a different color space. NEW : Add support for blend modes as specified in Compositing and Blending Level 1 . NEW : Rename overlay to compose as all compositing (including blend modes) is done through compose now. overlay is still present and is deprecated and will be removed at some future point before a stable release. compose will assume sRGB space unless a different space is specified, but overlay will function as it always did. FIX : Fix some small internal issues with in_place logic.","title":"0.1.0a16"},{"location":"about/changelog/#010a15","text":"NEW : The adjust parameter on interpolate , steps , and mix has been dropped. Instead, a general purpose method has been added to the Color object to mask one or more channels at a time. This can be used to create a temporary color with masked channels for the purpose of interpolation. FIX : Ensure that when alpha is NaN that it is handled in overlay . FIX : When using raw data in the color() function, and there is too little data, fill data with NaN . FIX : Fix issue where API interpolate method does not pass out_space parameter down. FIX : Disabling or forcing alpha did not work properly for HSL colors via to_string . FIX : contrast and luminance should use XYZ with a D65 white point, not the default XYZ space which uses a D50 white point. FIX : Fix bug in Delta E 2000 algorithm.","title":"0.1.0a15"},{"location":"about/changelog/#010a14","text":"NEW : sRGB string output parameter hex_upper has been renamed to just upper . Expose it in documentation as well.","title":"0.1.0a14"},{"location":"about/changelog/#010a13","text":"FIX : More efficient calculation of CIELAB, following CIE 15.3:2004. Results are still the same, but it makes the math a little simpler. FIX : HSV did not always set hue to NaN when saturation was 0 . FIX : Give better conversion results by having HWB colors pass through HSV instead of sRGB. FIX : Fix slight issue with REC.2020 and ProPhoto color space conversion. Small issue when using <= when < was desired.","title":"0.1.0a13"},{"location":"about/changelog/#010a12","text":"FIX : More stable saturation calculation for HSL to ensure divide by zero doesn't occur. 2(V - L) / (1 - abs(2 * L - 1)) is likely to yield zero in the denominator when L is very small, while the equivalent (V - L) / min(L, 1 - L) is not.","title":"0.1.0a12"},{"location":"about/changelog/#010a11","text":"FIX : Ensure that when hex , compress , and names is enabled in to_string for srgb that colors will still match the color name if the color can be compressed.","title":"0.1.0a11"},{"location":"about/changelog/#010a10","text":"FIX : Address two divide by zero cases in HSL algorithm. Was missing some special cases when luminance equals 1 or 0 .","title":"0.1.0a10"},{"location":"about/changelog/#010a9","text":"FIX : Ensure all cases of hue handling, in regards to gamut mapping, are done the same.","title":"0.1.0a9"},{"location":"about/changelog/#010a8","text":"NEW : Remove workaround to force cylindrical colors to overlay in non-cylindrical spaces. Allow colors to be overlaid in any color space. Original issues related to allowing cylindrical spaces as been fixed. Overlaying in cylindrical spaces may not make sense, but it is no longer prohibited. FIX : Ensure color comparison will yield true if two channels have NaN .","title":"0.1.0a8"},{"location":"about/changelog/#010a7","text":"FIX : Fix issue with translation of an input that is compressed hex with a specified alpha.","title":"0.1.0a7"},{"location":"about/changelog/#010a6","text":"FIX : Don't return detached color spaces from steps . Ensure they are wrapped with a Color object on return.","title":"0.1.0a6"},{"location":"about/changelog/#010a5","text":"FIX : Fix an issue where update can fail due to a color space detached from a parent. FIX : Adjust fit tolerance to be a little more forgiving, but make an adjustment for in_gmaut in relation to HSL as saturation can be wildly out of range for an sRGB color that is only slightly out of gamut. FIX : Ensure in_gamut handles NaN properly.","title":"0.1.0a5"},{"location":"about/changelog/#010a4","text":"NEW : Use NaN to track undefined hues. NEW : Remove is_hue_null and add new API function is_nan to test if any channel is currently set to NaN . NEW : Remove get_default from the Color class and instead allow properties that can be overridden when subclassing the Color object.","title":"0.1.0a4"},{"location":"about/changelog/#010a3","text":"FIX : Color object API was missing the ability to receive the premultiplied argument.","title":"0.1.0a3"},{"location":"about/changelog/#010a2","text":"NEW : Expose access to srgb-linear color space. This is mainly for development and testing and not listed in docs currently. FIX : Cylindrical spaces, when calling overlay can now request to be overlaid in a different space. This is because alpha composition does not work well in cylindrical spaces. HSL, HSV, and HWB will now request overlay to be done in sRGB, and CIELCH will request overlay to be done in CIELAB. FIX : Add support for premultiplied alpha when interpolating via premultiplied option.","title":"0.1.0a2"},{"location":"about/changelog/#010a1","text":"NEW : Initial alpha release. Library is experimental and API is unstable.","title":"0.1.0a1"},{"location":"about/contributing/","text":"Contributing & Support Become a Sponsor Open source projects take time and money. Help support the project by becoming a sponsor. You can add your support at any tier you feel comfortable with. No amount is too little. We also accept one time contributions via PayPal. GitHub Sponsors PayPal Bug Reports Please read the documentation and search the issue tracker to try and find the answer to your question before posting an issue. When creating an issue on the repository, please provide as much info as possible: Version being used. Operating system. Version of Python. Errors in console. Detailed description of the problem. Examples for reproducing the error. You can post pictures, but if specific text or code is required to reproduce the issue, please provide the text in a plain text format for easy copy/paste. The more info provided, the greater the chance someone will take the time to answer, implement, or fix the issue. Be prepared to answer questions and provide additional information if required. Issues in which the creator refuses to respond to follow up questions will be marked as stale and closed. Reviewing Code Take part in reviewing pull requests and/or reviewing direct commits. Make suggestions to improve the code and discuss solutions to overcome weakness in the algorithm. Answer Questions in Issues Take time and answer questions and offer suggestions to people who've created issues in the issue tracker. Often people will have questions that you might have an answer for. Or maybe you know how to help them accomplish a specific task they are asking about. Feel free to share your experience to help others out. Pull Requests Pull requests are welcome, and a great way to help fix bugs and add new features. Documentation Improvements A ton of time has been spent not only creating and supporting this tool and related extensions, but also spent making this documentation. If you feel it is still lacking, show your appreciation for the tool and/or extensions by helping to improve the documentation.","title":"Contributing &amp; Support"},{"location":"about/contributing/#contributing--support","text":"","title":"Contributing &amp; Support"},{"location":"about/contributing/#become-a-sponsor","text":"Open source projects take time and money. Help support the project by becoming a sponsor. You can add your support at any tier you feel comfortable with. No amount is too little. We also accept one time contributions via PayPal. GitHub Sponsors PayPal","title":"Become a Sponsor "},{"location":"about/contributing/#bug-reports","text":"Please read the documentation and search the issue tracker to try and find the answer to your question before posting an issue. When creating an issue on the repository, please provide as much info as possible: Version being used. Operating system. Version of Python. Errors in console. Detailed description of the problem. Examples for reproducing the error. You can post pictures, but if specific text or code is required to reproduce the issue, please provide the text in a plain text format for easy copy/paste. The more info provided, the greater the chance someone will take the time to answer, implement, or fix the issue. Be prepared to answer questions and provide additional information if required. Issues in which the creator refuses to respond to follow up questions will be marked as stale and closed.","title":"Bug Reports"},{"location":"about/contributing/#reviewing-code","text":"Take part in reviewing pull requests and/or reviewing direct commits. Make suggestions to improve the code and discuss solutions to overcome weakness in the algorithm.","title":"Reviewing Code"},{"location":"about/contributing/#answer-questions-in-issues","text":"Take time and answer questions and offer suggestions to people who've created issues in the issue tracker. Often people will have questions that you might have an answer for. Or maybe you know how to help them accomplish a specific task they are asking about. Feel free to share your experience to help others out.","title":"Answer Questions in Issues"},{"location":"about/contributing/#pull-requests","text":"Pull requests are welcome, and a great way to help fix bugs and add new features.","title":"Pull Requests"},{"location":"about/contributing/#documentation-improvements","text":"A ton of time has been spent not only creating and supporting this tool and related extensions, but also spent making this documentation. If you feel it is still lacking, show your appreciation for the tool and/or extensions by helping to improve the documentation.","title":"Documentation Improvements"},{"location":"about/license/","text":"License ColorAide The MIT License (MIT) Copyright \u00a9 2020 - 2021 Isaac Muse Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"about/license/#license","text":"","title":"License"},{"location":"about/license/#coloraide","text":"The MIT License (MIT) Copyright \u00a9 2020 - 2021 Isaac Muse Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"ColorAide"},{"location":"api/","text":"Color API coloraide.NaN Description NaN is a convenience constant for float('nan') . NaN . Import path NaN is imported from the coloraide library: from coloraide import NaN coloraide.Piecewise class Piecewise ( namedtuple ( 'Piecewise' , [ 'color' , 'stop' , 'progress' , 'hue' , 'premultiplied' ] ) ): Description Piecewise objects are used in interpolate methods. They allow a user to control interpolation stops , progress , hue , or premultiplied options for a specific interpolation piece when doing piecewise interpolation. Import Path Piecewise is imported from coloraide library: from coloraide import Piecewise Parameters Input parameters match interpolate parameters of the same name. Only color is required and all other parameters default to None . If a parameter is None , it will be ignored by interpolate . coloraide.Color class Color : def __init__ ( self , color , data = None , alpha = util . DEF_ALPHA , * , filters = None , ** kwargs ): Description The Color class object is a wrapper around the internal color space objects. It provides an API interface to allow users to specify and manipulate colors. Import path Color is imported from the coloraide library: from coloraide import Color Parameters Parameters Defaults Description color A color string, or other Color class object. If given data , a string must be used and should represent the color space to use. data None data accepts a list of numbers representing the coordinates of the color. If provided, color must be a string specifying the color space. alpha 1 alpha accepts a number specifying the alpha channel. Must be used in conjunction with data or it will be ignored. filters None filters accepts a list of color spaces to allow. When None is provided (the default) all supported color spaces are accepted. Color.match @classmethod def match ( cls , string , start = 0 , fullmatch = False , * , filters = None ): Description The match class method provides access to the color matching interface and allows a user to provide a color string and get back a ColorMatch object. ColorMatch objects contain three properties: class ColorMatch : def __init__ ( self , color , start , end ): color : the Color object. start : the starting point within the string buffer where the color was found. end : the ending point within the string buffer where the color was found. Match does not search the entire buffer, but simply matches at the location specified by start . Parameters Parameters Defaults Description string A string representing the color. start 0 Accepts a integer offset into the provided string buffer to start the match. fullmatch False A boolean which defines whether match must match to the end of the string buffer. filters None filters accepts a list of color spaces to allow. When None is provided (the default) all supported color spaces are accepted. Return Returns a ColorMatch object. Color.new def new ( self , color , data = None , alpha = util . DEF_ALPHA , * , filters = None , ** kwargs ): Description The new class method exposes the interface of creating new color objects. Using new is the same as using Color() . Parameters Parameters Defaults Description color A color string, or other Color class object. If given data , a string must be used and should represent the color space to use. data None data accepts a list of numbers representing the coordinates of the color. If provided, color must be a string specifying the color space. alpha 1 alpha accepts a number specifying the alpha channel. Must be used in conjunction with data or it will be ignored. filters None filters accepts a list of color spaces to allow. When None is provided (the default) all supported color spaces are accepted. Return Returns a Color object. Color.clone def clone ( self ): Description The clone method provides a way to create a duplicate of the current Color instance. Return Returns a Color object. Color.update def update ( self , color , data = None , alpha = util . DEF_ALPHA , * , filters = None , ** kwargs ): Description The update method provides a way to update the underlying color spaces with coordinates from any color space. The methods signature looks just like new and accepts color strings, Color objects, or raw data points specified with a color space string and coordinates. The object itself will be updated and remain in its current color space. Parameters Parameters Defaults Description color A color string, or other Color class object. If given data , a string must be used and should represent the color space to use. data None data accepts a list of numbers representing the coordinates of the color. If provided, color must be a string specifying the color space. alpha 1 alpha accepts a number specifying the alpha channel. Must be used in conjunction with data or it will be ignored. filters None filters accepts a list of color spaces to allow. When None is provided (the default) all supported color spaces are accepted. Return Returns a reference to the current Color object. Color.mutate def mutate ( self , color , data = None , alpha = util . DEF_ALPHA , * , filters = None , ** kwargs ): Description The mutate method is just like update except that it will not only update the color space, but mutate it to the provided color space. Parameters Parameters Defaults Description color A color string, or other Color class object. If given data , a string must be used and should represent the color space to use. data None data accepts a list of numbers representing the coordinates of the color. If provided, color must be a string specifying the color space. alpha 1 alpha accepts a number specifying the alpha channel. Must be used in conjunction with data or it will be ignored. filters None filters accepts a list of color spaces to allow. When None is provided (the default) all supported color spaces are accepted. Return Returns a reference to the current Color object. Color.convert def convert ( self , space , * , fit = False , in_place = False ): Description Converts a Color object from one color space to another. If the current color space matches the specified color space, the object will be cloned. Parameters Parameters Defaults Description space A string representing the desired final color space. fit False Boolean specifying whether the current color should be gamut mapped into the final, desired color space. in_place False Boolean specifying whether the convert should alter the current Color object or return a new one. Return Returns a reference to the converted Color object. If in_place is True , the return will be a reference to the current Color object. Color.space def space ( self ): Description Retrieves the current color space of the color. Return Returns a string with the name of the current color space. Color.coords def coords ( self ): Description Returns a list of the color's coordinates. This does not include the alpha channel. Alpha can be accessed via the alpha property or get and set accessors. Return Returns a list of numbers indicating the current coordinate values. Color.to_string def to_string ( self , ** kwargs ): Description Method that converts the current color to an output format supported by the color space. While a number of the parameters are common, some may be specific to the color space. The usage guide covers color space specific options in more details. Parameters Common parameters: Parameters Defaults Description alpha None Boolean or None value which determines whether the output includes alpha . If None (the default) alpha will only be shown if less than 1. If True , alpha will always be shown. If False , alpha will be omitted. precision 5 Integer value that sets precision and scale. Precision and scale will match the value if greater than zero. If 0 , values will be rounded to the nearest integer. If -1 , number will be output at the highest precision. fit True A boolean that controls whether gamut mapping is performed on string creation. By default, colors will be fit to their own color space. This can be disabled by setting to False . color False A boolean that will determine if the color(space coord+ / alpha) format is used for string output. Has highest precedence. sRGB specific parameters: Parameters Defaults Description hex . False String output will be in #RRGGBBAA format. names False Boolean indicating a preference for CSS color names. When translating a color to it's closest hex form, if that hex value matches a CSS color name, that color name will be returned as the output. hex does not have to be True for this to apply. compress False If hex is True and compress is True , hex values will be compressed if possible: #RRGGBBAA \u2192 #RGBA . Space dependent parameters: Parameters Defaults Description comma False If supported by the color space and the current output format, commas will be used instead of space format: rgba(0, 0, 0, 1) \u2192 rgb(0 0 0 /1) . Return Returns a string representation of the current color. Color.luminance def luminance ( self ): Description Get the relative luminance. Relative luminance is obtained from the Y coordinate in the XYZ color space. XYZ, in this case, has a D65 white point. Return Returns an float indicating the relative luminance. Color.contrast def contrast ( self , color ): Description Get the contrast ratio based on the relative luminance between two colors. Parameters Parameters Defaults Description color A color string or Color object representing a color. Return Returns a float indicating the contrast ratio between two colors. Color.distance def distance ( self , color , * , space = util . DEF_DISTANCE_SPACE ): Description Performs a euclidean distance algorithm on two colors. Parameters Parameters Defaults Description color A color string or Color object representing a color. space \"lab\" Color space to perform distancing algorithm in. Return Returns a float indicating euclidean distance between the two colors. Color.delta_e def delta_e ( self , color , * , method = None , ** kwargs ): Description Performs a delta E distance algorithm on two colors. Default algorithm that is used is Delta E 1976 ( 76 ). Some methods have additional weighting that can be configured through method specific options which are represented by **kwargs . Available methods: Name Input CIE76 76 CIE94 94 CIEDE2000 2000 CMC l:c (1984) cmc Parameters Parameters Defaults Description color A color string or Color object representing a color. method None String that specifies the method to use. If None , the default will be used. Return Returns a float indicating the delta E distance between the two colors. color.mask def mask self , channels , invert = False , in_place = False ): Description The mask method will set any and all specified channels to NaN . If invert is set to True , mask will set any and all channels not specified to NaN . Parameters Parameters Defaults Description channel A string specifying a channel, or a list of strings specifying multiple channels. Specified channels will be masked (or the only channels not masked if invert is True ). invert False Use inverse masking logic and mask all channels that are not specified. in_place False Boolean used to determine if the the current color should be modified \"in place\" or a new Color object should be returned. Return Returns a reference to the masked Color object. If in_place is True , the return will be a reference to the current Color object. Color.interpolate def interpolate ( self , color , * , stop = 0 , space = \"lab\" , progress = None , out_space = None , hue = util . DEF_HUE_ADJ , premultiplied = False ): Description The interpolate method creates a function that takes a value between 0 - 1 and interpolates a new color based on the input value. If more than one color is provided, the returned function will span the interpolations between all the provided colors with the same range of 0 - 1. Interpolation can be customized by limiting the interpolation to specific color channels, providing custom interpolation functions, and even adjusting the hue logic used. Piecewise objects can be used to specify stops or adjust the interpolation for itself and the preceding color. Hue Evaluation Description shorter Angles are adjusted so that \u03b8\u2082 - \u03b8\u2081 \u2208 [-180, 180]. longer Angles are adjusted so that \u03b8\u2082 - \u03b8\u2081 \u2208 {0, [180, 360)}. increasing Angles are adjusted so that \u03b8\u2082 - \u03b8\u2081 \u2208 [0, 360). decreasing Angles are adjusted so that \u03b8\u2082 - \u03b8\u2081 \u2208 (-360, 0] specified No fixup is performed. Angles are interpolated in the same way as every other component. Parameters Parameters Defaults Description color A color string, Color object, or Piecewise object representing a color. Also, multiple can be provided via a list. space \"lab\" Color space to interpolate in. progress None An optional function that that allows for custom logic to perform non-linear interpolation. out_space None Color space that the new color should be in. If None , the color will be in the same color space as the base color. hue \"shorter\" Define how color spaces which have hue angles are interpolated. Default evaluates between the shortest angle. premultiplied False Use premultiplied alpha when interpolating. Return Returns a function that takes a range from [0..1] . The function returns a reference to the interpolated Color object. Color.steps def steps ( self , color , * , steps = 2 , max_steps = 1000 , max_delta_e = 0 , ** interpolate_args ): Description Creates an interpolate function and iterates through it with user defined step parameters to produce discrete color steps. Will attempt to provide the minimum number of steps without exceeding max_steps . If max_delta_e is provided, the distance between each stop will be cut in half until there are no colors with a distance greater than the specified max_delta_e . If more than one color is provided, the steps will be returned from the interpolations between all the provided colors. Like interpolate , the default interpolation space is lab . Parameters Parameters Defaults Description color A color string or Color object representing a color. Also, multiple can be provided via a list. steps 2 Minimum number of steps. max_steps 1000 Maximum number of steps. max_delta_e 0 Maximum delta E distance between the color stops. A value of 0 or less will be ignored. ** interpolate_args See interpolate Keyword arguments defined in interpolate . Return List of Color objects. Color.mix def mix ( self , color , percent = util . DEF_MIX , * , in_place = False , ** interpolate_args ): Description Interpolates between two colors returning a color that represents the mixing of the base color and the provided color mixed at the provided percent , where percent applies to how much the provided color contributes to the the final result. Parameters Parameters Defaults Description color A color string or Color object representing a color. percent 0.5 A numerical value between 0 - 1 representing the percentage at which the parameter color will be mixed. in_place False Boolean used to determine if the the current color should be modified \"in place\" or a new Color object should be returned. ** interpolate_args See interpolate Keyword arguments defined in interpolate . Return Returns a reference to the new Color object or a reference to the current Color if in_place is True . Color.average def average ( self , color , weights = None , * , space = 'lab' , out_space = None , in_place = False , hue = util . DEF_HUE_ADJ , sort_hue = False ): Description Allows the averaging of one or more colors essentially allowing a mixing of any number of colors. Each color is mixed in such a way so that each color has an equal weight. If, and only if, a color set has a color with transparency, the transparency will be averaged separately. The specified color(s) to average with the base color can be a single color, or a list of colors as specified in the parameters below. Like interpolate , the default interpolation space is lab . Parameters Parameters Defaults Description color A color string or Color object representing a color. Also, multiple can be provided via a list. weights [ 1 ] * n An array of length n (where n is number of colors that are to be averaged) that specifies the weight of the given colors. Order of the weights should match the order of the inputs where the base color is index 0. space \"lab\" Color space to interpolate in. out_space None Color space that the new color should be in. If None , the color will be in the same color space as the base color. hue \"shorter\" Define how color spaces which have hue angles are interpolated. Default evaluates between the shortest angle. in_place False Boolean used to determine if the the current color should be modified \"in place\" or a new Color object should be returned. sort_hue #py3 False Specifies whether cylindrical spaces should sort colors by hue before averaging to ensure a consistence, predictable averaging regardless of what order the colors are provided. Return Returns a reference to the new Color object or a reference to the current Color if in_place is True . Color.compose def compose ( self , backdrop , * , blend = None , operator = None , space = None , out_space = None , in_place = False ): Description Apply compositing which consists of a blend mode and a Porter Duff operator for alpha compositing. The current color is treated as the source (top layer) and the provided color as the backdrop (bottom layer). Colors will be composited in the srgb color space unless otherwise specified. Colors should generally be RGB-ish colors (sRGB, Display P3, A98 RGB, etc.). Some non-RGB-ish colors may work okay, with the defaults, but many the algorithm is really designed for RGB-ish colors. Non-RGB-ish colors are likely to provide nonsense results. Supported blend modes are: Blend Modes normal multiply darken lighten burn dodge screen overlay hard-light exclusion difference soft-light hue saturation luminosity color color hue saturation luminosity Supported Port Duff operators are: Operators clear copy destination source-over destination-over source-in destination-in source-out destination-out source-atop destination-atop xor lighter Parameters Parameters Defaults Description backdrop A background color represented with either a string or Color object. blend None A blend mode to use to use when compositing. Values should be a string specifying the name of the blend mode to use. If None , normal will be used. If False , blending will be skipped. operator None A Porter Duff operator to use for alpha compositing. Values should be a string specifying the name of the operator to use. If None , source-over will be used. If False , alpha compositing will be skipped. space None A color space to perform the overlay in. If None , the base color's space will be used. out_space None A color space to output the resultant color to. in_place False Boolean used to determine if the the current color should be modified \"in place\" or a new Color object should be returned. Return Returns a reference to the new Color object or a reference to the current Color if in_place is True . Color.fit def fit ( self , space = None , * , method = None , in_place = False ): Description Fits color to the current or specified color gamut. By default, lch-chroma gamut mapping is used. This is essentially an approach that holds lightness and hue constant in the CIELCH color space while reducing chroma until the color is in gamut. Clipping is done at each step of the way and the color distance measured to see how close our color is to the intended color. The supported gamut mapping methods are: Name Input LCH Chroma lch-chroma Clipping clip Parameters Parameters Defaults Description space None The color space that the color must be mapped to. If space is None , then the current color space will be used. method None String that specifies which gamut mapping method to use. If None , lch-chroma will be used. Return Returns a reference to the new Color object or a reference to the current Color if in_place is True . Color.in_gamut def in_gamut ( self , space = None , * , tolerance = util . DEF_FIT_TOLERANCE ): Description Checks if the current color is in the current or specified gamut. Parameters Parameters Defaults Description space None The color space that the color must be fit within. If space is None , then the current color space will be used. tolerance 0.000075 Tolerance allowed when checking bounds of color. Return Returns a boolean indicating whether the color is in the specified gamut. Color.get def get ( self , name ): Description Retrieves the coordinate value from the specified channel. Channel must be a channel name in the current color space or a channel name in the specified color space using the syntax: space.channel . Parameters Parameters Defaults Description name Channel name or color space and channel name to retrieve value from. Return Returns a numerical value that is stored internally for the specified channel, or a calculated value in the case that a channel in a different color space is requested. Color.set def set ( self , name , value ): Description Sets the given value to the specified channel. If the name is provided in the form space.channel , the value will be applied to the channel of the specified color space while keeping current color space the same. The value can be a numerical value, a CSS string compatible with the specified color space, or a function that accepts a numerical channel value and returns a numerical channel value. This function returns the current colors reference so that multiple sets can be chained together. Parameters Parameters Defaults Description name Channel name or color space and channel name to retrieve value from. value A numerical value, a string value accepted by the specified color space, or a function. Return Returns a reference to the current Color object. Color.is_nan def is_nan ( self , name ): Description Retrieves the coordinate value from the specified channel and checks whether the value is NaN . Channel must be a channel name in the current color space or a channel name in the specified color space using the syntax: space.channel . Parameters Parameters Defaults Description name A string indicating what channel property to check. Return Returns a boolean indicating whether the specified color space's channel is NaN . Color Channel Properties Depending on the given color space, channel properties will be available on the color object as well. These are dynamically available depending on what the current color space is. For instance, if the color space is sRGB, the channels red , green , blue , and alpha will all be available. Color channel names are defined in Supported Colors . These properties are read and writable. When read, they will return the numerical value stored in the specified channel. When written, they can accept a numerical value or a string value using CSS syntax acceptable for that channel in that color space. For more complex setting operations, or to chain multiple set operations, please use set and get .","title":"Color API"},{"location":"api/#color-api","text":"","title":"Color API"},{"location":"api/#nan","text":"Description NaN is a convenience constant for float('nan') . NaN . Import path NaN is imported from the coloraide library: from coloraide import NaN","title":"coloraide.NaN"},{"location":"api/#piecewise","text":"class Piecewise ( namedtuple ( 'Piecewise' , [ 'color' , 'stop' , 'progress' , 'hue' , 'premultiplied' ] ) ): Description Piecewise objects are used in interpolate methods. They allow a user to control interpolation stops , progress , hue , or premultiplied options for a specific interpolation piece when doing piecewise interpolation. Import Path Piecewise is imported from coloraide library: from coloraide import Piecewise Parameters Input parameters match interpolate parameters of the same name. Only color is required and all other parameters default to None . If a parameter is None , it will be ignored by interpolate .","title":"coloraide.Piecewise"},{"location":"api/#color","text":"class Color : def __init__ ( self , color , data = None , alpha = util . DEF_ALPHA , * , filters = None , ** kwargs ): Description The Color class object is a wrapper around the internal color space objects. It provides an API interface to allow users to specify and manipulate colors. Import path Color is imported from the coloraide library: from coloraide import Color Parameters Parameters Defaults Description color A color string, or other Color class object. If given data , a string must be used and should represent the color space to use. data None data accepts a list of numbers representing the coordinates of the color. If provided, color must be a string specifying the color space. alpha 1 alpha accepts a number specifying the alpha channel. Must be used in conjunction with data or it will be ignored. filters None filters accepts a list of color spaces to allow. When None is provided (the default) all supported color spaces are accepted.","title":"coloraide.Color"},{"location":"api/#match","text":"@classmethod def match ( cls , string , start = 0 , fullmatch = False , * , filters = None ): Description The match class method provides access to the color matching interface and allows a user to provide a color string and get back a ColorMatch object. ColorMatch objects contain three properties: class ColorMatch : def __init__ ( self , color , start , end ): color : the Color object. start : the starting point within the string buffer where the color was found. end : the ending point within the string buffer where the color was found. Match does not search the entire buffer, but simply matches at the location specified by start . Parameters Parameters Defaults Description string A string representing the color. start 0 Accepts a integer offset into the provided string buffer to start the match. fullmatch False A boolean which defines whether match must match to the end of the string buffer. filters None filters accepts a list of color spaces to allow. When None is provided (the default) all supported color spaces are accepted. Return Returns a ColorMatch object.","title":"Color.match"},{"location":"api/#new","text":"def new ( self , color , data = None , alpha = util . DEF_ALPHA , * , filters = None , ** kwargs ): Description The new class method exposes the interface of creating new color objects. Using new is the same as using Color() . Parameters Parameters Defaults Description color A color string, or other Color class object. If given data , a string must be used and should represent the color space to use. data None data accepts a list of numbers representing the coordinates of the color. If provided, color must be a string specifying the color space. alpha 1 alpha accepts a number specifying the alpha channel. Must be used in conjunction with data or it will be ignored. filters None filters accepts a list of color spaces to allow. When None is provided (the default) all supported color spaces are accepted. Return Returns a Color object.","title":"Color.new"},{"location":"api/#clone","text":"def clone ( self ): Description The clone method provides a way to create a duplicate of the current Color instance. Return Returns a Color object.","title":"Color.clone"},{"location":"api/#update","text":"def update ( self , color , data = None , alpha = util . DEF_ALPHA , * , filters = None , ** kwargs ): Description The update method provides a way to update the underlying color spaces with coordinates from any color space. The methods signature looks just like new and accepts color strings, Color objects, or raw data points specified with a color space string and coordinates. The object itself will be updated and remain in its current color space. Parameters Parameters Defaults Description color A color string, or other Color class object. If given data , a string must be used and should represent the color space to use. data None data accepts a list of numbers representing the coordinates of the color. If provided, color must be a string specifying the color space. alpha 1 alpha accepts a number specifying the alpha channel. Must be used in conjunction with data or it will be ignored. filters None filters accepts a list of color spaces to allow. When None is provided (the default) all supported color spaces are accepted. Return Returns a reference to the current Color object.","title":"Color.update"},{"location":"api/#mutate","text":"def mutate ( self , color , data = None , alpha = util . DEF_ALPHA , * , filters = None , ** kwargs ): Description The mutate method is just like update except that it will not only update the color space, but mutate it to the provided color space. Parameters Parameters Defaults Description color A color string, or other Color class object. If given data , a string must be used and should represent the color space to use. data None data accepts a list of numbers representing the coordinates of the color. If provided, color must be a string specifying the color space. alpha 1 alpha accepts a number specifying the alpha channel. Must be used in conjunction with data or it will be ignored. filters None filters accepts a list of color spaces to allow. When None is provided (the default) all supported color spaces are accepted. Return Returns a reference to the current Color object.","title":"Color.mutate"},{"location":"api/#convert","text":"def convert ( self , space , * , fit = False , in_place = False ): Description Converts a Color object from one color space to another. If the current color space matches the specified color space, the object will be cloned. Parameters Parameters Defaults Description space A string representing the desired final color space. fit False Boolean specifying whether the current color should be gamut mapped into the final, desired color space. in_place False Boolean specifying whether the convert should alter the current Color object or return a new one. Return Returns a reference to the converted Color object. If in_place is True , the return will be a reference to the current Color object.","title":"Color.convert"},{"location":"api/#space","text":"def space ( self ): Description Retrieves the current color space of the color. Return Returns a string with the name of the current color space.","title":"Color.space"},{"location":"api/#coords","text":"def coords ( self ): Description Returns a list of the color's coordinates. This does not include the alpha channel. Alpha can be accessed via the alpha property or get and set accessors. Return Returns a list of numbers indicating the current coordinate values.","title":"Color.coords"},{"location":"api/#to_string","text":"def to_string ( self , ** kwargs ): Description Method that converts the current color to an output format supported by the color space. While a number of the parameters are common, some may be specific to the color space. The usage guide covers color space specific options in more details. Parameters Common parameters: Parameters Defaults Description alpha None Boolean or None value which determines whether the output includes alpha . If None (the default) alpha will only be shown if less than 1. If True , alpha will always be shown. If False , alpha will be omitted. precision 5 Integer value that sets precision and scale. Precision and scale will match the value if greater than zero. If 0 , values will be rounded to the nearest integer. If -1 , number will be output at the highest precision. fit True A boolean that controls whether gamut mapping is performed on string creation. By default, colors will be fit to their own color space. This can be disabled by setting to False . color False A boolean that will determine if the color(space coord+ / alpha) format is used for string output. Has highest precedence. sRGB specific parameters: Parameters Defaults Description hex . False String output will be in #RRGGBBAA format. names False Boolean indicating a preference for CSS color names. When translating a color to it's closest hex form, if that hex value matches a CSS color name, that color name will be returned as the output. hex does not have to be True for this to apply. compress False If hex is True and compress is True , hex values will be compressed if possible: #RRGGBBAA \u2192 #RGBA . Space dependent parameters: Parameters Defaults Description comma False If supported by the color space and the current output format, commas will be used instead of space format: rgba(0, 0, 0, 1) \u2192 rgb(0 0 0 /1) . Return Returns a string representation of the current color.","title":"Color.to_string"},{"location":"api/#luminance","text":"def luminance ( self ): Description Get the relative luminance. Relative luminance is obtained from the Y coordinate in the XYZ color space. XYZ, in this case, has a D65 white point. Return Returns an float indicating the relative luminance.","title":"Color.luminance"},{"location":"api/#colorcontrast","text":"def contrast ( self , color ): Description Get the contrast ratio based on the relative luminance between two colors. Parameters Parameters Defaults Description color A color string or Color object representing a color. Return Returns a float indicating the contrast ratio between two colors.","title":"Color.contrast"},{"location":"api/#distance","text":"def distance ( self , color , * , space = util . DEF_DISTANCE_SPACE ): Description Performs a euclidean distance algorithm on two colors. Parameters Parameters Defaults Description color A color string or Color object representing a color. space \"lab\" Color space to perform distancing algorithm in. Return Returns a float indicating euclidean distance between the two colors.","title":"Color.distance"},{"location":"api/#delta_e","text":"def delta_e ( self , color , * , method = None , ** kwargs ): Description Performs a delta E distance algorithm on two colors. Default algorithm that is used is Delta E 1976 ( 76 ). Some methods have additional weighting that can be configured through method specific options which are represented by **kwargs . Available methods: Name Input CIE76 76 CIE94 94 CIEDE2000 2000 CMC l:c (1984) cmc Parameters Parameters Defaults Description color A color string or Color object representing a color. method None String that specifies the method to use. If None , the default will be used. Return Returns a float indicating the delta E distance between the two colors.","title":"Color.delta_e"},{"location":"api/#mask","text":"def mask self , channels , invert = False , in_place = False ): Description The mask method will set any and all specified channels to NaN . If invert is set to True , mask will set any and all channels not specified to NaN . Parameters Parameters Defaults Description channel A string specifying a channel, or a list of strings specifying multiple channels. Specified channels will be masked (or the only channels not masked if invert is True ). invert False Use inverse masking logic and mask all channels that are not specified. in_place False Boolean used to determine if the the current color should be modified \"in place\" or a new Color object should be returned. Return Returns a reference to the masked Color object. If in_place is True , the return will be a reference to the current Color object.","title":"color.mask"},{"location":"api/#interpolate","text":"def interpolate ( self , color , * , stop = 0 , space = \"lab\" , progress = None , out_space = None , hue = util . DEF_HUE_ADJ , premultiplied = False ): Description The interpolate method creates a function that takes a value between 0 - 1 and interpolates a new color based on the input value. If more than one color is provided, the returned function will span the interpolations between all the provided colors with the same range of 0 - 1. Interpolation can be customized by limiting the interpolation to specific color channels, providing custom interpolation functions, and even adjusting the hue logic used. Piecewise objects can be used to specify stops or adjust the interpolation for itself and the preceding color. Hue Evaluation Description shorter Angles are adjusted so that \u03b8\u2082 - \u03b8\u2081 \u2208 [-180, 180]. longer Angles are adjusted so that \u03b8\u2082 - \u03b8\u2081 \u2208 {0, [180, 360)}. increasing Angles are adjusted so that \u03b8\u2082 - \u03b8\u2081 \u2208 [0, 360). decreasing Angles are adjusted so that \u03b8\u2082 - \u03b8\u2081 \u2208 (-360, 0] specified No fixup is performed. Angles are interpolated in the same way as every other component. Parameters Parameters Defaults Description color A color string, Color object, or Piecewise object representing a color. Also, multiple can be provided via a list. space \"lab\" Color space to interpolate in. progress None An optional function that that allows for custom logic to perform non-linear interpolation. out_space None Color space that the new color should be in. If None , the color will be in the same color space as the base color. hue \"shorter\" Define how color spaces which have hue angles are interpolated. Default evaluates between the shortest angle. premultiplied False Use premultiplied alpha when interpolating. Return Returns a function that takes a range from [0..1] . The function returns a reference to the interpolated Color object.","title":"Color.interpolate"},{"location":"api/#steps","text":"def steps ( self , color , * , steps = 2 , max_steps = 1000 , max_delta_e = 0 , ** interpolate_args ): Description Creates an interpolate function and iterates through it with user defined step parameters to produce discrete color steps. Will attempt to provide the minimum number of steps without exceeding max_steps . If max_delta_e is provided, the distance between each stop will be cut in half until there are no colors with a distance greater than the specified max_delta_e . If more than one color is provided, the steps will be returned from the interpolations between all the provided colors. Like interpolate , the default interpolation space is lab . Parameters Parameters Defaults Description color A color string or Color object representing a color. Also, multiple can be provided via a list. steps 2 Minimum number of steps. max_steps 1000 Maximum number of steps. max_delta_e 0 Maximum delta E distance between the color stops. A value of 0 or less will be ignored. ** interpolate_args See interpolate Keyword arguments defined in interpolate . Return List of Color objects.","title":"Color.steps"},{"location":"api/#mix","text":"def mix ( self , color , percent = util . DEF_MIX , * , in_place = False , ** interpolate_args ): Description Interpolates between two colors returning a color that represents the mixing of the base color and the provided color mixed at the provided percent , where percent applies to how much the provided color contributes to the the final result. Parameters Parameters Defaults Description color A color string or Color object representing a color. percent 0.5 A numerical value between 0 - 1 representing the percentage at which the parameter color will be mixed. in_place False Boolean used to determine if the the current color should be modified \"in place\" or a new Color object should be returned. ** interpolate_args See interpolate Keyword arguments defined in interpolate . Return Returns a reference to the new Color object or a reference to the current Color if in_place is True .","title":"Color.mix"},{"location":"api/#average","text":"def average ( self , color , weights = None , * , space = 'lab' , out_space = None , in_place = False , hue = util . DEF_HUE_ADJ , sort_hue = False ): Description Allows the averaging of one or more colors essentially allowing a mixing of any number of colors. Each color is mixed in such a way so that each color has an equal weight. If, and only if, a color set has a color with transparency, the transparency will be averaged separately. The specified color(s) to average with the base color can be a single color, or a list of colors as specified in the parameters below. Like interpolate , the default interpolation space is lab . Parameters Parameters Defaults Description color A color string or Color object representing a color. Also, multiple can be provided via a list. weights [ 1 ] * n An array of length n (where n is number of colors that are to be averaged) that specifies the weight of the given colors. Order of the weights should match the order of the inputs where the base color is index 0. space \"lab\" Color space to interpolate in. out_space None Color space that the new color should be in. If None , the color will be in the same color space as the base color. hue \"shorter\" Define how color spaces which have hue angles are interpolated. Default evaluates between the shortest angle. in_place False Boolean used to determine if the the current color should be modified \"in place\" or a new Color object should be returned. sort_hue #py3 False Specifies whether cylindrical spaces should sort colors by hue before averaging to ensure a consistence, predictable averaging regardless of what order the colors are provided. Return Returns a reference to the new Color object or a reference to the current Color if in_place is True .","title":"Color.average"},{"location":"api/#compose","text":"def compose ( self , backdrop , * , blend = None , operator = None , space = None , out_space = None , in_place = False ): Description Apply compositing which consists of a blend mode and a Porter Duff operator for alpha compositing. The current color is treated as the source (top layer) and the provided color as the backdrop (bottom layer). Colors will be composited in the srgb color space unless otherwise specified. Colors should generally be RGB-ish colors (sRGB, Display P3, A98 RGB, etc.). Some non-RGB-ish colors may work okay, with the defaults, but many the algorithm is really designed for RGB-ish colors. Non-RGB-ish colors are likely to provide nonsense results. Supported blend modes are: Blend Modes normal multiply darken lighten burn dodge screen overlay hard-light exclusion difference soft-light hue saturation luminosity color color hue saturation luminosity Supported Port Duff operators are: Operators clear copy destination source-over destination-over source-in destination-in source-out destination-out source-atop destination-atop xor lighter Parameters Parameters Defaults Description backdrop A background color represented with either a string or Color object. blend None A blend mode to use to use when compositing. Values should be a string specifying the name of the blend mode to use. If None , normal will be used. If False , blending will be skipped. operator None A Porter Duff operator to use for alpha compositing. Values should be a string specifying the name of the operator to use. If None , source-over will be used. If False , alpha compositing will be skipped. space None A color space to perform the overlay in. If None , the base color's space will be used. out_space None A color space to output the resultant color to. in_place False Boolean used to determine if the the current color should be modified \"in place\" or a new Color object should be returned. Return Returns a reference to the new Color object or a reference to the current Color if in_place is True .","title":"Color.compose"},{"location":"api/#fit","text":"def fit ( self , space = None , * , method = None , in_place = False ): Description Fits color to the current or specified color gamut. By default, lch-chroma gamut mapping is used. This is essentially an approach that holds lightness and hue constant in the CIELCH color space while reducing chroma until the color is in gamut. Clipping is done at each step of the way and the color distance measured to see how close our color is to the intended color. The supported gamut mapping methods are: Name Input LCH Chroma lch-chroma Clipping clip Parameters Parameters Defaults Description space None The color space that the color must be mapped to. If space is None , then the current color space will be used. method None String that specifies which gamut mapping method to use. If None , lch-chroma will be used. Return Returns a reference to the new Color object or a reference to the current Color if in_place is True .","title":"Color.fit"},{"location":"api/#in_gamut","text":"def in_gamut ( self , space = None , * , tolerance = util . DEF_FIT_TOLERANCE ): Description Checks if the current color is in the current or specified gamut. Parameters Parameters Defaults Description space None The color space that the color must be fit within. If space is None , then the current color space will be used. tolerance 0.000075 Tolerance allowed when checking bounds of color. Return Returns a boolean indicating whether the color is in the specified gamut.","title":"Color.in_gamut"},{"location":"api/#get","text":"def get ( self , name ): Description Retrieves the coordinate value from the specified channel. Channel must be a channel name in the current color space or a channel name in the specified color space using the syntax: space.channel . Parameters Parameters Defaults Description name Channel name or color space and channel name to retrieve value from. Return Returns a numerical value that is stored internally for the specified channel, or a calculated value in the case that a channel in a different color space is requested.","title":"Color.get"},{"location":"api/#set","text":"def set ( self , name , value ): Description Sets the given value to the specified channel. If the name is provided in the form space.channel , the value will be applied to the channel of the specified color space while keeping current color space the same. The value can be a numerical value, a CSS string compatible with the specified color space, or a function that accepts a numerical channel value and returns a numerical channel value. This function returns the current colors reference so that multiple sets can be chained together. Parameters Parameters Defaults Description name Channel name or color space and channel name to retrieve value from. value A numerical value, a string value accepted by the specified color space, or a function. Return Returns a reference to the current Color object.","title":"Color.set"},{"location":"api/#is_nan","text":"def is_nan ( self , name ): Description Retrieves the coordinate value from the specified channel and checks whether the value is NaN . Channel must be a channel name in the current color space or a channel name in the specified color space using the syntax: space.channel . Parameters Parameters Defaults Description name A string indicating what channel property to check. Return Returns a boolean indicating whether the specified color space's channel is NaN .","title":"Color.is_nan"},{"location":"api/#color-channel-properties","text":"Depending on the given color space, channel properties will be available on the color object as well. These are dynamically available depending on what the current color space is. For instance, if the color space is sRGB, the channels red , green , blue , and alpha will all be available. Color channel names are defined in Supported Colors . These properties are read and writable. When read, they will return the numerical value stored in the specified channel. When written, they can accept a numerical value or a string value using CSS syntax acceptable for that channel in that color space. For more complex setting operations, or to chain multiple set operations, please use set and get .","title":"Color Channel Properties"},{"location":"colors/","text":"Supported Colors sRGB Properties Identifier: srgb White Point: D65 Coordinates: Name Range red 0 - 1 green 0 - 1 blue 0 - 1 sRGB is a standard RGB (red, green, blue) color space that HP and Microsoft created cooperatively in 1996 to use on monitors, printers, and the Web. SRGB stands for \"Standard RGB\". It is the most widely used color space and is supported by most operating systems, software programs, monitors, and printers. Learn about sRGB HSV Properties Identifier: hsv White Point: D65 Coordinates: Name Range hue 0 - 360 saturation 0 - 100 value 0 - 100 HSV is a color space similar to the modern RGB and CMYK models. The HSV color space has three components: hue, saturation and value. 'Value' is sometimes substituted with 'brightness' and then it is known as HSB. HSV represents models how colors appear under light. Learn about HSV HSL Properties Identifier: hsl White Point: D65 Coordinates: Name Range hue 0 - 360 saturation 0 - 100 lightness 0 - 100 HSL is an alternative representations of the RGB color model, designed in the 1970s by computer graphics researchers to more closely align with the way human vision perceives color-making attributes. In these models, colors of each hue are arranged in a radial slice, around a central axis of neutral colors which ranges from black at the bottom to white at the top. HSL models the way different paints mix together to create color in the real world, with the lightness dimension resembling the varying amounts of black or white paint in the mixture. Learn about HSL HWB Properties Identifier: hwb White Point: D65 Coordinates: Name Range hue 0 - 360 whiteness 0 - 100 blackness 0 - 100 HWB is a cylindrical-coordinate representation of points in an RGB color model, similar to HSL and HSV. It was developed by HSV 's creator Alvy Ray Smith in 1996 to address some of the issues with HSV. HWB was designed to be more intuitive for humans to use and slightly faster to compute. The first coordinate, H (Hue), is the same as the Hue coordinate in HSL and HSV . W and B stand for Whiteness and Blackness respectively and range from 0-100% (or 0-1). The mental model is that the user can pick a main hue and then \"mix\" it with white and/or black to produce the desired color. Learn about HWB Display P3 Properties Identifier: display-p3 White Point: D65 Coordinates: Name Range red 0 - 1 green 0 - 1 blue 0 - 1 Display P3 is a combination of the DCI-P3 color gamut with the D65 white point together with the sRGB gamma curve. It originated from the DCI-P3 color gamut's implementation in digital cinema projectors, as this standard offers more vibrant greens and reds than the traditional sRGB color gamut. Learn about Display P3 A98 RGB Properties Identifier: a98-rgb White Point: D65 Coordinates: Name Range red 0 - 1 green 0 - 1 blue 0 - 1 The Adobe RGB (1998) color space or opRGB is a color space developed by Adobe Systems, Inc. in 1998. It was designed to encompass most of the colors achievable on CMYK color printers, but by using RGB primary colors on a device such as a computer display. The Adobe RGB (1998) color space encompasses roughly 50% of the visible colors specified by the CIELAB color space - improving upon the gamut of the sRGB color space, primarily in cyan-green hues. Learn about A98 RGB REC.2020 Properties Identifier: rec2020 White Point: D65 Coordinates: Name Range red 0 - 1 green 0 - 1 blue 0 - 1 The Rec. 2020 color space is a result of this and is a very wide gamut RGB color space which is used in 4k and 8k UHDTV. ITU-R Recommendation BT.2020, more commonly known by the abbreviations Rec. 2020 or BT.2020, defines various aspects of ultra-high-definition television (UHDTV) with standard dynamic range (SDR) and wide color gamut (WCG), including picture resolutions, frame rates with progressive scan, bit depths, color primaries, RGB and luma-chroma color representations, chroma subsamplings, and an opto-electronic transfer function. Learn about REC.2020 ProPhoto Properties Identifier: prophoto-rgb White Point: D50 Coordinates: Name Range red 0 - 1 green 0 - 1 blue 0 - 1 The ProPhoto RGB color space, also known as ROMM RGB (Reference Output Medium Metric), is an output referred RGB color space developed by Kodak. It offers an especially large gamut designed for use with photographic output in mind. The ProPhoto RGB color space encompasses over 90% of possible surface colors in the CIE L*a*b* color space, and 100% of likely occurring real-world surface colors documented by Pointer in 1980. Learn about ProPhoto XYZ Properties Identifier: xyz White Point: D50 Coordinates: Name Range x 0 - 1 y 0 - 1 z 0 - 1 The CIE 1931 RGB color space and CIE 1931 XYZ color space were created by the International Commission on Illumination (CIE) in 1931. They resulted from a series of experiments done in the late 1920s by William David Wright using ten observers and John Guild using seven observers. The experimental results were combined into the specification of the CIE RGB color space, from which the CIE XYZ color space was derived. The CIE 1931 color spaces are the first defined quantitative links between distributions of wavelengths in the electromagnetic visible spectrum, and physiologically perceived colors in human color vision. Learn about XYZ XYZ D65 Properties Identifier: xyz-d65 White Point: D65 Coordinates: Name Range x 0 - 1 y 0 - 1 z 0 - 1 XYZ D65 is the same as XYZ except it uses a D65 white point. Learn about XYZ .info-container { overflow: hidden; } .info-container .admonition.inline.end { margin-right: 0.5rem; } CIELAB Properties Identifier: lab White Point: D50 Coordinates: Name Range lightness 0 - 100 a -160 - 160 b -160 - 160 The CIELAB color space also referred to as L*a*b* is a color space defined by the International Commission on Illumination (abbreviated CIE) in 1976. It expresses color as three values: L* for perceptual lightness, and a* and b* for the four unique colors of human vision: red, green, blue, and yellow. CIELAB was intended as a perceptually uniform space, where a given numerical change corresponds to similar perceived change in color. While the CIELAB space is not truly perceptually uniform, it nevertheless is useful in industry for detecting small differences in color. Learn about CIELAB CIELCH Properties Identifier: lch White Point: D50 Coordinates: Name Range lightness 0 - 100 chroma 0 - 100 hue 0 - 360 The \"CIELCH\" or \"CIEHLC\" space is a color space based on CIELAB , which uses the polar coordinates C* (chroma, relative saturation) and h\u00b0 (hue angle, angle of the hue in the CIELAB color wheel) instead of the Cartesian coordinates a* and b*. The CIELAB lightness L* remains unchanged. Learn about CIELCH CIELAB D65 Properties Identifier: lab-d65 White Point: D65 Coordinates: Name Range lightness 0 - 100 a -160 - 160 b -160 - 160 CIELAB D65 is the same as CIELAB except it uses a D65 white point. Learn about CIELAB CIELCH D65 Properties Identifier: lch-d65 White Point: D65 Coordinates: Name Range lightness 0 - 100 chroma 0 - 100 hue 0 - 360 CIELCH D65 is the same as CIELCH except it uses a D65 white point. Learn about CIELCH Oklab Properties Identifier: oklab White Point: D65 Coordinates: Name Range lightness 0 - 1 a -0.5 - 0.5 b -0.5 - 0.5 A new perceptual color space that claims to be simple to use, while doing a good job at predicting perceived lightness, chroma and hue. It is called the Oklab color space, because it is an OK Lab color space. Learn about Oklab Oklch Properties Identifier: oklch White Point: D65 Coordinates: Name Range lightness 0 - 1 chroma 0 - 1 hue 0 - 360 Oklch is the cylindrical form of Oklab . Learn about Oklch Jzazbz Properties Identifier: jzazbz White Point: D65 Coordinates: Name Range lightness 0 - 1 a -0.5 - 0.5 b -0.5 - 0.5 Jzazbz is a a color space designed for perceptual uniformity in high dynamic range (HDR) and wide color gamut (WCG) applications. Conceptually it is similar to CIELAB , but claims the following improvements: Perceptual color difference is predicted by Euclidean distance. Perceptually uniform: MacAdam ellipses of just-noticeable-difference (JND) are more circular, and closer to the same sizes. Hue linearity: changing saturation or lightness has less shift in hue. Learn about Jzazbz JzCzhz Properties Identifier: jzczhz White Point: D65 Coordinates: Name Range lightness 0 - 1 chroma 0 - 1 hue 0 - 360 JzCzhz is the cylindrical form of Jzazbz . Learn about JzCzhz ICtCp Properties Identifier: ictcp White Point: D65 Coordinates: Name Range i 0 - 1 ct -0.5 - 0.5 cp -0.5 - 0.5 ICtCp is a color space format with better perceptual uniformity than CIELAB and is used as a part of the color image pipeline in video and digital photography systems for high dynamic range (HDR) and wide color gamut (WCG) imagery. It was developed by Dolby Laboratories from the IPT color space by Ebner and Fairchild. It was designed with the intention to replace YCbCr. Learn about ICtCp","title":"Supported Colors"},{"location":"colors/#supported-colors","text":"","title":"Supported Colors"},{"location":"colors/#srgb","text":"Properties Identifier: srgb White Point: D65 Coordinates: Name Range red 0 - 1 green 0 - 1 blue 0 - 1 sRGB is a standard RGB (red, green, blue) color space that HP and Microsoft created cooperatively in 1996 to use on monitors, printers, and the Web. SRGB stands for \"Standard RGB\". It is the most widely used color space and is supported by most operating systems, software programs, monitors, and printers. Learn about sRGB","title":"sRGB"},{"location":"colors/#hsv","text":"Properties Identifier: hsv White Point: D65 Coordinates: Name Range hue 0 - 360 saturation 0 - 100 value 0 - 100 HSV is a color space similar to the modern RGB and CMYK models. The HSV color space has three components: hue, saturation and value. 'Value' is sometimes substituted with 'brightness' and then it is known as HSB. HSV represents models how colors appear under light. Learn about HSV","title":"HSV"},{"location":"colors/#hsl","text":"Properties Identifier: hsl White Point: D65 Coordinates: Name Range hue 0 - 360 saturation 0 - 100 lightness 0 - 100 HSL is an alternative representations of the RGB color model, designed in the 1970s by computer graphics researchers to more closely align with the way human vision perceives color-making attributes. In these models, colors of each hue are arranged in a radial slice, around a central axis of neutral colors which ranges from black at the bottom to white at the top. HSL models the way different paints mix together to create color in the real world, with the lightness dimension resembling the varying amounts of black or white paint in the mixture. Learn about HSL","title":"HSL"},{"location":"colors/#hwb","text":"Properties Identifier: hwb White Point: D65 Coordinates: Name Range hue 0 - 360 whiteness 0 - 100 blackness 0 - 100 HWB is a cylindrical-coordinate representation of points in an RGB color model, similar to HSL and HSV. It was developed by HSV 's creator Alvy Ray Smith in 1996 to address some of the issues with HSV. HWB was designed to be more intuitive for humans to use and slightly faster to compute. The first coordinate, H (Hue), is the same as the Hue coordinate in HSL and HSV . W and B stand for Whiteness and Blackness respectively and range from 0-100% (or 0-1). The mental model is that the user can pick a main hue and then \"mix\" it with white and/or black to produce the desired color. Learn about HWB","title":"HWB"},{"location":"colors/#display-p3","text":"Properties Identifier: display-p3 White Point: D65 Coordinates: Name Range red 0 - 1 green 0 - 1 blue 0 - 1 Display P3 is a combination of the DCI-P3 color gamut with the D65 white point together with the sRGB gamma curve. It originated from the DCI-P3 color gamut's implementation in digital cinema projectors, as this standard offers more vibrant greens and reds than the traditional sRGB color gamut. Learn about Display P3","title":"Display P3"},{"location":"colors/#a98-rgb","text":"Properties Identifier: a98-rgb White Point: D65 Coordinates: Name Range red 0 - 1 green 0 - 1 blue 0 - 1 The Adobe RGB (1998) color space or opRGB is a color space developed by Adobe Systems, Inc. in 1998. It was designed to encompass most of the colors achievable on CMYK color printers, but by using RGB primary colors on a device such as a computer display. The Adobe RGB (1998) color space encompasses roughly 50% of the visible colors specified by the CIELAB color space - improving upon the gamut of the sRGB color space, primarily in cyan-green hues. Learn about A98 RGB","title":"A98 RGB"},{"location":"colors/#rec2020","text":"Properties Identifier: rec2020 White Point: D65 Coordinates: Name Range red 0 - 1 green 0 - 1 blue 0 - 1 The Rec. 2020 color space is a result of this and is a very wide gamut RGB color space which is used in 4k and 8k UHDTV. ITU-R Recommendation BT.2020, more commonly known by the abbreviations Rec. 2020 or BT.2020, defines various aspects of ultra-high-definition television (UHDTV) with standard dynamic range (SDR) and wide color gamut (WCG), including picture resolutions, frame rates with progressive scan, bit depths, color primaries, RGB and luma-chroma color representations, chroma subsamplings, and an opto-electronic transfer function. Learn about REC.2020","title":"REC.2020"},{"location":"colors/#prophoto","text":"Properties Identifier: prophoto-rgb White Point: D50 Coordinates: Name Range red 0 - 1 green 0 - 1 blue 0 - 1 The ProPhoto RGB color space, also known as ROMM RGB (Reference Output Medium Metric), is an output referred RGB color space developed by Kodak. It offers an especially large gamut designed for use with photographic output in mind. The ProPhoto RGB color space encompasses over 90% of possible surface colors in the CIE L*a*b* color space, and 100% of likely occurring real-world surface colors documented by Pointer in 1980. Learn about ProPhoto","title":"ProPhoto"},{"location":"colors/#xyz","text":"Properties Identifier: xyz White Point: D50 Coordinates: Name Range x 0 - 1 y 0 - 1 z 0 - 1 The CIE 1931 RGB color space and CIE 1931 XYZ color space were created by the International Commission on Illumination (CIE) in 1931. They resulted from a series of experiments done in the late 1920s by William David Wright using ten observers and John Guild using seven observers. The experimental results were combined into the specification of the CIE RGB color space, from which the CIE XYZ color space was derived. The CIE 1931 color spaces are the first defined quantitative links between distributions of wavelengths in the electromagnetic visible spectrum, and physiologically perceived colors in human color vision. Learn about XYZ","title":"XYZ"},{"location":"colors/#xyz-d65","text":"Properties Identifier: xyz-d65 White Point: D65 Coordinates: Name Range x 0 - 1 y 0 - 1 z 0 - 1 XYZ D65 is the same as XYZ except it uses a D65 white point. Learn about XYZ .info-container { overflow: hidden; } .info-container .admonition.inline.end { margin-right: 0.5rem; }","title":"XYZ D65"},{"location":"colors/#cielab","text":"Properties Identifier: lab White Point: D50 Coordinates: Name Range lightness 0 - 100 a -160 - 160 b -160 - 160 The CIELAB color space also referred to as L*a*b* is a color space defined by the International Commission on Illumination (abbreviated CIE) in 1976. It expresses color as three values: L* for perceptual lightness, and a* and b* for the four unique colors of human vision: red, green, blue, and yellow. CIELAB was intended as a perceptually uniform space, where a given numerical change corresponds to similar perceived change in color. While the CIELAB space is not truly perceptually uniform, it nevertheless is useful in industry for detecting small differences in color. Learn about CIELAB","title":"CIELAB"},{"location":"colors/#cielch","text":"Properties Identifier: lch White Point: D50 Coordinates: Name Range lightness 0 - 100 chroma 0 - 100 hue 0 - 360 The \"CIELCH\" or \"CIEHLC\" space is a color space based on CIELAB , which uses the polar coordinates C* (chroma, relative saturation) and h\u00b0 (hue angle, angle of the hue in the CIELAB color wheel) instead of the Cartesian coordinates a* and b*. The CIELAB lightness L* remains unchanged. Learn about CIELCH","title":"CIELCH"},{"location":"colors/#cielab-d65","text":"Properties Identifier: lab-d65 White Point: D65 Coordinates: Name Range lightness 0 - 100 a -160 - 160 b -160 - 160 CIELAB D65 is the same as CIELAB except it uses a D65 white point. Learn about CIELAB","title":"CIELAB D65"},{"location":"colors/#cielch-d65","text":"Properties Identifier: lch-d65 White Point: D65 Coordinates: Name Range lightness 0 - 100 chroma 0 - 100 hue 0 - 360 CIELCH D65 is the same as CIELCH except it uses a D65 white point. Learn about CIELCH","title":"CIELCH D65"},{"location":"colors/#oklab","text":"Properties Identifier: oklab White Point: D65 Coordinates: Name Range lightness 0 - 1 a -0.5 - 0.5 b -0.5 - 0.5 A new perceptual color space that claims to be simple to use, while doing a good job at predicting perceived lightness, chroma and hue. It is called the Oklab color space, because it is an OK Lab color space. Learn about Oklab","title":"Oklab"},{"location":"colors/#oklch","text":"Properties Identifier: oklch White Point: D65 Coordinates: Name Range lightness 0 - 1 chroma 0 - 1 hue 0 - 360 Oklch is the cylindrical form of Oklab . Learn about Oklch","title":"Oklch"},{"location":"colors/#jzazbz","text":"Properties Identifier: jzazbz White Point: D65 Coordinates: Name Range lightness 0 - 1 a -0.5 - 0.5 b -0.5 - 0.5 Jzazbz is a a color space designed for perceptual uniformity in high dynamic range (HDR) and wide color gamut (WCG) applications. Conceptually it is similar to CIELAB , but claims the following improvements: Perceptual color difference is predicted by Euclidean distance. Perceptually uniform: MacAdam ellipses of just-noticeable-difference (JND) are more circular, and closer to the same sizes. Hue linearity: changing saturation or lightness has less shift in hue. Learn about Jzazbz","title":"Jzazbz"},{"location":"colors/#jzczhz","text":"Properties Identifier: jzczhz White Point: D65 Coordinates: Name Range lightness 0 - 1 chroma 0 - 1 hue 0 - 360 JzCzhz is the cylindrical form of Jzazbz . Learn about JzCzhz","title":"JzCzhz"},{"location":"colors/#ictcp","text":"Properties Identifier: ictcp White Point: D65 Coordinates: Name Range i 0 - 1 ct -0.5 - 0.5 cp -0.5 - 0.5 ICtCp is a color space format with better perceptual uniformity than CIELAB and is used as a part of the color image pipeline in video and digital photography systems for high dynamic range (HDR) and wide color gamut (WCG) imagery. It was developed by Dolby Laboratories from the IPT color space by Ebner and Fairchild. It was designed with the intention to replace YCbCr. Learn about ICtCp","title":"ICtCp"}]}