{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Setup Currently in Alpha While ColorAide is very usable, it is currently in an alpha stage. While that doesn't necessarily mean buggy, it does mean the API could be unstable. Overview ColorAide is a color library for Python with the intent to provide an easy to use interface to work with colors. While ColorAide is not just for CSS colors, there is a focus on supporting modern CSS color syntax as it is a format that is very commonly used. In addition to being able to parse almost all colors as specified in the CSS specification, ColorAide also supports a number of colors and formats for colors that are not in the CSS spec. ColorAide is built on the idea of having a general color object in which you can easily manipulate a color, convert between colors in different spaces, and perform color related functions: interpolation, color distancing, color contrast, etc. In the process of developing ColorAide, we also stumbled upon the JavaScript library Color.js which is created/maintained by the co-authors of some of the recent CSS color specifications. This project became heavily influenced by Color.js as it adopted a model we were already interested in. While our aim was not to port that library and be a 1:1 copy of it, it provided much clarity on the CSS specification and, in the end, left a clear impression on our API. With ColorAide, you can create colors: >>> from coloraide import Color >>> c = Color ( 'red' ) >>> c . to_string () rgb(255 0 0) from coloraide import Color c = Color('red') c.to_string() Edit Share Run Cancel Convert colors: >>> from coloraide import Color >>> Color ( 'red' ) . convert ( 'hsl' ) . to_string () hsl(0 100% 50%) from coloraide import Color Color('red').convert('hsl').to_string() Edit Share Run Cancel Modify colors: >>> from coloraide import Color >>> Color ( 'red' ) . set ( \"lch.chroma\" , 30 ) . to_string () rgb(173.81 114.28 97.213) from coloraide import Color Color('red').set(\"lch.chroma\", 30).to_string() Edit Share Run Cancel Mix colors: >>> from coloraide import Color >>> Color ( \"blue\" ) . mix ( \"yellow\" , space = \"lch\" ) . to_string () rgb(255 87.006 113.14) from coloraide import Color Color(\"blue\").mix(\"yellow\", space=\"lch\").to_string() Edit Share Run Cancel And much more! Installation ColorAide can be installed via Python's pip : $ pip install coloraide","title":"Setup"},{"location":"#setup","text":"Currently in Alpha While ColorAide is very usable, it is currently in an alpha stage. While that doesn't necessarily mean buggy, it does mean the API could be unstable.","title":"Setup"},{"location":"#overview","text":"ColorAide is a color library for Python with the intent to provide an easy to use interface to work with colors. While ColorAide is not just for CSS colors, there is a focus on supporting modern CSS color syntax as it is a format that is very commonly used. In addition to being able to parse almost all colors as specified in the CSS specification, ColorAide also supports a number of colors and formats for colors that are not in the CSS spec. ColorAide is built on the idea of having a general color object in which you can easily manipulate a color, convert between colors in different spaces, and perform color related functions: interpolation, color distancing, color contrast, etc. In the process of developing ColorAide, we also stumbled upon the JavaScript library Color.js which is created/maintained by the co-authors of some of the recent CSS color specifications. This project became heavily influenced by Color.js as it adopted a model we were already interested in. While our aim was not to port that library and be a 1:1 copy of it, it provided much clarity on the CSS specification and, in the end, left a clear impression on our API. With ColorAide, you can create colors: >>> from coloraide import Color >>> c = Color ( 'red' ) >>> c . to_string () rgb(255 0 0) from coloraide import Color c = Color('red') c.to_string() Edit Share Run Cancel Convert colors: >>> from coloraide import Color >>> Color ( 'red' ) . convert ( 'hsl' ) . to_string () hsl(0 100% 50%) from coloraide import Color Color('red').convert('hsl').to_string() Edit Share Run Cancel Modify colors: >>> from coloraide import Color >>> Color ( 'red' ) . set ( \"lch.chroma\" , 30 ) . to_string () rgb(173.81 114.28 97.213) from coloraide import Color Color('red').set(\"lch.chroma\", 30).to_string() Edit Share Run Cancel Mix colors: >>> from coloraide import Color >>> Color ( \"blue\" ) . mix ( \"yellow\" , space = \"lch\" ) . to_string () rgb(255 87.006 113.14) from coloraide import Color Color(\"blue\").mix(\"yellow\", space=\"lch\").to_string() Edit Share Run Cancel And much more!","title":"Overview"},{"location":"#installation","text":"ColorAide can be installed via Python's pip : $ pip install coloraide","title":"Installation"},{"location":"cat/","text":"Chromatic Adaptation Overview Chromatic adaptation is the human visual system's ability to adjust to changes in illumination in order to preserve the appearance of object colors. It is responsible for the stable appearance of object colors despite the wide variation of light which might be reflected from an object and observed by our eyes. A chromatic adaptation transform ( CAT ) function emulates this important aspect of color perception in color appearance models. In short, colors look different under different lights. Viewing a color in daylight will look different than viewing it by candle light. Color spaces usually define a reference illuminant that clarifies the assumed lighting for the given space. For instance, sRGB is a color space defined with an illuminant of D65 (light in the shade - no direct sunlight - at noon). On the other hand, the ProPhoto RGB space a uses D50 illuminant (direct sunlight at noon). A given color under one illuminant would look different under the other. Often, when converting a color to a new illuminant, it is desired to have the new color look the same as the first under the new illuminant. A CAT can predict what that corresponding color under the new illuminant would have to be in order to look the same as the original color under the original illuminant. When translating a color from one illuminant to another, it is often desirable to represent that color under the new illuminant such that it appears to the eye the same as it did under the original illuminant. CATs are used to predict what the new color under the new illuminant should be in order to fulfill these requirements. For a quick example, we can demonstrate the basic principle when translating a color in the XYZ color space from a D50 illuminant to a D65 illuminant. Below, we can see that the colors look pretty much the same, even though they are now described under different illuminants. >>> d50 = Color ( 'color(xyz 0.11627 0.07261 0.23256 / 1)' ) >>> d65 = d50 . convert ( 'xyz-d65' ) >>> d50 , d65 (color(xyz 0.11627 0.07261 0.23256 / 1), color(--xyz-d65 0.12413 0.07493 0.30933 / 1)) d50 = Color('color(xyz 0.11627 0.07261 0.23256 / 1)') d65 = d50.convert('xyz-d65') d50, d65 Edit Share Run Cancel Under the hood, this is using the Bradford CAT (ColorAide's default CAT ). Additionally, when translating from one color space to another, colors usually pass through an XYZ conversion as a common way point where a given CAT is applied. So we can actually do this manually and compare the results to what we did above. In order to this, we need to provide the specified \"white point\" for the source color and the \"white point\" for the destination color along with the XYZ coordinates we wish to transform: >>> from coloraide.color.convert import cat >>> Color ( 'color(xyz 0.11627 0.07261 0.23256 / 1)' ) . convert ( 'xyz-d65' ) . coords () [0.12412728550131341, 0.07493061731402743, 0.3093325898995686] >>> cat . chromatic_adaptation ( \"D50\" , \"D65\" , [ 0.11627 , 0.07261 , 0.23256 ], method = 'bradford' ) [0.12412728550131341, 0.07493061731402743, 0.3093325898995686] from coloraide.color.convert import cat Color('color(xyz 0.11627 0.07261 0.23256 / 1)').convert('xyz-d65').coords() cat.chromatic_adaptation(\"D50\", \"D65\", [0.11627, 0.07261, 0.23256], method='bradford') Edit Share Run Cancel Changing the Default CAT Changing the default CAT is easy and follows the same pattern as the rest of the available class overrides . Simply derive a new Color () class from the original and override the CHROMATIC_ADAPTATION property with the name of the desired CAT . Afterwards, all color transforms will use the specified CAT . >>> class Custom ( Color ): ... CHROMATIC_ADAPTATION = 'cat02' ... >>> d50 = Custom ( 'color(xyz 0.11627 0.07261 0.23256 / 1)' ) >>> d65 = d50 . convert ( 'xyz-d65' ) >>> d50 , d65 (color(xyz 0.11627 0.07261 0.23256 / 1), color(--xyz-d65 0.12476 0.07614 0.30581 / 1)) class Custom(Color): CHROMATIC_ADAPTATION = 'cat02' d50 = Custom('color(xyz 0.11627 0.07261 0.23256 / 1)') d65 = d50.convert('xyz-d65') d50, d65 Edit Share Run Cancel Supported CATs There are various CATs , all varying in complexity and accuracy. We will not go through all of them and instead will leave that up to the user to research as needed. Suffice it to say though that the Bradford CAT is currently the industry standard (in most cases), but there are a variety options available, and research continues to try and improve upon CATs of the past to come up with a better CAT for the future. Currently, ColorAide mainly supports von Kries type CATs (named after an early 20 th century color scientist), or CATs that are similar to and/or are built upon the original von Kries CAT . We also do not currently support every known von Kries CAT out there, but a good number are available. In the future, support may be expanded. CAT bradford von-kries xyz-scaling sharp cat02 cmccat97 cmccat2000","title":"Chromatic Adaptation"},{"location":"cat/#chromatic-adaptation","text":"","title":"Chromatic Adaptation"},{"location":"cat/#overview","text":"Chromatic adaptation is the human visual system's ability to adjust to changes in illumination in order to preserve the appearance of object colors. It is responsible for the stable appearance of object colors despite the wide variation of light which might be reflected from an object and observed by our eyes. A chromatic adaptation transform ( CAT ) function emulates this important aspect of color perception in color appearance models. In short, colors look different under different lights. Viewing a color in daylight will look different than viewing it by candle light. Color spaces usually define a reference illuminant that clarifies the assumed lighting for the given space. For instance, sRGB is a color space defined with an illuminant of D65 (light in the shade - no direct sunlight - at noon). On the other hand, the ProPhoto RGB space a uses D50 illuminant (direct sunlight at noon). A given color under one illuminant would look different under the other. Often, when converting a color to a new illuminant, it is desired to have the new color look the same as the first under the new illuminant. A CAT can predict what that corresponding color under the new illuminant would have to be in order to look the same as the original color under the original illuminant. When translating a color from one illuminant to another, it is often desirable to represent that color under the new illuminant such that it appears to the eye the same as it did under the original illuminant. CATs are used to predict what the new color under the new illuminant should be in order to fulfill these requirements. For a quick example, we can demonstrate the basic principle when translating a color in the XYZ color space from a D50 illuminant to a D65 illuminant. Below, we can see that the colors look pretty much the same, even though they are now described under different illuminants. >>> d50 = Color ( 'color(xyz 0.11627 0.07261 0.23256 / 1)' ) >>> d65 = d50 . convert ( 'xyz-d65' ) >>> d50 , d65 (color(xyz 0.11627 0.07261 0.23256 / 1), color(--xyz-d65 0.12413 0.07493 0.30933 / 1)) d50 = Color('color(xyz 0.11627 0.07261 0.23256 / 1)') d65 = d50.convert('xyz-d65') d50, d65 Edit Share Run Cancel Under the hood, this is using the Bradford CAT (ColorAide's default CAT ). Additionally, when translating from one color space to another, colors usually pass through an XYZ conversion as a common way point where a given CAT is applied. So we can actually do this manually and compare the results to what we did above. In order to this, we need to provide the specified \"white point\" for the source color and the \"white point\" for the destination color along with the XYZ coordinates we wish to transform: >>> from coloraide.color.convert import cat >>> Color ( 'color(xyz 0.11627 0.07261 0.23256 / 1)' ) . convert ( 'xyz-d65' ) . coords () [0.12412728550131341, 0.07493061731402743, 0.3093325898995686] >>> cat . chromatic_adaptation ( \"D50\" , \"D65\" , [ 0.11627 , 0.07261 , 0.23256 ], method = 'bradford' ) [0.12412728550131341, 0.07493061731402743, 0.3093325898995686] from coloraide.color.convert import cat Color('color(xyz 0.11627 0.07261 0.23256 / 1)').convert('xyz-d65').coords() cat.chromatic_adaptation(\"D50\", \"D65\", [0.11627, 0.07261, 0.23256], method='bradford') Edit Share Run Cancel","title":"Overview"},{"location":"cat/#changing-the-default-cat","text":"Changing the default CAT is easy and follows the same pattern as the rest of the available class overrides . Simply derive a new Color () class from the original and override the CHROMATIC_ADAPTATION property with the name of the desired CAT . Afterwards, all color transforms will use the specified CAT . >>> class Custom ( Color ): ... CHROMATIC_ADAPTATION = 'cat02' ... >>> d50 = Custom ( 'color(xyz 0.11627 0.07261 0.23256 / 1)' ) >>> d65 = d50 . convert ( 'xyz-d65' ) >>> d50 , d65 (color(xyz 0.11627 0.07261 0.23256 / 1), color(--xyz-d65 0.12476 0.07614 0.30581 / 1)) class Custom(Color): CHROMATIC_ADAPTATION = 'cat02' d50 = Custom('color(xyz 0.11627 0.07261 0.23256 / 1)') d65 = d50.convert('xyz-d65') d50, d65 Edit Share Run Cancel","title":"Changing the Default CAT"},{"location":"cat/#supported-cats","text":"There are various CATs , all varying in complexity and accuracy. We will not go through all of them and instead will leave that up to the user to research as needed. Suffice it to say though that the Bradford CAT is currently the industry standard (in most cases), but there are a variety options available, and research continues to try and improve upon CATs of the past to come up with a better CAT for the future. Currently, ColorAide mainly supports von Kries type CATs (named after an early 20 th century color scientist), or CATs that are similar to and/or are built upon the original von Kries CAT . We also do not currently support every known von Kries CAT out there, but a good number are available. In the future, support may be expanded. CAT bradford von-kries xyz-scaling sharp cat02 cmccat97 cmccat2000","title":"Supported CATs"},{"location":"color/","text":"The Color Object Creating Colors The Color object can be imported from coloraide . from coloraide import Color Afterwards, colors can be created using various, valid CSS syntax: >>> Color ( \"red\" ), (color(srgb 1 0 0 / 1),) >>> Color ( \"#00ff00\" ), (color(srgb 0 1 0 / 1),) >>> Color ( \"rgb(0 0 255 / 1)\" ) color(srgb 0 0 1 / 1) Color(\"red\"), Color(\"#00ff00\"), Color(\"rgb(0 0 255 / 1)\") Edit Share Run Cancel In general, each color space can be recognized using valid CSS syntax as specified in the CSS level 4 spec. Additionally, all colors are recognized using the CSS color function ( color ( space coord ... / alpha ) ), even if the color is not defined in the CSS color spec or supported in the spec in this way. While the color () function in CSS does not explicitly support color spaces with angular channels (hues), it has been adapted to support cylindrical colors, and is generally used as a generic input and default output for string representation of colors. Colors not found in the CSS spec are usually done as custom names with the -- prefix. Check the documentation of the given color space to discover the appropriate CSS identifier name. >>> Color ( 'color(--hsl 130 40 % 75% / 0.5)' ) color(--hsl 130 40% 75% / 0.5) Color('color(--hsl 130 40% 75% / 0.5)') Edit Share Run Cancel While CSS input is useful, we can also insert raw data points directly. When doing things this way, we must be mindful of the actual accepted input range. For instance, RGB colors are not specified in ranges from 0 - 255, but from 0 - 1. >>> Color ( \"srgb\" , [ 0.5 , 0 , 1 ], 0.3 ) color(srgb 0.5 0 1 / 0.3) Color(\"srgb\", [0.5, 0, 1], 0.3) Edit Share Run Cancel The name is usually just the name of the color space and will not necessarily match the CSS identifier name. For instance, HSL will use --hsl in the CSS color function, but will just use the hsl when specify raw colors. >>> Color ( 'color(--hsl 130 40 % 75% / 0.5)' ) color(--hsl 130 40% 75% / 0.5) >>> Color ( \"hsl\" , [ 130 , 40 , 75 ], 0.5 ) color(--hsl 130 40% 75% / 0.5) Color('color(--hsl 130 40% 75% / 0.5)') Color(\"hsl\", [130, 40, 75], 0.5) Edit Share Run Cancel It is important to note that raw inputs are always accepted exactly as they are specified. Take, for instance, an HSL color with zero saturation. When providing a color via a string, the color is parsed and normalized as appropriate. If we pass in an HSL color with zero saturation, the parsed string will treat the hue as undefined, while the raw input values remain unaltered. Raw inputs are essentially treated as if the user is directly setting those channels. >>> Color ( \"hsl(130 0 % 50% )\" ) color(--hsl 0 0% 50% / 1) >>> Color ( \"hsl\" , [ 130 , 0 , 50 ]) color(--hsl 130 0% 50% / 1) Color(\"hsl(130 0% 50%)\") Color(\"hsl\", [130, 0, 50]) Edit Share Run Cancel If another color instance is passed as the input, a new color will be created, essentially cloning the passed object. >>> c1 = Color ( 'red' ) >>> c2 = Color ( c1 ) >>> c1 , c2 (color(srgb 1 0 0 / 1), color(srgb 1 0 0 / 1)) c1 = Color('red') c2 = Color(c1) c1, c2 Edit Share Run Cancel You can also use the new method to generate new colors from already instantiated color objects. >>> color1 = Color ( \"red\" ) >>> color1 color(srgb 1 0 0 / 1) >>> color1 . new ( \"blue\" ) color(srgb 0 0 1 / 1) color1 = Color(\"red\") color1 color1.new(\"blue\") Edit Share Run Cancel If desired, all creation method can be configured to also filter out color spaces that we are not interested in by using the filter parameter and specifying only the color spaces we do care about. Valid colors will then be constrained only to those spaces in the list. >>> try : ... Color ( \"red\" , filters = [ \"hsl\" ]) ... except ValueError : ... print ( 'Not a valid color' ) ... Not a valid color >>> Color ( \"hsl(130 30 % 75% )\" , filters = [ \"hsl\" ]) color(--hsl 130 30% 75% / 1) try: Color(\"red\", filters=[\"hsl\"]) except ValueError: print('Not a valid color') Color(\"hsl(130 30% 75%)\", filters=[\"hsl\"]) Edit Share Run Cancel Cloning The clone method is an easy way to duplicate the current color object. Here we clone the green object so we have two. >>> c1 = Color ( \"green\" ) >>> c1 color(srgb 0 0.50196 0 / 1) >>> c1 . clone () color(srgb 0 0.50196 0 / 1) c1 = Color(\"green\") c1 c1.clone() Edit Share Run Cancel Updating A color can be \"updated\" using another color object. When an update occurs, the current color space is updated with the data from the second color, but the color space does not change. It is basically the equivalent of converting the second color to the color space of the first and then updating all the coordinates (including alpha). The input parameters are identical to the new method, so we can use a color object, a color string, or even raw data points. Here we update the color red to the color blue : >>> Color ( \"red\" ) color(srgb 1 0 0 / 1) >>> Color ( \"red\" ) . update ( Color ( \"blue\" )) color(srgb 0 0 1 / 1) Color(\"red\") Color(\"red\").update(Color(\"blue\")) Edit Share Run Cancel Here we update the sRGB red with the color lch ( 80 % 50 130 ) . >>> Color ( \"red\" ) . update ( \"lch(80% 50 130)\" ) color(srgb 0.60392 0.8398 0.48396 / 1) Color(\"red\").update(\"lch(80% 50 130)\") Edit Share Run Cancel Mutating \"Mutating\" is similar to updating except that it will update the color and the color space from another color. The input parameters are identical to the new method, so we can use a color object, a color string, or even raw data points. In this example, the red color object literally becomes the specified CIELCH color of lch ( 80 % 50 130 ) . >>> Color ( \"red\" ) . mutate ( \"lch(80% 50 130)\" ) color(--lch 80% 50 130 / 1) Color(\"red\").mutate(\"lch(80% 50 130)\") Edit Share Run Cancel Converting Colors can be converted to other color spaces as needed. Converting will always return a new color unless the in_place parameter is set to True , in which case, the current color will be mutated to the new converted color and a reference to itself is returned. For instance, if we had a color yellow , and we needed to work with it in another color space, such as CIELAB, we could simply call the convert method with the desired color space. >>> Color ( 'yellow' ) . convert ( \"lab\" ) color(--lab 97.607% -15.75 93.394 / 1) Color('yellow').convert(\"lab\") Edit Share Run Cancel Color Matching As previously mentioned, the Color () object can take in CSS style string inputs. The string matching logic is exposed via the match method. We can simply pass match a string, and, if the string is a valid color, a ColorMatch object will be returned. The ColorMatch object has a simple structure that contains the matched color as a Color object, and the start and end points it was located at. >>> Color . match ( \"red\" ) ColorMatch(color=color(srgb 1 0 0 / 1), start=0, end=3) Color.match(\"red\") Edit Share Run Cancel By default it matches at the start of the buffer and returns a color if it finds one. If desired, we can do a fullmatch which requires the entire buffer to match a color. >>> Color . match ( \"red and yellow\" ) ColorMatch(color=color(srgb 1 0 0 / 1), start=0, end=3) >>> Color . match ( \"red and yellow\" , fullmatch = True ) Color.match(\"red and yellow\") Color.match(\"red and yellow\", fullmatch=True) Edit Share Run Cancel We can also adjust the start position of the search. In this case, by adjusting the start position to 8 characters later, we will match yellow instead of red . >>> Color . match ( \"red and yellow\" , start = 8 ) ColorMatch(color=color(srgb 1 1 0 / 1), start=8, end=14) Color.match(\"red and yellow\", start=8) Edit Share Run Cancel Filtering unwanted color spaces is also available via the filter parameter, and is typically how creation methods avoid parsing unwanted color spaces. >>> Color . match ( \"red and yellow\" , filters = [ \"hsl\" ]) >>> Color . match ( \"hsl(130 30 % 75% )\" , filters = [ \"hsl\" ]) ColorMatch(color=color(--hsl 130 30% 75% / 1), start=0, end=16) Color.match(\"red and yellow\", filters=[\"hsl\"]) Color.match(\"hsl(130 30% 75%)\", filters=[\"hsl\"]) Edit Share Run Cancel A method to find all colors in a buffer is not currently provided as looping through all the color spaces and matching all potential colors on every character is not really efficient. Additionally, some buffers way require additional context that is not available to the to the match function. If such behavior is desired, what is recommended would be to apply this with some logic to find potential places in the buffer to test, and only test those places. In this example, we construct a regex to find places within the buffer that potentially has a valid color, but we also try and filter out cases that are unfavorable by providing additional context. As we are interested in matching full colors in HTML or CSS, we don't want to match hex in HTML entities or color names that are part of color variables ( var ( --color-red ) ). >>> import re >>> from coloraide import Color >>> RE_COLOR_START = re . compile ( r \"(?i)(?:\\b(?<![-#&$])(?:color\\((?!\\s*-)|(?:hsla?|lch|lab|hwb|rgba?)\\()|\\b(?<![-#&$])[\\w]{3,}(?![(-])\\b|(?<![&])#)\" ) >>> text = \"\"\" ... <html> ... <head> ... <style> ... body { ... background-color: red; ... color: yellow; ... } ... </style> ... </head> ... <body> ... <p>This is a test <span style=\"background-color: #000088; color: lch(75% 50 50)\">test</span></p> ... </body> ... </html> ... \"\"\" >>> colors = [] >>> for m in RE_COLOR_START . finditer ( text ): ... start = m . start () ... mcolor = Color . match ( text , start = start ) ... if mcolor is not None : ... colors . append ( mcolor . color ) ... >>> [ x . to_string () for x in colors ] ['rgb(255 0 0)', 'rgb(255 255 0)', 'rgb(0 0 136)', 'lch(75% 50 50)'] import re from coloraide import Color RE_COLOR_START = re.compile(r\"(?i)(?:\\b(?<![-#&$])(?:color\\((?!\\s*-)|(?:hsla?|lch|lab|hwb|rgba?)\\()|\\b(?<![-#&$])[\\w]{3,}(?![(-])\\b|(?<![&])#)\") text = \"\"\" <html> <head> <style> body { background-color: red; color: yellow; } </style> </head> <body> <p>This is a test <span style=\"background-color: #000088; color: lch(75% 50 50)\">test</span></p> </body> </html> \"\"\" colors = [] for m in RE_COLOR_START.finditer(text): start = m.start() mcolor = Color.match(text, start=start) if mcolor is not None: colors.append(mcolor.color) [x.to_string() for x in colors] Edit Share Run Cancel Override Default Settings ColorAide has a couple of default settings, such as the default precision for string outputs, default gamut mapping mode, etc. All of these options can be set on demand when calling certain functions, but when not explicitly set, the base class defaults are used. If needed, the defaults can be changed for an entire application or library. To do so, simply subclass the Color object and override the class defaults. The new derived class can be used throughout an application or library and will use the specified defaults. >>> class Color2 ( Color ): ... PRECISION = 3 ... >>> Color ( 'rgb(128.12345 0 128.12345)' ) . to_string () rgb(128.12 0 128.12) >>> Color2 ( 'rgb(128.12345 0 128.12345)' ) . to_string () rgb(128 0 128) class Color2(Color): PRECISION = 3 Color('rgb(128.12345 0 128.12345)').to_string() Color2('rgb(128.12345 0 128.12345)').to_string() Edit Share Run Cancel Properties Description FIT The default gamut mapping method used by the Color object. DELTA_E The default delta E algorithm used for gamut distancing calls internally. PRECISION The default precision for string outputs. CHROMATIC_ADAPTATION The default chromatic adaptation method (default is bradford ). See Chromatic Adaptation for more information.","title":"The Color Object"},{"location":"color/#the-color-object","text":"","title":"The Color Object"},{"location":"color/#creating-colors","text":"The Color object can be imported from coloraide . from coloraide import Color Afterwards, colors can be created using various, valid CSS syntax: >>> Color ( \"red\" ), (color(srgb 1 0 0 / 1),) >>> Color ( \"#00ff00\" ), (color(srgb 0 1 0 / 1),) >>> Color ( \"rgb(0 0 255 / 1)\" ) color(srgb 0 0 1 / 1) Color(\"red\"), Color(\"#00ff00\"), Color(\"rgb(0 0 255 / 1)\") Edit Share Run Cancel In general, each color space can be recognized using valid CSS syntax as specified in the CSS level 4 spec. Additionally, all colors are recognized using the CSS color function ( color ( space coord ... / alpha ) ), even if the color is not defined in the CSS color spec or supported in the spec in this way. While the color () function in CSS does not explicitly support color spaces with angular channels (hues), it has been adapted to support cylindrical colors, and is generally used as a generic input and default output for string representation of colors. Colors not found in the CSS spec are usually done as custom names with the -- prefix. Check the documentation of the given color space to discover the appropriate CSS identifier name. >>> Color ( 'color(--hsl 130 40 % 75% / 0.5)' ) color(--hsl 130 40% 75% / 0.5) Color('color(--hsl 130 40% 75% / 0.5)') Edit Share Run Cancel While CSS input is useful, we can also insert raw data points directly. When doing things this way, we must be mindful of the actual accepted input range. For instance, RGB colors are not specified in ranges from 0 - 255, but from 0 - 1. >>> Color ( \"srgb\" , [ 0.5 , 0 , 1 ], 0.3 ) color(srgb 0.5 0 1 / 0.3) Color(\"srgb\", [0.5, 0, 1], 0.3) Edit Share Run Cancel The name is usually just the name of the color space and will not necessarily match the CSS identifier name. For instance, HSL will use --hsl in the CSS color function, but will just use the hsl when specify raw colors. >>> Color ( 'color(--hsl 130 40 % 75% / 0.5)' ) color(--hsl 130 40% 75% / 0.5) >>> Color ( \"hsl\" , [ 130 , 40 , 75 ], 0.5 ) color(--hsl 130 40% 75% / 0.5) Color('color(--hsl 130 40% 75% / 0.5)') Color(\"hsl\", [130, 40, 75], 0.5) Edit Share Run Cancel It is important to note that raw inputs are always accepted exactly as they are specified. Take, for instance, an HSL color with zero saturation. When providing a color via a string, the color is parsed and normalized as appropriate. If we pass in an HSL color with zero saturation, the parsed string will treat the hue as undefined, while the raw input values remain unaltered. Raw inputs are essentially treated as if the user is directly setting those channels. >>> Color ( \"hsl(130 0 % 50% )\" ) color(--hsl 0 0% 50% / 1) >>> Color ( \"hsl\" , [ 130 , 0 , 50 ]) color(--hsl 130 0% 50% / 1) Color(\"hsl(130 0% 50%)\") Color(\"hsl\", [130, 0, 50]) Edit Share Run Cancel If another color instance is passed as the input, a new color will be created, essentially cloning the passed object. >>> c1 = Color ( 'red' ) >>> c2 = Color ( c1 ) >>> c1 , c2 (color(srgb 1 0 0 / 1), color(srgb 1 0 0 / 1)) c1 = Color('red') c2 = Color(c1) c1, c2 Edit Share Run Cancel You can also use the new method to generate new colors from already instantiated color objects. >>> color1 = Color ( \"red\" ) >>> color1 color(srgb 1 0 0 / 1) >>> color1 . new ( \"blue\" ) color(srgb 0 0 1 / 1) color1 = Color(\"red\") color1 color1.new(\"blue\") Edit Share Run Cancel If desired, all creation method can be configured to also filter out color spaces that we are not interested in by using the filter parameter and specifying only the color spaces we do care about. Valid colors will then be constrained only to those spaces in the list. >>> try : ... Color ( \"red\" , filters = [ \"hsl\" ]) ... except ValueError : ... print ( 'Not a valid color' ) ... Not a valid color >>> Color ( \"hsl(130 30 % 75% )\" , filters = [ \"hsl\" ]) color(--hsl 130 30% 75% / 1) try: Color(\"red\", filters=[\"hsl\"]) except ValueError: print('Not a valid color') Color(\"hsl(130 30% 75%)\", filters=[\"hsl\"]) Edit Share Run Cancel","title":"Creating Colors"},{"location":"color/#cloning","text":"The clone method is an easy way to duplicate the current color object. Here we clone the green object so we have two. >>> c1 = Color ( \"green\" ) >>> c1 color(srgb 0 0.50196 0 / 1) >>> c1 . clone () color(srgb 0 0.50196 0 / 1) c1 = Color(\"green\") c1 c1.clone() Edit Share Run Cancel","title":"Cloning"},{"location":"color/#updating","text":"A color can be \"updated\" using another color object. When an update occurs, the current color space is updated with the data from the second color, but the color space does not change. It is basically the equivalent of converting the second color to the color space of the first and then updating all the coordinates (including alpha). The input parameters are identical to the new method, so we can use a color object, a color string, or even raw data points. Here we update the color red to the color blue : >>> Color ( \"red\" ) color(srgb 1 0 0 / 1) >>> Color ( \"red\" ) . update ( Color ( \"blue\" )) color(srgb 0 0 1 / 1) Color(\"red\") Color(\"red\").update(Color(\"blue\")) Edit Share Run Cancel Here we update the sRGB red with the color lch ( 80 % 50 130 ) . >>> Color ( \"red\" ) . update ( \"lch(80% 50 130)\" ) color(srgb 0.60392 0.8398 0.48396 / 1) Color(\"red\").update(\"lch(80% 50 130)\") Edit Share Run Cancel","title":"Updating"},{"location":"color/#mutating","text":"\"Mutating\" is similar to updating except that it will update the color and the color space from another color. The input parameters are identical to the new method, so we can use a color object, a color string, or even raw data points. In this example, the red color object literally becomes the specified CIELCH color of lch ( 80 % 50 130 ) . >>> Color ( \"red\" ) . mutate ( \"lch(80% 50 130)\" ) color(--lch 80% 50 130 / 1) Color(\"red\").mutate(\"lch(80% 50 130)\") Edit Share Run Cancel","title":"Mutating"},{"location":"color/#converting","text":"Colors can be converted to other color spaces as needed. Converting will always return a new color unless the in_place parameter is set to True , in which case, the current color will be mutated to the new converted color and a reference to itself is returned. For instance, if we had a color yellow , and we needed to work with it in another color space, such as CIELAB, we could simply call the convert method with the desired color space. >>> Color ( 'yellow' ) . convert ( \"lab\" ) color(--lab 97.607% -15.75 93.394 / 1) Color('yellow').convert(\"lab\") Edit Share Run Cancel","title":"Converting"},{"location":"color/#color-matching","text":"As previously mentioned, the Color () object can take in CSS style string inputs. The string matching logic is exposed via the match method. We can simply pass match a string, and, if the string is a valid color, a ColorMatch object will be returned. The ColorMatch object has a simple structure that contains the matched color as a Color object, and the start and end points it was located at. >>> Color . match ( \"red\" ) ColorMatch(color=color(srgb 1 0 0 / 1), start=0, end=3) Color.match(\"red\") Edit Share Run Cancel By default it matches at the start of the buffer and returns a color if it finds one. If desired, we can do a fullmatch which requires the entire buffer to match a color. >>> Color . match ( \"red and yellow\" ) ColorMatch(color=color(srgb 1 0 0 / 1), start=0, end=3) >>> Color . match ( \"red and yellow\" , fullmatch = True ) Color.match(\"red and yellow\") Color.match(\"red and yellow\", fullmatch=True) Edit Share Run Cancel We can also adjust the start position of the search. In this case, by adjusting the start position to 8 characters later, we will match yellow instead of red . >>> Color . match ( \"red and yellow\" , start = 8 ) ColorMatch(color=color(srgb 1 1 0 / 1), start=8, end=14) Color.match(\"red and yellow\", start=8) Edit Share Run Cancel Filtering unwanted color spaces is also available via the filter parameter, and is typically how creation methods avoid parsing unwanted color spaces. >>> Color . match ( \"red and yellow\" , filters = [ \"hsl\" ]) >>> Color . match ( \"hsl(130 30 % 75% )\" , filters = [ \"hsl\" ]) ColorMatch(color=color(--hsl 130 30% 75% / 1), start=0, end=16) Color.match(\"red and yellow\", filters=[\"hsl\"]) Color.match(\"hsl(130 30% 75%)\", filters=[\"hsl\"]) Edit Share Run Cancel A method to find all colors in a buffer is not currently provided as looping through all the color spaces and matching all potential colors on every character is not really efficient. Additionally, some buffers way require additional context that is not available to the to the match function. If such behavior is desired, what is recommended would be to apply this with some logic to find potential places in the buffer to test, and only test those places. In this example, we construct a regex to find places within the buffer that potentially has a valid color, but we also try and filter out cases that are unfavorable by providing additional context. As we are interested in matching full colors in HTML or CSS, we don't want to match hex in HTML entities or color names that are part of color variables ( var ( --color-red ) ). >>> import re >>> from coloraide import Color >>> RE_COLOR_START = re . compile ( r \"(?i)(?:\\b(?<![-#&$])(?:color\\((?!\\s*-)|(?:hsla?|lch|lab|hwb|rgba?)\\()|\\b(?<![-#&$])[\\w]{3,}(?![(-])\\b|(?<![&])#)\" ) >>> text = \"\"\" ... <html> ... <head> ... <style> ... body { ... background-color: red; ... color: yellow; ... } ... </style> ... </head> ... <body> ... <p>This is a test <span style=\"background-color: #000088; color: lch(75% 50 50)\">test</span></p> ... </body> ... </html> ... \"\"\" >>> colors = [] >>> for m in RE_COLOR_START . finditer ( text ): ... start = m . start () ... mcolor = Color . match ( text , start = start ) ... if mcolor is not None : ... colors . append ( mcolor . color ) ... >>> [ x . to_string () for x in colors ] ['rgb(255 0 0)', 'rgb(255 255 0)', 'rgb(0 0 136)', 'lch(75% 50 50)'] import re from coloraide import Color RE_COLOR_START = re.compile(r\"(?i)(?:\\b(?<![-#&$])(?:color\\((?!\\s*-)|(?:hsla?|lch|lab|hwb|rgba?)\\()|\\b(?<![-#&$])[\\w]{3,}(?![(-])\\b|(?<![&])#)\") text = \"\"\" <html> <head> <style> body { background-color: red; color: yellow; } </style> </head> <body> <p>This is a test <span style=\"background-color: #000088; color: lch(75% 50 50)\">test</span></p> </body> </html> \"\"\" colors = [] for m in RE_COLOR_START.finditer(text): start = m.start() mcolor = Color.match(text, start=start) if mcolor is not None: colors.append(mcolor.color) [x.to_string() for x in colors] Edit Share Run Cancel","title":"Color Matching"},{"location":"color/#override-default-settings","text":"ColorAide has a couple of default settings, such as the default precision for string outputs, default gamut mapping mode, etc. All of these options can be set on demand when calling certain functions, but when not explicitly set, the base class defaults are used. If needed, the defaults can be changed for an entire application or library. To do so, simply subclass the Color object and override the class defaults. The new derived class can be used throughout an application or library and will use the specified defaults. >>> class Color2 ( Color ): ... PRECISION = 3 ... >>> Color ( 'rgb(128.12345 0 128.12345)' ) . to_string () rgb(128.12 0 128.12) >>> Color2 ( 'rgb(128.12345 0 128.12345)' ) . to_string () rgb(128 0 128) class Color2(Color): PRECISION = 3 Color('rgb(128.12345 0 128.12345)').to_string() Color2('rgb(128.12345 0 128.12345)').to_string() Edit Share Run Cancel Properties Description FIT The default gamut mapping method used by the Color object. DELTA_E The default delta E algorithm used for gamut distancing calls internally. PRECISION The default precision for string outputs. CHROMATIC_ADAPTATION The default chromatic adaptation method (default is bradford ). See Chromatic Adaptation for more information.","title":"Override Default Settings"},{"location":"compositing/","text":"Compositing and Blending Compositing Alpha compositing and blending are tied together under the umbrella of compositing. Each is just an aspect of the overall compositing of colors. Blend is run first, followed by alpha compositing. ColorAide implements both alpha compositing and blending as described in the Compositing and Blending Level 1 specification. Alpha composting is based on Porter Duff compositing . By default, the compose method uses the normal blend mode and the source-over Porter Duff operator. Blending Blending is the aspect of compositing that calculates the mixing of colors where the source element and backdrop overlap. Conceptually, the colors in the source element (top layer) are blended in place with the backdrop (bottom layer). There are various blend modes, the most common is the normal blend mode which is the default blending mode for browsers when a layer is placed over another layer. The normal mode simply returns the top layer's color when two are overlaid. Some weighting of colors can occur if the top layer is semi-transparent. But there are many blend modes that could be used, all of which yield different results. If we were to apply a multiply blend mode, we would get something very different: When composing, the blend mode can be controlled separately in ColorAide. Here, we again use the multiply example and replicate it in ColorAide. Display Differences As some browsers apply compositing based on the display's current color space, we've provided examples in both sRGB and Display P3 so that the examples can be compared on different displays. Which of the below matches your browser? Display P3 >>> Color ( '#07c7ed' ) . compose ( '#fc3d99' , blend = 'multiply' , space = \"display-p3\" ) color(srgb 0.33867 0.23261 0.55966 / 1) Color('#07c7ed').compose('#fc3d99', blend='multiply', space=\"display-p3\") Edit Share Run Cancel sRGB >>> Color ( '#07c7ed' ) . compose ( '#fc3d99' , blend = 'multiply' , space = \"srgb\" ) color(srgb 0.02713 0.18668 0.55765 / 1) Color('#07c7ed').compose('#fc3d99', blend='multiply', space=\"srgb\") Edit Share Run Cancel You can even blend multiple colors. Simply send in a list, and the colors will be blended from right to left with the right most color being on the bottom of the stack, and the base color being on the very top. Display P3 >>> Color ( '#07c7ed' ) . compose ([ '#fc3d99' , '#f5d311' ], blend = 'multiply' , space = \"display-p3\" ) color(srgb 0.32151 0.19137 0.14794 / 1) Color('#07c7ed').compose(['#fc3d99', '#f5d311'], blend='multiply', space=\"display-p3\") Edit Share Run Cancel sRGB >>> Color ( '#07c7ed' ) . compose ([ '#fc3d99' , '#f5d311' ], blend = 'multiply' , space = \"srgb\" ) color(srgb 0.02606 0.15447 0.03718 / 1) Color('#07c7ed').compose(['#fc3d99', '#f5d311'], blend='multiply', space=\"srgb\") Edit Share Run Cancel Lastly, if for any reason, it is desired to compose with blending disabled (e.g. just run alpha compositing), then you can simply set operator to False . multiply is just one of many blend modes that are offered in ColorAide, check out Blend Modes to learn about other blend modes. Alpha Compositing Alpha compositing or alpha blending is the process of combining one image with a background to create the appearance of partial or full transparency. When dealing with layers, there are many possible ways to handle them: Porter Duff compositing covers all possible configurations of layers. Many of these configurations can be useful for all sorts of operations, such as masking. While this library supports all of them , the most commonly used one is source-over which is used to implement simple alpha compositing to simulate semi-transparent layers on top of each other. Given two colors, ColorAide can replicate this behavior and determine the resultant color by applying compositing. We will use the demonstration above and replicate the result in the example below. Below we set the source color to rgb ( 7 199 237 / 0 . 5 ) and the backdrop color to # fc3d99 and run it through the compose method. Display Differences As some browsers apply compositing based on the display's current color space, we've provided examples in both sRGB and Display P3 so that the examples can be compared on different displays. Which of the below matches your browser? Display P3 >>> Color ( '#07c7ed' ) . set ( 'alpha' , 0.5 ) . compose ( '#fc3d99' , space = \"display-p3\" ) color(srgb 0.65142 0.53412 0.76833 / 1) Color('#07c7ed').set('alpha', 0.5).compose('#fc3d99', space=\"display-p3\") Edit Share Run Cancel sRGB >>> Color ( '#07c7ed' ) . set ( 'alpha' , 0.5 ) . compose ( '#fc3d99' , space = \"srgb\" ) color(srgb 0.50784 0.5098 0.76471 / 1) Color('#07c7ed').set('alpha', 0.5).compose('#fc3d99', space=\"srgb\") Edit Share Run Cancel While the average user will be content with the default alpha compositing, Porter Duff offers many other configurations. If desired, we can change the Porter Duff operator used and apply different composite logic. For instance, in this case we can get the resultant of the backdrop over the source color by setting the operator to destination-over . As the backdrop is fully opaque, we just get the backdrop color unaltered. Display P3 >>> Color ( '#07c7ed' ) . set ( 'alpha' , 0.5 ) . compose ( '#fc3d99' , operator = 'destination-over' , space = \"display-p3\" ) color(srgb 0.98824 0.23922 0.6 / 1) Color('#07c7ed').set('alpha', 0.5).compose('#fc3d99', operator='destination-over', space=\"display-p3\") Edit Share Run Cancel sRGB >>> Color ( '#07c7ed' ) . set ( 'alpha' , 0.5 ) . compose ( '#fc3d99' , operator = 'destination-over' , space = \"srgb\" ) color(srgb 0.98824 0.23922 0.6 / 1) Color('#07c7ed').set('alpha', 0.5).compose('#fc3d99', operator='destination-over', space=\"srgb\") Edit Share Run Cancel You can also apply alpha compositing to multiple layers at once. Simply send in a list, and the colors will be composed from right to left with the right most color being on the bottom of the stack and the base color being on the very top. Here we are using the normal blend mode and 50% transparency on all the circles with an opaque white background. We will calculate the center color where all three layers overlap. Display P3 >>> Color ( '#07c7ed' ) . set ( 'alpha' , 0.5 ) . compose ( ... [ Color ( '#fc3d99' ) . set ( 'alpha' , 0.5 ), Color ( '#f5d311' ) . set ( 'alpha' , 0.5 ), 'white' ], ... blend = 'normal' , ... space = \"display-p3\" ... ) color(srgb 0.63703 0.69225 0.77313 / 1) Color('#07c7ed').set('alpha', 0.5).compose( [Color('#fc3d99').set('alpha', 0.5), Color('#f5d311').set('alpha', 0.5), 'white'], blend='normal', space=\"display-p3\" ) Edit Share Run Cancel sRGB >>> Color ( '#07c7ed' ) . set ( 'alpha' , 0.5 ) . compose ( ... [ Color ( '#fc3d99' ) . set ( 'alpha' , 0.5 ), Color ( '#f5d311' ) . set ( 'alpha' , 0.5 ), 'white' ], ... blend = 'normal' , ... space = \"srgb\" ... ) color(srgb 0.50588 0.67843 0.74804 / 1) Color('#07c7ed').set('alpha', 0.5).compose( [Color('#fc3d99').set('alpha', 0.5), Color('#f5d311').set('alpha', 0.5), 'white'], blend='normal', space=\"srgb\" ) Edit Share Run Cancel Lastly, if for any reason, it is desired to run compose with alpha compositing disabled (e.g. just run blending), then you can simply set operator to False . Check out Compositing Operators to learn about the many variations that are supported. Complex Compositing We've covered alpha compositing and blending and have demonstrated their use with simple two color examples and multi-layered examples layers, but what about different blend modes mixed with alpha compositing? In this example, we will consider three circles, each with a unique color: # 07c7ed , # fc3d99 , and # f5d311 . We apply 50% transparency to all the circles and place them on a white background. We then perform a multiply blend on all the circles but isolate them so the multiply blend does not apply to the background. The circles are all represented with CSS. We will now try and replicate the colors with ColorAide. So in the code below, we work our way from the bottom of the stack to the top. Since the background is isolated from the multiply blending, in each region, we start by performing a normal blend on the bottom circle against the background. We then apply multiply blending on each color that is stacked on top. We've provided both the P3 and sRGB outputs to make it easy to compare in case your browser blends in one instead of the other. Display P3 >>> c1 = Color ( '#07c7ed' ) . set ( 'alpha' , 0.5 ) >>> c2 = Color ( '#fc3d99' ) . set ( 'alpha' , 0.5 ) >>> c3 = Color ( '#f5d311' ) . set ( 'alpha' , 0.5 ) >>> cw2 = c2 . compose ( 'white' , blend = 'normal' , space = 'display-p3' ) >>> cw3 = c3 . compose ( 'white' , blend = 'normal' , space = 'display-p3' ) >>> r1 = c2 . compose ( cw3 , blend = 'multiply' , space = 'display-p3' ) >>> r2 = c1 . compose ( cw2 , blend = 'multiply' , space = 'display-p3' ) >>> r3 = c1 . compose ( cw3 , blend = 'multiply' , space = 'display-p3' ) >>> r1 , r2 , r3 (color(srgb 0.98122 0.58007 0.49257 / 1), color(srgb 0.66117 0.57542 0.77558 / 1), color(srgb 0.61489 0.8159 0.59659 / 1)) >>> c1 . compose ([ c2 , cw3 ], blend = 'multiply' , space = 'display-p3' ) color(srgb 0.64659 0.52543 0.48429 / 1) c1 = Color('#07c7ed').set('alpha', 0.5) c2 = Color('#fc3d99').set('alpha', 0.5) c3 = Color('#f5d311').set('alpha', 0.5) cw2 = c2.compose('white', blend='normal', space='display-p3') cw3 = c3.compose('white', blend='normal', space='display-p3') r1 = c2.compose(cw3, blend='multiply', space='display-p3') r2 = c1.compose(cw2, blend='multiply', space='display-p3') r3 = c1.compose(cw3, blend='multiply', space='display-p3') r1, r2, r3 c1.compose([c2, cw3], blend='multiply', space='display-p3') Edit Share Run Cancel sRGB >>> c1 = Color ( '#07c7ed' ) . set ( 'alpha' , 0.5 ) >>> c2 = Color ( '#fc3d99' ) . set ( 'alpha' , 0.5 ) >>> c3 = Color ( '#f5d311' ) . set ( 'alpha' , 0.5 ) >>> cw2 = c2 . compose ( 'white' , blend = 'normal' , space = 'srgb' ) >>> cw3 = c3 . compose ( 'white' , blend = 'normal' , space = 'srgb' ) >>> r1 = c2 . compose ( cw3 , blend = 'multiply' , space = 'srgb' ) >>> r2 = c1 . compose ( cw2 , blend = 'multiply' , space = 'srgb' ) >>> r3 = c1 . compose ( cw3 , blend = 'multiply' , space = 'srgb' ) >>> r1 , r2 , r3 (color(srgb 0.97463 0.56615 0.42667 / 1), color(srgb 0.5107 0.55157 0.77176 / 1), color(srgb 0.50365 0.81339 0.51451 / 1)) >>> c1 . compose ([ c2 , cw3 ], blend = 'multiply' , space = 'srgb' ) color(srgb 0.50069 0.50399 0.41161 / 1) c1 = Color('#07c7ed').set('alpha', 0.5) c2 = Color('#fc3d99').set('alpha', 0.5) c3 = Color('#f5d311').set('alpha', 0.5) cw2 = c2.compose('white', blend='normal', space='srgb') cw3 = c3.compose('white', blend='normal', space='srgb') r1 = c2.compose(cw3, blend='multiply', space='srgb') r2 = c1.compose(cw2, blend='multiply', space='srgb') r3 = c1.compose(cw3, blend='multiply', space='srgb') r1, r2, r3 c1.compose([c2, cw3], blend='multiply', space='srgb') Edit Share Run Cancel Results may vary depending on the browser, but we can see (ignoring rounding differences) that the colors match up. This was performed on Chrome in macOS using a display that uses display-p3 . Blend Modes Normal The blending formula simply selects the source color. Specified as 'normal' . Multiply The source color is multiplied by the destination color and replaces the destination. The resultant color is always at least as dark as either the source or destination color. Multiplying any color with black results in black. Multiplying any color with white preserves the original color. Specified as 'multiply' . Screen Multiplies the complements of the backdrop and source color values, then complements the result. The result color is always at least as light as either of the two constituent colors. Screening any color with white produces white; screening with black leaves the original color unchanged. The effect is similar to projecting multiple photographic slides simultaneously onto a single screen. Specified as 'screen' . Overlay Multiplies or screens the colors, depending on the backdrop color value. Source colors overlay the backdrop while preserving its highlights and shadows. The backdrop color is not replaced but is mixed with the source color to reflect the lightness or darkness of the backdrop. Specified as 'overlay' . Darken Selects the darker of the backdrop and source colors. The backdrop is replaced with the source where the source is darker; otherwise, it is left unchanged. Specified as 'darken' . Lighten Selects the lighter of the backdrop and source colors. The backdrop is replaced with the source where the source is lighter; otherwise, it is left unchanged. Specified as 'lighten' . Color Dodge Brightens the backdrop color to reflect the source color. Painting with black produces no changes. Specified as 'color-dodge' . Color Burn Darkens the backdrop color to reflect the source color. Painting with white produces no change. Specified as 'color-burn' . Hard Light Multiplies or screens the colors, depending on the source color value. The effect is similar to shining a harsh spotlight on the backdrop. Specified as 'hard-light' . Soft Light Darkens or lightens the colors, depending on the source color value. The effect is similar to shining a diffused spotlight on the backdrop. Specified as 'soft-light' . Difference Subtracts the darker of the two constituent colors from the lighter color. Painting with white inverts the backdrop color; painting with black produces no change. Specified as 'difference' . Exclusion Produces an effect similar to that of the Difference mode but lower in contrast. Painting with white inverts the backdrop color; painting with black produces no change. Specified as 'exclusion' . Hue Creates a color with the hue of the source color and the saturation and luminosity of the backdrop color. Specified as 'hue' . Saturation Creates a color with the saturation of the source color and the hue and luminosity of the backdrop color. Painting with this mode in an area of the backdrop that is a pure gray (no saturation) produces no change. Specified as 'saturation' . Luminosity Creates a color with the luminosity of the source color and the hue and saturation of the backdrop color. This produces an inverse effect to that of the Color mode. This mode is the one you can use to create monochrome \"tinted\" image effects like the ones you can see in different website headers. Specified as 'luminosity' . Color Creates a color with the hue and saturation of the source color and the luminosity of the backdrop color. This preserves the gray levels of the backdrop and is useful for coloring monochrome images or tinting color images. Specified as 'color' . Compositing Operators Clear No regions are enabled. Specified as 'clear' . Copy Only the source will be present. Specified as 'copy' . Destination Only the destination will be present. Specified as 'destination' . Source Over Source is placed over the destination. Specified as 'source-over' . Destination Over Destination is placed over the source. Specified as 'destination-over' . Source In The source that overlaps the destination, replaces the destination. Specified as 'source-in' . Destination In Destination which overlaps the source, replaces the source. Specified as 'destination-in' . Source Out Source is placed, where it falls outside of the destination. Specified as 'source-out' . Destination Out Destination is placed, where it falls outside of the source. Specified as 'destination-out' . Source Atop Source which overlaps the destination, replaces the destination. Destination is placed elsewhere. Specified as 'source-atop' . Destination Atop Destination which overlaps the source replaces the source. Source is placed elsewhere. Specified as 'destination-atop' . XOR Destination which overlaps the source replaces the source. Source is placed elsewhere. Specified as 'xor' . Lighter Display the sum of the source image and destination image. Specified as 'lighter' . img { background: white; } .circle { display: block; width: 80px; height: 80px; border-radius: 50%; position: absolute; transition: all 0.5s ease; z-index: 10; } .isolate label { position: absolute; bottom: 0; width: 100%; text-align: center; } .circle-1 { background: #f5d311; } .dual .circle-1 { background: #fc3d99; } .isolate:not(.dual):hover .circle-1 { transform: translateX(-10px) translateY(-7.5px); } .isolate.dual:hover .circle-1 { transform: translateX(-10px); } .circle-2 { background: #fc3d99; left: 40px; } .dual .circle-2 { background: #07c7ed; } .isolate:not(.dual):hover .circle-2 { transform: translateX(10px) translateY(-7.5px); } .isolate.dual:hover .circle-2 { transform: translateX(20px); } .circle-3 { background: #07c7ed; left: 20px; top: 40px; } .isolate:not(.dual):hover .circle-3 { transform: translateY(7.5px); } .isolate { display: block; height: 120px; width: 120px; isolation: isolate; position: relative; margin: 0 10px; } .isolate.dual { height: 80px; } div.blend-wrap { display: flex; min-height: calc(120px + 0.8em); width: 100%; } div.blend-wrap > :not(.blend-content) { order: 0; } div.blend-wrap .isolate { margin-top: 0.8em; } div.blend-wrap > .blend-content { order: 1; } .blend-normal .circle { mix-blend-mode: normal; } .blend-multiply .circle { mix-blend-mode: multiply; } .blend-screen .circle { mix-blend-mode: screen; } .blend-overlay .circle { mix-blend-mode: overlay; } .blend-color-burn .circle { mix-blend-mode: color-burn; } .blend-color-dodge .circle { mix-blend-mode: color-dodge; } .blend-exclusion .circle { mix-blend-mode: exclusion; } .blend-difference .circle { mix-blend-mode: difference; } .blend-darken .circle { mix-blend-mode: darken; } .blend-lighten .circle { mix-blend-mode: lighten; } .blend-soft-light .circle { mix-blend-mode: soft-light; } .blend-hard-light .circle { mix-blend-mode: hard-light; } .blend-hue .circle { mix-blend-mode: hue; } .blend-saturation .circle { mix-blend-mode: saturation; } .blend-luminosity .circle { mix-blend-mode: luminosity; } .blend-color .circle { mix-blend-mode: color; }","title":"Compositing and Blending"},{"location":"compositing/#compositing-and-blending","text":"","title":"Compositing and Blending"},{"location":"compositing/#compositing","text":"Alpha compositing and blending are tied together under the umbrella of compositing. Each is just an aspect of the overall compositing of colors. Blend is run first, followed by alpha compositing. ColorAide implements both alpha compositing and blending as described in the Compositing and Blending Level 1 specification. Alpha composting is based on Porter Duff compositing . By default, the compose method uses the normal blend mode and the source-over Porter Duff operator.","title":"Compositing"},{"location":"compositing/#blending","text":"Blending is the aspect of compositing that calculates the mixing of colors where the source element and backdrop overlap. Conceptually, the colors in the source element (top layer) are blended in place with the backdrop (bottom layer). There are various blend modes, the most common is the normal blend mode which is the default blending mode for browsers when a layer is placed over another layer. The normal mode simply returns the top layer's color when two are overlaid. Some weighting of colors can occur if the top layer is semi-transparent. But there are many blend modes that could be used, all of which yield different results. If we were to apply a multiply blend mode, we would get something very different: When composing, the blend mode can be controlled separately in ColorAide. Here, we again use the multiply example and replicate it in ColorAide. Display Differences As some browsers apply compositing based on the display's current color space, we've provided examples in both sRGB and Display P3 so that the examples can be compared on different displays. Which of the below matches your browser? Display P3 >>> Color ( '#07c7ed' ) . compose ( '#fc3d99' , blend = 'multiply' , space = \"display-p3\" ) color(srgb 0.33867 0.23261 0.55966 / 1) Color('#07c7ed').compose('#fc3d99', blend='multiply', space=\"display-p3\") Edit Share Run Cancel sRGB >>> Color ( '#07c7ed' ) . compose ( '#fc3d99' , blend = 'multiply' , space = \"srgb\" ) color(srgb 0.02713 0.18668 0.55765 / 1) Color('#07c7ed').compose('#fc3d99', blend='multiply', space=\"srgb\") Edit Share Run Cancel You can even blend multiple colors. Simply send in a list, and the colors will be blended from right to left with the right most color being on the bottom of the stack, and the base color being on the very top. Display P3 >>> Color ( '#07c7ed' ) . compose ([ '#fc3d99' , '#f5d311' ], blend = 'multiply' , space = \"display-p3\" ) color(srgb 0.32151 0.19137 0.14794 / 1) Color('#07c7ed').compose(['#fc3d99', '#f5d311'], blend='multiply', space=\"display-p3\") Edit Share Run Cancel sRGB >>> Color ( '#07c7ed' ) . compose ([ '#fc3d99' , '#f5d311' ], blend = 'multiply' , space = \"srgb\" ) color(srgb 0.02606 0.15447 0.03718 / 1) Color('#07c7ed').compose(['#fc3d99', '#f5d311'], blend='multiply', space=\"srgb\") Edit Share Run Cancel Lastly, if for any reason, it is desired to compose with blending disabled (e.g. just run alpha compositing), then you can simply set operator to False . multiply is just one of many blend modes that are offered in ColorAide, check out Blend Modes to learn about other blend modes.","title":"Blending"},{"location":"compositing/#alpha-compositing","text":"Alpha compositing or alpha blending is the process of combining one image with a background to create the appearance of partial or full transparency. When dealing with layers, there are many possible ways to handle them: Porter Duff compositing covers all possible configurations of layers. Many of these configurations can be useful for all sorts of operations, such as masking. While this library supports all of them , the most commonly used one is source-over which is used to implement simple alpha compositing to simulate semi-transparent layers on top of each other. Given two colors, ColorAide can replicate this behavior and determine the resultant color by applying compositing. We will use the demonstration above and replicate the result in the example below. Below we set the source color to rgb ( 7 199 237 / 0 . 5 ) and the backdrop color to # fc3d99 and run it through the compose method. Display Differences As some browsers apply compositing based on the display's current color space, we've provided examples in both sRGB and Display P3 so that the examples can be compared on different displays. Which of the below matches your browser? Display P3 >>> Color ( '#07c7ed' ) . set ( 'alpha' , 0.5 ) . compose ( '#fc3d99' , space = \"display-p3\" ) color(srgb 0.65142 0.53412 0.76833 / 1) Color('#07c7ed').set('alpha', 0.5).compose('#fc3d99', space=\"display-p3\") Edit Share Run Cancel sRGB >>> Color ( '#07c7ed' ) . set ( 'alpha' , 0.5 ) . compose ( '#fc3d99' , space = \"srgb\" ) color(srgb 0.50784 0.5098 0.76471 / 1) Color('#07c7ed').set('alpha', 0.5).compose('#fc3d99', space=\"srgb\") Edit Share Run Cancel While the average user will be content with the default alpha compositing, Porter Duff offers many other configurations. If desired, we can change the Porter Duff operator used and apply different composite logic. For instance, in this case we can get the resultant of the backdrop over the source color by setting the operator to destination-over . As the backdrop is fully opaque, we just get the backdrop color unaltered. Display P3 >>> Color ( '#07c7ed' ) . set ( 'alpha' , 0.5 ) . compose ( '#fc3d99' , operator = 'destination-over' , space = \"display-p3\" ) color(srgb 0.98824 0.23922 0.6 / 1) Color('#07c7ed').set('alpha', 0.5).compose('#fc3d99', operator='destination-over', space=\"display-p3\") Edit Share Run Cancel sRGB >>> Color ( '#07c7ed' ) . set ( 'alpha' , 0.5 ) . compose ( '#fc3d99' , operator = 'destination-over' , space = \"srgb\" ) color(srgb 0.98824 0.23922 0.6 / 1) Color('#07c7ed').set('alpha', 0.5).compose('#fc3d99', operator='destination-over', space=\"srgb\") Edit Share Run Cancel You can also apply alpha compositing to multiple layers at once. Simply send in a list, and the colors will be composed from right to left with the right most color being on the bottom of the stack and the base color being on the very top. Here we are using the normal blend mode and 50% transparency on all the circles with an opaque white background. We will calculate the center color where all three layers overlap. Display P3 >>> Color ( '#07c7ed' ) . set ( 'alpha' , 0.5 ) . compose ( ... [ Color ( '#fc3d99' ) . set ( 'alpha' , 0.5 ), Color ( '#f5d311' ) . set ( 'alpha' , 0.5 ), 'white' ], ... blend = 'normal' , ... space = \"display-p3\" ... ) color(srgb 0.63703 0.69225 0.77313 / 1) Color('#07c7ed').set('alpha', 0.5).compose( [Color('#fc3d99').set('alpha', 0.5), Color('#f5d311').set('alpha', 0.5), 'white'], blend='normal', space=\"display-p3\" ) Edit Share Run Cancel sRGB >>> Color ( '#07c7ed' ) . set ( 'alpha' , 0.5 ) . compose ( ... [ Color ( '#fc3d99' ) . set ( 'alpha' , 0.5 ), Color ( '#f5d311' ) . set ( 'alpha' , 0.5 ), 'white' ], ... blend = 'normal' , ... space = \"srgb\" ... ) color(srgb 0.50588 0.67843 0.74804 / 1) Color('#07c7ed').set('alpha', 0.5).compose( [Color('#fc3d99').set('alpha', 0.5), Color('#f5d311').set('alpha', 0.5), 'white'], blend='normal', space=\"srgb\" ) Edit Share Run Cancel Lastly, if for any reason, it is desired to run compose with alpha compositing disabled (e.g. just run blending), then you can simply set operator to False . Check out Compositing Operators to learn about the many variations that are supported.","title":"Alpha Compositing"},{"location":"compositing/#complex-compositing","text":"We've covered alpha compositing and blending and have demonstrated their use with simple two color examples and multi-layered examples layers, but what about different blend modes mixed with alpha compositing? In this example, we will consider three circles, each with a unique color: # 07c7ed , # fc3d99 , and # f5d311 . We apply 50% transparency to all the circles and place them on a white background. We then perform a multiply blend on all the circles but isolate them so the multiply blend does not apply to the background. The circles are all represented with CSS. We will now try and replicate the colors with ColorAide. So in the code below, we work our way from the bottom of the stack to the top. Since the background is isolated from the multiply blending, in each region, we start by performing a normal blend on the bottom circle against the background. We then apply multiply blending on each color that is stacked on top. We've provided both the P3 and sRGB outputs to make it easy to compare in case your browser blends in one instead of the other. Display P3 >>> c1 = Color ( '#07c7ed' ) . set ( 'alpha' , 0.5 ) >>> c2 = Color ( '#fc3d99' ) . set ( 'alpha' , 0.5 ) >>> c3 = Color ( '#f5d311' ) . set ( 'alpha' , 0.5 ) >>> cw2 = c2 . compose ( 'white' , blend = 'normal' , space = 'display-p3' ) >>> cw3 = c3 . compose ( 'white' , blend = 'normal' , space = 'display-p3' ) >>> r1 = c2 . compose ( cw3 , blend = 'multiply' , space = 'display-p3' ) >>> r2 = c1 . compose ( cw2 , blend = 'multiply' , space = 'display-p3' ) >>> r3 = c1 . compose ( cw3 , blend = 'multiply' , space = 'display-p3' ) >>> r1 , r2 , r3 (color(srgb 0.98122 0.58007 0.49257 / 1), color(srgb 0.66117 0.57542 0.77558 / 1), color(srgb 0.61489 0.8159 0.59659 / 1)) >>> c1 . compose ([ c2 , cw3 ], blend = 'multiply' , space = 'display-p3' ) color(srgb 0.64659 0.52543 0.48429 / 1) c1 = Color('#07c7ed').set('alpha', 0.5) c2 = Color('#fc3d99').set('alpha', 0.5) c3 = Color('#f5d311').set('alpha', 0.5) cw2 = c2.compose('white', blend='normal', space='display-p3') cw3 = c3.compose('white', blend='normal', space='display-p3') r1 = c2.compose(cw3, blend='multiply', space='display-p3') r2 = c1.compose(cw2, blend='multiply', space='display-p3') r3 = c1.compose(cw3, blend='multiply', space='display-p3') r1, r2, r3 c1.compose([c2, cw3], blend='multiply', space='display-p3') Edit Share Run Cancel sRGB >>> c1 = Color ( '#07c7ed' ) . set ( 'alpha' , 0.5 ) >>> c2 = Color ( '#fc3d99' ) . set ( 'alpha' , 0.5 ) >>> c3 = Color ( '#f5d311' ) . set ( 'alpha' , 0.5 ) >>> cw2 = c2 . compose ( 'white' , blend = 'normal' , space = 'srgb' ) >>> cw3 = c3 . compose ( 'white' , blend = 'normal' , space = 'srgb' ) >>> r1 = c2 . compose ( cw3 , blend = 'multiply' , space = 'srgb' ) >>> r2 = c1 . compose ( cw2 , blend = 'multiply' , space = 'srgb' ) >>> r3 = c1 . compose ( cw3 , blend = 'multiply' , space = 'srgb' ) >>> r1 , r2 , r3 (color(srgb 0.97463 0.56615 0.42667 / 1), color(srgb 0.5107 0.55157 0.77176 / 1), color(srgb 0.50365 0.81339 0.51451 / 1)) >>> c1 . compose ([ c2 , cw3 ], blend = 'multiply' , space = 'srgb' ) color(srgb 0.50069 0.50399 0.41161 / 1) c1 = Color('#07c7ed').set('alpha', 0.5) c2 = Color('#fc3d99').set('alpha', 0.5) c3 = Color('#f5d311').set('alpha', 0.5) cw2 = c2.compose('white', blend='normal', space='srgb') cw3 = c3.compose('white', blend='normal', space='srgb') r1 = c2.compose(cw3, blend='multiply', space='srgb') r2 = c1.compose(cw2, blend='multiply', space='srgb') r3 = c1.compose(cw3, blend='multiply', space='srgb') r1, r2, r3 c1.compose([c2, cw3], blend='multiply', space='srgb') Edit Share Run Cancel Results may vary depending on the browser, but we can see (ignoring rounding differences) that the colors match up. This was performed on Chrome in macOS using a display that uses display-p3 .","title":"Complex Compositing"},{"location":"compositing/#blend-modes","text":"","title":"Blend Modes"},{"location":"compositing/#normal","text":"The blending formula simply selects the source color. Specified as 'normal' .","title":"Normal"},{"location":"compositing/#multiply","text":"The source color is multiplied by the destination color and replaces the destination. The resultant color is always at least as dark as either the source or destination color. Multiplying any color with black results in black. Multiplying any color with white preserves the original color. Specified as 'multiply' .","title":"Multiply"},{"location":"compositing/#screen","text":"Multiplies the complements of the backdrop and source color values, then complements the result. The result color is always at least as light as either of the two constituent colors. Screening any color with white produces white; screening with black leaves the original color unchanged. The effect is similar to projecting multiple photographic slides simultaneously onto a single screen. Specified as 'screen' .","title":"Screen"},{"location":"compositing/#overlay","text":"Multiplies or screens the colors, depending on the backdrop color value. Source colors overlay the backdrop while preserving its highlights and shadows. The backdrop color is not replaced but is mixed with the source color to reflect the lightness or darkness of the backdrop. Specified as 'overlay' .","title":"Overlay"},{"location":"compositing/#darken","text":"Selects the darker of the backdrop and source colors. The backdrop is replaced with the source where the source is darker; otherwise, it is left unchanged. Specified as 'darken' .","title":"Darken"},{"location":"compositing/#lighten","text":"Selects the lighter of the backdrop and source colors. The backdrop is replaced with the source where the source is lighter; otherwise, it is left unchanged. Specified as 'lighten' .","title":"Lighten"},{"location":"compositing/#color-dodge","text":"Brightens the backdrop color to reflect the source color. Painting with black produces no changes. Specified as 'color-dodge' .","title":"Color Dodge"},{"location":"compositing/#color-burn","text":"Darkens the backdrop color to reflect the source color. Painting with white produces no change. Specified as 'color-burn' .","title":"Color Burn"},{"location":"compositing/#hard-light","text":"Multiplies or screens the colors, depending on the source color value. The effect is similar to shining a harsh spotlight on the backdrop. Specified as 'hard-light' .","title":"Hard Light"},{"location":"compositing/#soft-light","text":"Darkens or lightens the colors, depending on the source color value. The effect is similar to shining a diffused spotlight on the backdrop. Specified as 'soft-light' .","title":"Soft Light"},{"location":"compositing/#difference","text":"Subtracts the darker of the two constituent colors from the lighter color. Painting with white inverts the backdrop color; painting with black produces no change. Specified as 'difference' .","title":"Difference"},{"location":"compositing/#exclusion","text":"Produces an effect similar to that of the Difference mode but lower in contrast. Painting with white inverts the backdrop color; painting with black produces no change. Specified as 'exclusion' .","title":"Exclusion"},{"location":"compositing/#hue","text":"Creates a color with the hue of the source color and the saturation and luminosity of the backdrop color. Specified as 'hue' .","title":"Hue"},{"location":"compositing/#saturation","text":"Creates a color with the saturation of the source color and the hue and luminosity of the backdrop color. Painting with this mode in an area of the backdrop that is a pure gray (no saturation) produces no change. Specified as 'saturation' .","title":"Saturation"},{"location":"compositing/#luminosity","text":"Creates a color with the luminosity of the source color and the hue and saturation of the backdrop color. This produces an inverse effect to that of the Color mode. This mode is the one you can use to create monochrome \"tinted\" image effects like the ones you can see in different website headers. Specified as 'luminosity' .","title":"Luminosity"},{"location":"compositing/#color","text":"Creates a color with the hue and saturation of the source color and the luminosity of the backdrop color. This preserves the gray levels of the backdrop and is useful for coloring monochrome images or tinting color images. Specified as 'color' .","title":"Color"},{"location":"compositing/#compositing-operators","text":"","title":"Compositing Operators"},{"location":"compositing/#clear","text":"No regions are enabled. Specified as 'clear' .","title":"Clear"},{"location":"compositing/#copy","text":"Only the source will be present. Specified as 'copy' .","title":"Copy"},{"location":"compositing/#destination","text":"Only the destination will be present. Specified as 'destination' .","title":"Destination"},{"location":"compositing/#source-over","text":"Source is placed over the destination. Specified as 'source-over' .","title":"Source Over"},{"location":"compositing/#destination-over","text":"Destination is placed over the source. Specified as 'destination-over' .","title":"Destination Over"},{"location":"compositing/#source-in","text":"The source that overlaps the destination, replaces the destination. Specified as 'source-in' .","title":"Source In"},{"location":"compositing/#destination-in","text":"Destination which overlaps the source, replaces the source. Specified as 'destination-in' .","title":"Destination In"},{"location":"compositing/#source-out","text":"Source is placed, where it falls outside of the destination. Specified as 'source-out' .","title":"Source Out"},{"location":"compositing/#destination-out","text":"Destination is placed, where it falls outside of the source. Specified as 'destination-out' .","title":"Destination Out"},{"location":"compositing/#source-atop","text":"Source which overlaps the destination, replaces the destination. Destination is placed elsewhere. Specified as 'source-atop' .","title":"Source Atop"},{"location":"compositing/#destination-atop","text":"Destination which overlaps the source replaces the source. Source is placed elsewhere. Specified as 'destination-atop' .","title":"Destination Atop"},{"location":"compositing/#xor","text":"Destination which overlaps the source replaces the source. Source is placed elsewhere. Specified as 'xor' .","title":"XOR"},{"location":"compositing/#lighter","text":"Display the sum of the source image and destination image. Specified as 'lighter' . img { background: white; } .circle { display: block; width: 80px; height: 80px; border-radius: 50%; position: absolute; transition: all 0.5s ease; z-index: 10; } .isolate label { position: absolute; bottom: 0; width: 100%; text-align: center; } .circle-1 { background: #f5d311; } .dual .circle-1 { background: #fc3d99; } .isolate:not(.dual):hover .circle-1 { transform: translateX(-10px) translateY(-7.5px); } .isolate.dual:hover .circle-1 { transform: translateX(-10px); } .circle-2 { background: #fc3d99; left: 40px; } .dual .circle-2 { background: #07c7ed; } .isolate:not(.dual):hover .circle-2 { transform: translateX(10px) translateY(-7.5px); } .isolate.dual:hover .circle-2 { transform: translateX(20px); } .circle-3 { background: #07c7ed; left: 20px; top: 40px; } .isolate:not(.dual):hover .circle-3 { transform: translateY(7.5px); } .isolate { display: block; height: 120px; width: 120px; isolation: isolate; position: relative; margin: 0 10px; } .isolate.dual { height: 80px; } div.blend-wrap { display: flex; min-height: calc(120px + 0.8em); width: 100%; } div.blend-wrap > :not(.blend-content) { order: 0; } div.blend-wrap .isolate { margin-top: 0.8em; } div.blend-wrap > .blend-content { order: 1; } .blend-normal .circle { mix-blend-mode: normal; } .blend-multiply .circle { mix-blend-mode: multiply; } .blend-screen .circle { mix-blend-mode: screen; } .blend-overlay .circle { mix-blend-mode: overlay; } .blend-color-burn .circle { mix-blend-mode: color-burn; } .blend-color-dodge .circle { mix-blend-mode: color-dodge; } .blend-exclusion .circle { mix-blend-mode: exclusion; } .blend-difference .circle { mix-blend-mode: difference; } .blend-darken .circle { mix-blend-mode: darken; } .blend-lighten .circle { mix-blend-mode: lighten; } .blend-soft-light .circle { mix-blend-mode: soft-light; } .blend-hard-light .circle { mix-blend-mode: hard-light; } .blend-hue .circle { mix-blend-mode: hue; } .blend-saturation .circle { mix-blend-mode: saturation; } .blend-luminosity .circle { mix-blend-mode: luminosity; } .blend-color .circle { mix-blend-mode: color; }","title":"Lighter"},{"location":"contrast/","text":"Contrast Relative Luminance Relative luminance is used to calculate the contrast ratio. To get the luminance, simply call the luminance method: >>> Color ( \"black\" ) . luminance () 0.0 >>> Color ( \"white\" ) . luminance () 1.0 >>> Color ( \"blue\" ) . luminance () 0.07219231536073374 Color(\"black\").luminance() Color(\"white\").luminance() Color(\"blue\").luminance() Edit Share Run Cancel Contrast Ratio To get the contrast ratio between two colors, simply pass in the second color: >>> Color ( \"blue\" ) . contrast ( \"red\" ) 2.149390533243867 Color(\"blue\").contrast(\"red\") Edit Share Run Cancel","title":"Contrast"},{"location":"contrast/#contrast","text":"","title":"Contrast"},{"location":"contrast/#relative-luminance","text":"Relative luminance is used to calculate the contrast ratio. To get the luminance, simply call the luminance method: >>> Color ( \"black\" ) . luminance () 0.0 >>> Color ( \"white\" ) . luminance () 1.0 >>> Color ( \"blue\" ) . luminance () 0.07219231536073374 Color(\"black\").luminance() Color(\"white\").luminance() Color(\"blue\").luminance() Edit Share Run Cancel","title":"Relative Luminance"},{"location":"contrast/#contrast-ratio","text":"To get the contrast ratio between two colors, simply pass in the second color: >>> Color ( \"blue\" ) . contrast ( \"red\" ) 2.149390533243867 Color(\"blue\").contrast(\"red\") Edit Share Run Cancel","title":"Contrast Ratio"},{"location":"distance/","text":"Color Distance and Delta E Color Distance ColorAide provides a simple euclidean color distance function. By default, it evaluates the distance in the CIELAB color space, but it can be configured to evaluate in any color space. It may be less useful in some color spaces compared to others: >>> Color ( \"red\" ) . distance ( \"blue\" , space = \"srgb\" ) 1.4142135623730951 >>> Color ( \"red\" ) . distance ( \"blue\" , space = \"lab\" ) 184.0190486209969 Color(\"red\").distance(\"blue\", space=\"srgb\") Color(\"red\").distance(\"blue\", space=\"lab\") Edit Share Run Cancel Delta E The delta_e function gives access to various \u2206E implementations. >>> Color ( \"red\" ) . delta_e ( \"blue\" ) 184.0190486209969 >>> Color ( \"red\" ) . delta_e ( \"blue\" , method = \"2000\" ) 55.799773390197785 Color(\"red\").delta_e(\"blue\") Color(\"red\").delta_e(\"blue\", method=\"2000\") Edit Share Run Cancel The general delta_e function can be used to specify any supported \u2206E method. Optional parameters can be passed in if desired. See table below for supported methods, names, and parameters. Follow relevant links to read the specs or find our more about a given \u2206E method. Delta E Name Parameters \u2206E * ab (CIE76) 76 \u2206E * cmc (CMC l:c (1984)) cmc l=2, c=1 \u2206E * 94 (CIE94) 94 kl=1, k1=0.045, k2=0.015 \u2206E * 00 (CIEDE2000) 2000 kl=1, kc=1, kh=1 \u2206E itp (ICtCp) itp scalar=720 \u2206E z (Jzazbz) jz \u2206E 99o (DIN99o) 99o \u2206E HyAB (HyAB) hyab space=\"lab\" \u2206E methods are also accessible via methods delta_e_<name> , where <name> is a name from the above table. >>> Color ( \"red\" ) . delta_e_jz ( \"blue\" ) 0.33960388420164045 >>> Color ( \"red\" ) . delta_e_hyab ( \"blue\" ) 207.07305826980567 Color(\"red\").delta_e_jz(\"blue\") Color(\"red\").delta_e_hyab(\"blue\") Edit Share Run Cancel If no name is specified, the default implementation is \u2206E * ab (CIE76). Originally, when the CIELAB color space was created, it was thought that it was more perceptually uniform than it actually was. At first, the distance algorithm was a simple euclidean implementation (\u2206E * 1976), but over time it has been tweaked to make corrections to account for the fact that it is not perfectly uniform. This gave rise to all of the various \u2206E * methods above. There are areas and industries that still use many of these for different reasons. Additionally, there are other implementations that use different color spaces, such as \u2206E itp which uses ICtCp or \u2206E z which uses Jzazbz. Also, there are some general methods such as \u2206E HyAB . HyAB is designed to work with Lab-ish colors (CIELAB, CIELUV, DIN99o, etc.).","title":"Color Distance and Delta E"},{"location":"distance/#color-distance-and-delta-e","text":"","title":"Color Distance and Delta E"},{"location":"distance/#color-distance","text":"ColorAide provides a simple euclidean color distance function. By default, it evaluates the distance in the CIELAB color space, but it can be configured to evaluate in any color space. It may be less useful in some color spaces compared to others: >>> Color ( \"red\" ) . distance ( \"blue\" , space = \"srgb\" ) 1.4142135623730951 >>> Color ( \"red\" ) . distance ( \"blue\" , space = \"lab\" ) 184.0190486209969 Color(\"red\").distance(\"blue\", space=\"srgb\") Color(\"red\").distance(\"blue\", space=\"lab\") Edit Share Run Cancel","title":"Color Distance"},{"location":"distance/#delta-e","text":"The delta_e function gives access to various \u2206E implementations. >>> Color ( \"red\" ) . delta_e ( \"blue\" ) 184.0190486209969 >>> Color ( \"red\" ) . delta_e ( \"blue\" , method = \"2000\" ) 55.799773390197785 Color(\"red\").delta_e(\"blue\") Color(\"red\").delta_e(\"blue\", method=\"2000\") Edit Share Run Cancel The general delta_e function can be used to specify any supported \u2206E method. Optional parameters can be passed in if desired. See table below for supported methods, names, and parameters. Follow relevant links to read the specs or find our more about a given \u2206E method. Delta E Name Parameters \u2206E * ab (CIE76) 76 \u2206E * cmc (CMC l:c (1984)) cmc l=2, c=1 \u2206E * 94 (CIE94) 94 kl=1, k1=0.045, k2=0.015 \u2206E * 00 (CIEDE2000) 2000 kl=1, kc=1, kh=1 \u2206E itp (ICtCp) itp scalar=720 \u2206E z (Jzazbz) jz \u2206E 99o (DIN99o) 99o \u2206E HyAB (HyAB) hyab space=\"lab\" \u2206E methods are also accessible via methods delta_e_<name> , where <name> is a name from the above table. >>> Color ( \"red\" ) . delta_e_jz ( \"blue\" ) 0.33960388420164045 >>> Color ( \"red\" ) . delta_e_hyab ( \"blue\" ) 207.07305826980567 Color(\"red\").delta_e_jz(\"blue\") Color(\"red\").delta_e_hyab(\"blue\") Edit Share Run Cancel If no name is specified, the default implementation is \u2206E * ab (CIE76). Originally, when the CIELAB color space was created, it was thought that it was more perceptually uniform than it actually was. At first, the distance algorithm was a simple euclidean implementation (\u2206E * 1976), but over time it has been tweaked to make corrections to account for the fact that it is not perfectly uniform. This gave rise to all of the various \u2206E * methods above. There are areas and industries that still use many of these for different reasons. Additionally, there are other implementations that use different color spaces, such as \u2206E itp which uses ICtCp or \u2206E z which uses Jzazbz. Also, there are some general methods such as \u2206E HyAB . HyAB is designed to work with Lab-ish colors (CIELAB, CIELUV, DIN99o, etc.).","title":"Delta E"},{"location":"gamut/","text":"Gamut Mapping Overview Many color spaces have limits to the colors they can accurately represent. This is the color gamut. The bounds represent the limits to which a color space can represent a color. Some color spaces are theoretically unbounded, but past a point, the eye can't see them. When moving from a large color space like CIELAB to a small color space like sRGB, many CIELAB colors will not fit without mapping the color to one that does fit. This \"fitting\" of the color from one gamut into another is called gamut mapping. Checking Gamut When dealing with colors, it can be important to know whether a color is within its own gamut. The in_gamut function allows for comparing the current color's specified values against the color space's gamut. Let's assume we have a color rgb ( 30 % 105 % 0 % ) . The color is out of gamut due to the green channel exceeding the channel's limit of 100 % . When we execute in_gamut , we can see that the color is not in its own gamut. >>> Color ( \"rgb(30 % 105% 0%)\" ) . in_gamut () False Color(\"rgb(30% 105% 0%)\").in_gamut() Edit Share Run Cancel On the other hand, some colors do not have a limit, only suggested limits for usability. CIELAB does not really have bounds as it is formulated in such a way that it can represent any color, even if they are not visible. When we check a CIELAB color, we will find that it is always in gamut. >>> Color ( \"lab(200% -20 40 / 1)\" ) . in_gamut () True Color(\"lab(200% -20 40 / 1)\").in_gamut() Edit Share Run Cancel While checking CIELAB's own gamut isn't very useful, we can test it against a different color space's gamut. By simply passing in the name of a different color space, the current color will be converted to the provided space and then will run in_gamut on the new color. You could do this manually, but using in_gamut in this manner can be very convenient. In the example below, we can see that the CIELAB color of lab ( 200 % - 20 40 / 1 ) is outside the narrow gamut of sRGB. >>> Color ( \"lab(200% -20 40 / 1)\" ) . in_gamut ( 'srgb' ) False Color(\"lab(200% -20 40 / 1)\").in_gamut('srgb') Edit Share Run Cancel Generally, ColorAide does not round off values in order to guarantee the best possible values for round tripping, but due to limitations of floating-point arithmetic , there can be edge cases where colors don't round trip perfectly. By default, in_gamut allows for a tolerance of 0.000075 to account for such cases where a color is \"close enough\". If desired, this \"tolerance\" can be adjusted. Let's consider CIELAB. The sRGB round trip through CIELAB for white does not perfectly convert back to the original color. We can see that when using a tolerance of zero, the color is considered out of gamut. Depending on what you are doing, this may not be an issue up until you are ready to finalize the color, so sometimes it may be desirable to have some tolerance, and other times not. >>> Color ( 'color(srgb 1 1 1)' ) . convert ( 'lab' ) . convert ( 'srgb' ) . coords () [0.9999999999999999, 0.9999999999999997, 1.0000000000000002] >>> Color ( 'color(srgb 1 1 1)' ) . convert ( 'lab' ) . convert ( 'srgb' ) . in_gamut () True >>> Color ( 'color(srgb 1 1 1)' ) . convert ( 'lab' ) . convert ( 'srgb' ) . in_gamut ( tolerance = 0 ) False Color('color(srgb 1 1 1)').convert('lab').convert('srgb').coords() Color('color(srgb 1 1 1)').convert('lab').convert('srgb').in_gamut() Color('color(srgb 1 1 1)').convert('lab').convert('srgb').in_gamut(tolerance=0) Edit Share Run Cancel On the topic of tolerance, there are some spaces that inherently are based off gamuts of other spaces. For instance, the cylindrical spaces HSL, HSV, and HWB are just different color models for the sRGB space, so their gamut is the same as sRGB. So it stands to reason that simply using the sRGB gamut check for them should be sufficient, and if we are using strict tolerance, this would make sense: >>> Color ( 'rgb(255 255 255)' ) . in_gamut ( 'srgb' , tolerance = 0 ) True >>> Color ( 'hsl(0 0 % 100% )' ) . in_gamut ( 'srgb' , tolerance = 0 ) True >>> Color ( 'color(--hsv 0 0 % 100% )' ) . in_gamut ( 'srgb' , tolerance = 0 ) True >>> Color ( 'rgb(255.05 255 255)' ) . in_gamut ( 'srgb' , tolerance = 0 ) False >>> Color ( 'hsl(0 0 % 100.05% )' ) . in_gamut ( 'srgb' , tolerance = 0 ) False >>> Color ( 'color(--hsv 0 0 % 100.05% )' ) . in_gamut ( 'srgb' , tolerance = 0 ) False Color('rgb(255 255 255)').in_gamut('srgb', tolerance=0) Color('hsl(0 0% 100%)').in_gamut('srgb', tolerance=0) Color('color(--hsv 0 0% 100%)').in_gamut('srgb', tolerance=0) Color('rgb(255.05 255 255)').in_gamut('srgb', tolerance=0) Color('hsl(0 0% 100.05%)').in_gamut('srgb', tolerance=0) Color('color(--hsv 0 0% 100.05%)').in_gamut('srgb', tolerance=0) Edit Share Run Cancel HWB is a little funny as values over 100% for whiteness and blackness are normalized, but the results are technically correct as the value will convert to an sRGB value perfectly in gamut. >>> Color ( 'hwb(0 100 % 0% )' ) . in_gamut ( 'srgb' , tolerance = 0 ) True >>> Color ( 'hwb(0 100.05 % 0% )' ) . in_gamut ( 'srgb' , tolerance = 0 ) True >>> Color ( 'hwb(0 100.05 % 0% )' ) . convert ( 'srgb' ) . coords () [1.0, 1.0, 1.0] Color('hwb(0 100% 0%)').in_gamut('srgb', tolerance=0) Color('hwb(0 100.05% 0%)').in_gamut('srgb', tolerance=0) Color('hwb(0 100.05% 0%)').convert('srgb').coords() Edit Share Run Cancel But when using a tolerance check in a Cartesian model while in a cylindrical model, we can end up with some surprising results. In this example, we have an sRGB color that is extremely close to being in gamut, but when we convert it to HSL we can see wildly large saturation. There isn't anything technically wrong with this value as saturation and hue are essentially meaningless when lightness is 100 % , but this may be undesirable to a user. >>> hsl = Color ( 'color(srgb 0.9999999999994 1.0000000000002 0.9999999999997)' ) . convert ( 'hsl' ) >>> hsl color(--hsl 142.5 200.06% 100% / 1) >>> hsl . in_gamut ( 'srgb' ) True hsl = Color('color(srgb 0.9999999999994 1.0000000000002 0.9999999999997)').convert('hsl') hsl hsl.in_gamut('srgb') Edit Share Run Cancel For this reason, if passing in hsl , hsv , or hwb as gamut inputs, the tolerance is also compared not only against the Cartesian coordinates, but also the cylindrical coordinates. In this way, we are still checking that the colors are in the sRGB gamut, but the tolerance is now relative to the constraints of the cylindrical color model. There is no HSL, HSV, and HWB gamuts as these are just alternative models for RGB based colors. One could easily map the Display P3 color space, which has a different gamut, to one of these models. We can see below that now the gamut check will fail. If the color is an HSL color, we do not have to specify hsl , as it will be the default for that color space, but we specify it below just for illustration. >>> hsl = Color ( 'color(srgb 0.9999999999994 1.0000000000002 0.9999999999997)' ) . convert ( 'hsl' ) >>> hsl color(--hsl 142.5 200.06% 100% / 1) >>> hsl . in_gamut ( 'hsl' ) False hsl = Color('color(srgb 0.9999999999994 1.0000000000002 0.9999999999997)').convert('hsl') hsl hsl.in_gamut('hsl') Edit Share Run Cancel We can also see that the tolerance is now relative to the color model: >>> hsl = Color ( 'hsl(140 100.000002 % 0% )' ) >>> hsl . convert ( 'srgb' ) . coords () [0.0, 0.0, 0.0] >>> hsl . in_gamut ( 'hsl' ) True hsl = Color('hsl(140 100.000002% 0%)') hsl.convert('srgb').coords() hsl.in_gamut('hsl') Edit Share Run Cancel But don't worry, the tolerance constraint above isn't solely based on the HSL coordinates. If the color deviates past the threshold for sRGB or HSL, the gamut will yield False . It is simply an extra check added that ensures the tolerance is compared against both the Cartesian coordinates and the cylindrical coordinates to ensure that we are working with sane values. If the Cartesian check is the only desired check, and the strange cylindrical values that are returned are not a problem, srgb can always be specified. tolerance = 0 can always be used to constrain the check to values exactly in the gamut. Mapping Colors Gamut mapping is the process of taking a color that is out of gamut and adjusting it such that it fits within the gamut. There are various different ways to gamut map a color into a smaller gamut. Currently, ColorAide provides two methods: naive clipping, and LCH Chroma. The recommended approach (and the default for ColorAide) is to use LCH Chroma. This method compresses the chroma while in the CIELCH color space mostly keeping the other attributes intact. There is a little more to it than that, but that is essentially the basic concept. In this example, we will take the color lch ( 100 % 50 75 ) . CIELCH's gamut is technically unbounded, but when we convert the color to sRGB, we find that the color is out of gamut. So, using the fit method, we can actually transform the color to one that fits in the sRGB space and gives a color that represents the intent of the larger color as best we can. As the color's lightness is so high, when fitting, we essentially end up with white . >>> rgb = Color ( \"lch(100% 50 75)\" ) . convert ( 'srgb' ) >>> rgb . in_gamut () False >>> rgb . coords () [1.1833386979489748, 0.9589979721391798, 0.6278282254203291] >>> rgb . fit () color(srgb 1 1 1 / 1) rgb = Color(\"lch(100% 50 75)\").convert('srgb') rgb.in_gamut() rgb.coords() rgb.fit() Edit Share Run Cancel If desired, simple clipping can be used instead of the default gamut mapping. Clipping is a naive way to fit a color as it simply truncates any color channels whose values are two big or too small. While gamut mapping via chroma compression can give better results, gamut clipping is much faster and is actually what browsers do. If your desire is to match how browsers handle out of gamut color or if you greatly value speed over correctness, clipping may be the way to go. In this example, we can change the fitting method parameter to clip . Notice the difference when compared to the previous fitting result. We now end up with a very yellow-ish color. >>> Color ( \"lch(100% 50 75)\" ) . fit ( \"srgb\" , method = \"clip\" ) color(--lch 95.816% 42.313 96.903 / 1) >>> Color ( \"lch(100% 50 75)\" ) . fit ( \"srgb\" ) color(--lch 100% 0 0 / 1) Color(\"lch(100% 50 75)\").fit(\"srgb\", method=\"clip\") Color(\"lch(100% 50 75)\").fit(\"srgb\") Edit Share Run Cancel If we wanted to change the default \"fitting\" to clip , we can also just use a class override . Doing this will cause the class to default to clip any time a color needs to be mapped. Though, you can still use chroma compression by specifying lch-chroma for the method . >>> class Custom ( Color ): ... FIT = 'clip' ... >>> Custom ( \"lch(100% 50 75)\" ) . convert ( 'srgb' ) . fit () color(srgb 1 0.959 0.62783 / 1) >>> Custom ( \"lch(100% 50 75)\" ) . convert ( 'srgb' ) . fit ( method = 'lch-chroma' ) color(srgb 1 1 1 / 1) class Custom(Color): FIT = 'clip' Custom(\"lch(100% 50 75)\").convert('srgb').fit() Custom(\"lch(100% 50 75)\").convert('srgb').fit(method='lch-chroma') Edit Share Run Cancel It is important to note that when using fit, there is no tolerance, so even if in_gamut allowed enough tolerance to consider a color within the gamut, calling fit will fit any color that is not exactly in gamut. >>> lab = Color ( 'lab(100% 0 0)' ) >>> srgb = lab . convert ( 'srgb' ) >>> srgb . in_gamut () True >>> srgb . coords () [1.0000000000000002, 0.9999999999999997, 0.9999999999999997] >>> srgb . fit () . coords () [1.0, 0.9999999999999994, 0.9999999999999997] lab = Color('lab(100% 0 0)') srgb = lab.convert('srgb') srgb.in_gamut() srgb.coords() srgb.fit().coords() Edit Share Run Cancel And much like gamut checking , we can fit a color in a different color space. >>> Color ( \"lch(100% 50 75)\" ) . fit ( 'srgb' ) color(--lch 100% 0 0 / 1) Color(\"lch(100% 50 75)\").fit('srgb') Edit Share Run Cancel When fitting in another color space, results may vary depending on what color space you are in and what color space you are using to fit the color. We went into great depths when discussing gamut checking about how transform functions from one color space to another are not always exact. We also gave quite a number of examples showing cases in which some color spaces were more sensitive to slight deviations from their gamut than others. This is mainly mentioned as fitting in one color space and round tripping back may not give exact results: >>> Color ( \"lch(100% 50 75)\" ) . convert ( 'srgb' ) . fit () . coords () [1.0, 0.9999999999999997, 0.9999999999999997] >>> Color ( \"lch(100% 50 75)\" ) . fit ( 'srgb' ) . convert ( 'srgb' ) . coords () [1.0000000000000002, 0.9999999999999994, 0.9999999999999997] Color(\"lch(100% 50 75)\").convert('srgb').fit().coords() Color(\"lch(100% 50 75)\").fit('srgb').convert('srgb').coords() Edit Share Run Cancel Depending on what you are doing, and what spaces you are working in, it may make sense to fully convert to a space and work directly in that space opposed to the indirect fitting of a color in a different color space.","title":"Gamut Mapping"},{"location":"gamut/#gamut-mapping","text":"","title":"Gamut Mapping"},{"location":"gamut/#overview","text":"Many color spaces have limits to the colors they can accurately represent. This is the color gamut. The bounds represent the limits to which a color space can represent a color. Some color spaces are theoretically unbounded, but past a point, the eye can't see them. When moving from a large color space like CIELAB to a small color space like sRGB, many CIELAB colors will not fit without mapping the color to one that does fit. This \"fitting\" of the color from one gamut into another is called gamut mapping.","title":"Overview"},{"location":"gamut/#checking-gamut","text":"When dealing with colors, it can be important to know whether a color is within its own gamut. The in_gamut function allows for comparing the current color's specified values against the color space's gamut. Let's assume we have a color rgb ( 30 % 105 % 0 % ) . The color is out of gamut due to the green channel exceeding the channel's limit of 100 % . When we execute in_gamut , we can see that the color is not in its own gamut. >>> Color ( \"rgb(30 % 105% 0%)\" ) . in_gamut () False Color(\"rgb(30% 105% 0%)\").in_gamut() Edit Share Run Cancel On the other hand, some colors do not have a limit, only suggested limits for usability. CIELAB does not really have bounds as it is formulated in such a way that it can represent any color, even if they are not visible. When we check a CIELAB color, we will find that it is always in gamut. >>> Color ( \"lab(200% -20 40 / 1)\" ) . in_gamut () True Color(\"lab(200% -20 40 / 1)\").in_gamut() Edit Share Run Cancel While checking CIELAB's own gamut isn't very useful, we can test it against a different color space's gamut. By simply passing in the name of a different color space, the current color will be converted to the provided space and then will run in_gamut on the new color. You could do this manually, but using in_gamut in this manner can be very convenient. In the example below, we can see that the CIELAB color of lab ( 200 % - 20 40 / 1 ) is outside the narrow gamut of sRGB. >>> Color ( \"lab(200% -20 40 / 1)\" ) . in_gamut ( 'srgb' ) False Color(\"lab(200% -20 40 / 1)\").in_gamut('srgb') Edit Share Run Cancel Generally, ColorAide does not round off values in order to guarantee the best possible values for round tripping, but due to limitations of floating-point arithmetic , there can be edge cases where colors don't round trip perfectly. By default, in_gamut allows for a tolerance of 0.000075 to account for such cases where a color is \"close enough\". If desired, this \"tolerance\" can be adjusted. Let's consider CIELAB. The sRGB round trip through CIELAB for white does not perfectly convert back to the original color. We can see that when using a tolerance of zero, the color is considered out of gamut. Depending on what you are doing, this may not be an issue up until you are ready to finalize the color, so sometimes it may be desirable to have some tolerance, and other times not. >>> Color ( 'color(srgb 1 1 1)' ) . convert ( 'lab' ) . convert ( 'srgb' ) . coords () [0.9999999999999999, 0.9999999999999997, 1.0000000000000002] >>> Color ( 'color(srgb 1 1 1)' ) . convert ( 'lab' ) . convert ( 'srgb' ) . in_gamut () True >>> Color ( 'color(srgb 1 1 1)' ) . convert ( 'lab' ) . convert ( 'srgb' ) . in_gamut ( tolerance = 0 ) False Color('color(srgb 1 1 1)').convert('lab').convert('srgb').coords() Color('color(srgb 1 1 1)').convert('lab').convert('srgb').in_gamut() Color('color(srgb 1 1 1)').convert('lab').convert('srgb').in_gamut(tolerance=0) Edit Share Run Cancel On the topic of tolerance, there are some spaces that inherently are based off gamuts of other spaces. For instance, the cylindrical spaces HSL, HSV, and HWB are just different color models for the sRGB space, so their gamut is the same as sRGB. So it stands to reason that simply using the sRGB gamut check for them should be sufficient, and if we are using strict tolerance, this would make sense: >>> Color ( 'rgb(255 255 255)' ) . in_gamut ( 'srgb' , tolerance = 0 ) True >>> Color ( 'hsl(0 0 % 100% )' ) . in_gamut ( 'srgb' , tolerance = 0 ) True >>> Color ( 'color(--hsv 0 0 % 100% )' ) . in_gamut ( 'srgb' , tolerance = 0 ) True >>> Color ( 'rgb(255.05 255 255)' ) . in_gamut ( 'srgb' , tolerance = 0 ) False >>> Color ( 'hsl(0 0 % 100.05% )' ) . in_gamut ( 'srgb' , tolerance = 0 ) False >>> Color ( 'color(--hsv 0 0 % 100.05% )' ) . in_gamut ( 'srgb' , tolerance = 0 ) False Color('rgb(255 255 255)').in_gamut('srgb', tolerance=0) Color('hsl(0 0% 100%)').in_gamut('srgb', tolerance=0) Color('color(--hsv 0 0% 100%)').in_gamut('srgb', tolerance=0) Color('rgb(255.05 255 255)').in_gamut('srgb', tolerance=0) Color('hsl(0 0% 100.05%)').in_gamut('srgb', tolerance=0) Color('color(--hsv 0 0% 100.05%)').in_gamut('srgb', tolerance=0) Edit Share Run Cancel HWB is a little funny as values over 100% for whiteness and blackness are normalized, but the results are technically correct as the value will convert to an sRGB value perfectly in gamut. >>> Color ( 'hwb(0 100 % 0% )' ) . in_gamut ( 'srgb' , tolerance = 0 ) True >>> Color ( 'hwb(0 100.05 % 0% )' ) . in_gamut ( 'srgb' , tolerance = 0 ) True >>> Color ( 'hwb(0 100.05 % 0% )' ) . convert ( 'srgb' ) . coords () [1.0, 1.0, 1.0] Color('hwb(0 100% 0%)').in_gamut('srgb', tolerance=0) Color('hwb(0 100.05% 0%)').in_gamut('srgb', tolerance=0) Color('hwb(0 100.05% 0%)').convert('srgb').coords() Edit Share Run Cancel But when using a tolerance check in a Cartesian model while in a cylindrical model, we can end up with some surprising results. In this example, we have an sRGB color that is extremely close to being in gamut, but when we convert it to HSL we can see wildly large saturation. There isn't anything technically wrong with this value as saturation and hue are essentially meaningless when lightness is 100 % , but this may be undesirable to a user. >>> hsl = Color ( 'color(srgb 0.9999999999994 1.0000000000002 0.9999999999997)' ) . convert ( 'hsl' ) >>> hsl color(--hsl 142.5 200.06% 100% / 1) >>> hsl . in_gamut ( 'srgb' ) True hsl = Color('color(srgb 0.9999999999994 1.0000000000002 0.9999999999997)').convert('hsl') hsl hsl.in_gamut('srgb') Edit Share Run Cancel For this reason, if passing in hsl , hsv , or hwb as gamut inputs, the tolerance is also compared not only against the Cartesian coordinates, but also the cylindrical coordinates. In this way, we are still checking that the colors are in the sRGB gamut, but the tolerance is now relative to the constraints of the cylindrical color model. There is no HSL, HSV, and HWB gamuts as these are just alternative models for RGB based colors. One could easily map the Display P3 color space, which has a different gamut, to one of these models. We can see below that now the gamut check will fail. If the color is an HSL color, we do not have to specify hsl , as it will be the default for that color space, but we specify it below just for illustration. >>> hsl = Color ( 'color(srgb 0.9999999999994 1.0000000000002 0.9999999999997)' ) . convert ( 'hsl' ) >>> hsl color(--hsl 142.5 200.06% 100% / 1) >>> hsl . in_gamut ( 'hsl' ) False hsl = Color('color(srgb 0.9999999999994 1.0000000000002 0.9999999999997)').convert('hsl') hsl hsl.in_gamut('hsl') Edit Share Run Cancel We can also see that the tolerance is now relative to the color model: >>> hsl = Color ( 'hsl(140 100.000002 % 0% )' ) >>> hsl . convert ( 'srgb' ) . coords () [0.0, 0.0, 0.0] >>> hsl . in_gamut ( 'hsl' ) True hsl = Color('hsl(140 100.000002% 0%)') hsl.convert('srgb').coords() hsl.in_gamut('hsl') Edit Share Run Cancel But don't worry, the tolerance constraint above isn't solely based on the HSL coordinates. If the color deviates past the threshold for sRGB or HSL, the gamut will yield False . It is simply an extra check added that ensures the tolerance is compared against both the Cartesian coordinates and the cylindrical coordinates to ensure that we are working with sane values. If the Cartesian check is the only desired check, and the strange cylindrical values that are returned are not a problem, srgb can always be specified. tolerance = 0 can always be used to constrain the check to values exactly in the gamut.","title":"Checking Gamut"},{"location":"gamut/#mapping-colors","text":"Gamut mapping is the process of taking a color that is out of gamut and adjusting it such that it fits within the gamut. There are various different ways to gamut map a color into a smaller gamut. Currently, ColorAide provides two methods: naive clipping, and LCH Chroma. The recommended approach (and the default for ColorAide) is to use LCH Chroma. This method compresses the chroma while in the CIELCH color space mostly keeping the other attributes intact. There is a little more to it than that, but that is essentially the basic concept. In this example, we will take the color lch ( 100 % 50 75 ) . CIELCH's gamut is technically unbounded, but when we convert the color to sRGB, we find that the color is out of gamut. So, using the fit method, we can actually transform the color to one that fits in the sRGB space and gives a color that represents the intent of the larger color as best we can. As the color's lightness is so high, when fitting, we essentially end up with white . >>> rgb = Color ( \"lch(100% 50 75)\" ) . convert ( 'srgb' ) >>> rgb . in_gamut () False >>> rgb . coords () [1.1833386979489748, 0.9589979721391798, 0.6278282254203291] >>> rgb . fit () color(srgb 1 1 1 / 1) rgb = Color(\"lch(100% 50 75)\").convert('srgb') rgb.in_gamut() rgb.coords() rgb.fit() Edit Share Run Cancel If desired, simple clipping can be used instead of the default gamut mapping. Clipping is a naive way to fit a color as it simply truncates any color channels whose values are two big or too small. While gamut mapping via chroma compression can give better results, gamut clipping is much faster and is actually what browsers do. If your desire is to match how browsers handle out of gamut color or if you greatly value speed over correctness, clipping may be the way to go. In this example, we can change the fitting method parameter to clip . Notice the difference when compared to the previous fitting result. We now end up with a very yellow-ish color. >>> Color ( \"lch(100% 50 75)\" ) . fit ( \"srgb\" , method = \"clip\" ) color(--lch 95.816% 42.313 96.903 / 1) >>> Color ( \"lch(100% 50 75)\" ) . fit ( \"srgb\" ) color(--lch 100% 0 0 / 1) Color(\"lch(100% 50 75)\").fit(\"srgb\", method=\"clip\") Color(\"lch(100% 50 75)\").fit(\"srgb\") Edit Share Run Cancel If we wanted to change the default \"fitting\" to clip , we can also just use a class override . Doing this will cause the class to default to clip any time a color needs to be mapped. Though, you can still use chroma compression by specifying lch-chroma for the method . >>> class Custom ( Color ): ... FIT = 'clip' ... >>> Custom ( \"lch(100% 50 75)\" ) . convert ( 'srgb' ) . fit () color(srgb 1 0.959 0.62783 / 1) >>> Custom ( \"lch(100% 50 75)\" ) . convert ( 'srgb' ) . fit ( method = 'lch-chroma' ) color(srgb 1 1 1 / 1) class Custom(Color): FIT = 'clip' Custom(\"lch(100% 50 75)\").convert('srgb').fit() Custom(\"lch(100% 50 75)\").convert('srgb').fit(method='lch-chroma') Edit Share Run Cancel It is important to note that when using fit, there is no tolerance, so even if in_gamut allowed enough tolerance to consider a color within the gamut, calling fit will fit any color that is not exactly in gamut. >>> lab = Color ( 'lab(100% 0 0)' ) >>> srgb = lab . convert ( 'srgb' ) >>> srgb . in_gamut () True >>> srgb . coords () [1.0000000000000002, 0.9999999999999997, 0.9999999999999997] >>> srgb . fit () . coords () [1.0, 0.9999999999999994, 0.9999999999999997] lab = Color('lab(100% 0 0)') srgb = lab.convert('srgb') srgb.in_gamut() srgb.coords() srgb.fit().coords() Edit Share Run Cancel And much like gamut checking , we can fit a color in a different color space. >>> Color ( \"lch(100% 50 75)\" ) . fit ( 'srgb' ) color(--lch 100% 0 0 / 1) Color(\"lch(100% 50 75)\").fit('srgb') Edit Share Run Cancel When fitting in another color space, results may vary depending on what color space you are in and what color space you are using to fit the color. We went into great depths when discussing gamut checking about how transform functions from one color space to another are not always exact. We also gave quite a number of examples showing cases in which some color spaces were more sensitive to slight deviations from their gamut than others. This is mainly mentioned as fitting in one color space and round tripping back may not give exact results: >>> Color ( \"lch(100% 50 75)\" ) . convert ( 'srgb' ) . fit () . coords () [1.0, 0.9999999999999997, 0.9999999999999997] >>> Color ( \"lch(100% 50 75)\" ) . fit ( 'srgb' ) . convert ( 'srgb' ) . coords () [1.0000000000000002, 0.9999999999999994, 0.9999999999999997] Color(\"lch(100% 50 75)\").convert('srgb').fit().coords() Color(\"lch(100% 50 75)\").fit('srgb').convert('srgb').coords() Edit Share Run Cancel Depending on what you are doing, and what spaces you are working in, it may make sense to fully convert to a space and work directly in that space opposed to the indirect fitting of a color in a different color space.","title":"Mapping Colors"},{"location":"interpolation/","text":"Color Interpolation Interpolating The interpolate method allows a user to create an interpolation function. This can be used to create a list of gradient colors, or whatever is needed. This function is used to drive all the features under the interpolation umbrella. A returned interpolation function accepts an input between 0 - 1, if values are provided out of this range, the color will be extrapolated and the results may be surprising. In this example, we create an interpolation between rebeccapurple and lch ( 85 % 100 85 ) (color previews are fit to the sRGB gamut). We then step through values of 0.1 , 0.2 , 0.3 , etc. >>> i = Color ( \"rebeccapurple\" ) . interpolate ( \"lch(85% 100 85)\" , space = 'lch' ) >>> [ i ( x / 10 ) . to_string () for x in range ( 10 )] ['rgb(102 51 153)', 'rgb(142.02 45.341 154.32)', 'rgb(178.57 36.395 149.51)', 'rgb(211.1 28.455 139.17)', 'rgb(238.6 32.963 124.25)', 'rgb(255 53.081 105.76)', 'rgb(255 91.117 89.871)', 'rgb(255 123.98 77.934)', 'rgb(255 152.81 68.274)', 'rgb(255 178.34 45.626)'] i = Color(\"rebeccapurple\").interpolate(\"lch(85% 100 85)\", space='lch') [i(x/10).to_string() for x in range(10)] Edit Share Run Cancel This allows us to create a range of colors that we can use in a gradient. >>> Color ( \"rebeccapurple\" ) . interpolate ( ... \"lch(85% 100 85)\" , ... space = 'lch' ... ) <coloraide.color.interpolate.InterpolateSingle object at 0x12795f400> Color(\"rebeccapurple\").interpolate( \"lch(85% 100 85)\", space='lch' ) Edit Share Run Cancel Interpolation can also be done across multiple colors. The function, just like when interpolating between two colors, takes a range of 0 - 1. When interpolating multiple colors, piecewise interpolation is used (which is covered in more detail later). >>> Color ( 'black' ) . interpolate ([ 'red' , 'white' ]) <coloraide.color.interpolate.InterpolatePiecewise object at 0x12795f820> Color('black').interpolate(['red', 'white']) Edit Share Run Cancel If desired, we can target one or more specific channels (even alpha) for interpolation which will keep all the other base color channels constant. Specified channels must be associated with the color space in which the interpolation is taking place. In the following example, we have a base color of lch ( 52 % 58 . 1 22 . 7 ) which we then interpolate with lch ( 56 % 49 . 1 257 . 1 ) . We also specify that we want to only interpolate the hue channel by applying a mask to all the other channels except hue . Applying this logic, we will end up with a range of colors that maintains the same lightness and chroma, but with different hues. To learn more about masking and null hues, check out Null Handling . We can see as we step through the colors that only the hue is interpolated. >>> i = Color ( \"lch(52% 58.1 22.7)\" ) . interpolate ( ... Color ( \"lch(56% 49.1 257.1)\" ) . mask ( \"hue\" , invert = True ), ... space = \"lch\" ... ) >>> [ i ( x / 10 ) . to_string () for x in range ( 10 )] ['lch(52% 58.1 22.7)', 'lch(52% 58.1 10.14)', 'lch(52% 58.1 357.58)', 'lch(52% 58.1 345.02)', 'lch(52% 58.1 332.46)', 'lch(52% 58.1 319.9)', 'lch(52% 58.1 307.34)', 'lch(52% 58.1 294.78)', 'lch(52% 58.1 282.22)', 'lch(52% 58.1 269.66)'] i = Color(\"lch(52% 58.1 22.7)\").interpolate( Color(\"lch(56% 49.1 257.1)\").mask(\"hue\", invert=True), space=\"lch\" ) [i(x/10).to_string() for x in range(10)] Edit Share Run Cancel Additionally, hues are special, and we can control the way the interpolation is evaluated. The hue parameter accepts such values as shorter , longer , increasing , decreasing , and specified ( shorter being the default). Below, we can see how the interpolation varies using shorter vs longer . >>> i = Color ( \"lch(52% 58.1 22.7)\" ) . interpolate ( ... Color ( \"lch(56% 49.1 257.1)\" ) . mask ( \"hue\" , invert = True ), ... space = \"lch\" ... ) >>> i ( 0.2477 ) . to_string () lch(52% 58.1 351.59) >>> i = Color ( \"lch(52% 58.1 22.7)\" ) . interpolate ( ... Color ( \"lch(56% 49.1 257.1)\" ) . mask ( \"hue\" , invert = True ), ... space = \"lch\" , ... hue = \"longer\" ... ) >>> i ( 0.2477 ) . to_string () lch(52% 58.1 80.761) i = Color(\"lch(52% 58.1 22.7)\").interpolate( Color(\"lch(56% 49.1 257.1)\").mask(\"hue\", invert=True), space=\"lch\" ) i(0.2477).to_string() i = Color(\"lch(52% 58.1 22.7)\").interpolate( Color(\"lch(56% 49.1 257.1)\").mask(\"hue\", invert=True), space=\"lch\", hue=\"longer\" ) i(0.2477).to_string() Edit Share Run Cancel To help visualize the different hue methods, consider the following evaluation between rebeccapurple and lch ( 85 % 85 805 ) . Below we will demonstrate each of the different hue evaluations. To learn more check out the CSS level 4 specification to learn more about each one. shorter >>> Color ( \"rebeccapurple\" ) . interpolate ( ... \"lch(85% 100 805)\" , ... space = 'lch' , ... hue = \"shorter\" ... ) <coloraide.color.interpolate.InterpolateSingle object at 0x127718f10> Color(\"rebeccapurple\").interpolate( \"lch(85% 100 805)\", space='lch', hue=\"shorter\" ) Edit Share Run Cancel longer >>> Color ( \"rebeccapurple\" ) . interpolate ( ... \"lch(85% 100 805)\" , ... space = 'lch' , ... hue = \"longer\" ... ) <coloraide.color.interpolate.InterpolateSingle object at 0x1276ce160> Color(\"rebeccapurple\").interpolate( \"lch(85% 100 805)\", space='lch', hue=\"longer\" ) Edit Share Run Cancel increasing >>> Color ( \"rebeccapurple\" ) . interpolate ( ... \"lch(85% 100 805)\" , ... space = 'lch' , ... hue = \"increasing\" ... ) <coloraide.color.interpolate.InterpolateSingle object at 0x1276caaf0> Color(\"rebeccapurple\").interpolate( \"lch(85% 100 805)\", space='lch', hue=\"increasing\" ) Edit Share Run Cancel decreasing >>> Color ( \"rebeccapurple\" ) . interpolate ( ... \"lch(85% 100 805)\" , ... space = 'lch' , ... hue = \"decreasing\" ... ) <coloraide.color.interpolate.InterpolateSingle object at 0x1276caac0> Color(\"rebeccapurple\").interpolate( \"lch(85% 100 805)\", space='lch', hue=\"decreasing\" ) Edit Share Run Cancel specified >>> Color ( \"rebeccapurple\" ) . interpolate ( ... \"lch(85% 100 805)\" , ... space = 'lch' , ... hue = \"specified\" ... ) <coloraide.color.interpolate.InterpolateSingle object at 0x12795f160> Color(\"rebeccapurple\").interpolate( \"lch(85% 100 805)\", space='lch', hue=\"specified\" ) Edit Share Run Cancel We can also apply easing functions by providing a function via progress . Here we use a function that returns t ** 3 for the period when interpolating each channel: >>> Color ( \"lch(50% 50 0)\" ) . interpolate ( ... \"lch(90% 50 20)\" , ... progress = lambda t : t ** 3 ... ) <coloraide.color.interpolate.InterpolateSingle object at 0x12795ff40> Color(\"lch(50% 50 0)\").interpolate( \"lch(90% 50 20)\", progress=lambda t: t ** 3 ) Edit Share Run Cancel We can even apply a specific easing functions to a specific channels. Below, we apply t ** 3 to alpha while t (the default) is applied to all other channels. This can be done to one or more channels, all with different functions. >>> Color ( \"lch(50% 50 0)\" ) . interpolate ( ... \"lch(90% 50 20 / 0)\" , ... progress = { ... 'alpha' : lambda t : t ** 3 ... } ... ) <coloraide.color.interpolate.InterpolateSingle object at 0x12794cf10> Color(\"lch(50% 50 0)\").interpolate( \"lch(90% 50 20 / 0)\", progress={ 'alpha': lambda t: t ** 3 } ) Edit Share Run Cancel You can also set all the channels to a function via all and then override specific channels. >>> Color ( \"lch(50% 50 0)\" ) . interpolate ( ... \"lch(90% 50 20 / 0)\" , ... progress = { ... 'all' : lambda t : 1 - t , ... 'alpha' : lambda t : t ** 3 ... } ... ) <coloraide.color.interpolate.InterpolateSingle object at 0x127335f10> Color(\"lch(50% 50 0)\").interpolate( \"lch(90% 50 20 / 0)\", progress={ 'all': lambda t: 1 - t, 'alpha': lambda t: t ** 3 } ) Edit Share Run Cancel Mixing Colors can be mixed together to create new colors. Mixing is built on top of the interpolate function and will return a color between the current and specified color. If colors are requested to be interpolated within a color space smaller than the original, the colors will be gamut mapped into the desired color space. Tip Mix, just like interpolation, also accepts the accept and hue parameters. As an example, if we had the color red and the color blue , and we wanted to mix them, we can just call the mix method, and we'll get: >>> Color ( \"red\" ) . mix ( Color ( \"blue\" )) color(srgb 0.75682 -0.1157 0.53399 / 1) Color(\"red\").mix(Color(\"blue\")) Edit Share Run Cancel The mix method will mix the two colors in the CIELAB color space by default. If needed, a different color space can be specified with the space parameter. Notice below that this creates a different color. The results of mixing in a different color space may be more desirable as color mixing may be more natural. >>> Color ( \"red\" ) . mix ( Color ( \"blue\" ), space = \"lch\" ) color(srgb 0.96063 -0.39552 0.52587 / 1) Color(\"red\").mix(Color(\"blue\"), space=\"lch\") Edit Share Run Cancel By default, colors are mixed at 50%, but the percentage can be controlled. Here we mix the color blue into the color red at 20%. This gives us the color of rgb ( 204 0 51 ) (after fitting). >>> Color ( \"red\" ) . mix ( Color ( \"blue\" ), 0.2 ) color(srgb 0.91305 -0.08549 0.26445 / 1) Color(\"red\").mix(Color(\"blue\"), 0.2) Edit Share Run Cancel Mix can also accept a string and will create the color for us which is great if we don't need to work with the second color afterwards. >>> Color ( \"red\" ) . mix ( \"blue\" , 0.2 ) color(srgb 0.91305 -0.08549 0.26445 / 1) Color(\"red\").mix(\"blue\", 0.2) Edit Share Run Cancel Mixing will always return a new color unless in_place is set True . Steps The steps method creates a list of discrete colors. Like mixing, it is also built on interpolate . Just provide two colors, and specify how many steps are wanted. >>> Color ( \"red\" ) . steps ( \"blue\" , steps = 10 ) [color(srgb 1 0 0 / 1), color(srgb 0.95272 -0.0596 0.17632 / 1), color(srgb 0.9028 -0.09018 0.28511 / 1), color(srgb 0.84898 -0.10673 0.38542 / 1), color(srgb 0.78947 -0.11454 0.48433 / 1), color(srgb 0.72167 -0.11509 0.58396 / 1), color(srgb 0.64127 -0.10831 0.68512 / 1), color(srgb 0.54001 -0.09254 0.78812 / 1), color(srgb 0.39654 -0.06222 0.89308 / 1), color(srgb 0 0 1 / 1)] Color(\"red\").steps(\"blue\", steps=10) Edit Share Run Cancel If desired, multiple colors can be provided, and steps will be returned for all the interpolation regions. When interpolating multiple colors, piecewise interpolation is used (which is covered in more detail later). >>> Color ( \"red\" ) . steps ([ \"orange\" , \"yellow\" , \"green\" ], steps = 10 ) [color(srgb 1 0 0 / 1), color(srgb 1.0074 0.34698 -0.01707 / 1), color(srgb 1.0078 0.50984 -0.01863 / 1), color(srgb 1 0.64706 0 / 1), color(srgb 1.0072 0.76726 -0.00616 / 1), color(srgb 1.0075 0.88437 -0.00657 / 1), color(srgb 1 1 0 / 1), color(srgb 0.71125 0.83172 -0.00637 / 1), color(srgb 0.42248 0.66583 -0.00518 / 1), color(srgb 0 0.50196 0 / 1)] Color(\"red\").steps([\"orange\", \"yellow\", \"green\"], steps=10) Edit Share Run Cancel Steps can also be configured to return colors based on a maximum Delta E distance. This means you can ensure the distance between all colors is no greater than a certain value. In this example, we specify the color color ( display-p3 0 1 0 ) and interpolate steps between red . The result gives us an array of colors, where the distance between any two colors should be no greater than the Delta E result of 10. >>> Color ( \"display-p3\" , [ 0 , 1 , 0 ]) . steps ( ... \"red\" , ... space = \"lch\" , ... out_space = \"srgb\" , ... max_delta_e = 10 ... ) [color(srgb -0.5116 1.0183 -0.31067 / 1), color(srgb -0.46346 1.0029 -0.32404 / 1), color(srgb -0.40809 0.98732 -0.33344 / 1), color(srgb -0.34139 0.97149 -0.33975 / 1), color(srgb -0.25333 0.95542 -0.34363 / 1), color(srgb -0.09291 0.9391 -0.34554 / 1), color(srgb 0.20395 0.92252 -0.34587 / 1), color(srgb 0.30881 0.90567 -0.3449 / 1), color(srgb 0.38262 0.88855 -0.34288 / 1), color(srgb 0.44216 0.87114 -0.34031 / 1), color(srgb 0.49308 0.85343 -0.33745 / 1), color(srgb 0.53801 0.83543 -0.33432 / 1), color(srgb 0.57843 0.81711 -0.3309 / 1), color(srgb 0.61529 0.79848 -0.3272 / 1), color(srgb 0.6492 0.77953 -0.3232 / 1), color(srgb 0.6806 0.76025 -0.3189 / 1), color(srgb 0.7098 0.74064 -0.3143 / 1), color(srgb 0.73704 0.72068 -0.30938 / 1), color(srgb 0.76251 0.70037 -0.30415 / 1), color(srgb 0.78634 0.6797 -0.2986 / 1), color(srgb 0.80865 0.65865 -0.29271 / 1), color(srgb 0.82951 0.63722 -0.28647 / 1), color(srgb 0.84901 0.61539 -0.27988 / 1), color(srgb 0.86719 0.59316 -0.27292 / 1), color(srgb 0.8841 0.57048 -0.26557 / 1), color(srgb 0.89978 0.54736 -0.25782 / 1), color(srgb 0.91427 0.52375 -0.24963 / 1), color(srgb 0.92758 0.49962 -0.241 / 1), color(srgb 0.93973 0.47493 -0.23187 / 1), color(srgb 0.95075 0.44961 -0.2222 / 1), color(srgb 0.96064 0.4236 -0.21195 / 1), color(srgb 0.96942 0.39678 -0.20105 / 1), color(srgb 0.97711 0.36904 -0.1894 / 1), color(srgb 0.98371 0.34016 -0.17689 / 1), color(srgb 0.98924 0.30989 -0.16335 / 1), color(srgb 0.99369 0.27779 -0.14854 / 1), color(srgb 0.99709 0.24321 -0.13211 / 1), color(srgb 0.99942 0.20495 -0.11292 / 1), color(srgb 1.0007 0.1606 -0.08857 / 1), color(srgb 1.0009 0.1035 -0.05395 / 1), color(srgb 1 0 0 / 1)] Color(\"display-p3\", [0, 1, 0]).steps( \"red\", space=\"lch\", out_space=\"srgb\", max_delta_e=10 ) Edit Share Run Cancel max_steps can be used to limit the results of max_delta_e . Obviously, this affects the Delta E between the colors inversely. >>> Color ( \"display-p3\" , [ 0 , 1 , 0 ]) . steps ( ... \"red\" , ... space = \"lch\" , ... out_space = \"srgb\" , ... max_delta_e = 10 , ... max_steps = 10 ... ) [color(srgb -0.5116 1.0183 -0.31067 / 1), color(srgb -0.19966 0.9482 -0.34469 / 1), color(srgb 0.43603 0.87309 -0.34061 / 1), color(srgb 0.6269 0.7922 -0.3259 / 1), color(srgb 0.757 0.70491 -0.30534 / 1), color(srgb 0.85316 0.61049 -0.27836 / 1), color(srgb 0.92327 0.50772 -0.24393 / 1), color(srgb 0.97033 0.39375 -0.19979 / 1), color(srgb 0.99571 0.25894 -0.13964 / 1), color(srgb 1 0 0 / 1)] Color(\"display-p3\", [0, 1, 0]).steps( \"red\", space=\"lch\", out_space=\"srgb\", max_delta_e=10, max_steps=10 ) Edit Share Run Cancel When specifying a max_delta_e , steps will function as a minimum required steps and will push the delta even smaller if the required steps is greater than the calculated maximum Delta E. >>> Color ( \"display-p3\" , [ 0 , 1 , 0 ]) . steps ( ... \"red\" , ... space = \"lch\" , ... out_space = \"srgb\" , ... max_delta_e = 10 , ... steps = 50 ... ) [color(srgb -0.5116 1.0183 -0.31067 / 1), color(srgb -0.47276 1.0057 -0.32192 / 1), color(srgb -0.42946 0.99307 -0.33039 / 1), color(srgb -0.37992 0.98024 -0.33661 / 1), color(srgb -0.32082 0.96725 -0.341 / 1), color(srgb -0.24447 0.9541 -0.34385 / 1), color(srgb -0.1198 0.94078 -0.34542 / 1), color(srgb 0.15996 0.92729 -0.34592 / 1), color(srgb 0.26558 0.91362 -0.3455 / 1), color(srgb 0.33665 0.89976 -0.34431 / 1), color(srgb 0.3931 0.88572 -0.34248 / 1), color(srgb 0.44104 0.8715 -0.34036 / 1), color(srgb 0.48324 0.85707 -0.33806 / 1), color(srgb 0.52118 0.84244 -0.33557 / 1), color(srgb 0.55582 0.82761 -0.33289 / 1), color(srgb 0.58776 0.81258 -0.33002 / 1), color(srgb 0.61745 0.79733 -0.32696 / 1), color(srgb 0.64519 0.78187 -0.32371 / 1), color(srgb 0.67123 0.76619 -0.32025 / 1), color(srgb 0.69575 0.75029 -0.31659 / 1), color(srgb 0.7189 0.73416 -0.31273 / 1), color(srgb 0.74079 0.7178 -0.30866 / 1), color(srgb 0.76151 0.7012 -0.30437 / 1), color(srgb 0.78113 0.68437 -0.29987 / 1), color(srgb 0.79972 0.66729 -0.29515 / 1), color(srgb 0.81733 0.64995 -0.2902 / 1), color(srgb 0.834 0.63236 -0.28502 / 1), color(srgb 0.84977 0.6145 -0.2796 / 1), color(srgb 0.86467 0.59636 -0.27393 / 1), color(srgb 0.87872 0.57794 -0.26801 / 1), color(srgb 0.89194 0.55922 -0.26182 / 1), color(srgb 0.90434 0.54018 -0.25536 / 1), color(srgb 0.91596 0.52082 -0.2486 / 1), color(srgb 0.92679 0.50111 -0.24154 / 1), color(srgb 0.93686 0.48103 -0.23415 / 1), color(srgb 0.94616 0.46054 -0.22641 / 1), color(srgb 0.95471 0.43961 -0.2183 / 1), color(srgb 0.96252 0.41819 -0.20979 / 1), color(srgb 0.96959 0.39623 -0.20082 / 1), color(srgb 0.97593 0.37364 -0.19136 / 1), color(srgb 0.98155 0.35032 -0.18134 / 1), color(srgb 0.98644 0.32615 -0.17067 / 1), color(srgb 0.99062 0.30093 -0.15926 / 1), color(srgb 0.99409 0.27439 -0.14694 / 1), color(srgb 0.99685 0.24615 -0.13353 / 1), color(srgb 0.99891 0.21556 -0.11841 / 1), color(srgb 1.0002 0.18152 -0.10034 / 1), color(srgb 1.0009 0.14177 -0.07755 / 1), color(srgb 1.0008 0.09013 -0.04535 / 1), color(srgb 1 0 0 / 1)] Color(\"display-p3\", [0, 1, 0]).steps( \"red\", space=\"lch\", out_space=\"srgb\", max_delta_e=10, steps=50 ) Edit Share Run Cancel The default delta E method is Delta E 76, which is a simple euclidean distancing in the CIELAB color space. While a Delta E 2000 is far more accurate, it is a much more expensive operation. Piecewise Interpolation The interploate and steps method allows for piecewise interpolation across multiple color ranges. Anytime, multiple colors are provided via a list, the piecewise logic will be applied to the various segments. >>> Color ( 'red' ) . interpolate ([ 'white' , 'black' , 'blue' ]) <coloraide.color.interpolate.InterpolatePiecewise object at 0x12795f670> Color('red').interpolate(['white', 'black', 'blue']) Edit Share Run Cancel The interpolation between each pair of colors defaults to using the options provided via the interpolate parameters, but you can change them for a given range by using the Piecewise object. For instance, we could apply an easing between just the white and black . Notice that Piecewise is applied to the second color in the range, and the options will only apply to the interpolation of that color and the color immediately before it. >>> Color ( 'red' ) . interpolate ([ 'white' , Piecewise ( 'black' , progress = lambda t : t * ( 2 - t )), 'blue' ]) <coloraide.color.interpolate.InterpolatePiecewise object at 0x12794c9d0> Color('red').interpolate(['white', Piecewise('black', progress=lambda t: t * (2 - t)), 'blue']) Edit Share Run Cancel Additionally, you can set color stops using the stop parameter. To set the stop on the base color, simply set the stop parameter in the interploate method. >>> Color ( 'red' ) . interpolate ([ Piecewise ( 'white' , 0.6 ), Piecewise ( 'black' , 0.8 ), 'blue' ], stop = 0.4 ) <coloraide.color.interpolate.InterpolatePiecewise object at 0x1276cac70> Color('red').interpolate([Piecewise('white', 0.6), Piecewise('black', 0.8), 'blue'], stop=0.4) Edit Share Run Cancel As previously mentioned, this can also be applied to steps as well. >>> Color ( 'red' ) . steps ([ Piecewise ( 'white' , 0.6 ), Piecewise ( 'black' , 0.8 ), 'blue' ], stop = 0.4 , steps = 15 ) [color(srgb 1 0 0 / 1), color(srgb 1 0 0 / 1), color(srgb 1 0 0 / 1), color(srgb 1 0 0 / 1), color(srgb 1 0 0 / 1), color(srgb 1 0 0 / 1), color(srgb 1.0271 0.29998 0.16978 / 1), color(srgb 1.0626 0.62412 0.50306 / 1), color(srgb 1.0355 0.89487 0.85334 / 1), color(srgb 0.7623 0.7623 0.7623 / 1), color(srgb 0.39678 0.39678 0.39678 / 1), color(srgb 0.08542 0.08542 0.08542 / 1), color(srgb 0.10804 0.05743 0.26725 / 1), color(srgb 0.13752 0.05966 0.61311 / 1), color(srgb 0 0 1 / 1)] Color('red').steps([Piecewise('white', 0.6), Piecewise('black', 0.8), 'blue'], stop=0.4, steps=15) Edit Share Run Cancel Null/ NaN Handling Color spaces that have hue coordinates often have rules about when the hue is considered relevant. For instance, in the HSL color space, if saturation is zero, the hue is considered null. This is because the color is \"without color\" or achromatic; therefore, it has no hue, or the hue is undefined. Many libraries, like d3-color , chroma.js , and color.js , represent null hues with NaN (not a number). This is usually done to make color interpolation easier. Some, like d3-color, are a bit more liberal with NaN and will target special cases that are above and beyond the normal rules to help ensure good interpolation. For instance, they not only mark hue null on HSL colors when saturation is zero, but also when lightness is zero or one hundred (essentially appearing black or white). In fact, they'll mark saturation as NaN when lightness indicates \"black\" or \"white\". ColorAide also uses NaN , or in Python float ( 'nan' ) . In certain situations, when a hue is deemed undefined, the hue value will be set to coloraide.NaN , which is just a constant containing float ( 'nan' ) . When interpolating, if one color's channel has a NaN , the other color's channel will be used as the result. If both colors have a NaN for the same channel, then 0 will be returned. Notice that in this example, because white's saturation is zero, the hue is undefined. Because the hue is undefined, when the color is mixed with a second color ( purple ), the hue of the second color is used. >>> color = Color ( 'white' ) . convert ( 'hsl' ) >>> color . coords () [nan, 0.0, 100.0] >>> color2 = Color ( 'purple' ) . convert ( 'hsl' ) >>> color2 . coords () [300.0, 100.0, 25.098039215686274] >>> color . mix ( color2 , space = \"hsl\" ) color(--hsl 300 50% 62.549% / 1) color = Color('white').convert('hsl') color.coords() color2 = Color('purple').convert('hsl') color2.coords() color.mix(color2, space=\"hsl\") Edit Share Run Cancel Technically, any channel can be set to NaN . This is basically what the mask method is used for. It can set any and all specified channels to NaN for the purpose of restricting channels when interpolating: >>> Color ( 'white' ) . mask ([ 'red' , 'green' ]) . coords () [nan, nan, 1.0] Color('white').mask(['red', 'green']).coords() Edit Share Run Cancel Channels can also be set directly to NaN , but it must be done by instantiating a Color object with raw data or by manually setting it via a channel property or accessor. CSS input string do not allow the NaN values at this time. >>> from coloraide import NaN >>> Color ( \"srgb\" , [ 1 , NaN , 1 ]) . coords () [1.0, nan, 1.0] >>> Color ( \"red\" ) . set ( 'green' , NaN ) . coords () [1.0, nan, 0.0] from coloraide import NaN Color(\"srgb\", [1, NaN, 1]).coords() Color(\"red\").set('green', NaN).coords() Edit Share Run Cancel When printing to a string, NaN s are always converted to 0 : >>> from coloraide import NaN >>> Color ( \"srgb\" , [ 1 , NaN , 1 ]) color(srgb 1 0 1 / 1) from coloraide import NaN Color(\"srgb\", [1, NaN, 1]) Edit Share Run Cancel At any time, a channel can be checked for whether it is NaN by using the is_nan method: >>> Color ( \"white\" ) . convert ( 'hsl' ) . is_nan ( 'hue' ) True Color(\"white\").convert('hsl').is_nan('hue') Edit Share Run Cancel It can be useful to check whether a channel is NaN as NaN values can't be added, subtracted, multiplied, etc. They will always return NaN unless you directly replace them. >>> color = Color ( \"white\" ) . convert ( 'hsl' ) >>> color . hue = color . hue + 3 >>> color . is_nan ( 'hue' ) True >>> color . hue = 3 >>> color . is_nan ( 'hue' ) False color = Color(\"white\").convert('hsl') color.hue = color.hue + 3 color.is_nan('hue') color.hue = 3 color.is_nan('hue') Edit Share Run Cancel","title":"Color Interpolation"},{"location":"interpolation/#color-interpolation","text":"","title":"Color Interpolation"},{"location":"interpolation/#interpolating","text":"The interpolate method allows a user to create an interpolation function. This can be used to create a list of gradient colors, or whatever is needed. This function is used to drive all the features under the interpolation umbrella. A returned interpolation function accepts an input between 0 - 1, if values are provided out of this range, the color will be extrapolated and the results may be surprising. In this example, we create an interpolation between rebeccapurple and lch ( 85 % 100 85 ) (color previews are fit to the sRGB gamut). We then step through values of 0.1 , 0.2 , 0.3 , etc. >>> i = Color ( \"rebeccapurple\" ) . interpolate ( \"lch(85% 100 85)\" , space = 'lch' ) >>> [ i ( x / 10 ) . to_string () for x in range ( 10 )] ['rgb(102 51 153)', 'rgb(142.02 45.341 154.32)', 'rgb(178.57 36.395 149.51)', 'rgb(211.1 28.455 139.17)', 'rgb(238.6 32.963 124.25)', 'rgb(255 53.081 105.76)', 'rgb(255 91.117 89.871)', 'rgb(255 123.98 77.934)', 'rgb(255 152.81 68.274)', 'rgb(255 178.34 45.626)'] i = Color(\"rebeccapurple\").interpolate(\"lch(85% 100 85)\", space='lch') [i(x/10).to_string() for x in range(10)] Edit Share Run Cancel This allows us to create a range of colors that we can use in a gradient. >>> Color ( \"rebeccapurple\" ) . interpolate ( ... \"lch(85% 100 85)\" , ... space = 'lch' ... ) <coloraide.color.interpolate.InterpolateSingle object at 0x12795f400> Color(\"rebeccapurple\").interpolate( \"lch(85% 100 85)\", space='lch' ) Edit Share Run Cancel Interpolation can also be done across multiple colors. The function, just like when interpolating between two colors, takes a range of 0 - 1. When interpolating multiple colors, piecewise interpolation is used (which is covered in more detail later). >>> Color ( 'black' ) . interpolate ([ 'red' , 'white' ]) <coloraide.color.interpolate.InterpolatePiecewise object at 0x12795f820> Color('black').interpolate(['red', 'white']) Edit Share Run Cancel If desired, we can target one or more specific channels (even alpha) for interpolation which will keep all the other base color channels constant. Specified channels must be associated with the color space in which the interpolation is taking place. In the following example, we have a base color of lch ( 52 % 58 . 1 22 . 7 ) which we then interpolate with lch ( 56 % 49 . 1 257 . 1 ) . We also specify that we want to only interpolate the hue channel by applying a mask to all the other channels except hue . Applying this logic, we will end up with a range of colors that maintains the same lightness and chroma, but with different hues. To learn more about masking and null hues, check out Null Handling . We can see as we step through the colors that only the hue is interpolated. >>> i = Color ( \"lch(52% 58.1 22.7)\" ) . interpolate ( ... Color ( \"lch(56% 49.1 257.1)\" ) . mask ( \"hue\" , invert = True ), ... space = \"lch\" ... ) >>> [ i ( x / 10 ) . to_string () for x in range ( 10 )] ['lch(52% 58.1 22.7)', 'lch(52% 58.1 10.14)', 'lch(52% 58.1 357.58)', 'lch(52% 58.1 345.02)', 'lch(52% 58.1 332.46)', 'lch(52% 58.1 319.9)', 'lch(52% 58.1 307.34)', 'lch(52% 58.1 294.78)', 'lch(52% 58.1 282.22)', 'lch(52% 58.1 269.66)'] i = Color(\"lch(52% 58.1 22.7)\").interpolate( Color(\"lch(56% 49.1 257.1)\").mask(\"hue\", invert=True), space=\"lch\" ) [i(x/10).to_string() for x in range(10)] Edit Share Run Cancel Additionally, hues are special, and we can control the way the interpolation is evaluated. The hue parameter accepts such values as shorter , longer , increasing , decreasing , and specified ( shorter being the default). Below, we can see how the interpolation varies using shorter vs longer . >>> i = Color ( \"lch(52% 58.1 22.7)\" ) . interpolate ( ... Color ( \"lch(56% 49.1 257.1)\" ) . mask ( \"hue\" , invert = True ), ... space = \"lch\" ... ) >>> i ( 0.2477 ) . to_string () lch(52% 58.1 351.59) >>> i = Color ( \"lch(52% 58.1 22.7)\" ) . interpolate ( ... Color ( \"lch(56% 49.1 257.1)\" ) . mask ( \"hue\" , invert = True ), ... space = \"lch\" , ... hue = \"longer\" ... ) >>> i ( 0.2477 ) . to_string () lch(52% 58.1 80.761) i = Color(\"lch(52% 58.1 22.7)\").interpolate( Color(\"lch(56% 49.1 257.1)\").mask(\"hue\", invert=True), space=\"lch\" ) i(0.2477).to_string() i = Color(\"lch(52% 58.1 22.7)\").interpolate( Color(\"lch(56% 49.1 257.1)\").mask(\"hue\", invert=True), space=\"lch\", hue=\"longer\" ) i(0.2477).to_string() Edit Share Run Cancel To help visualize the different hue methods, consider the following evaluation between rebeccapurple and lch ( 85 % 85 805 ) . Below we will demonstrate each of the different hue evaluations. To learn more check out the CSS level 4 specification to learn more about each one. shorter >>> Color ( \"rebeccapurple\" ) . interpolate ( ... \"lch(85% 100 805)\" , ... space = 'lch' , ... hue = \"shorter\" ... ) <coloraide.color.interpolate.InterpolateSingle object at 0x127718f10> Color(\"rebeccapurple\").interpolate( \"lch(85% 100 805)\", space='lch', hue=\"shorter\" ) Edit Share Run Cancel longer >>> Color ( \"rebeccapurple\" ) . interpolate ( ... \"lch(85% 100 805)\" , ... space = 'lch' , ... hue = \"longer\" ... ) <coloraide.color.interpolate.InterpolateSingle object at 0x1276ce160> Color(\"rebeccapurple\").interpolate( \"lch(85% 100 805)\", space='lch', hue=\"longer\" ) Edit Share Run Cancel increasing >>> Color ( \"rebeccapurple\" ) . interpolate ( ... \"lch(85% 100 805)\" , ... space = 'lch' , ... hue = \"increasing\" ... ) <coloraide.color.interpolate.InterpolateSingle object at 0x1276caaf0> Color(\"rebeccapurple\").interpolate( \"lch(85% 100 805)\", space='lch', hue=\"increasing\" ) Edit Share Run Cancel decreasing >>> Color ( \"rebeccapurple\" ) . interpolate ( ... \"lch(85% 100 805)\" , ... space = 'lch' , ... hue = \"decreasing\" ... ) <coloraide.color.interpolate.InterpolateSingle object at 0x1276caac0> Color(\"rebeccapurple\").interpolate( \"lch(85% 100 805)\", space='lch', hue=\"decreasing\" ) Edit Share Run Cancel specified >>> Color ( \"rebeccapurple\" ) . interpolate ( ... \"lch(85% 100 805)\" , ... space = 'lch' , ... hue = \"specified\" ... ) <coloraide.color.interpolate.InterpolateSingle object at 0x12795f160> Color(\"rebeccapurple\").interpolate( \"lch(85% 100 805)\", space='lch', hue=\"specified\" ) Edit Share Run Cancel We can also apply easing functions by providing a function via progress . Here we use a function that returns t ** 3 for the period when interpolating each channel: >>> Color ( \"lch(50% 50 0)\" ) . interpolate ( ... \"lch(90% 50 20)\" , ... progress = lambda t : t ** 3 ... ) <coloraide.color.interpolate.InterpolateSingle object at 0x12795ff40> Color(\"lch(50% 50 0)\").interpolate( \"lch(90% 50 20)\", progress=lambda t: t ** 3 ) Edit Share Run Cancel We can even apply a specific easing functions to a specific channels. Below, we apply t ** 3 to alpha while t (the default) is applied to all other channels. This can be done to one or more channels, all with different functions. >>> Color ( \"lch(50% 50 0)\" ) . interpolate ( ... \"lch(90% 50 20 / 0)\" , ... progress = { ... 'alpha' : lambda t : t ** 3 ... } ... ) <coloraide.color.interpolate.InterpolateSingle object at 0x12794cf10> Color(\"lch(50% 50 0)\").interpolate( \"lch(90% 50 20 / 0)\", progress={ 'alpha': lambda t: t ** 3 } ) Edit Share Run Cancel You can also set all the channels to a function via all and then override specific channels. >>> Color ( \"lch(50% 50 0)\" ) . interpolate ( ... \"lch(90% 50 20 / 0)\" , ... progress = { ... 'all' : lambda t : 1 - t , ... 'alpha' : lambda t : t ** 3 ... } ... ) <coloraide.color.interpolate.InterpolateSingle object at 0x127335f10> Color(\"lch(50% 50 0)\").interpolate( \"lch(90% 50 20 / 0)\", progress={ 'all': lambda t: 1 - t, 'alpha': lambda t: t ** 3 } ) Edit Share Run Cancel","title":"Interpolating"},{"location":"interpolation/#mixing","text":"Colors can be mixed together to create new colors. Mixing is built on top of the interpolate function and will return a color between the current and specified color. If colors are requested to be interpolated within a color space smaller than the original, the colors will be gamut mapped into the desired color space. Tip Mix, just like interpolation, also accepts the accept and hue parameters. As an example, if we had the color red and the color blue , and we wanted to mix them, we can just call the mix method, and we'll get: >>> Color ( \"red\" ) . mix ( Color ( \"blue\" )) color(srgb 0.75682 -0.1157 0.53399 / 1) Color(\"red\").mix(Color(\"blue\")) Edit Share Run Cancel The mix method will mix the two colors in the CIELAB color space by default. If needed, a different color space can be specified with the space parameter. Notice below that this creates a different color. The results of mixing in a different color space may be more desirable as color mixing may be more natural. >>> Color ( \"red\" ) . mix ( Color ( \"blue\" ), space = \"lch\" ) color(srgb 0.96063 -0.39552 0.52587 / 1) Color(\"red\").mix(Color(\"blue\"), space=\"lch\") Edit Share Run Cancel By default, colors are mixed at 50%, but the percentage can be controlled. Here we mix the color blue into the color red at 20%. This gives us the color of rgb ( 204 0 51 ) (after fitting). >>> Color ( \"red\" ) . mix ( Color ( \"blue\" ), 0.2 ) color(srgb 0.91305 -0.08549 0.26445 / 1) Color(\"red\").mix(Color(\"blue\"), 0.2) Edit Share Run Cancel Mix can also accept a string and will create the color for us which is great if we don't need to work with the second color afterwards. >>> Color ( \"red\" ) . mix ( \"blue\" , 0.2 ) color(srgb 0.91305 -0.08549 0.26445 / 1) Color(\"red\").mix(\"blue\", 0.2) Edit Share Run Cancel Mixing will always return a new color unless in_place is set True .","title":"Mixing"},{"location":"interpolation/#steps","text":"The steps method creates a list of discrete colors. Like mixing, it is also built on interpolate . Just provide two colors, and specify how many steps are wanted. >>> Color ( \"red\" ) . steps ( \"blue\" , steps = 10 ) [color(srgb 1 0 0 / 1), color(srgb 0.95272 -0.0596 0.17632 / 1), color(srgb 0.9028 -0.09018 0.28511 / 1), color(srgb 0.84898 -0.10673 0.38542 / 1), color(srgb 0.78947 -0.11454 0.48433 / 1), color(srgb 0.72167 -0.11509 0.58396 / 1), color(srgb 0.64127 -0.10831 0.68512 / 1), color(srgb 0.54001 -0.09254 0.78812 / 1), color(srgb 0.39654 -0.06222 0.89308 / 1), color(srgb 0 0 1 / 1)] Color(\"red\").steps(\"blue\", steps=10) Edit Share Run Cancel If desired, multiple colors can be provided, and steps will be returned for all the interpolation regions. When interpolating multiple colors, piecewise interpolation is used (which is covered in more detail later). >>> Color ( \"red\" ) . steps ([ \"orange\" , \"yellow\" , \"green\" ], steps = 10 ) [color(srgb 1 0 0 / 1), color(srgb 1.0074 0.34698 -0.01707 / 1), color(srgb 1.0078 0.50984 -0.01863 / 1), color(srgb 1 0.64706 0 / 1), color(srgb 1.0072 0.76726 -0.00616 / 1), color(srgb 1.0075 0.88437 -0.00657 / 1), color(srgb 1 1 0 / 1), color(srgb 0.71125 0.83172 -0.00637 / 1), color(srgb 0.42248 0.66583 -0.00518 / 1), color(srgb 0 0.50196 0 / 1)] Color(\"red\").steps([\"orange\", \"yellow\", \"green\"], steps=10) Edit Share Run Cancel Steps can also be configured to return colors based on a maximum Delta E distance. This means you can ensure the distance between all colors is no greater than a certain value. In this example, we specify the color color ( display-p3 0 1 0 ) and interpolate steps between red . The result gives us an array of colors, where the distance between any two colors should be no greater than the Delta E result of 10. >>> Color ( \"display-p3\" , [ 0 , 1 , 0 ]) . steps ( ... \"red\" , ... space = \"lch\" , ... out_space = \"srgb\" , ... max_delta_e = 10 ... ) [color(srgb -0.5116 1.0183 -0.31067 / 1), color(srgb -0.46346 1.0029 -0.32404 / 1), color(srgb -0.40809 0.98732 -0.33344 / 1), color(srgb -0.34139 0.97149 -0.33975 / 1), color(srgb -0.25333 0.95542 -0.34363 / 1), color(srgb -0.09291 0.9391 -0.34554 / 1), color(srgb 0.20395 0.92252 -0.34587 / 1), color(srgb 0.30881 0.90567 -0.3449 / 1), color(srgb 0.38262 0.88855 -0.34288 / 1), color(srgb 0.44216 0.87114 -0.34031 / 1), color(srgb 0.49308 0.85343 -0.33745 / 1), color(srgb 0.53801 0.83543 -0.33432 / 1), color(srgb 0.57843 0.81711 -0.3309 / 1), color(srgb 0.61529 0.79848 -0.3272 / 1), color(srgb 0.6492 0.77953 -0.3232 / 1), color(srgb 0.6806 0.76025 -0.3189 / 1), color(srgb 0.7098 0.74064 -0.3143 / 1), color(srgb 0.73704 0.72068 -0.30938 / 1), color(srgb 0.76251 0.70037 -0.30415 / 1), color(srgb 0.78634 0.6797 -0.2986 / 1), color(srgb 0.80865 0.65865 -0.29271 / 1), color(srgb 0.82951 0.63722 -0.28647 / 1), color(srgb 0.84901 0.61539 -0.27988 / 1), color(srgb 0.86719 0.59316 -0.27292 / 1), color(srgb 0.8841 0.57048 -0.26557 / 1), color(srgb 0.89978 0.54736 -0.25782 / 1), color(srgb 0.91427 0.52375 -0.24963 / 1), color(srgb 0.92758 0.49962 -0.241 / 1), color(srgb 0.93973 0.47493 -0.23187 / 1), color(srgb 0.95075 0.44961 -0.2222 / 1), color(srgb 0.96064 0.4236 -0.21195 / 1), color(srgb 0.96942 0.39678 -0.20105 / 1), color(srgb 0.97711 0.36904 -0.1894 / 1), color(srgb 0.98371 0.34016 -0.17689 / 1), color(srgb 0.98924 0.30989 -0.16335 / 1), color(srgb 0.99369 0.27779 -0.14854 / 1), color(srgb 0.99709 0.24321 -0.13211 / 1), color(srgb 0.99942 0.20495 -0.11292 / 1), color(srgb 1.0007 0.1606 -0.08857 / 1), color(srgb 1.0009 0.1035 -0.05395 / 1), color(srgb 1 0 0 / 1)] Color(\"display-p3\", [0, 1, 0]).steps( \"red\", space=\"lch\", out_space=\"srgb\", max_delta_e=10 ) Edit Share Run Cancel max_steps can be used to limit the results of max_delta_e . Obviously, this affects the Delta E between the colors inversely. >>> Color ( \"display-p3\" , [ 0 , 1 , 0 ]) . steps ( ... \"red\" , ... space = \"lch\" , ... out_space = \"srgb\" , ... max_delta_e = 10 , ... max_steps = 10 ... ) [color(srgb -0.5116 1.0183 -0.31067 / 1), color(srgb -0.19966 0.9482 -0.34469 / 1), color(srgb 0.43603 0.87309 -0.34061 / 1), color(srgb 0.6269 0.7922 -0.3259 / 1), color(srgb 0.757 0.70491 -0.30534 / 1), color(srgb 0.85316 0.61049 -0.27836 / 1), color(srgb 0.92327 0.50772 -0.24393 / 1), color(srgb 0.97033 0.39375 -0.19979 / 1), color(srgb 0.99571 0.25894 -0.13964 / 1), color(srgb 1 0 0 / 1)] Color(\"display-p3\", [0, 1, 0]).steps( \"red\", space=\"lch\", out_space=\"srgb\", max_delta_e=10, max_steps=10 ) Edit Share Run Cancel When specifying a max_delta_e , steps will function as a minimum required steps and will push the delta even smaller if the required steps is greater than the calculated maximum Delta E. >>> Color ( \"display-p3\" , [ 0 , 1 , 0 ]) . steps ( ... \"red\" , ... space = \"lch\" , ... out_space = \"srgb\" , ... max_delta_e = 10 , ... steps = 50 ... ) [color(srgb -0.5116 1.0183 -0.31067 / 1), color(srgb -0.47276 1.0057 -0.32192 / 1), color(srgb -0.42946 0.99307 -0.33039 / 1), color(srgb -0.37992 0.98024 -0.33661 / 1), color(srgb -0.32082 0.96725 -0.341 / 1), color(srgb -0.24447 0.9541 -0.34385 / 1), color(srgb -0.1198 0.94078 -0.34542 / 1), color(srgb 0.15996 0.92729 -0.34592 / 1), color(srgb 0.26558 0.91362 -0.3455 / 1), color(srgb 0.33665 0.89976 -0.34431 / 1), color(srgb 0.3931 0.88572 -0.34248 / 1), color(srgb 0.44104 0.8715 -0.34036 / 1), color(srgb 0.48324 0.85707 -0.33806 / 1), color(srgb 0.52118 0.84244 -0.33557 / 1), color(srgb 0.55582 0.82761 -0.33289 / 1), color(srgb 0.58776 0.81258 -0.33002 / 1), color(srgb 0.61745 0.79733 -0.32696 / 1), color(srgb 0.64519 0.78187 -0.32371 / 1), color(srgb 0.67123 0.76619 -0.32025 / 1), color(srgb 0.69575 0.75029 -0.31659 / 1), color(srgb 0.7189 0.73416 -0.31273 / 1), color(srgb 0.74079 0.7178 -0.30866 / 1), color(srgb 0.76151 0.7012 -0.30437 / 1), color(srgb 0.78113 0.68437 -0.29987 / 1), color(srgb 0.79972 0.66729 -0.29515 / 1), color(srgb 0.81733 0.64995 -0.2902 / 1), color(srgb 0.834 0.63236 -0.28502 / 1), color(srgb 0.84977 0.6145 -0.2796 / 1), color(srgb 0.86467 0.59636 -0.27393 / 1), color(srgb 0.87872 0.57794 -0.26801 / 1), color(srgb 0.89194 0.55922 -0.26182 / 1), color(srgb 0.90434 0.54018 -0.25536 / 1), color(srgb 0.91596 0.52082 -0.2486 / 1), color(srgb 0.92679 0.50111 -0.24154 / 1), color(srgb 0.93686 0.48103 -0.23415 / 1), color(srgb 0.94616 0.46054 -0.22641 / 1), color(srgb 0.95471 0.43961 -0.2183 / 1), color(srgb 0.96252 0.41819 -0.20979 / 1), color(srgb 0.96959 0.39623 -0.20082 / 1), color(srgb 0.97593 0.37364 -0.19136 / 1), color(srgb 0.98155 0.35032 -0.18134 / 1), color(srgb 0.98644 0.32615 -0.17067 / 1), color(srgb 0.99062 0.30093 -0.15926 / 1), color(srgb 0.99409 0.27439 -0.14694 / 1), color(srgb 0.99685 0.24615 -0.13353 / 1), color(srgb 0.99891 0.21556 -0.11841 / 1), color(srgb 1.0002 0.18152 -0.10034 / 1), color(srgb 1.0009 0.14177 -0.07755 / 1), color(srgb 1.0008 0.09013 -0.04535 / 1), color(srgb 1 0 0 / 1)] Color(\"display-p3\", [0, 1, 0]).steps( \"red\", space=\"lch\", out_space=\"srgb\", max_delta_e=10, steps=50 ) Edit Share Run Cancel The default delta E method is Delta E 76, which is a simple euclidean distancing in the CIELAB color space. While a Delta E 2000 is far more accurate, it is a much more expensive operation.","title":"Steps"},{"location":"interpolation/#piecewise-interpolation","text":"The interploate and steps method allows for piecewise interpolation across multiple color ranges. Anytime, multiple colors are provided via a list, the piecewise logic will be applied to the various segments. >>> Color ( 'red' ) . interpolate ([ 'white' , 'black' , 'blue' ]) <coloraide.color.interpolate.InterpolatePiecewise object at 0x12795f670> Color('red').interpolate(['white', 'black', 'blue']) Edit Share Run Cancel The interpolation between each pair of colors defaults to using the options provided via the interpolate parameters, but you can change them for a given range by using the Piecewise object. For instance, we could apply an easing between just the white and black . Notice that Piecewise is applied to the second color in the range, and the options will only apply to the interpolation of that color and the color immediately before it. >>> Color ( 'red' ) . interpolate ([ 'white' , Piecewise ( 'black' , progress = lambda t : t * ( 2 - t )), 'blue' ]) <coloraide.color.interpolate.InterpolatePiecewise object at 0x12794c9d0> Color('red').interpolate(['white', Piecewise('black', progress=lambda t: t * (2 - t)), 'blue']) Edit Share Run Cancel Additionally, you can set color stops using the stop parameter. To set the stop on the base color, simply set the stop parameter in the interploate method. >>> Color ( 'red' ) . interpolate ([ Piecewise ( 'white' , 0.6 ), Piecewise ( 'black' , 0.8 ), 'blue' ], stop = 0.4 ) <coloraide.color.interpolate.InterpolatePiecewise object at 0x1276cac70> Color('red').interpolate([Piecewise('white', 0.6), Piecewise('black', 0.8), 'blue'], stop=0.4) Edit Share Run Cancel As previously mentioned, this can also be applied to steps as well. >>> Color ( 'red' ) . steps ([ Piecewise ( 'white' , 0.6 ), Piecewise ( 'black' , 0.8 ), 'blue' ], stop = 0.4 , steps = 15 ) [color(srgb 1 0 0 / 1), color(srgb 1 0 0 / 1), color(srgb 1 0 0 / 1), color(srgb 1 0 0 / 1), color(srgb 1 0 0 / 1), color(srgb 1 0 0 / 1), color(srgb 1.0271 0.29998 0.16978 / 1), color(srgb 1.0626 0.62412 0.50306 / 1), color(srgb 1.0355 0.89487 0.85334 / 1), color(srgb 0.7623 0.7623 0.7623 / 1), color(srgb 0.39678 0.39678 0.39678 / 1), color(srgb 0.08542 0.08542 0.08542 / 1), color(srgb 0.10804 0.05743 0.26725 / 1), color(srgb 0.13752 0.05966 0.61311 / 1), color(srgb 0 0 1 / 1)] Color('red').steps([Piecewise('white', 0.6), Piecewise('black', 0.8), 'blue'], stop=0.4, steps=15) Edit Share Run Cancel","title":"Piecewise Interpolation"},{"location":"interpolation/#null-handling","text":"Color spaces that have hue coordinates often have rules about when the hue is considered relevant. For instance, in the HSL color space, if saturation is zero, the hue is considered null. This is because the color is \"without color\" or achromatic; therefore, it has no hue, or the hue is undefined. Many libraries, like d3-color , chroma.js , and color.js , represent null hues with NaN (not a number). This is usually done to make color interpolation easier. Some, like d3-color, are a bit more liberal with NaN and will target special cases that are above and beyond the normal rules to help ensure good interpolation. For instance, they not only mark hue null on HSL colors when saturation is zero, but also when lightness is zero or one hundred (essentially appearing black or white). In fact, they'll mark saturation as NaN when lightness indicates \"black\" or \"white\". ColorAide also uses NaN , or in Python float ( 'nan' ) . In certain situations, when a hue is deemed undefined, the hue value will be set to coloraide.NaN , which is just a constant containing float ( 'nan' ) . When interpolating, if one color's channel has a NaN , the other color's channel will be used as the result. If both colors have a NaN for the same channel, then 0 will be returned. Notice that in this example, because white's saturation is zero, the hue is undefined. Because the hue is undefined, when the color is mixed with a second color ( purple ), the hue of the second color is used. >>> color = Color ( 'white' ) . convert ( 'hsl' ) >>> color . coords () [nan, 0.0, 100.0] >>> color2 = Color ( 'purple' ) . convert ( 'hsl' ) >>> color2 . coords () [300.0, 100.0, 25.098039215686274] >>> color . mix ( color2 , space = \"hsl\" ) color(--hsl 300 50% 62.549% / 1) color = Color('white').convert('hsl') color.coords() color2 = Color('purple').convert('hsl') color2.coords() color.mix(color2, space=\"hsl\") Edit Share Run Cancel Technically, any channel can be set to NaN . This is basically what the mask method is used for. It can set any and all specified channels to NaN for the purpose of restricting channels when interpolating: >>> Color ( 'white' ) . mask ([ 'red' , 'green' ]) . coords () [nan, nan, 1.0] Color('white').mask(['red', 'green']).coords() Edit Share Run Cancel Channels can also be set directly to NaN , but it must be done by instantiating a Color object with raw data or by manually setting it via a channel property or accessor. CSS input string do not allow the NaN values at this time. >>> from coloraide import NaN >>> Color ( \"srgb\" , [ 1 , NaN , 1 ]) . coords () [1.0, nan, 1.0] >>> Color ( \"red\" ) . set ( 'green' , NaN ) . coords () [1.0, nan, 0.0] from coloraide import NaN Color(\"srgb\", [1, NaN, 1]).coords() Color(\"red\").set('green', NaN).coords() Edit Share Run Cancel When printing to a string, NaN s are always converted to 0 : >>> from coloraide import NaN >>> Color ( \"srgb\" , [ 1 , NaN , 1 ]) color(srgb 1 0 1 / 1) from coloraide import NaN Color(\"srgb\", [1, NaN, 1]) Edit Share Run Cancel At any time, a channel can be checked for whether it is NaN by using the is_nan method: >>> Color ( \"white\" ) . convert ( 'hsl' ) . is_nan ( 'hue' ) True Color(\"white\").convert('hsl').is_nan('hue') Edit Share Run Cancel It can be useful to check whether a channel is NaN as NaN values can't be added, subtracted, multiplied, etc. They will always return NaN unless you directly replace them. >>> color = Color ( \"white\" ) . convert ( 'hsl' ) >>> color . hue = color . hue + 3 >>> color . is_nan ( 'hue' ) True >>> color . hue = 3 >>> color . is_nan ( 'hue' ) False color = Color(\"white\").convert('hsl') color.hue = color.hue + 3 color.is_nan('hue') color.hue = 3 color.is_nan('hue') Edit Share Run Cancel","title":"Null/NaN Handling"},{"location":"manipulation/","text":"Manipulating Colors Reading Coordinates There are various ways to read the current values of color coordinates. Channel properties can be read directly: >>> color = Color ( \"orange\" ) >>> color . red 1.0 color = Color(\"orange\") color.red Edit Share Run Cancel Channel values can also be read by using the get method and providing the name of desired channel. >>> color = Color ( \"orange\" ) >>> color . get ( \"green\" ) 0.6470588235294118 color = Color(\"orange\") color.get(\"green\") Edit Share Run Cancel All coordinates can be read simultaneously by using the coords function. The alpha channel is excluded from coords and must be retrieved separately. >>> color = Color ( \"orange\" ) >>> color . coords () [1.0, 0.6470588235294118, 0.0] >>> color . alpha 1.0 color = Color(\"orange\") color.coords() color.alpha Edit Share Run Cancel If a color coordinate is needed from another color space, it can be accessed by passing in the color space followed by the name of the desired coordinate. The necessary conversions will happen behind the scenes and the desired value will be returned. >>> Color ( \"blue\" ) . get ( \"lch.chroma\" ) 131.2014480889621 Color(\"blue\").get(\"lch.chroma\") Edit Share Run Cancel Modifying Coordinates Channel properties can be modified directly by using the named property. Here we modify red by adjusting its green property and get an orange hued color. >>> color = Color ( \"red\" ) >>> color . green = 0.5 >>> color . to_string () rgb(255 127.5 0) color = Color(\"red\") color.green = 0.5 color.to_string() Edit Share Run Cancel When doing so, keep in mind, the internal coordinates are being adjusted, and so they must be modified within the range in which the values are stored, and for sRGB, it is in the range of [0, 1]. Much like reading with the get method, values can be modified with the set method. As these methods return a reference to the current class, multiple set operations can be chained together. Chaining multiple set operations together, we can transform white to rgb ( 0 127 . 5 255 ) . >>> Color ( \"white\" ) . set ( \"red\" , 0 ) . set ( \"green\" , 0.5 ) color(srgb 0 0.5 1 / 1) Color(\"white\").set(\"red\", 0).set(\"green\", 0.5) Edit Share Run Cancel Functions can also be used to modify a channel property. This allows us to do more complex set operations. Here we do a relative adjustment of the green channel and transform the color pink to rgb ( 255 249 . 6 203 ) . >>> Color ( \"pink\" ) . set ( 'green' , lambda g : g * 1.3 ) color(srgb 1 0.97882 0.79608 / 1) Color(\"pink\").set('green', lambda g: g * 1.3) Edit Share Run Cancel Channels in other color spaces can also be modified with the set function. Here we alter the color blue by editing the hue channel in the CIELCH color space and get rgb (- 63 . 911 91 . 016 - 63 . 173 ) . Keep in mind though that the colors are being converted to the specified space under the hood, set, and then converted back, so if you have multiple operations to apply in a given color space, it may be more efficient to convert to that space, apply the set operations directly, and then convert back. >>> Color ( \"blue\" ) . set ( 'lch.hue' , 130 ) color(srgb -0.25063 0.35692 -0.24774 / 1) Color(\"blue\").set('lch.hue', 130) Edit Share Run Cancel When setting a color in another color space, the final value is subject to any rounding errors that may occur in the round trip to and from the specified color space. Also, depending on the transform functions of the spaces involved and whether the original color is on the edge of its own gamut, this can lead to a color going slightly out of gamut, and if one of the spaces involved in the conversion doesn't handle out of gamut colors with sensible values, you may get something unexpected back. >>> Color ( 'hsl(0 0 % 50% )' ) . set ( 'hwb.blackness' , 0 ) . set ( 'hwb.whiteness' , 100 ) color(--hsl 0 0% 100% / 1) >>> Color ( 'hsl(0 0 % 50% )' ) . set ( 'lch-d65.lightness' , 100 ) color(--hsl 0 0% 100% / 1) >>> Color ( 'hsl(0 0 % 50% )' ) . set ( 'lch-d65.lightness' , 100 ) . convert ( 'srgb' ) . coords () [1.0, 1.0, 1.0] Color('hsl(0 0% 50%)').set('hwb.blackness', 0).set('hwb.whiteness', 100) Color('hsl(0 0% 50%)').set('lch-d65.lightness', 100) Color('hsl(0 0% 50%)').set('lch-d65.lightness', 100).convert('srgb').coords() Edit Share Run Cancel The above example cleanly converts between HSL and HWB as the conversion between these two is much more precise, but the CIELCH D65 example is not quite as precise and returns a color with a saturation that is way out of bounds. But keep in mind, it looks worse than it really is. When converting the HSL value to sRGB, we see it is barely off. None of this is a bug, it is just the nature of the algorithms we are using to convert, the precision of the floats, and the slight rounding errors that occur when using floating-point arithmetic . In the end, while the HSL color with high saturation seems a bit unexpected, it is actually pretty close to the intended value once you realize that the 100% lightness dominates the result and makes the saturation and hue values insignificant. For this reason, it makes a lot of sense that the sRGB coordinates are still so close. HSL just doesn't represent out of gamut colors as well as sRGB does. Masking Channels Colors in general can use NaN to represent undefined color channels. This currently only happens by default for hue channels when the color is achromatic and has no defined hue. When interpolating, undefined channels will not be interpolated. While we won't dive into all the interpolation specifics here, we will demonstrate how to mask channels. To learn more about interpolation and how masking can help, you can read more about it in Interpolation . Suffice it to say, a user may want to mask channels on their own for various reasons, using the mask function can allow for a user to quickly and easily mask one or more channels: >>> Color ( 'white' ) . coords () [1.0, 1.0, 1.0] >>> Color ( 'white' ) . mask ([ 'red' , 'green' ]) . coords () [nan, nan, 1.0] Color('white').coords() Color('white').mask(['red', 'green']).coords() Edit Share Run Cancel The alpha channel can also be masked: >>> Color ( 'white' ) . mask ( 'alpha' ) . alpha nan Color('white').mask('alpha').alpha Edit Share Run Cancel Additionally, you can do inverse masks, or masks that apply to every channel not specified. >>> c = Color ( 'white' ) . mask ( 'blue' , invert = True ) >>> c . coords () [nan, nan, 1.0] >>> c . alpha nan c = Color('white').mask('blue', invert=True) c.coords() c.alpha Edit Share Run Cancel Checking for Null/ NaN As previously mentioned, a user can set a channel to NaN via the mask function, or potentially by passing NaN directly to the channel. In addition, cylindrical colors that offer a hue property can sometimes return NaN for a hue. This occurs only when the hue is undefined, and only when ColorAide is converting from one color space to another, or when interpreting a color string input. As an example, the color hsl ( 360 0 % 100 % ) , while assigned a hue, does not actually exhibit any real hue since saturation is 0. Essentially, hue could be set to anything, and it would still have no affect on the actual color. So, ColorAide will actually set hue to NaN (or \"not a number\"). When outputting to a string, NaN is treated as a zero on output. >>> color = Color ( 'hsl(360 0 % 100% )' ) >>> color color(--hsl 0 0% 100% / 1) >>> color . coords () [nan, 0.0, 100.0] color = Color('hsl(360 0% 100%)') color color.coords() Edit Share Run Cancel The only time hue is not automatically evaluated is when raw data inputs are used. This can be when a user instantiates a color with raw data points or manually sets the channel with an explicit value. While the rendered color still looks the same as the previous example, the channel values are preserved. >>> color = Color ( 'hsl' , [ 360 , 0 , 100 ]) >>> color color(--hsl 360 0% 100% / 1) >>> color . coords () [360.0, 0.0, 100.0] >>> color . hue = 270 >>> color color(--hsl 270 0% 100% / 1) color = Color('hsl', [360, 0, 100]) color color.coords() color.hue = 270 color Edit Share Run Cancel Because NaN values are not numbers, and these values cannot be added, multiplied, or take part in any real math operations. All math operations performed with a NaN simply return NaN . >>> float ( 'nan' ) * 3 nan >>> float ( 'nan' ) + 3 nan float('nan') * 3 float('nan') + 3 Edit Share Run Cancel Because a NaN may cause unexpected results, it can be useful to check if a hue (or any channel) is NaN before applying certain operations. To make checking for NaN s easy, the convenience function is_nan has been made available. You can simply give is_nan the property you wish to check, and it will return either True or False . >>> Color ( 'hsl(360 0 % 100% )' ) . is_nan ( 'hue' ) True Color('hsl(360 0% 100%)').is_nan('hue') Edit Share Run Cancel This is equivalent to using the math library and comparing the value directly: >>> import math >>> math . isnan ( Color ( 'hsl(360 0 % 100% )' ) . hue ) True import math math.isnan(Color('hsl(360 0% 100%)').hue) Edit Share Run Cancel","title":"Manipulating Colors"},{"location":"manipulation/#manipulating-colors","text":"","title":"Manipulating Colors"},{"location":"manipulation/#reading-coordinates","text":"There are various ways to read the current values of color coordinates. Channel properties can be read directly: >>> color = Color ( \"orange\" ) >>> color . red 1.0 color = Color(\"orange\") color.red Edit Share Run Cancel Channel values can also be read by using the get method and providing the name of desired channel. >>> color = Color ( \"orange\" ) >>> color . get ( \"green\" ) 0.6470588235294118 color = Color(\"orange\") color.get(\"green\") Edit Share Run Cancel All coordinates can be read simultaneously by using the coords function. The alpha channel is excluded from coords and must be retrieved separately. >>> color = Color ( \"orange\" ) >>> color . coords () [1.0, 0.6470588235294118, 0.0] >>> color . alpha 1.0 color = Color(\"orange\") color.coords() color.alpha Edit Share Run Cancel If a color coordinate is needed from another color space, it can be accessed by passing in the color space followed by the name of the desired coordinate. The necessary conversions will happen behind the scenes and the desired value will be returned. >>> Color ( \"blue\" ) . get ( \"lch.chroma\" ) 131.2014480889621 Color(\"blue\").get(\"lch.chroma\") Edit Share Run Cancel","title":"Reading Coordinates"},{"location":"manipulation/#modifying-coordinates","text":"Channel properties can be modified directly by using the named property. Here we modify red by adjusting its green property and get an orange hued color. >>> color = Color ( \"red\" ) >>> color . green = 0.5 >>> color . to_string () rgb(255 127.5 0) color = Color(\"red\") color.green = 0.5 color.to_string() Edit Share Run Cancel When doing so, keep in mind, the internal coordinates are being adjusted, and so they must be modified within the range in which the values are stored, and for sRGB, it is in the range of [0, 1]. Much like reading with the get method, values can be modified with the set method. As these methods return a reference to the current class, multiple set operations can be chained together. Chaining multiple set operations together, we can transform white to rgb ( 0 127 . 5 255 ) . >>> Color ( \"white\" ) . set ( \"red\" , 0 ) . set ( \"green\" , 0.5 ) color(srgb 0 0.5 1 / 1) Color(\"white\").set(\"red\", 0).set(\"green\", 0.5) Edit Share Run Cancel Functions can also be used to modify a channel property. This allows us to do more complex set operations. Here we do a relative adjustment of the green channel and transform the color pink to rgb ( 255 249 . 6 203 ) . >>> Color ( \"pink\" ) . set ( 'green' , lambda g : g * 1.3 ) color(srgb 1 0.97882 0.79608 / 1) Color(\"pink\").set('green', lambda g: g * 1.3) Edit Share Run Cancel Channels in other color spaces can also be modified with the set function. Here we alter the color blue by editing the hue channel in the CIELCH color space and get rgb (- 63 . 911 91 . 016 - 63 . 173 ) . Keep in mind though that the colors are being converted to the specified space under the hood, set, and then converted back, so if you have multiple operations to apply in a given color space, it may be more efficient to convert to that space, apply the set operations directly, and then convert back. >>> Color ( \"blue\" ) . set ( 'lch.hue' , 130 ) color(srgb -0.25063 0.35692 -0.24774 / 1) Color(\"blue\").set('lch.hue', 130) Edit Share Run Cancel When setting a color in another color space, the final value is subject to any rounding errors that may occur in the round trip to and from the specified color space. Also, depending on the transform functions of the spaces involved and whether the original color is on the edge of its own gamut, this can lead to a color going slightly out of gamut, and if one of the spaces involved in the conversion doesn't handle out of gamut colors with sensible values, you may get something unexpected back. >>> Color ( 'hsl(0 0 % 50% )' ) . set ( 'hwb.blackness' , 0 ) . set ( 'hwb.whiteness' , 100 ) color(--hsl 0 0% 100% / 1) >>> Color ( 'hsl(0 0 % 50% )' ) . set ( 'lch-d65.lightness' , 100 ) color(--hsl 0 0% 100% / 1) >>> Color ( 'hsl(0 0 % 50% )' ) . set ( 'lch-d65.lightness' , 100 ) . convert ( 'srgb' ) . coords () [1.0, 1.0, 1.0] Color('hsl(0 0% 50%)').set('hwb.blackness', 0).set('hwb.whiteness', 100) Color('hsl(0 0% 50%)').set('lch-d65.lightness', 100) Color('hsl(0 0% 50%)').set('lch-d65.lightness', 100).convert('srgb').coords() Edit Share Run Cancel The above example cleanly converts between HSL and HWB as the conversion between these two is much more precise, but the CIELCH D65 example is not quite as precise and returns a color with a saturation that is way out of bounds. But keep in mind, it looks worse than it really is. When converting the HSL value to sRGB, we see it is barely off. None of this is a bug, it is just the nature of the algorithms we are using to convert, the precision of the floats, and the slight rounding errors that occur when using floating-point arithmetic . In the end, while the HSL color with high saturation seems a bit unexpected, it is actually pretty close to the intended value once you realize that the 100% lightness dominates the result and makes the saturation and hue values insignificant. For this reason, it makes a lot of sense that the sRGB coordinates are still so close. HSL just doesn't represent out of gamut colors as well as sRGB does.","title":"Modifying Coordinates"},{"location":"manipulation/#masking-channels","text":"Colors in general can use NaN to represent undefined color channels. This currently only happens by default for hue channels when the color is achromatic and has no defined hue. When interpolating, undefined channels will not be interpolated. While we won't dive into all the interpolation specifics here, we will demonstrate how to mask channels. To learn more about interpolation and how masking can help, you can read more about it in Interpolation . Suffice it to say, a user may want to mask channels on their own for various reasons, using the mask function can allow for a user to quickly and easily mask one or more channels: >>> Color ( 'white' ) . coords () [1.0, 1.0, 1.0] >>> Color ( 'white' ) . mask ([ 'red' , 'green' ]) . coords () [nan, nan, 1.0] Color('white').coords() Color('white').mask(['red', 'green']).coords() Edit Share Run Cancel The alpha channel can also be masked: >>> Color ( 'white' ) . mask ( 'alpha' ) . alpha nan Color('white').mask('alpha').alpha Edit Share Run Cancel Additionally, you can do inverse masks, or masks that apply to every channel not specified. >>> c = Color ( 'white' ) . mask ( 'blue' , invert = True ) >>> c . coords () [nan, nan, 1.0] >>> c . alpha nan c = Color('white').mask('blue', invert=True) c.coords() c.alpha Edit Share Run Cancel","title":"Masking Channels"},{"location":"manipulation/#checking-for-nullnan","text":"As previously mentioned, a user can set a channel to NaN via the mask function, or potentially by passing NaN directly to the channel. In addition, cylindrical colors that offer a hue property can sometimes return NaN for a hue. This occurs only when the hue is undefined, and only when ColorAide is converting from one color space to another, or when interpreting a color string input. As an example, the color hsl ( 360 0 % 100 % ) , while assigned a hue, does not actually exhibit any real hue since saturation is 0. Essentially, hue could be set to anything, and it would still have no affect on the actual color. So, ColorAide will actually set hue to NaN (or \"not a number\"). When outputting to a string, NaN is treated as a zero on output. >>> color = Color ( 'hsl(360 0 % 100% )' ) >>> color color(--hsl 0 0% 100% / 1) >>> color . coords () [nan, 0.0, 100.0] color = Color('hsl(360 0% 100%)') color color.coords() Edit Share Run Cancel The only time hue is not automatically evaluated is when raw data inputs are used. This can be when a user instantiates a color with raw data points or manually sets the channel with an explicit value. While the rendered color still looks the same as the previous example, the channel values are preserved. >>> color = Color ( 'hsl' , [ 360 , 0 , 100 ]) >>> color color(--hsl 360 0% 100% / 1) >>> color . coords () [360.0, 0.0, 100.0] >>> color . hue = 270 >>> color color(--hsl 270 0% 100% / 1) color = Color('hsl', [360, 0, 100]) color color.coords() color.hue = 270 color Edit Share Run Cancel Because NaN values are not numbers, and these values cannot be added, multiplied, or take part in any real math operations. All math operations performed with a NaN simply return NaN . >>> float ( 'nan' ) * 3 nan >>> float ( 'nan' ) + 3 nan float('nan') * 3 float('nan') + 3 Edit Share Run Cancel Because a NaN may cause unexpected results, it can be useful to check if a hue (or any channel) is NaN before applying certain operations. To make checking for NaN s easy, the convenience function is_nan has been made available. You can simply give is_nan the property you wish to check, and it will return either True or False . >>> Color ( 'hsl(360 0 % 100% )' ) . is_nan ( 'hue' ) True Color('hsl(360 0% 100%)').is_nan('hue') Edit Share Run Cancel This is equivalent to using the math library and comparing the value directly: >>> import math >>> math . isnan ( Color ( 'hsl(360 0 % 100% )' ) . hue ) True import math math.isnan(Color('hsl(360 0% 100%)').hue) Edit Share Run Cancel","title":"Checking for Null/NaN"},{"location":"playground/","text":"Notebook Submit Cancel","title":"Playground"},{"location":"strings/","text":"String Output Convert to Strings Colors can be translated to strings by using the to_string method. The color class will convert the current color into one of the many of CSS formats supported for the given color space. >>> Color ( \"srgb\" , [ 0.5 , 0 , 1 ], 0.3 ) . to_string () rgb(127.5 0 255 / 0.3) Color(\"srgb\", [0.5, 0, 1], 0.3).to_string() Edit Share Run Cancel All color spaces support the following parameters: alpha : set to None by default, alpha will only be shown if less than 100%, but if set to True , alpha will always be shown. Setting to False will cause alpha to be ignored in the output. precision : precision controls the precision of the output values. The name is a little misleading as it will actually adjust the precision and scale of the values. The default is 5. In some cases, like sRGB hex output, precision may not really come into play as hex values are rounded to the nearest whole number anyways. >>> Color ( \"rgb(30.3456 % 75% 100%)\" ) . to_string ( precision = 5 , percent = True ) rgb(30.346% 75% 100%) >>> Color ( \"rgb(30.3456 % 75% 100%)\" ) . to_string ( precision = 4 , percent = True ) rgb(30.35% 75% 100%) >>> Color ( \"rgb(30.3456 % 75% 100%)\" ) . to_string ( precision = 3 , percent = True ) rgb(30.3% 75% 100%) >>> Color ( \"rgb(30.3456 % 75% 100%)\" ) . to_string ( precision = 2 , percent = True ) rgb(30% 75% 100%) >>> Color ( \"rgb(30.3456 % 75% 100%)\" ) . to_string ( precision = 1 , percent = True ) rgb(30% 80% 100%) Color(\"rgb(30.3456% 75% 100%)\").to_string(precision=5, percent=True) Color(\"rgb(30.3456% 75% 100%)\").to_string(precision=4, percent=True) Color(\"rgb(30.3456% 75% 100%)\").to_string(precision=3, percent=True) Color(\"rgb(30.3456% 75% 100%)\").to_string(precision=2, percent=True) Color(\"rgb(30.3456% 75% 100%)\").to_string(precision=1, percent=True) Edit Share Run Cancel Providing a precision of 0 will simply enable simple rounding to the nearest whole number. >>> Color ( \"rgb(30.3456 % 75% 100%)\" ) . to_string ( precision = 0 , percent = True ) rgb(30% 75% 100%) Color(\"rgb(30.3456% 75% 100%)\").to_string(precision=0, percent=True) Edit Share Run Cancel Providing a precision of -1 is a special input that will give the highest precision that can be given. Not particularly helpful except to look at the raw decimal number. >>> Color ( \"rgb(30.3456 % 75% 100%)\" ) . to_string ( precision =- 1 , percent = True ) rgb(30.345600000000001017497197608463466167449951171875% 75% 100%) Color(\"rgb(30.3456% 75% 100%)\").to_string(precision=-1, percent=True) Edit Share Run Cancel One note though, format of the value matters. Here we output in the range of 0 - 255. We can see that a precision of 1 , in this case, can throw the color out of gamut. So remember to use a sufficient precision for what you are doing and the values you are working in. >>> Color ( \"rgb(30.3456 % 75% 100%)\" ) . to_string ( precision = 1 ) rgb(80 200 300) Color(\"rgb(30.3456% 75% 100%)\").to_string(precision=1) Edit Share Run Cancel fit : set to True by default, fit controls whether colors are fit to their gamut or not. Some color spaces are technically unbounded, so no fitting may occur in those color spaces. Additionally, some color formats, like sRGB hex, are always fitted (regardless of the this setting) as they must fit into the gamut or they cannot be translated. >>> Color ( \"rgb(30 % 105% 0%)\" ) . to_string () rgb(106.26 255 58.974) >>> Color ( \"rgb(30 % 105% 0%)\" ) . to_string ( fit = False ) rgb(76.5 267.75 0) Color(\"rgb(30% 105% 0%)\").to_string() Color(\"rgb(30% 105% 0%)\").to_string(fit=False) Edit Share Run Cancel Additionally, we can choose a different fitting method by passing fit the name of the method we would like. >>> Color ( \"rgb(30 % 105% 0%)\" ) . to_string () rgb(106.26 255 58.974) >>> Color ( \"rgb(30 % 105% 0%)\" ) . to_string ( fit = 'clip' ) rgb(76.5 255 0) Color(\"rgb(30% 105% 0%)\").to_string() Color(\"rgb(30% 105% 0%)\").to_string(fit='clip') Edit Share Run Cancel color : for some color spaces, this is the default output, but for others this format can be explicitly requested by setting color to True . If set to True , this will take priority over other format options. >>> Color ( \"rebeccapurple\" ) . to_string ( color = True ) color(srgb 0.4 0.2 0.6) Color(\"rebeccapurple\").to_string(color=True) Edit Share Run Cancel In general, a color in a given color space may share the same options as listed above, but a given color space may also have options unique to itself. sRGB Specific sRGB can output colors to a hex format which is unique compared to HSL and others. Simply enable hex . >>> Color ( \"rebeccapurple\" ) . to_string ( hex = True ) #663399 Color(\"rebeccapurple\").to_string(hex=True) Edit Share Run Cancel You can force hex to output in uppercase. >>> Color ( \"red\" ) . to_string ( hex = True ) #ff0000 >>> Color ( \"red\" ) . to_string ( hex = True , upper = True ) #FF0000 Color(\"red\").to_string(hex=True) Color(\"red\").to_string(hex=True, upper=True) Edit Share Run Cancel When converting to the hex color format, a color can be compressed in certain cases. Enabling compress will compress a hex color if possible. >>> Color ( \"#11223388\" ) . to_string ( hex = True ) #11223388 >>> Color ( \"#11223388\" ) . to_string ( hex = True , compress = True ) #1238 Color(\"#11223388\").to_string(hex=True) Color(\"#11223388\").to_string(hex=True, compress=True) Edit Share Run Cancel sRGB also can output colors in an optional percent format. This will output the channels in the range of [0%,100%] instead of using the range [0,255]. >>> Color ( \"rebeccapurple\" ) . to_string ( percent = True ) rgb(40% 20% 60%) Color(\"rebeccapurple\").to_string(percent=True) Edit Share Run Cancel sRGB can also output color names. If a color evaluates to a hex code which also evaluates to a color name in the internal CSS color name mapping, then a color name will be returned. If the color does not match a color name, it will fallback to whatever the other options dictate. Simply enable names . >>> Color ( \"#663399\" ) . to_string ( names = True ) rebeccapurple Color(\"#663399\").to_string(names=True) Edit Share Run Cancel Comma Format In CSS, there are a number of color spaces that allow a comma format: srgb and hsl . ColorAide allows these to be read in and to be output in their legacy comma format. Even though lch , lab , and hwb do not have a comma format, they are allowed to be read in with commas and can be specified to output with comma format. The one format that ColorAide will not allow commas on is color() . color() is the common serialization format that ColorAide uses and it is strict about its format. If we want commas, we can force the comma syntax by setting comma to True . This can alter some color space output in other subtle ways. As the comma format is the old legacy approach, when sRGB has commas enabled, it will use rgba instead of the rgb . If using the default space syntax, rgb is always used, even when the color has transparency. >>> Color ( \"rgb(30 75 100 / 20%)\" ) . to_string ( comma = True ) rgba(30, 75, 100, 0.2) Color(\"rgb(30 75 100 / 20%)\").to_string(comma=True) Edit Share Run Cancel","title":"String Output"},{"location":"strings/#string-output","text":"","title":"String Output"},{"location":"strings/#convert-to-strings","text":"Colors can be translated to strings by using the to_string method. The color class will convert the current color into one of the many of CSS formats supported for the given color space. >>> Color ( \"srgb\" , [ 0.5 , 0 , 1 ], 0.3 ) . to_string () rgb(127.5 0 255 / 0.3) Color(\"srgb\", [0.5, 0, 1], 0.3).to_string() Edit Share Run Cancel All color spaces support the following parameters: alpha : set to None by default, alpha will only be shown if less than 100%, but if set to True , alpha will always be shown. Setting to False will cause alpha to be ignored in the output. precision : precision controls the precision of the output values. The name is a little misleading as it will actually adjust the precision and scale of the values. The default is 5. In some cases, like sRGB hex output, precision may not really come into play as hex values are rounded to the nearest whole number anyways. >>> Color ( \"rgb(30.3456 % 75% 100%)\" ) . to_string ( precision = 5 , percent = True ) rgb(30.346% 75% 100%) >>> Color ( \"rgb(30.3456 % 75% 100%)\" ) . to_string ( precision = 4 , percent = True ) rgb(30.35% 75% 100%) >>> Color ( \"rgb(30.3456 % 75% 100%)\" ) . to_string ( precision = 3 , percent = True ) rgb(30.3% 75% 100%) >>> Color ( \"rgb(30.3456 % 75% 100%)\" ) . to_string ( precision = 2 , percent = True ) rgb(30% 75% 100%) >>> Color ( \"rgb(30.3456 % 75% 100%)\" ) . to_string ( precision = 1 , percent = True ) rgb(30% 80% 100%) Color(\"rgb(30.3456% 75% 100%)\").to_string(precision=5, percent=True) Color(\"rgb(30.3456% 75% 100%)\").to_string(precision=4, percent=True) Color(\"rgb(30.3456% 75% 100%)\").to_string(precision=3, percent=True) Color(\"rgb(30.3456% 75% 100%)\").to_string(precision=2, percent=True) Color(\"rgb(30.3456% 75% 100%)\").to_string(precision=1, percent=True) Edit Share Run Cancel Providing a precision of 0 will simply enable simple rounding to the nearest whole number. >>> Color ( \"rgb(30.3456 % 75% 100%)\" ) . to_string ( precision = 0 , percent = True ) rgb(30% 75% 100%) Color(\"rgb(30.3456% 75% 100%)\").to_string(precision=0, percent=True) Edit Share Run Cancel Providing a precision of -1 is a special input that will give the highest precision that can be given. Not particularly helpful except to look at the raw decimal number. >>> Color ( \"rgb(30.3456 % 75% 100%)\" ) . to_string ( precision =- 1 , percent = True ) rgb(30.345600000000001017497197608463466167449951171875% 75% 100%) Color(\"rgb(30.3456% 75% 100%)\").to_string(precision=-1, percent=True) Edit Share Run Cancel One note though, format of the value matters. Here we output in the range of 0 - 255. We can see that a precision of 1 , in this case, can throw the color out of gamut. So remember to use a sufficient precision for what you are doing and the values you are working in. >>> Color ( \"rgb(30.3456 % 75% 100%)\" ) . to_string ( precision = 1 ) rgb(80 200 300) Color(\"rgb(30.3456% 75% 100%)\").to_string(precision=1) Edit Share Run Cancel fit : set to True by default, fit controls whether colors are fit to their gamut or not. Some color spaces are technically unbounded, so no fitting may occur in those color spaces. Additionally, some color formats, like sRGB hex, are always fitted (regardless of the this setting) as they must fit into the gamut or they cannot be translated. >>> Color ( \"rgb(30 % 105% 0%)\" ) . to_string () rgb(106.26 255 58.974) >>> Color ( \"rgb(30 % 105% 0%)\" ) . to_string ( fit = False ) rgb(76.5 267.75 0) Color(\"rgb(30% 105% 0%)\").to_string() Color(\"rgb(30% 105% 0%)\").to_string(fit=False) Edit Share Run Cancel Additionally, we can choose a different fitting method by passing fit the name of the method we would like. >>> Color ( \"rgb(30 % 105% 0%)\" ) . to_string () rgb(106.26 255 58.974) >>> Color ( \"rgb(30 % 105% 0%)\" ) . to_string ( fit = 'clip' ) rgb(76.5 255 0) Color(\"rgb(30% 105% 0%)\").to_string() Color(\"rgb(30% 105% 0%)\").to_string(fit='clip') Edit Share Run Cancel color : for some color spaces, this is the default output, but for others this format can be explicitly requested by setting color to True . If set to True , this will take priority over other format options. >>> Color ( \"rebeccapurple\" ) . to_string ( color = True ) color(srgb 0.4 0.2 0.6) Color(\"rebeccapurple\").to_string(color=True) Edit Share Run Cancel In general, a color in a given color space may share the same options as listed above, but a given color space may also have options unique to itself.","title":"Convert to Strings"},{"location":"strings/#srgb-specific","text":"sRGB can output colors to a hex format which is unique compared to HSL and others. Simply enable hex . >>> Color ( \"rebeccapurple\" ) . to_string ( hex = True ) #663399 Color(\"rebeccapurple\").to_string(hex=True) Edit Share Run Cancel You can force hex to output in uppercase. >>> Color ( \"red\" ) . to_string ( hex = True ) #ff0000 >>> Color ( \"red\" ) . to_string ( hex = True , upper = True ) #FF0000 Color(\"red\").to_string(hex=True) Color(\"red\").to_string(hex=True, upper=True) Edit Share Run Cancel When converting to the hex color format, a color can be compressed in certain cases. Enabling compress will compress a hex color if possible. >>> Color ( \"#11223388\" ) . to_string ( hex = True ) #11223388 >>> Color ( \"#11223388\" ) . to_string ( hex = True , compress = True ) #1238 Color(\"#11223388\").to_string(hex=True) Color(\"#11223388\").to_string(hex=True, compress=True) Edit Share Run Cancel sRGB also can output colors in an optional percent format. This will output the channels in the range of [0%,100%] instead of using the range [0,255]. >>> Color ( \"rebeccapurple\" ) . to_string ( percent = True ) rgb(40% 20% 60%) Color(\"rebeccapurple\").to_string(percent=True) Edit Share Run Cancel sRGB can also output color names. If a color evaluates to a hex code which also evaluates to a color name in the internal CSS color name mapping, then a color name will be returned. If the color does not match a color name, it will fallback to whatever the other options dictate. Simply enable names . >>> Color ( \"#663399\" ) . to_string ( names = True ) rebeccapurple Color(\"#663399\").to_string(names=True) Edit Share Run Cancel","title":"sRGB Specific"},{"location":"strings/#comma-format","text":"In CSS, there are a number of color spaces that allow a comma format: srgb and hsl . ColorAide allows these to be read in and to be output in their legacy comma format. Even though lch , lab , and hwb do not have a comma format, they are allowed to be read in with commas and can be specified to output with comma format. The one format that ColorAide will not allow commas on is color() . color() is the common serialization format that ColorAide uses and it is strict about its format. If we want commas, we can force the comma syntax by setting comma to True . This can alter some color space output in other subtle ways. As the comma format is the old legacy approach, when sRGB has commas enabled, it will use rgba instead of the rgb . If using the default space syntax, rgb is always used, even when the color has transparency. >>> Color ( \"rgb(30 75 100 / 20%)\" ) . to_string ( comma = True ) rgba(30, 75, 100, 0.2) Color(\"rgb(30 75 100 / 20%)\").to_string(comma=True) Edit Share Run Cancel","title":"Comma Format"},{"location":"about/changelog/","text":"Changelog 0.1.0a26 NEW : Use D65 and D50 white points as specified in CSS spec, but limited to 4 decimals as everyone else seems to do. Other white points were also adjusted as outlined in CIE 2004 Colorimetry T.3 and T.8. FIX : When converting, ensure that NaN s are converted to normal numbers. 0.1.0a25 NEW : Add luv and lchuv color space using a D50 illuminant. NEW : Add din99o and din99o-lch color space using a D65 illuminant and associated Delta E 99o distance algorithm. NEW : Make it easier to add additional Delta E methods and gamut mapping methods to a custom Color() class. NEW : Add new Delta E z algorithm (Jzazbz). NEW : Add new Delta E hyab algorithm for any Lab-ish style color spaces. NEW : Expose delta_e_<type> methods dynamically depending on what Delta E methods are currently available. FIX : Consistent calculation of achromatic thresholds across all Lch-ish color spaces. 0.1.0a24 NEW : color() function locks accepted to channels to the number of actual channels. NEW : All color() function implementations for color spaces that do not formally support such notation in the current CSS spec now use the custom identifier notation --name . For instance, HSL, which does not support the color() format in the CSS spec, is now specified via: color(--hsl h s l / a) . NEW : Channels that do not support percentages will no longer be accepted in the color() form. For instance, according to the CSS spec, XYZ color space does not allow percentages in the color() format. ColorAide will no longer allow such notation in order to conform to the spec. color(--lab) will still support percentages for l as it did prior to removal from the spec. All other percentage only channels will also still be supported. NEW : Internal restructuring of some files and file locations. 0.1.0a23 FIX : Faster precision adjustment. 0.1.0a22 FIX : Don't have sRGB fail gamut check due to HSL having extreme numbers. If sRGB is within tolerance range, it should pass. Instead, HSL, HSV, and HWB will all be checked to see if they are within the sRGB gamut as they are just representations of sRGB, but they will also have the tolerance checked against their own coordinates to help catch values that are way out of bounds but still yield values within the sRGB tolerance range. FIX : Improve gamut mapping a bit more. 0.1.0a21 NEW : Refactor CAT to allow for other CAT methods: von-kries , xyz-scaling , cat02 , cmccat97 , cmccat2000 , and sharp . Currently, bradford is the default and the overall preferred option. FIX : Fix issues gamut mapping algorithm. 0.1.0a20 FIX : Fix lab-d65 which was not using the correct white point in all places. 0.1.0a19 FIX : Ensure that subclassed Color objects are normalized when performing operations with more than one color to prevent issues in case one subclassed object has overridden important functions. FIX : Spaces like lab , lch , etc., which specify certain channels as percent only should require the color() format to only accept percentages for those channels and output those channels as percentages when converting to a string. 0.1.0a18 NEW : Refactor of internals. NEW : interpolate and steps can now accept multiple colors and will return an interpolation function that spans all specified colors via the range of [0..1] . NEW : Better control over piecewise interpolation: setting stops, adjusting options per segment, etc. NEW : compose can now accept multiple colors and will return a result where all colors are layered on top of each other. NEW : new method does not need to be a classmethod . Make it a normal method on the instance. NEW : Add Jzazbz and JzCzhz color spaces. NEW : Add D65 variants of CIELAB, CIELCH, and XYZ. NEW : Add ICtCp color space and Delta E ITP method. FIX : Actually make mix default to lab like interpolate and friends do. 0.1.0a17 FIX : Ensure that both the Bradford CAT and the XYZ transformation matrix all use ASTM E308-01 white points. This fixes a number of conversion issues when going to and from D65 to D50 color spaces. 0.1.0a16 NEW : Make mix use the same space logic as interpolate and step . Colors are mixed in CIELAB unless space is set to a different color space. NEW : Add support for blend modes as specified in Compositing and Blending Level 1 . NEW : Rename overlay to compose as all compositing (including blend modes) is done through compose now. overlay is still present and is deprecated and will be removed at some future point before a stable release. compose will assume sRGB space unless a different space is specified, but overlay will function as it always did. FIX : Fix some small internal issues with in_place logic. 0.1.0a15 NEW : The adjust parameter on interpolate , steps , and mix has been dropped. Instead, a general purpose method has been added to the Color object to mask one or more channels at a time. This can be used to create a temporary color with masked channels for the purpose of interpolation. FIX : Ensure that when alpha is NaN that it is handled in overlay . FIX : When using raw data in the color() function, and there is too little data, fill data with NaN . FIX : Fix issue where API interpolate method does not pass out_space parameter down. FIX : Disabling or forcing alpha did not work properly for HSL colors via to_string . FIX : contrast and luminance should use XYZ with a D65 white point, not the default XYZ space which uses a D50 white point. FIX : Fix bug in Delta E 2000 algorithm. 0.1.0a14 NEW : sRGB string output parameter hex_upper has been renamed to just upper . Expose it in documentation as well. 0.1.0a13 FIX : More efficient calculation of CIELAB, following CIE 15.3:2004. Results are still the same, but it makes the math a little simpler. FIX : HSV did not always set hue to NaN when saturation was 0 . FIX : Give better conversion results by having HWB colors pass through HSV instead of sRGB. FIX : Fix slight issue with REC.2020 and ProPhoto color space conversion. Small issue when using <= when < was desired. 0.1.0a12 FIX : More stable saturation calculation for HSL to ensure divide by zero doesn't occur. 2(V - L) / (1 - abs(2 * L - 1)) is likely to yield zero in the denominator when L is very small, while the equivalent (V - L) / min(L, 1 - L) is not. 0.1.0a11 FIX : Ensure that when hex , compress , and names is enabled in to_string for srgb that colors will still match the color name if the color can be compressed. 0.1.0a10 FIX : Address two divide by zero cases in HSL algorithm. Was missing some special cases when luminance equals 1 or 0 . 0.1.0a9 FIX : Ensure all cases of hue handling, in regards to gamut mapping, are done the same. 0.1.0a8 NEW : Remove workaround to force cylindrical colors to overlay in non-cylindrical spaces. Allow colors to be overlaid in any color space. Original issues related to allowing cylindrical spaces as been fixed. Overlaying in cylindrical spaces may not make sense, but it is no longer prohibited. FIX : Ensure color comparison will yield true if two channels have NaN . 0.1.0a7 FIX : Fix issue with translation of an input that is compressed hex with a specified alpha. 0.1.0a6 FIX : Don't return detached color spaces from steps . Ensure they are wrapped with a Color object on return. 0.1.0a5 FIX : Fix an issue where update can fail due to a color space detached from a parent. FIX : Adjust fit tolerance to be a little more forgiving, but make an adjustment for in_gmaut in relation to HSL as saturation can be wildly out of range for an sRGB color that is only slightly out of gamut. FIX : Ensure in_gamut handles NaN properly. 0.1.0a4 NEW : Use NaN to track undefined hues. NEW : Remove is_hue_null and add new API function is_nan to test if any channel is currently set to NaN . NEW : Remove get_default from the Color class and instead allow properties that can be overridden when subclassing the Color object. 0.1.0a3 FIX : Color object API was missing the ability to receive the premultiplied argument. 0.1.0a2 NEW : Expose access to srgb-linear color space. This is mainly for development and testing and not listed in docs currently. FIX : Cylindrical spaces, when calling overlay can now request to be overlaid in a different space. This is because alpha composition does not work well in cylindrical spaces. HSL, HSV, and HWB will now request overlay to be done in sRGB, and CIELCH will request overlay to be done in CIELAB. FIX : Add support for premultiplied alpha when interpolating via premultiplied option. 0.1.0a1 NEW : Initial alpha release. Library is experimental and API is unstable.","title":"Changelog"},{"location":"about/changelog/#changelog","text":"","title":"Changelog"},{"location":"about/changelog/#010a26","text":"NEW : Use D65 and D50 white points as specified in CSS spec, but limited to 4 decimals as everyone else seems to do. Other white points were also adjusted as outlined in CIE 2004 Colorimetry T.3 and T.8. FIX : When converting, ensure that NaN s are converted to normal numbers.","title":"0.1.0a26"},{"location":"about/changelog/#010a25","text":"NEW : Add luv and lchuv color space using a D50 illuminant. NEW : Add din99o and din99o-lch color space using a D65 illuminant and associated Delta E 99o distance algorithm. NEW : Make it easier to add additional Delta E methods and gamut mapping methods to a custom Color() class. NEW : Add new Delta E z algorithm (Jzazbz). NEW : Add new Delta E hyab algorithm for any Lab-ish style color spaces. NEW : Expose delta_e_<type> methods dynamically depending on what Delta E methods are currently available. FIX : Consistent calculation of achromatic thresholds across all Lch-ish color spaces.","title":"0.1.0a25"},{"location":"about/changelog/#010a24","text":"NEW : color() function locks accepted to channels to the number of actual channels. NEW : All color() function implementations for color spaces that do not formally support such notation in the current CSS spec now use the custom identifier notation --name . For instance, HSL, which does not support the color() format in the CSS spec, is now specified via: color(--hsl h s l / a) . NEW : Channels that do not support percentages will no longer be accepted in the color() form. For instance, according to the CSS spec, XYZ color space does not allow percentages in the color() format. ColorAide will no longer allow such notation in order to conform to the spec. color(--lab) will still support percentages for l as it did prior to removal from the spec. All other percentage only channels will also still be supported. NEW : Internal restructuring of some files and file locations.","title":"0.1.0a24"},{"location":"about/changelog/#010a23","text":"FIX : Faster precision adjustment.","title":"0.1.0a23"},{"location":"about/changelog/#010a22","text":"FIX : Don't have sRGB fail gamut check due to HSL having extreme numbers. If sRGB is within tolerance range, it should pass. Instead, HSL, HSV, and HWB will all be checked to see if they are within the sRGB gamut as they are just representations of sRGB, but they will also have the tolerance checked against their own coordinates to help catch values that are way out of bounds but still yield values within the sRGB tolerance range. FIX : Improve gamut mapping a bit more.","title":"0.1.0a22"},{"location":"about/changelog/#010a21","text":"NEW : Refactor CAT to allow for other CAT methods: von-kries , xyz-scaling , cat02 , cmccat97 , cmccat2000 , and sharp . Currently, bradford is the default and the overall preferred option. FIX : Fix issues gamut mapping algorithm.","title":"0.1.0a21"},{"location":"about/changelog/#010a20","text":"FIX : Fix lab-d65 which was not using the correct white point in all places.","title":"0.1.0a20"},{"location":"about/changelog/#010a19","text":"FIX : Ensure that subclassed Color objects are normalized when performing operations with more than one color to prevent issues in case one subclassed object has overridden important functions. FIX : Spaces like lab , lch , etc., which specify certain channels as percent only should require the color() format to only accept percentages for those channels and output those channels as percentages when converting to a string.","title":"0.1.0a19"},{"location":"about/changelog/#010a18","text":"NEW : Refactor of internals. NEW : interpolate and steps can now accept multiple colors and will return an interpolation function that spans all specified colors via the range of [0..1] . NEW : Better control over piecewise interpolation: setting stops, adjusting options per segment, etc. NEW : compose can now accept multiple colors and will return a result where all colors are layered on top of each other. NEW : new method does not need to be a classmethod . Make it a normal method on the instance. NEW : Add Jzazbz and JzCzhz color spaces. NEW : Add D65 variants of CIELAB, CIELCH, and XYZ. NEW : Add ICtCp color space and Delta E ITP method. FIX : Actually make mix default to lab like interpolate and friends do.","title":"0.1.0a18"},{"location":"about/changelog/#010a17","text":"FIX : Ensure that both the Bradford CAT and the XYZ transformation matrix all use ASTM E308-01 white points. This fixes a number of conversion issues when going to and from D65 to D50 color spaces.","title":"0.1.0a17"},{"location":"about/changelog/#010a16","text":"NEW : Make mix use the same space logic as interpolate and step . Colors are mixed in CIELAB unless space is set to a different color space. NEW : Add support for blend modes as specified in Compositing and Blending Level 1 . NEW : Rename overlay to compose as all compositing (including blend modes) is done through compose now. overlay is still present and is deprecated and will be removed at some future point before a stable release. compose will assume sRGB space unless a different space is specified, but overlay will function as it always did. FIX : Fix some small internal issues with in_place logic.","title":"0.1.0a16"},{"location":"about/changelog/#010a15","text":"NEW : The adjust parameter on interpolate , steps , and mix has been dropped. Instead, a general purpose method has been added to the Color object to mask one or more channels at a time. This can be used to create a temporary color with masked channels for the purpose of interpolation. FIX : Ensure that when alpha is NaN that it is handled in overlay . FIX : When using raw data in the color() function, and there is too little data, fill data with NaN . FIX : Fix issue where API interpolate method does not pass out_space parameter down. FIX : Disabling or forcing alpha did not work properly for HSL colors via to_string . FIX : contrast and luminance should use XYZ with a D65 white point, not the default XYZ space which uses a D50 white point. FIX : Fix bug in Delta E 2000 algorithm.","title":"0.1.0a15"},{"location":"about/changelog/#010a14","text":"NEW : sRGB string output parameter hex_upper has been renamed to just upper . Expose it in documentation as well.","title":"0.1.0a14"},{"location":"about/changelog/#010a13","text":"FIX : More efficient calculation of CIELAB, following CIE 15.3:2004. Results are still the same, but it makes the math a little simpler. FIX : HSV did not always set hue to NaN when saturation was 0 . FIX : Give better conversion results by having HWB colors pass through HSV instead of sRGB. FIX : Fix slight issue with REC.2020 and ProPhoto color space conversion. Small issue when using <= when < was desired.","title":"0.1.0a13"},{"location":"about/changelog/#010a12","text":"FIX : More stable saturation calculation for HSL to ensure divide by zero doesn't occur. 2(V - L) / (1 - abs(2 * L - 1)) is likely to yield zero in the denominator when L is very small, while the equivalent (V - L) / min(L, 1 - L) is not.","title":"0.1.0a12"},{"location":"about/changelog/#010a11","text":"FIX : Ensure that when hex , compress , and names is enabled in to_string for srgb that colors will still match the color name if the color can be compressed.","title":"0.1.0a11"},{"location":"about/changelog/#010a10","text":"FIX : Address two divide by zero cases in HSL algorithm. Was missing some special cases when luminance equals 1 or 0 .","title":"0.1.0a10"},{"location":"about/changelog/#010a9","text":"FIX : Ensure all cases of hue handling, in regards to gamut mapping, are done the same.","title":"0.1.0a9"},{"location":"about/changelog/#010a8","text":"NEW : Remove workaround to force cylindrical colors to overlay in non-cylindrical spaces. Allow colors to be overlaid in any color space. Original issues related to allowing cylindrical spaces as been fixed. Overlaying in cylindrical spaces may not make sense, but it is no longer prohibited. FIX : Ensure color comparison will yield true if two channels have NaN .","title":"0.1.0a8"},{"location":"about/changelog/#010a7","text":"FIX : Fix issue with translation of an input that is compressed hex with a specified alpha.","title":"0.1.0a7"},{"location":"about/changelog/#010a6","text":"FIX : Don't return detached color spaces from steps . Ensure they are wrapped with a Color object on return.","title":"0.1.0a6"},{"location":"about/changelog/#010a5","text":"FIX : Fix an issue where update can fail due to a color space detached from a parent. FIX : Adjust fit tolerance to be a little more forgiving, but make an adjustment for in_gmaut in relation to HSL as saturation can be wildly out of range for an sRGB color that is only slightly out of gamut. FIX : Ensure in_gamut handles NaN properly.","title":"0.1.0a5"},{"location":"about/changelog/#010a4","text":"NEW : Use NaN to track undefined hues. NEW : Remove is_hue_null and add new API function is_nan to test if any channel is currently set to NaN . NEW : Remove get_default from the Color class and instead allow properties that can be overridden when subclassing the Color object.","title":"0.1.0a4"},{"location":"about/changelog/#010a3","text":"FIX : Color object API was missing the ability to receive the premultiplied argument.","title":"0.1.0a3"},{"location":"about/changelog/#010a2","text":"NEW : Expose access to srgb-linear color space. This is mainly for development and testing and not listed in docs currently. FIX : Cylindrical spaces, when calling overlay can now request to be overlaid in a different space. This is because alpha composition does not work well in cylindrical spaces. HSL, HSV, and HWB will now request overlay to be done in sRGB, and CIELCH will request overlay to be done in CIELAB. FIX : Add support for premultiplied alpha when interpolating via premultiplied option.","title":"0.1.0a2"},{"location":"about/changelog/#010a1","text":"NEW : Initial alpha release. Library is experimental and API is unstable.","title":"0.1.0a1"},{"location":"about/contributing/","text":"Contributing & Support Become a Sponsor Open source projects take time and money. Help support the project by becoming a sponsor. You can add your support at any tier you feel comfortable with. No amount is too little. We also accept one time contributions via PayPal. GitHub Sponsors PayPal Bug Reports Please read the documentation and search the issue tracker to try and find the answer to your question before posting an issue. When creating an issue on the repository, please provide as much info as possible: Version being used. Operating system. Version of Python. Errors in console. Detailed description of the problem. Examples for reproducing the error. You can post pictures, but if specific text or code is required to reproduce the issue, please provide the text in a plain text format for easy copy/paste. The more info provided, the greater the chance someone will take the time to answer, implement, or fix the issue. Be prepared to answer questions and provide additional information if required. Issues in which the creator refuses to respond to follow up questions will be marked as stale and closed. Reviewing Code Take part in reviewing pull requests and/or reviewing direct commits. Make suggestions to improve the code and discuss solutions to overcome weakness in the algorithm. Answer Questions in Issues Take time and answer questions and offer suggestions to people who've created issues in the issue tracker. Often people will have questions that you might have an answer for. Or maybe you know how to help them accomplish a specific task they are asking about. Feel free to share your experience to help others out. Pull Requests Pull requests are welcome, and a great way to help fix bugs and add new features. Documentation Improvements A ton of time has been spent not only creating and supporting this tool and related extensions, but also spent making this documentation. If you feel it is still lacking, show your appreciation for the tool and/or extensions by helping to improve the documentation.","title":"Contributing &amp; Support"},{"location":"about/contributing/#contributing--support","text":"","title":"Contributing &amp; Support"},{"location":"about/contributing/#become-a-sponsor","text":"Open source projects take time and money. Help support the project by becoming a sponsor. You can add your support at any tier you feel comfortable with. No amount is too little. We also accept one time contributions via PayPal. GitHub Sponsors PayPal","title":"Become a Sponsor "},{"location":"about/contributing/#bug-reports","text":"Please read the documentation and search the issue tracker to try and find the answer to your question before posting an issue. When creating an issue on the repository, please provide as much info as possible: Version being used. Operating system. Version of Python. Errors in console. Detailed description of the problem. Examples for reproducing the error. You can post pictures, but if specific text or code is required to reproduce the issue, please provide the text in a plain text format for easy copy/paste. The more info provided, the greater the chance someone will take the time to answer, implement, or fix the issue. Be prepared to answer questions and provide additional information if required. Issues in which the creator refuses to respond to follow up questions will be marked as stale and closed.","title":"Bug Reports"},{"location":"about/contributing/#reviewing-code","text":"Take part in reviewing pull requests and/or reviewing direct commits. Make suggestions to improve the code and discuss solutions to overcome weakness in the algorithm.","title":"Reviewing Code"},{"location":"about/contributing/#answer-questions-in-issues","text":"Take time and answer questions and offer suggestions to people who've created issues in the issue tracker. Often people will have questions that you might have an answer for. Or maybe you know how to help them accomplish a specific task they are asking about. Feel free to share your experience to help others out.","title":"Answer Questions in Issues"},{"location":"about/contributing/#pull-requests","text":"Pull requests are welcome, and a great way to help fix bugs and add new features.","title":"Pull Requests"},{"location":"about/contributing/#documentation-improvements","text":"A ton of time has been spent not only creating and supporting this tool and related extensions, but also spent making this documentation. If you feel it is still lacking, show your appreciation for the tool and/or extensions by helping to improve the documentation.","title":"Documentation Improvements"},{"location":"about/license/","text":"License ColorAide MIT License Copyright \u00a9 2020 - 2021 Isaac Muse Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"about/license/#license","text":"","title":"License"},{"location":"about/license/#coloraide","text":"MIT License Copyright \u00a9 2020 - 2021 Isaac Muse Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"ColorAide"},{"location":"api/","text":"Color API coloraide.NaN Description NaN is a convenience constant for float('nan') . NaN . Import path NaN is imported from the coloraide library: from coloraide import NaN coloraide.Piecewise class Piecewise ( namedtuple ( 'Piecewise' , [ 'color' , 'stop' , 'progress' , 'hue' , 'premultiplied' ] ) ): Description Piecewise objects are used in interpolate methods. They allow a user to control interpolation stops , progress , hue , or premultiplied options for a specific interpolation piece when doing piecewise interpolation. Import Path Piecewise is imported from coloraide library: from coloraide import Piecewise Parameters Input parameters match interpolate parameters of the same name. Only color is required and all other parameters default to None . If a parameter is None , it will be ignored by interpolate . coloraide.Color class Color : def __init__ ( self , color , data = None , alpha = util . DEF_ALPHA , * , filters = None , ** kwargs ): Description The Color class object is a wrapper around the internal color space objects. It provides an API interface to allow users to specify and manipulate colors. Import path Color is imported from the coloraide library: from coloraide import Color Parameters Parameters Defaults Description color A color string, or other Color class object. If given data , a string must be used and should represent the color space to use. data None data accepts a list of numbers representing the coordinates of the color. If provided, color must be a string specifying the color space. alpha 1 alpha accepts a number specifying the alpha channel. Must be used in conjunction with data or it will be ignored. filters None filters accepts a list of color spaces to allow. When None is provided (the default) all supported color spaces are accepted. Color.match @classmethod def match ( cls , string , start = 0 , fullmatch = False , * , filters = None ): Description The match class method provides access to the color matching interface and allows a user to provide a color string and get back a ColorMatch object. ColorMatch objects contain three properties: class ColorMatch : def __init__ ( self , color , start , end ): color : the Color object. start : the starting point within the string buffer where the color was found. end : the ending point within the string buffer where the color was found. Match does not search the entire buffer, but simply matches at the location specified by start . Parameters Parameters Defaults Description string A string representing the color. start 0 Accepts a integer offset into the provided string buffer to start the match. fullmatch False A boolean which defines whether match must match to the end of the string buffer. filters None filters accepts a list of color spaces to allow. When None is provided (the default) all supported color spaces are accepted. Return Returns a ColorMatch object. Color.new def new ( self , color , data = None , alpha = util . DEF_ALPHA , * , filters = None , ** kwargs ): Description The new class method exposes the interface of creating new color objects. Using new is the same as using Color() . Parameters Parameters Defaults Description color A color string, or other Color class object. If given data , a string must be used and should represent the color space to use. data None data accepts a list of numbers representing the coordinates of the color. If provided, color must be a string specifying the color space. alpha 1 alpha accepts a number specifying the alpha channel. Must be used in conjunction with data or it will be ignored. filters None filters accepts a list of color spaces to allow. When None is provided (the default) all supported color spaces are accepted. Return Returns a Color object. Color.clone def clone ( self ): Description The clone method provides a way to create a duplicate of the current Color instance. Return Returns a Color object. Color.update def update ( self , color , data = None , alpha = util . DEF_ALPHA , * , filters = None , ** kwargs ): Description The update method provides a way to update the underlying color spaces with coordinates from any color space. The methods signature looks just like new and accepts color strings, Color objects, or raw data points specified with a color space string and coordinates. The object itself will be updated and remain in its current color space. Parameters Parameters Defaults Description color A color string, or other Color class object. If given data , a string must be used and should represent the color space to use. data None data accepts a list of numbers representing the coordinates of the color. If provided, color must be a string specifying the color space. alpha 1 alpha accepts a number specifying the alpha channel. Must be used in conjunction with data or it will be ignored. filters None filters accepts a list of color spaces to allow. When None is provided (the default) all supported color spaces are accepted. Return Returns a reference to the current Color object. Color.mutate def mutate ( self , color , data = None , alpha = util . DEF_ALPHA , * , filters = None , ** kwargs ): Description The mutate method is just like update except that it will not only update the color space, but mutate it to the provided color space. Parameters Parameters Defaults Description color A color string, or other Color class object. If given data , a string must be used and should represent the color space to use. data None data accepts a list of numbers representing the coordinates of the color. If provided, color must be a string specifying the color space. alpha 1 alpha accepts a number specifying the alpha channel. Must be used in conjunction with data or it will be ignored. filters None filters accepts a list of color spaces to allow. When None is provided (the default) all supported color spaces are accepted. Return Returns a reference to the current Color object. Color.convert def convert ( self , space , * , fit = False , in_place = False ): Description Converts a Color object from one color space to another. If the current color space matches the specified color space, the object will be cloned. Parameters Parameters Defaults Description space A string representing the desired final color space. fit False Boolean specifying whether the current color should be gamut mapped into the final, desired color space. in_place False Boolean specifying whether the convert should alter the current Color object or return a new one. Return Returns a reference to the converted Color object. If in_place is True , the return will be a reference to the current Color object. Color.space def space ( self ): Description Retrieves the current color space of the color. Return Returns a string with the name of the current color space. Color.coords def coords ( self ): Description Returns a list of the color's coordinates. This does not include the alpha channel. Alpha can be accessed via the alpha property or get and set accessors. Return Returns a list of numbers indicating the current coordinate values. Color.to_string def to_string ( self , ** kwargs ): Description Method that converts the current color to an output format supported by the color space. While a number of the parameters are common, some may be specific to the color space. The usage guide covers color space specific options in more details. Parameters Common parameters: Parameters Defaults Description alpha None Boolean or None value which determines whether the output includes alpha . If None (the default) alpha will only be shown if less than 1. If True , alpha will always be shown. If False , alpha will be omitted. precision 5 Integer value that sets precision and scale. Precision and scale will match the value if greater than zero. If 0 , values will be rounded to the nearest integer. If -1 , number will be output at the highest precision. fit True A boolean that controls whether gamut mapping is performed on string creation. By default, colors will be fit to their own color space. This can be disabled by setting to False . color False A boolean that will determine if the color(space coord+ / alpha) format is used for string output. Has highest precedence. sRGB specific parameters: Parameters Defaults Description hex . False String output will be in #RRGGBBAA format. names False Boolean indicating a preference for CSS color names. When translating a color to it's closest hex form, if that hex value matches a CSS color name, that color name will be returned as the output. hex does not have to be True for this to apply. compress False If hex is True and compress is True , hex values will be compressed if possible: #RRGGBBAA \u2192 #RGBA . Space dependent parameters: Parameters Defaults Description comma False If supported by the color space and the current output format, commas will be used instead of space format: rgba(0, 0, 0, 1) \u2192 rgb(0 0 0 /1) . Return Returns a string representation of the current color. Color.luminance def luminance ( self ): Description Get the relative luminance. Relative luminance is obtained from the Y coordinate in the XYZ color space. XYZ, in this case, has a D65 white point. Return Returns an float indicating the relative luminance. Color.contrast def contrast ( self , color ): Description Get the contrast ratio based on the relative luminance between two colors. Parameters Parameters Defaults Description color A color string or Color object representing a color. Return Returns a float indicating the contrast ratio between two colors. Color.distance def distance ( self , color , * , space = util . DEF_DISTANCE_SPACE ): Description Performs a euclidean distance algorithm on two colors. Parameters Parameters Defaults Description color A color string or Color object representing a color. space \"lab\" Color space to perform distancing algorithm in. Return Returns a float indicating euclidean distance between the two colors. Color.delta_e def delta_e ( self , color , * , method = None , ** kwargs ): Description Performs a delta E distance algorithm on two colors. Default algorithm that is used is Delta E 1976 ( 76 ). Some methods have additional weighting that can be configured through method specific options which are represented by **kwargs . Available methods: Name Input CIE76 76 CIE94 94 CIEDE2000 2000 CMC l:c (1984) cmc Parameters Parameters Defaults Description color A color string or Color object representing a color. method None String that specifies the method to use. If None , the default will be used. Return Returns a float indicating the delta E distance between the two colors. color.mask def mask self , channels , invert = False , in_place = False ): Description The mask method will set any and all specified channels to NaN . If invert is set to True , mask will set any and all channels not specified to NaN . Parameters Parameters Defaults Description channel A string specifying a channel, or a list of strings specifying multiple channels. Specified channels will be masked (or the only channels not masked if invert is True ). invert False Use inverse masking logic and mask all channels that are not specified. in_place False Boolean used to determine if the current color should be modified \"in place\" or a new Color object should be returned. Return Returns a reference to the masked Color object. If in_place is True , the return will be a reference to the current Color object. Color.interpolate def interpolate ( self , color , * , stop = 0 , space = \"lab\" , progress = None , out_space = None , hue = util . DEF_HUE_ADJ , premultiplied = False ): Description The interpolate method creates a function that takes a value between 0 - 1 and interpolates a new color based on the input value. If more than one color is provided, the returned function will span the interpolations between all the provided colors with the same range of 0 - 1. Interpolation can be customized by limiting the interpolation to specific color channels, providing custom interpolation functions, and even adjusting the hue logic used. Piecewise objects can be used to specify stops or adjust the interpolation for itself and the preceding color. Hue Evaluation Description shorter Angles are adjusted so that \u03b8\u2082 - \u03b8\u2081 \u2208 [-180, 180]. longer Angles are adjusted so that \u03b8\u2082 - \u03b8\u2081 \u2208 {0, [180, 360)}. increasing Angles are adjusted so that \u03b8\u2082 - \u03b8\u2081 \u2208 [0, 360). decreasing Angles are adjusted so that \u03b8\u2082 - \u03b8\u2081 \u2208 (-360, 0] specified No fixup is performed. Angles are interpolated in the same way as every other component. Parameters Parameters Defaults Description color A color string, Color object, or Piecewise object representing a color. Also, multiple can be provided via a list. space \"lab\" Color space to interpolate in. progress None An optional function that that allows for custom logic to perform non-linear interpolation. out_space None Color space that the new color should be in. If None , the color will be in the same color space as the base color. hue \"shorter\" Define how color spaces which have hue angles are interpolated. Default evaluates between the shortest angle. premultiplied False Use premultiplied alpha when interpolating. Return Returns a function that takes a range from [0..1] . The function returns a reference to the interpolated Color object. Color.steps def steps ( self , color , * , steps = 2 , max_steps = 1000 , max_delta_e = 0 , ** interpolate_args ): Description Creates an interpolate function and iterates through it with user defined step parameters to produce discrete color steps. Will attempt to provide the minimum number of steps without exceeding max_steps . If max_delta_e is provided, the distance between each stop will be cut in half until there are no colors with a distance greater than the specified max_delta_e . If more than one color is provided, the steps will be returned from the interpolations between all the provided colors. Like interpolate , the default interpolation space is lab . Parameters Parameters Defaults Description color A color string or Color object representing a color. Also, multiple can be provided via a list. steps 2 Minimum number of steps. max_steps 1000 Maximum number of steps. max_delta_e 0 Maximum delta E distance between the color stops. A value of 0 or less will be ignored. ** interpolate_args See interpolate Keyword arguments defined in interpolate . Return List of Color objects. Color.mix def mix ( self , color , percent = util . DEF_MIX , * , in_place = False , ** interpolate_args ): Description Interpolates between two colors returning a color that represents the mixing of the base color and the provided color mixed at the provided percent , where percent applies to how much the provided color contributes to the the final result. Parameters Parameters Defaults Description color A color string or Color object representing a color. percent 0.5 A numerical value between 0 - 1 representing the percentage at which the parameter color will be mixed. in_place False Boolean used to determine if the the current color should be modified \"in place\" or a new Color object should be returned. ** interpolate_args See interpolate Keyword arguments defined in interpolate . Return Returns a reference to the new Color object or a reference to the current Color if in_place is True . Color.average def average ( self , color , weights = None , * , space = 'lab' , out_space = None , in_place = False , hue = util . DEF_HUE_ADJ , sort_hue = False ): Description Allows the averaging of one or more colors essentially allowing a mixing of any number of colors. Each color is mixed in such a way so that each color has an equal weight. If, and only if, a color set has a color with transparency, the transparency will be averaged separately. The specified color(s) to average with the base color can be a single color, or a list of colors as specified in the parameters below. Like interpolate , the default interpolation space is lab . Parameters Parameters Defaults Description color A color string or Color object representing a color. Also, multiple can be provided via a list. weights [ 1 ] * n An array of length n (where n is number of colors that are to be averaged) that specifies the weight of the given colors. Order of the weights should match the order of the inputs where the base color is index 0. space \"lab\" Color space to interpolate in. out_space None Color space that the new color should be in. If None , the color will be in the same color space as the base color. hue \"shorter\" Define how color spaces which have hue angles are interpolated. Default evaluates between the shortest angle. in_place False Boolean used to determine if the the current color should be modified \"in place\" or a new Color object should be returned. sort_hue #py3 False Specifies whether cylindrical spaces should sort colors by hue before averaging to ensure a consistence, predictable averaging regardless of what order the colors are provided. Return Returns a reference to the new Color object or a reference to the current Color if in_place is True . Color.compose def compose ( self , backdrop , * , blend = None , operator = None , space = None , out_space = None , in_place = False ): Description Apply compositing which consists of a blend mode and a Porter Duff operator for alpha compositing. The current color is treated as the source (top layer) and the provided color as the backdrop (bottom layer). Colors will be composited in the srgb color space unless otherwise specified. Colors should generally be RGB-ish colors (sRGB, Display P3, A98 RGB, etc.). Some non-RGB-ish colors may work okay, with the defaults, but many the algorithm is really designed for RGB-ish colors. Non-RGB-ish colors are likely to provide nonsense results. Supported blend modes are: Blend Modes normal multiply darken lighten burn dodge screen overlay hard-light exclusion difference soft-light hue saturation luminosity color color hue saturation luminosity Supported Port Duff operators are: Operators clear copy destination source-over destination-over source-in destination-in source-out destination-out source-atop destination-atop xor lighter Parameters Parameters Defaults Description backdrop A background color represented with either a string or Color object. blend None A blend mode to use to use when compositing. Values should be a string specifying the name of the blend mode to use. If None , normal will be used. If False , blending will be skipped. operator None A Porter Duff operator to use for alpha compositing. Values should be a string specifying the name of the operator to use. If None , source-over will be used. If False , alpha compositing will be skipped. space None A color space to perform the overlay in. If None , the base color's space will be used. out_space None A color space to output the resultant color to. in_place False Boolean used to determine if the the current color should be modified \"in place\" or a new Color object should be returned. Return Returns a reference to the new Color object or a reference to the current Color if in_place is True . Color.fit def fit ( self , space = None , * , method = None , in_place = False ): Description Fits color to the current or specified color gamut. By default, lch-chroma gamut mapping is used. This is essentially an approach that holds lightness and hue constant in the CIELCH color space while reducing chroma until the color is in gamut. Clipping is done at each step of the way and the color distance measured to see how close our color is to the intended color. The supported gamut mapping methods are: Name Input LCH Chroma lch-chroma Clipping clip Parameters Parameters Defaults Description space None The color space that the color must be mapped to. If space is None , then the current color space will be used. method None String that specifies which gamut mapping method to use. If None , lch-chroma will be used. Return Returns a reference to the new Color object or a reference to the current Color if in_place is True . Color.in_gamut def in_gamut ( self , space = None , * , tolerance = util . DEF_FIT_TOLERANCE ): Description Checks if the current color is in the current or specified gamut. Parameters Parameters Defaults Description space None The color space that the color must be fit within. If space is None , then the current color space will be used. tolerance 0.000075 Tolerance allowed when checking bounds of color. Return Returns a boolean indicating whether the color is in the specified gamut. Color.get def get ( self , name ): Description Retrieves the coordinate value from the specified channel. Channel must be a channel name in the current color space or a channel name in the specified color space using the syntax: space.channel . Parameters Parameters Defaults Description name Channel name or color space and channel name to retrieve value from. Return Returns a numerical value that is stored internally for the specified channel, or a calculated value in the case that a channel in a different color space is requested. Color.set def set ( self , name , value ): Description Sets the given value to the specified channel. If the name is provided in the form space.channel , the value will be applied to the channel of the specified color space while keeping current color space the same. The value can be a numerical value, a CSS string compatible with the specified color space, or a function that accepts a numerical channel value and returns a numerical channel value. This function returns the current colors reference so that multiple sets can be chained together. Parameters Parameters Defaults Description name Channel name or color space and channel name to retrieve value from. value A numerical value, a string value accepted by the specified color space, or a function. Return Returns a reference to the current Color object. Color.is_nan def is_nan ( self , name ): Description Retrieves the coordinate value from the specified channel and checks whether the value is NaN . Channel must be a channel name in the current color space or a channel name in the specified color space using the syntax: space.channel . Parameters Parameters Defaults Description name A string indicating what channel property to check. Return Returns a boolean indicating whether the specified color space's channel is NaN . Color Channel Properties Depending on the given color space, channel properties will be available on the color object as well. These are dynamically available depending on what the current color space is. For instance, if the color space is sRGB, the channels red , green , blue , and alpha will all be available. Color channel names are defined in Supported Colors . These properties are read and writable. When read, they will return the numerical value stored in the specified channel. When written, they can accept a numerical value or a string value using CSS syntax acceptable for that channel in that color space. For more complex setting operations, or to chain multiple set operations, please use set and get .","title":"Color API"},{"location":"api/#color-api","text":"","title":"Color API"},{"location":"api/#nan","text":"Description NaN is a convenience constant for float('nan') . NaN . Import path NaN is imported from the coloraide library: from coloraide import NaN","title":"coloraide.NaN"},{"location":"api/#piecewise","text":"class Piecewise ( namedtuple ( 'Piecewise' , [ 'color' , 'stop' , 'progress' , 'hue' , 'premultiplied' ] ) ): Description Piecewise objects are used in interpolate methods. They allow a user to control interpolation stops , progress , hue , or premultiplied options for a specific interpolation piece when doing piecewise interpolation. Import Path Piecewise is imported from coloraide library: from coloraide import Piecewise Parameters Input parameters match interpolate parameters of the same name. Only color is required and all other parameters default to None . If a parameter is None , it will be ignored by interpolate .","title":"coloraide.Piecewise"},{"location":"api/#color","text":"class Color : def __init__ ( self , color , data = None , alpha = util . DEF_ALPHA , * , filters = None , ** kwargs ): Description The Color class object is a wrapper around the internal color space objects. It provides an API interface to allow users to specify and manipulate colors. Import path Color is imported from the coloraide library: from coloraide import Color Parameters Parameters Defaults Description color A color string, or other Color class object. If given data , a string must be used and should represent the color space to use. data None data accepts a list of numbers representing the coordinates of the color. If provided, color must be a string specifying the color space. alpha 1 alpha accepts a number specifying the alpha channel. Must be used in conjunction with data or it will be ignored. filters None filters accepts a list of color spaces to allow. When None is provided (the default) all supported color spaces are accepted.","title":"coloraide.Color"},{"location":"api/#match","text":"@classmethod def match ( cls , string , start = 0 , fullmatch = False , * , filters = None ): Description The match class method provides access to the color matching interface and allows a user to provide a color string and get back a ColorMatch object. ColorMatch objects contain three properties: class ColorMatch : def __init__ ( self , color , start , end ): color : the Color object. start : the starting point within the string buffer where the color was found. end : the ending point within the string buffer where the color was found. Match does not search the entire buffer, but simply matches at the location specified by start . Parameters Parameters Defaults Description string A string representing the color. start 0 Accepts a integer offset into the provided string buffer to start the match. fullmatch False A boolean which defines whether match must match to the end of the string buffer. filters None filters accepts a list of color spaces to allow. When None is provided (the default) all supported color spaces are accepted. Return Returns a ColorMatch object.","title":"Color.match"},{"location":"api/#new","text":"def new ( self , color , data = None , alpha = util . DEF_ALPHA , * , filters = None , ** kwargs ): Description The new class method exposes the interface of creating new color objects. Using new is the same as using Color() . Parameters Parameters Defaults Description color A color string, or other Color class object. If given data , a string must be used and should represent the color space to use. data None data accepts a list of numbers representing the coordinates of the color. If provided, color must be a string specifying the color space. alpha 1 alpha accepts a number specifying the alpha channel. Must be used in conjunction with data or it will be ignored. filters None filters accepts a list of color spaces to allow. When None is provided (the default) all supported color spaces are accepted. Return Returns a Color object.","title":"Color.new"},{"location":"api/#clone","text":"def clone ( self ): Description The clone method provides a way to create a duplicate of the current Color instance. Return Returns a Color object.","title":"Color.clone"},{"location":"api/#update","text":"def update ( self , color , data = None , alpha = util . DEF_ALPHA , * , filters = None , ** kwargs ): Description The update method provides a way to update the underlying color spaces with coordinates from any color space. The methods signature looks just like new and accepts color strings, Color objects, or raw data points specified with a color space string and coordinates. The object itself will be updated and remain in its current color space. Parameters Parameters Defaults Description color A color string, or other Color class object. If given data , a string must be used and should represent the color space to use. data None data accepts a list of numbers representing the coordinates of the color. If provided, color must be a string specifying the color space. alpha 1 alpha accepts a number specifying the alpha channel. Must be used in conjunction with data or it will be ignored. filters None filters accepts a list of color spaces to allow. When None is provided (the default) all supported color spaces are accepted. Return Returns a reference to the current Color object.","title":"Color.update"},{"location":"api/#mutate","text":"def mutate ( self , color , data = None , alpha = util . DEF_ALPHA , * , filters = None , ** kwargs ): Description The mutate method is just like update except that it will not only update the color space, but mutate it to the provided color space. Parameters Parameters Defaults Description color A color string, or other Color class object. If given data , a string must be used and should represent the color space to use. data None data accepts a list of numbers representing the coordinates of the color. If provided, color must be a string specifying the color space. alpha 1 alpha accepts a number specifying the alpha channel. Must be used in conjunction with data or it will be ignored. filters None filters accepts a list of color spaces to allow. When None is provided (the default) all supported color spaces are accepted. Return Returns a reference to the current Color object.","title":"Color.mutate"},{"location":"api/#convert","text":"def convert ( self , space , * , fit = False , in_place = False ): Description Converts a Color object from one color space to another. If the current color space matches the specified color space, the object will be cloned. Parameters Parameters Defaults Description space A string representing the desired final color space. fit False Boolean specifying whether the current color should be gamut mapped into the final, desired color space. in_place False Boolean specifying whether the convert should alter the current Color object or return a new one. Return Returns a reference to the converted Color object. If in_place is True , the return will be a reference to the current Color object.","title":"Color.convert"},{"location":"api/#space","text":"def space ( self ): Description Retrieves the current color space of the color. Return Returns a string with the name of the current color space.","title":"Color.space"},{"location":"api/#coords","text":"def coords ( self ): Description Returns a list of the color's coordinates. This does not include the alpha channel. Alpha can be accessed via the alpha property or get and set accessors. Return Returns a list of numbers indicating the current coordinate values.","title":"Color.coords"},{"location":"api/#to_string","text":"def to_string ( self , ** kwargs ): Description Method that converts the current color to an output format supported by the color space. While a number of the parameters are common, some may be specific to the color space. The usage guide covers color space specific options in more details. Parameters Common parameters: Parameters Defaults Description alpha None Boolean or None value which determines whether the output includes alpha . If None (the default) alpha will only be shown if less than 1. If True , alpha will always be shown. If False , alpha will be omitted. precision 5 Integer value that sets precision and scale. Precision and scale will match the value if greater than zero. If 0 , values will be rounded to the nearest integer. If -1 , number will be output at the highest precision. fit True A boolean that controls whether gamut mapping is performed on string creation. By default, colors will be fit to their own color space. This can be disabled by setting to False . color False A boolean that will determine if the color(space coord+ / alpha) format is used for string output. Has highest precedence. sRGB specific parameters: Parameters Defaults Description hex . False String output will be in #RRGGBBAA format. names False Boolean indicating a preference for CSS color names. When translating a color to it's closest hex form, if that hex value matches a CSS color name, that color name will be returned as the output. hex does not have to be True for this to apply. compress False If hex is True and compress is True , hex values will be compressed if possible: #RRGGBBAA \u2192 #RGBA . Space dependent parameters: Parameters Defaults Description comma False If supported by the color space and the current output format, commas will be used instead of space format: rgba(0, 0, 0, 1) \u2192 rgb(0 0 0 /1) . Return Returns a string representation of the current color.","title":"Color.to_string"},{"location":"api/#luminance","text":"def luminance ( self ): Description Get the relative luminance. Relative luminance is obtained from the Y coordinate in the XYZ color space. XYZ, in this case, has a D65 white point. Return Returns an float indicating the relative luminance.","title":"Color.luminance"},{"location":"api/#colorcontrast","text":"def contrast ( self , color ): Description Get the contrast ratio based on the relative luminance between two colors. Parameters Parameters Defaults Description color A color string or Color object representing a color. Return Returns a float indicating the contrast ratio between two colors.","title":"Color.contrast"},{"location":"api/#distance","text":"def distance ( self , color , * , space = util . DEF_DISTANCE_SPACE ): Description Performs a euclidean distance algorithm on two colors. Parameters Parameters Defaults Description color A color string or Color object representing a color. space \"lab\" Color space to perform distancing algorithm in. Return Returns a float indicating euclidean distance between the two colors.","title":"Color.distance"},{"location":"api/#delta_e","text":"def delta_e ( self , color , * , method = None , ** kwargs ): Description Performs a delta E distance algorithm on two colors. Default algorithm that is used is Delta E 1976 ( 76 ). Some methods have additional weighting that can be configured through method specific options which are represented by **kwargs . Available methods: Name Input CIE76 76 CIE94 94 CIEDE2000 2000 CMC l:c (1984) cmc Parameters Parameters Defaults Description color A color string or Color object representing a color. method None String that specifies the method to use. If None , the default will be used. Return Returns a float indicating the delta E distance between the two colors.","title":"Color.delta_e"},{"location":"api/#mask","text":"def mask self , channels , invert = False , in_place = False ): Description The mask method will set any and all specified channels to NaN . If invert is set to True , mask will set any and all channels not specified to NaN . Parameters Parameters Defaults Description channel A string specifying a channel, or a list of strings specifying multiple channels. Specified channels will be masked (or the only channels not masked if invert is True ). invert False Use inverse masking logic and mask all channels that are not specified. in_place False Boolean used to determine if the current color should be modified \"in place\" or a new Color object should be returned. Return Returns a reference to the masked Color object. If in_place is True , the return will be a reference to the current Color object.","title":"color.mask"},{"location":"api/#interpolate","text":"def interpolate ( self , color , * , stop = 0 , space = \"lab\" , progress = None , out_space = None , hue = util . DEF_HUE_ADJ , premultiplied = False ): Description The interpolate method creates a function that takes a value between 0 - 1 and interpolates a new color based on the input value. If more than one color is provided, the returned function will span the interpolations between all the provided colors with the same range of 0 - 1. Interpolation can be customized by limiting the interpolation to specific color channels, providing custom interpolation functions, and even adjusting the hue logic used. Piecewise objects can be used to specify stops or adjust the interpolation for itself and the preceding color. Hue Evaluation Description shorter Angles are adjusted so that \u03b8\u2082 - \u03b8\u2081 \u2208 [-180, 180]. longer Angles are adjusted so that \u03b8\u2082 - \u03b8\u2081 \u2208 {0, [180, 360)}. increasing Angles are adjusted so that \u03b8\u2082 - \u03b8\u2081 \u2208 [0, 360). decreasing Angles are adjusted so that \u03b8\u2082 - \u03b8\u2081 \u2208 (-360, 0] specified No fixup is performed. Angles are interpolated in the same way as every other component. Parameters Parameters Defaults Description color A color string, Color object, or Piecewise object representing a color. Also, multiple can be provided via a list. space \"lab\" Color space to interpolate in. progress None An optional function that that allows for custom logic to perform non-linear interpolation. out_space None Color space that the new color should be in. If None , the color will be in the same color space as the base color. hue \"shorter\" Define how color spaces which have hue angles are interpolated. Default evaluates between the shortest angle. premultiplied False Use premultiplied alpha when interpolating. Return Returns a function that takes a range from [0..1] . The function returns a reference to the interpolated Color object.","title":"Color.interpolate"},{"location":"api/#steps","text":"def steps ( self , color , * , steps = 2 , max_steps = 1000 , max_delta_e = 0 , ** interpolate_args ): Description Creates an interpolate function and iterates through it with user defined step parameters to produce discrete color steps. Will attempt to provide the minimum number of steps without exceeding max_steps . If max_delta_e is provided, the distance between each stop will be cut in half until there are no colors with a distance greater than the specified max_delta_e . If more than one color is provided, the steps will be returned from the interpolations between all the provided colors. Like interpolate , the default interpolation space is lab . Parameters Parameters Defaults Description color A color string or Color object representing a color. Also, multiple can be provided via a list. steps 2 Minimum number of steps. max_steps 1000 Maximum number of steps. max_delta_e 0 Maximum delta E distance between the color stops. A value of 0 or less will be ignored. ** interpolate_args See interpolate Keyword arguments defined in interpolate . Return List of Color objects.","title":"Color.steps"},{"location":"api/#mix","text":"def mix ( self , color , percent = util . DEF_MIX , * , in_place = False , ** interpolate_args ): Description Interpolates between two colors returning a color that represents the mixing of the base color and the provided color mixed at the provided percent , where percent applies to how much the provided color contributes to the the final result. Parameters Parameters Defaults Description color A color string or Color object representing a color. percent 0.5 A numerical value between 0 - 1 representing the percentage at which the parameter color will be mixed. in_place False Boolean used to determine if the the current color should be modified \"in place\" or a new Color object should be returned. ** interpolate_args See interpolate Keyword arguments defined in interpolate . Return Returns a reference to the new Color object or a reference to the current Color if in_place is True .","title":"Color.mix"},{"location":"api/#average","text":"def average ( self , color , weights = None , * , space = 'lab' , out_space = None , in_place = False , hue = util . DEF_HUE_ADJ , sort_hue = False ): Description Allows the averaging of one or more colors essentially allowing a mixing of any number of colors. Each color is mixed in such a way so that each color has an equal weight. If, and only if, a color set has a color with transparency, the transparency will be averaged separately. The specified color(s) to average with the base color can be a single color, or a list of colors as specified in the parameters below. Like interpolate , the default interpolation space is lab . Parameters Parameters Defaults Description color A color string or Color object representing a color. Also, multiple can be provided via a list. weights [ 1 ] * n An array of length n (where n is number of colors that are to be averaged) that specifies the weight of the given colors. Order of the weights should match the order of the inputs where the base color is index 0. space \"lab\" Color space to interpolate in. out_space None Color space that the new color should be in. If None , the color will be in the same color space as the base color. hue \"shorter\" Define how color spaces which have hue angles are interpolated. Default evaluates between the shortest angle. in_place False Boolean used to determine if the the current color should be modified \"in place\" or a new Color object should be returned. sort_hue #py3 False Specifies whether cylindrical spaces should sort colors by hue before averaging to ensure a consistence, predictable averaging regardless of what order the colors are provided. Return Returns a reference to the new Color object or a reference to the current Color if in_place is True .","title":"Color.average"},{"location":"api/#compose","text":"def compose ( self , backdrop , * , blend = None , operator = None , space = None , out_space = None , in_place = False ): Description Apply compositing which consists of a blend mode and a Porter Duff operator for alpha compositing. The current color is treated as the source (top layer) and the provided color as the backdrop (bottom layer). Colors will be composited in the srgb color space unless otherwise specified. Colors should generally be RGB-ish colors (sRGB, Display P3, A98 RGB, etc.). Some non-RGB-ish colors may work okay, with the defaults, but many the algorithm is really designed for RGB-ish colors. Non-RGB-ish colors are likely to provide nonsense results. Supported blend modes are: Blend Modes normal multiply darken lighten burn dodge screen overlay hard-light exclusion difference soft-light hue saturation luminosity color color hue saturation luminosity Supported Port Duff operators are: Operators clear copy destination source-over destination-over source-in destination-in source-out destination-out source-atop destination-atop xor lighter Parameters Parameters Defaults Description backdrop A background color represented with either a string or Color object. blend None A blend mode to use to use when compositing. Values should be a string specifying the name of the blend mode to use. If None , normal will be used. If False , blending will be skipped. operator None A Porter Duff operator to use for alpha compositing. Values should be a string specifying the name of the operator to use. If None , source-over will be used. If False , alpha compositing will be skipped. space None A color space to perform the overlay in. If None , the base color's space will be used. out_space None A color space to output the resultant color to. in_place False Boolean used to determine if the the current color should be modified \"in place\" or a new Color object should be returned. Return Returns a reference to the new Color object or a reference to the current Color if in_place is True .","title":"Color.compose"},{"location":"api/#fit","text":"def fit ( self , space = None , * , method = None , in_place = False ): Description Fits color to the current or specified color gamut. By default, lch-chroma gamut mapping is used. This is essentially an approach that holds lightness and hue constant in the CIELCH color space while reducing chroma until the color is in gamut. Clipping is done at each step of the way and the color distance measured to see how close our color is to the intended color. The supported gamut mapping methods are: Name Input LCH Chroma lch-chroma Clipping clip Parameters Parameters Defaults Description space None The color space that the color must be mapped to. If space is None , then the current color space will be used. method None String that specifies which gamut mapping method to use. If None , lch-chroma will be used. Return Returns a reference to the new Color object or a reference to the current Color if in_place is True .","title":"Color.fit"},{"location":"api/#in_gamut","text":"def in_gamut ( self , space = None , * , tolerance = util . DEF_FIT_TOLERANCE ): Description Checks if the current color is in the current or specified gamut. Parameters Parameters Defaults Description space None The color space that the color must be fit within. If space is None , then the current color space will be used. tolerance 0.000075 Tolerance allowed when checking bounds of color. Return Returns a boolean indicating whether the color is in the specified gamut.","title":"Color.in_gamut"},{"location":"api/#get","text":"def get ( self , name ): Description Retrieves the coordinate value from the specified channel. Channel must be a channel name in the current color space or a channel name in the specified color space using the syntax: space.channel . Parameters Parameters Defaults Description name Channel name or color space and channel name to retrieve value from. Return Returns a numerical value that is stored internally for the specified channel, or a calculated value in the case that a channel in a different color space is requested.","title":"Color.get"},{"location":"api/#set","text":"def set ( self , name , value ): Description Sets the given value to the specified channel. If the name is provided in the form space.channel , the value will be applied to the channel of the specified color space while keeping current color space the same. The value can be a numerical value, a CSS string compatible with the specified color space, or a function that accepts a numerical channel value and returns a numerical channel value. This function returns the current colors reference so that multiple sets can be chained together. Parameters Parameters Defaults Description name Channel name or color space and channel name to retrieve value from. value A numerical value, a string value accepted by the specified color space, or a function. Return Returns a reference to the current Color object.","title":"Color.set"},{"location":"api/#is_nan","text":"def is_nan ( self , name ): Description Retrieves the coordinate value from the specified channel and checks whether the value is NaN . Channel must be a channel name in the current color space or a channel name in the specified color space using the syntax: space.channel . Parameters Parameters Defaults Description name A string indicating what channel property to check. Return Returns a boolean indicating whether the specified color space's channel is NaN .","title":"Color.is_nan"},{"location":"api/#color-channel-properties","text":"Depending on the given color space, channel properties will be available on the color object as well. These are dynamically available depending on what the current color space is. For instance, if the color space is sRGB, the channels red , green , blue , and alpha will all be available. Color channel names are defined in Supported Colors . These properties are read and writable. When read, they will return the numerical value stored in the specified channel. When written, they can accept a numerical value or a string value using CSS syntax acceptable for that channel in that color space. For more complex setting operations, or to chain multiple set operations, please use set and get .","title":"Color Channel Properties"},{"location":"colors/","text":"Supported Colors sRGB Properties Name: srgb White Point: D65 Coordinates: Name Range red [0, 1] green [0, 1] blue [0, 1] The sRGB space is a standard RGB (red, green, blue) color space that HP and Microsoft created cooperatively in 1996 to use on monitors, printers, and the Web. SRGB stands for \"Standard RGB\". It is the most widely used color space and is supported by most operating systems, software programs, monitors, and printers. Parsed input and string output formats support all valid CSS forms: black // Color name # RRGGBBAA // Hex rgb ( r g b / a ) // RGB function rgb ( r , g , b ) // Legacy RGB Function rgba ( r , g , b , a ) // Legacy RGBA function color ( srgb r g b / a ) // Color function When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"srgb\" , [ 0 , 0 , 0 ], 1 ) The string representation of the color object will always default to the color ( srgb r g b / a ) form, but the default string output will be the rgb ( r g b / a ) form. >>> Color ( \"srgb\" , [ 0 , 0 , 0 ], 1 ) color(srgb 0 0 0 / 1) >>> Color ( \"srgb\" , [ 0 , 0 , 0 ], 1 ) . to_string () rgb(0 0 0) Color(\"srgb\", [0, 0, 0], 1) Color(\"srgb\", [0, 0, 0], 1).to_string() Edit Share Run Cancel Learn about sRGB HSV Properties Name: hsv White Point: D65 Coordinates: Name Range hue [0, 360) saturation [0, 100] value [0, 100] HSV is a color space similar to the modern RGB and CMYK models. The HSV color space has three components: hue, saturation and value. 'Value' is sometimes substituted with 'brightness' and then it is known as HSB. HSV models how colors appear under light. HSV is not supported via the CSS spec and the parser input and string output only supports the color () function format using the custom name --hsv : color ( --hsv 0 0 % 0 % / 1 ) When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"hsv\" , [ 0 , 0 , 0 ], 1 ) The string representation of the color object and default string output will always use the color ( hsv h s v / a ) form. >>> Color ( \"hsv\" , [ 0 , 0 , 0 ], 1 ) color(--hsv 0 0% 0% / 1) >>> Color ( \"hsv\" , [ 0 , 0 , 0 ], 1 ) . to_string () color(--hsv 0 0% 0%) Color(\"hsv\", [0, 0, 0], 1) Color(\"hsv\", [0, 0, 0], 1).to_string() Edit Share Run Cancel Learn about HSV HSL Properties Name: hsl White Point: D65 Coordinates: Name Range hue [0, 360) saturation [0, 100] lightness [0, 100] HSL is an alternative representations of the RGB color model, designed in the 1970s by computer graphics researchers to more closely align with the way human vision perceives color-making attributes. In these models, colors of each hue are arranged in a radial slice, around a central axis of neutral colors which ranges from black at the bottom to white at the top. HSL models the way different paints mix together to create color in the real world, with the lightness dimension resembling the varying amounts of black or white paint in the mixture. Parsed input and string output formats support all valid CSS forms. In addition, we also allow the color () function format using the custom name --hsl : hsl ( h s l / a ) // HSL function hsl ( h , s , l ) // Legacy HSL function hsla ( h , s , l , a ) // Legacy HSLA function color ( --hsl h s l / a ) // Color function When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"hsl\" , [ 0 , 0 , 0 ], 1 ) The string representation of the color object will always default to the color ( --hsl h s l / a ) form, but the default string output will be the hsl ( h s l / a ) form. >>> Color ( \"hsl\" , [ 0 , 0 , 0 ], 1 ) color(--hsl 0 0% 0% / 1) >>> Color ( \"hsl\" , [ 0 , 0 , 0 ], 1 ) . to_string () hsl(0 0% 0%) Color(\"hsl\", [0, 0, 0], 1) Color(\"hsl\", [0, 0, 0], 1).to_string() Edit Share Run Cancel Learn about HSL HWB Properties Name: hwb White Point: D65 Coordinates: Name Range hue [0, 360) whiteness [0, 100] blackness [0, 100] HWB is a cylindrical-coordinate representation of points in an RGB color model, similar to HSL and HSV. It was developed by HSV 's creator Alvy Ray Smith in 1996 to address some of the issues with HSV. HWB was designed to be more intuitive for humans to use and slightly faster to compute. The first coordinate, H (Hue), is the same as the Hue coordinate in HSL and HSV . W and B stand for Whiteness and Blackness respectively and range from 0-100% (or 0-1). The mental model is that the user can pick a main hue and then \"mix\" it with white and/or black to produce the desired color. Parsed input and string output formats support all valid CSS forms. In addition, we also allow the color () function format using the custom name --hwb : hwb ( h w b / a ) // HWB function color ( --hwb h w b / a ) // Color function When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"hwb\" , [ 0 , 0 , 100 ], 1 ) The string representation of the color object will always default to the color ( --hwb h w b / a ) form, but the default string output will be the hsl ( h s l / a ) form. >>> Color ( \"hwb\" , [ 0 , 0 , 100 ], 1 ) color(--hwb 0 0% 100% / 1) >>> Color ( \"hwb\" , [ 0 , 0 , 100 ], 1 ) . to_string () hwb(0 0% 100%) Color(\"hwb\", [0, 0, 100], 1) Color(\"hwb\", [0, 0, 100], 1).to_string() Edit Share Run Cancel Learn about HWB Display P3 Properties Name: display-p3 White Point: D65 Coordinates: Name Range red [0, 1] green [0, 1] blue [0, 1] Display P3 is a combination of the DCI-P3 color gamut with the D65 white point together with the sRGB gamma curve. It originated from the DCI-P3 color gamut's implementation in digital cinema projectors, as this standard offers more vibrant greens and reds than the traditional sRGB color gamut. Parsed input and string output formats support all valid CSS forms: color ( display-p3 r g b / a ) // Color function When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"display-p3\" , [ 0 , 0 , 0 ], 1 ) The string representation of the color object and the default string output will be in the color ( display-p3 r g b / a ) form. >>> Color ( \"display-p3\" , [ 0 , 0 , 0 ], 1 ) color(display-p3 0 0 0 / 1) >>> Color ( \"display-p3\" , [ 0 , 0 , 0 ], 1 ) . to_string () color(display-p3 0 0 0) Color(\"display-p3\", [0, 0, 0], 1) Color(\"display-p3\", [0, 0, 0], 1).to_string() Edit Share Run Cancel Learn about Display P3 A98 RGB Properties Name: a98-rgb White Point: D65 Coordinates: Name Range red [0, 1] green [0, 1] blue [0, 1] The Adobe RGB (1998) color space or opRGB is a color space developed by Adobe Systems, Inc. in 1998. It was designed to encompass most of the colors achievable on CMYK color printers, but by using RGB primary colors on a device such as a computer display. The Adobe RGB (1998) color space encompasses roughly 50% of the visible colors specified by the CIELAB color space - improving upon the gamut of the sRGB color space, primarily in cyan-green hues. Parsed input and string output formats support all valid CSS forms: color ( a98-rgb r g b / a ) // Color function When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"a98-rgb\" , [ 0 , 0 , 0 ], 1 ) The string representation of the color object and the default string output will be in the color ( a98-rgb r g b / a ) form. >>> Color ( \"a98-rgb\" , [ 0 , 0 , 0 ], 1 ) color(a98-rgb 0 0 0 / 1) >>> Color ( \"a98-rgb\" , [ 0 , 0 , 0 ], 1 ) . to_string () color(a98-rgb 0 0 0) Color(\"a98-rgb\", [0, 0, 0], 1) Color(\"a98-rgb\", [0, 0, 0], 1).to_string() Edit Share Run Cancel Learn about A98 RGB REC.2020 Properties Name: rec2020 White Point: D65 Coordinates: Name Range red [0, 1] green [0, 1] blue [0, 1] The Rec. 2020 color space is a result of this and is a very wide gamut RGB color space which is used in 4k and 8k UHDTV. ITU-R Recommendation BT.2020, more commonly known by the abbreviations Rec. 2020 or BT.2020, defines various aspects of ultra-high-definition television (UHDTV) with standard dynamic range (SDR) and wide color gamut (WCG), including picture resolutions, frame rates with progressive scan, bit depths, color primaries, RGB and luma-chroma color representations, chroma subsamplings, and an opto-electronic transfer function. Parsed input and string output formats support all valid CSS forms: color ( rec2020 r g b / a ) // Color function When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"rec2020\" , [ 0 , 0 , 0 ], 1 ) The string representation of the color object and the default string output will be in the color ( rec2020 r g b / a ) form. >>> Color ( \"rec2020\" , [ 0 , 0 , 0 ], 1 ) color(rec2020 0 0 0 / 1) >>> Color ( \"rec2020\" , [ 0 , 0 , 0 ], 1 ) . to_string () color(rec2020 0 0 0) Color(\"rec2020\", [0, 0, 0], 1) Color(\"rec2020\", [0, 0, 0], 1).to_string() Edit Share Run Cancel Learn about REC.2020 ProPhoto Properties Name: prophoto-rgb White Point: D50 Coordinates: Name Range red [0, 1] green [0, 1] blue [0, 1] The ProPhoto RGB color space, also known as ROMM RGB (Reference Output Medium Metric), is an output referred RGB color space developed by Kodak. It offers an especially large gamut designed for use with photographic output in mind. The ProPhoto RGB color space encompasses over 90% of possible surface colors in the CIE L*a*b* color space, and 100% of likely occurring real-world surface colors documented by Pointer in 1980. Parsed input and string output formats support all valid CSS forms: color ( prophoto-rgb r g b / a ) // Color function When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"prophoto-rgb\" , [ 0 , 0 , 0 ], 1 ) The string representation of the color object and the default string output will be in the color ( prophoto-rgb r g b / a ) form. >>> Color ( \"prophoto-rgb\" , [ 0 , 0 , 0 ], 1 ) color(prophoto-rgb 0 0 0 / 1) >>> Color ( \"prophoto-rgb\" , [ 0 , 0 , 0 ], 1 ) . to_string () color(prophoto-rgb 0 0 0) Color(\"prophoto-rgb\", [0, 0, 0], 1) Color(\"prophoto-rgb\", [0, 0, 0], 1).to_string() Edit Share Run Cancel Learn about ProPhoto XYZ Properties Name: xyz White Point: D50 Coordinates: Name Range x: [0.0, 0.964] * y: [0.0, 1.0] * z: [0.0, 0.825] * * \u2248 range in relation to sRGB rounded to 3 decimal places. The CIE 1931 RGB color space and CIE 1931 XYZ color space were created by the International Commission on Illumination (CIE) in 1931. They resulted from a series of experiments done in the late 1920s by William David Wright using ten observers and John Guild using seven observers. The experimental results were combined into the specification of the CIE RGB color space, from which the CIE XYZ color space was derived. The CIE 1931 color spaces are the first defined quantitative links between distributions of wavelengths in the electromagnetic visible spectrum, and physiologically perceived colors in human color vision. Parsed input and string output formats support all valid CSS forms: color ( xyz x y z / a ) // Color function When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"xyz\" , [ 0 , 0 , 0 ], 1 ) The string representation of the color object and the default string output will be in the color ( xyz x y z / a ) form. >>> Color ( \"xyz\" , [ 0 , 0 , 0 ], 1 ) color(xyz 0 0 0 / 1) >>> Color ( \"xyz\" , [ 0 , 0 , 0 ], 1 ) . to_string () color(xyz 0 0 0) Color(\"xyz\", [0, 0, 0], 1) Color(\"xyz\", [0, 0, 0], 1).to_string() Edit Share Run Cancel Learn about XYZ XYZ D65 Properties Name: xyz-d65 White Point: D65 Coordinates: Name Range x [0.0, 0.95] * y [0.0, 1.0] * z [0.0, 1.089] * * \u2248 range in relation to sRGB rounded to 3 decimal places. XYZ D65 is the same as XYZ except it uses a D65 white point. Parsed input and string output formats use the color () format with the custom name --xyz-d65 as XYZ D65 is not currently supported in the current CSS spec: color ( --xyz-d65 x y z / a ) // Color function When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"xyz-d65\" , [ 0 , 0 , 0 ], 1 ) The string representation of the color object and the default string output will be in the color ( --xyz x y z / a ) form. >>> Color ( \"xyz-d65\" , [ 0 , 0 , 0 ], 1 ) color(--xyz-d65 0 0 0 / 1) >>> Color ( \"xyz-d65\" , [ 0 , 0 , 0 ], 1 ) . to_string () color(--xyz-d65 0 0 0) Color(\"xyz-d65\", [0, 0, 0], 1) Color(\"xyz-d65\", [0, 0, 0], 1).to_string() Edit Share Run Cancel Learn about XYZ CIELAB Properties Name: lab White Point: D50 Coordinates: Name Range lightness [0, 100] * a [-79.287, 93.55] * b [-112.029, 93.388] * * \u2248 range in relation to sRGB rounded to 3 decimal places. The CIELAB color space also referred to as L*a*b* is a color space defined by the International Commission on Illumination (abbreviated CIE) in 1976. It expresses color as three values: L* for perceptual lightness, and a* and b* for the four unique colors of human vision: red, green, blue, and yellow. CIELAB was intended as a perceptually uniform space, where a given numerical change corresponds to similar perceived change in color. While the CIELAB space is not truly perceptually uniform, it nevertheless is useful in industry for detecting small differences in color. Parsed input and string output formats support all valid CSS forms. In addition, we also allow the color () function format using the custom name --lab : lab ( l a b / a ) // Lab function color ( --lab l a b / a ) // Color function When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"lab\" , [ 0 , 0 , 0 ], 1 ) The string representation of the color object will always default to the color ( --lab l a b / a ) form, but the default string output will be the hsl ( h s l / a ) form. >>> Color ( \"lab\" , [ 0 , 0 , 0 ], 1 ) color(--lab 0% 0 0 / 1) >>> Color ( \"lab\" , [ 0 , 0 , 0 ], 1 ) . to_string () lab(0% 0 0) Color(\"lab\", [0, 0, 0], 1) Color(\"lab\", [0, 0, 0], 1).to_string() Edit Share Run Cancel Learn about CIELAB CIELCH Properties Name: lch White Point: D50 Coordinates: Name Range lightness [0, 100] * chroma [0.0, 131.207] * hue [0, 360) * \u2248 range in relation to sRGB rounded to 3 decimal places. The \"CIELCH\" or \"CIEHLC\" space is a color space based on CIELAB , which uses the polar coordinates C* (chroma, relative saturation) and h\u00b0 (hue angle, angle of the hue in the CIELAB color wheel) instead of the Cartesian coordinates a* and b*. The CIELAB lightness L* remains unchanged. Parsed input and string output formats support all valid CSS forms. In addition, we also allow the color () function format using the custom name --lch : lch ( l c h / a ) // Lch function color ( --lch l c h / a ) // Color function When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"lch\" , [ 0 , 0 , 0 ], 1 ) The string representation of the color object will always default to the color ( --lch l c h / a ) form, but the default string output will be the hsl ( l c h / a ) form. >>> Color ( \"lch\" , [ 0 , 0 , 0 ], 1 ) color(--lch 0% 0 0 / 1) >>> Color ( \"lch\" , [ 0 , 0 , 0 ], 1 ) . to_string () lch(0% 0 0) Color(\"lch\", [0, 0, 0], 1) Color(\"lch\", [0, 0, 0], 1).to_string() Edit Share Run Cancel Learn about CIELCH CIELAB D65 Properties Name: lab-d65 White Point: D65 Coordinates: Name Range lightness [0, 100] * a [-86.183, 98.234] * b [-107.86, 94.478] * * \u2248 range in relation to sRGB rounded to 3 decimal places. CIELAB D65 is the same as CIELAB except it uses a D65 white point. As a D65 variant of CIELAB is not currently supported in the CSS spec, the parsed input and string output formats use the color () function format using the custom name --lab-d65 : color ( --lab-d65 l a b / a ) // Color function When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"lab-d65\" , [ 0 , 0 , 0 ], 1 ) The string representation of the color object and the default string output use the color ( --lab-d65 l a b / a ) form. >>> Color ( \"lab-d65\" , [ 0 , 0 , 0 ], 1 ) color(--lab-d65 0% 0 0 / 1) >>> Color ( \"lab-d65\" , [ 0 , 0 , 0 ], 1 ) . to_string () color(--lab-d65 0% 0 0) Color(\"lab-d65\", [0, 0, 0], 1) Color(\"lab-d65\", [0, 0, 0], 1).to_string() Edit Share Run Cancel Learn about CIELAB CIELCH D65 Properties Name: lch-d65 White Point: D65 Coordinates: Name Range lightness [0, 100] * chroma [0.0, 133.808] * hue [0, 360) * \u2248 range in relation to sRGB rounded to 3 decimal places. CIELCH D65 is the same as CIELCH except it uses a D65 white point. As a D65 variant of CIELCH is not currently supported in the CSS spec, the parsed input and string output formats use the color () function format using the custom name --lch-d65 : color ( --lch-d65 l c h / a ) // Color function When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"lch-d65\" , [ 0 , 0 , 0 ], 1 ) The string representation of the color object and the default string output use the color ( --lch-d65 l c h / a ) form. >>> Color ( \"lch-d65\" , [ 0 , 0 , 0 ], 1 ) color(--lch-d65 0% 0 0 / 1) >>> Color ( \"lch-d65\" , [ 0 , 0 , 0 ], 1 ) . to_string () color(--lch-d65 0% 0 0) Color(\"lch-d65\", [0, 0, 0], 1) Color(\"lch-d65\", [0, 0, 0], 1).to_string() Edit Share Run Cancel Learn about CIELCH CIELUV Properties Name: luv White Point: D50 Coordinates: Name Range lightness [0, 100] * a [-84.937, 175.043] * b [-125.882, 87.244] * * \u2248 range in relation to sRGB rounded to 3 decimal places. CIELUV, is a color space adopted by the CIE in 1976, as a simple-to-compute transformation of the 1931 CIE XYZ color space, but which attempted perceptual uniformity. As CIELUV is not currently supported in the CSS spec, the parsed input and string output formats use the color () function format using the custom name --luv : color ( --luv l u v / a ) // Color function When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"luv\" , [ 0 , 0 , 0 ], 1 ) The string representation of the color object and the default string output use the color ( --luv l u v / a ) form. >>> Color ( \"luv\" , [ 0 , 0 , 0 ], 1 ) color(--luv 0% 0 0 / 1) >>> Color ( \"luv\" , [ 0 , 0 , 0 ], 1 ) . to_string () color(--luv 0% 0 0) Color(\"luv\", [0, 0, 0], 1) Color(\"luv\", [0, 0, 0], 1).to_string() Edit Share Run Cancel Learn about CIELUV CIELCH uv Properties Name: jzczhz White Point: D65 Coordinates: Name Range jz [0, 100] * chroma [0, 176.957] * hue [0 - 360) * \u2248 range in relation to sRGB rounded to 3 decimal places. CIELCH uv is the polar form of CIELUV . As CIELCH uv is not currently supported in the CSS spec, the parsed input and string output formats use the color () function format using the custom name --lchuv : color ( --lchuv l c h / a ) // Color function When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"lchuv\" , [ 0 , 0 , 0 ], 1 ) The string representation of the color object and the default string output use the color ( --lchuv jz cz hz / a ) form. >>> Color ( \"lchuv\" , [ 0 , 0 , 0 ], 1 ) color(--lchuv 0% 0 0 / 1) >>> Color ( \"lchuv\" , [ 0 , 0 , 0 ], 1 ) . to_string () color(--lchuv 0% 0 0) Color(\"lchuv\", [0, 0, 0], 1) Color(\"lchuv\", [0, 0, 0], 1).to_string() Edit Share Run Cancel Learn about CIELCH uv Oklab Properties Name: oklab White Point: D65 Coordinates: Name Range lightness [0, 1] a [-0.5, 0.5] b [-0.5, 0.5] A new perceptual color space that claims to be simple to use, while doing a good job at predicting perceived lightness, chroma and hue. It is called the Oklab color space, because it is an OK Lab color space. As Oklab is not currently supported in the CSS spec, the parsed input and string output formats use the color () function format using the custom name --oklab : color ( --oklab l a b / a ) // Color function When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"oklab\" , [ 0 , 0 , 0 ], 1 ) The string representation of the color object and the default string output use the color ( --oklab l a b / a ) form. >>> Color ( \"oklab\" , [ 0 , 0 , 0 ], 1 ) color(--oklab 0 0 0 / 1) >>> Color ( \"oklab\" , [ 0 , 0 , 0 ], 1 ) . to_string () color(--oklab 0 0 0) Color(\"oklab\", [0, 0, 0], 1) Color(\"oklab\", [0, 0, 0], 1).to_string() Edit Share Run Cancel Learn about Oklab Oklch Properties Name: oklch White Point: D65 Coordinates: Name Range lightness [0, 1] chroma [0, 1] hue [0, 360) Oklch is the cylindrical form of Oklab . As Oklch is not currently supported in the CSS spec, the parsed input and string output formats use the color () function format using the custom name --oklch : color ( --oklch l c h / a ) // Color function When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"oklch\" , [ 0 , 0 , 0 ], 1 ) The string representation of the color object and the default string output use the color ( --oklch l c h / a ) form. >>> Color ( \"oklch\" , [ 0 , 0 , 0 ], 1 ) color(--oklch 0 0 0 / 1) >>> Color ( \"oklch\" , [ 0 , 0 , 0 ], 1 ) . to_string () color(--oklch 0 0 0) Color(\"oklch\", [0, 0, 0], 1) Color(\"oklch\", [0, 0, 0], 1).to_string() Edit Share Run Cancel Learn about Oklch Jzazbz Properties Name: jzazbz White Point: D65 Coordinates: Name Range jz [0.0, 0.222] * az [-0.109, 0.13] * bz [-0.186, 0.135] * * \u2248 range in relation to sRGB rounded to 3 decimal places. Jzazbz is a a color space designed for perceptual uniformity in high dynamic range (HDR) and wide color gamut (WCG) applications. Conceptually it is similar to CIELAB , but claims the following improvements: Perceptual color difference is predicted by Euclidean distance. Perceptually uniform: MacAdam ellipses of just-noticeable-difference ( JND ) are more circular, and closer to the same sizes. Hue linearity: changing saturation or lightness has less shift in hue. As Jzazbz is not currently supported in the CSS spec, the parsed input and string output formats use the color () function format using the custom name --jzazbz : color ( --jzazbz jz az bz / a ) // Color function When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"jzazbz\" , [ 0 , 0 , 0 ], 1 ) The string representation of the color object and the default string output use the color ( --jzazbz jz az bz / a ) form. >>> Color ( \"jzazbz\" , [ 0 , 0 , 0 ], 1 ) color(--jzazbz 0 0 0 / 1) >>> Color ( \"jzazbz\" , [ 0 , 0 , 0 ], 1 ) . to_string () color(--jzazbz 0 0 0) Color(\"jzazbz\", [0, 0, 0], 1) Color(\"jzazbz\", [0, 0, 0], 1).to_string() Edit Share Run Cancel Learn about Jzazbz JzCzhz Properties Name: jzczhz White Point: D65 Coordinates: Name Range jz [0.0, 0.222] * chroma [0.0, 0.190] * hue [0.0, 360.0) * \u2248 range in relation to sRGB rounded to 3 decimal places. JzCzhz is the cylindrical form of Jzazbz . As JzCzhz is not currently supported in the CSS spec, the parsed input and string output formats use the color () function format using the custom name --jzczhz : color ( --jzczhz jz cz hz / a ) // Color function When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"jzczhz\" , [ 0 , 0 , 0 ], 1 ) The string representation of the color object and the default string output use the color ( --jzczhz jz cz hz / a ) form. >>> Color ( \"jzczhz\" , [ 0 , 0 , 0 ], 1 ) color(--jzczhz 0 0 0 / 1) >>> Color ( \"jzczhz\" , [ 0 , 0 , 0 ], 1 ) . to_string () color(--jzczhz 0 0 0) Color(\"jzczhz\", [0, 0, 0], 1) Color(\"jzczhz\", [0, 0, 0], 1).to_string() Edit Share Run Cancel Learn about JzCzhz ICtCp Properties Name: ictcp White Point: D65 Coordinates: Name Range i [0.0, 0.581] * ct [-0.281, 0.277] * cp [-0.161, 0.279] * * \u2248 range in relation to sRGB rounded to 3 decimal places. ICtCp is a color space format with better perceptual uniformity than CIELAB and is used as a part of the color image pipeline in video and digital photography systems for high dynamic range (HDR) and wide color gamut (WCG) imagery. It was developed by Dolby Laboratories from the IPT color space by Ebner and Fairchild. It was designed with the intention to replace YCbCr. As ICtCp is not currently supported in the CSS spec, the parsed input and string output formats use the color () function format using the custom name --ictcp : color ( --ictcp i ct cp / a ) // Color function When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"ictcp\" , [ 0 , 0 , 0 ], 1 ) The string representation of the color object and the default string output use the color ( --ictcp i ct cp / a ) form. >>> Color ( \"ictcp\" , [ 0 , 0 , 0 ], 1 ) color(--ictcp 0 0 0 / 1) >>> Color ( \"ictcp\" , [ 0 , 0 , 0 ], 1 ) . to_string () color(--ictcp 0 0 0) Color(\"ictcp\", [0, 0, 0], 1) Color(\"ictcp\", [0, 0, 0], 1).to_string() Edit Share Run Cancel Learn about ICtCp DIN99o Properties Name: din99o White Point: D65 Coordinates: Name Range lightness [0, 100] * a [-40.09, 45.501] * b [-40.47, 44.344] * * \u2248 range in relation to sRGB rounded to 3 decimal places. The DIN99 color space system is a further development of the CIELAB color space system developed by the FNF / FNL 2 Colorimetry Working Committee. It takes the CIELAB space (with a D65 illuminant) and compresses it such that the space yields better equidistant using Euclidean distance. The whole color space is essentially modified to better fit the color distancing algorithm opposed to CIELAB which has adapted the color distancing algorithm to better fit the color space, the latest iteration being \u2206E * 00 . As DIN99o is not currently supported in the CSS spec, the parsed input and string output formats use the color () function format using the custom name --din99o : color ( --din99o l u v / a ) // Color function When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"din99o\" , [ 0 , 0 , 0 ], 1 ) The string representation of the color object and the default string output use the color ( --din99o l u v / a ) form. >>> Color ( \"din99o\" , [ 0 , 0 , 0 ], 1 ) color(--din99o 0% 0 0 / 1) >>> Color ( \"din99o\" , [ 0 , 0 , 0 ], 1 ) . to_string () color(--din99o 0% 0 0) Color(\"din99o\", [0, 0, 0], 1) Color(\"din99o\", [0, 0, 0], 1).to_string() Edit Share Run Cancel Learn about DIN99o DIN99o Lch Properties Name: din99o-lch White Point: D65 Coordinates: Name Range lightness [0, 100] * chroma [0.0, 51.484] * hue [0 - 360) * \u2248 range in relation to sRGB rounded to 3 decimal places. DIN99o Lch is the cylindrical form of DIN99o . As DIN99o Lch is not currently supported in the CSS spec, the parsed input and string output formats use the color () function format using the custom name --din99o-lch : color ( --din99o-lch jz cz hz / a ) // Color function When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"din99o-lch\" , [ 0 , 0 , 0 ], 1 ) The string representation of the color object and the default string output use the color ( --din99o-lch jz cz hz / a ) form. >>> Color ( \"din99o-lch\" , [ 0 , 0 , 0 ], 1 ) color(--din99o-lch 0% 0 0 / 1) >>> Color ( \"din99o-lch\" , [ 0 , 0 , 0 ], 1 ) . to_string () color(--din99o-lch 0% 0 0) Color(\"din99o-lch\", [0, 0, 0], 1) Color(\"din99o-lch\", [0, 0, 0], 1).to_string() Edit Share Run Cancel Learn about DIN99 Lch .info-container {display: inline-block;}","title":"Supported Colors"},{"location":"colors/#supported-colors","text":"","title":"Supported Colors"},{"location":"colors/#srgb","text":"Properties Name: srgb White Point: D65 Coordinates: Name Range red [0, 1] green [0, 1] blue [0, 1] The sRGB space is a standard RGB (red, green, blue) color space that HP and Microsoft created cooperatively in 1996 to use on monitors, printers, and the Web. SRGB stands for \"Standard RGB\". It is the most widely used color space and is supported by most operating systems, software programs, monitors, and printers. Parsed input and string output formats support all valid CSS forms: black // Color name # RRGGBBAA // Hex rgb ( r g b / a ) // RGB function rgb ( r , g , b ) // Legacy RGB Function rgba ( r , g , b , a ) // Legacy RGBA function color ( srgb r g b / a ) // Color function When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"srgb\" , [ 0 , 0 , 0 ], 1 ) The string representation of the color object will always default to the color ( srgb r g b / a ) form, but the default string output will be the rgb ( r g b / a ) form. >>> Color ( \"srgb\" , [ 0 , 0 , 0 ], 1 ) color(srgb 0 0 0 / 1) >>> Color ( \"srgb\" , [ 0 , 0 , 0 ], 1 ) . to_string () rgb(0 0 0) Color(\"srgb\", [0, 0, 0], 1) Color(\"srgb\", [0, 0, 0], 1).to_string() Edit Share Run Cancel Learn about sRGB","title":"sRGB"},{"location":"colors/#hsv","text":"Properties Name: hsv White Point: D65 Coordinates: Name Range hue [0, 360) saturation [0, 100] value [0, 100] HSV is a color space similar to the modern RGB and CMYK models. The HSV color space has three components: hue, saturation and value. 'Value' is sometimes substituted with 'brightness' and then it is known as HSB. HSV models how colors appear under light. HSV is not supported via the CSS spec and the parser input and string output only supports the color () function format using the custom name --hsv : color ( --hsv 0 0 % 0 % / 1 ) When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"hsv\" , [ 0 , 0 , 0 ], 1 ) The string representation of the color object and default string output will always use the color ( hsv h s v / a ) form. >>> Color ( \"hsv\" , [ 0 , 0 , 0 ], 1 ) color(--hsv 0 0% 0% / 1) >>> Color ( \"hsv\" , [ 0 , 0 , 0 ], 1 ) . to_string () color(--hsv 0 0% 0%) Color(\"hsv\", [0, 0, 0], 1) Color(\"hsv\", [0, 0, 0], 1).to_string() Edit Share Run Cancel Learn about HSV","title":"HSV"},{"location":"colors/#hsl","text":"Properties Name: hsl White Point: D65 Coordinates: Name Range hue [0, 360) saturation [0, 100] lightness [0, 100] HSL is an alternative representations of the RGB color model, designed in the 1970s by computer graphics researchers to more closely align with the way human vision perceives color-making attributes. In these models, colors of each hue are arranged in a radial slice, around a central axis of neutral colors which ranges from black at the bottom to white at the top. HSL models the way different paints mix together to create color in the real world, with the lightness dimension resembling the varying amounts of black or white paint in the mixture. Parsed input and string output formats support all valid CSS forms. In addition, we also allow the color () function format using the custom name --hsl : hsl ( h s l / a ) // HSL function hsl ( h , s , l ) // Legacy HSL function hsla ( h , s , l , a ) // Legacy HSLA function color ( --hsl h s l / a ) // Color function When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"hsl\" , [ 0 , 0 , 0 ], 1 ) The string representation of the color object will always default to the color ( --hsl h s l / a ) form, but the default string output will be the hsl ( h s l / a ) form. >>> Color ( \"hsl\" , [ 0 , 0 , 0 ], 1 ) color(--hsl 0 0% 0% / 1) >>> Color ( \"hsl\" , [ 0 , 0 , 0 ], 1 ) . to_string () hsl(0 0% 0%) Color(\"hsl\", [0, 0, 0], 1) Color(\"hsl\", [0, 0, 0], 1).to_string() Edit Share Run Cancel Learn about HSL","title":"HSL"},{"location":"colors/#hwb","text":"Properties Name: hwb White Point: D65 Coordinates: Name Range hue [0, 360) whiteness [0, 100] blackness [0, 100] HWB is a cylindrical-coordinate representation of points in an RGB color model, similar to HSL and HSV. It was developed by HSV 's creator Alvy Ray Smith in 1996 to address some of the issues with HSV. HWB was designed to be more intuitive for humans to use and slightly faster to compute. The first coordinate, H (Hue), is the same as the Hue coordinate in HSL and HSV . W and B stand for Whiteness and Blackness respectively and range from 0-100% (or 0-1). The mental model is that the user can pick a main hue and then \"mix\" it with white and/or black to produce the desired color. Parsed input and string output formats support all valid CSS forms. In addition, we also allow the color () function format using the custom name --hwb : hwb ( h w b / a ) // HWB function color ( --hwb h w b / a ) // Color function When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"hwb\" , [ 0 , 0 , 100 ], 1 ) The string representation of the color object will always default to the color ( --hwb h w b / a ) form, but the default string output will be the hsl ( h s l / a ) form. >>> Color ( \"hwb\" , [ 0 , 0 , 100 ], 1 ) color(--hwb 0 0% 100% / 1) >>> Color ( \"hwb\" , [ 0 , 0 , 100 ], 1 ) . to_string () hwb(0 0% 100%) Color(\"hwb\", [0, 0, 100], 1) Color(\"hwb\", [0, 0, 100], 1).to_string() Edit Share Run Cancel Learn about HWB","title":"HWB"},{"location":"colors/#display-p3","text":"Properties Name: display-p3 White Point: D65 Coordinates: Name Range red [0, 1] green [0, 1] blue [0, 1] Display P3 is a combination of the DCI-P3 color gamut with the D65 white point together with the sRGB gamma curve. It originated from the DCI-P3 color gamut's implementation in digital cinema projectors, as this standard offers more vibrant greens and reds than the traditional sRGB color gamut. Parsed input and string output formats support all valid CSS forms: color ( display-p3 r g b / a ) // Color function When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"display-p3\" , [ 0 , 0 , 0 ], 1 ) The string representation of the color object and the default string output will be in the color ( display-p3 r g b / a ) form. >>> Color ( \"display-p3\" , [ 0 , 0 , 0 ], 1 ) color(display-p3 0 0 0 / 1) >>> Color ( \"display-p3\" , [ 0 , 0 , 0 ], 1 ) . to_string () color(display-p3 0 0 0) Color(\"display-p3\", [0, 0, 0], 1) Color(\"display-p3\", [0, 0, 0], 1).to_string() Edit Share Run Cancel Learn about Display P3","title":"Display P3"},{"location":"colors/#a98-rgb","text":"Properties Name: a98-rgb White Point: D65 Coordinates: Name Range red [0, 1] green [0, 1] blue [0, 1] The Adobe RGB (1998) color space or opRGB is a color space developed by Adobe Systems, Inc. in 1998. It was designed to encompass most of the colors achievable on CMYK color printers, but by using RGB primary colors on a device such as a computer display. The Adobe RGB (1998) color space encompasses roughly 50% of the visible colors specified by the CIELAB color space - improving upon the gamut of the sRGB color space, primarily in cyan-green hues. Parsed input and string output formats support all valid CSS forms: color ( a98-rgb r g b / a ) // Color function When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"a98-rgb\" , [ 0 , 0 , 0 ], 1 ) The string representation of the color object and the default string output will be in the color ( a98-rgb r g b / a ) form. >>> Color ( \"a98-rgb\" , [ 0 , 0 , 0 ], 1 ) color(a98-rgb 0 0 0 / 1) >>> Color ( \"a98-rgb\" , [ 0 , 0 , 0 ], 1 ) . to_string () color(a98-rgb 0 0 0) Color(\"a98-rgb\", [0, 0, 0], 1) Color(\"a98-rgb\", [0, 0, 0], 1).to_string() Edit Share Run Cancel Learn about A98 RGB","title":"A98 RGB"},{"location":"colors/#rec2020","text":"Properties Name: rec2020 White Point: D65 Coordinates: Name Range red [0, 1] green [0, 1] blue [0, 1] The Rec. 2020 color space is a result of this and is a very wide gamut RGB color space which is used in 4k and 8k UHDTV. ITU-R Recommendation BT.2020, more commonly known by the abbreviations Rec. 2020 or BT.2020, defines various aspects of ultra-high-definition television (UHDTV) with standard dynamic range (SDR) and wide color gamut (WCG), including picture resolutions, frame rates with progressive scan, bit depths, color primaries, RGB and luma-chroma color representations, chroma subsamplings, and an opto-electronic transfer function. Parsed input and string output formats support all valid CSS forms: color ( rec2020 r g b / a ) // Color function When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"rec2020\" , [ 0 , 0 , 0 ], 1 ) The string representation of the color object and the default string output will be in the color ( rec2020 r g b / a ) form. >>> Color ( \"rec2020\" , [ 0 , 0 , 0 ], 1 ) color(rec2020 0 0 0 / 1) >>> Color ( \"rec2020\" , [ 0 , 0 , 0 ], 1 ) . to_string () color(rec2020 0 0 0) Color(\"rec2020\", [0, 0, 0], 1) Color(\"rec2020\", [0, 0, 0], 1).to_string() Edit Share Run Cancel Learn about REC.2020","title":"REC.2020"},{"location":"colors/#prophoto","text":"Properties Name: prophoto-rgb White Point: D50 Coordinates: Name Range red [0, 1] green [0, 1] blue [0, 1] The ProPhoto RGB color space, also known as ROMM RGB (Reference Output Medium Metric), is an output referred RGB color space developed by Kodak. It offers an especially large gamut designed for use with photographic output in mind. The ProPhoto RGB color space encompasses over 90% of possible surface colors in the CIE L*a*b* color space, and 100% of likely occurring real-world surface colors documented by Pointer in 1980. Parsed input and string output formats support all valid CSS forms: color ( prophoto-rgb r g b / a ) // Color function When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"prophoto-rgb\" , [ 0 , 0 , 0 ], 1 ) The string representation of the color object and the default string output will be in the color ( prophoto-rgb r g b / a ) form. >>> Color ( \"prophoto-rgb\" , [ 0 , 0 , 0 ], 1 ) color(prophoto-rgb 0 0 0 / 1) >>> Color ( \"prophoto-rgb\" , [ 0 , 0 , 0 ], 1 ) . to_string () color(prophoto-rgb 0 0 0) Color(\"prophoto-rgb\", [0, 0, 0], 1) Color(\"prophoto-rgb\", [0, 0, 0], 1).to_string() Edit Share Run Cancel Learn about ProPhoto","title":"ProPhoto"},{"location":"colors/#xyz","text":"Properties Name: xyz White Point: D50 Coordinates: Name Range x: [0.0, 0.964] * y: [0.0, 1.0] * z: [0.0, 0.825] * * \u2248 range in relation to sRGB rounded to 3 decimal places. The CIE 1931 RGB color space and CIE 1931 XYZ color space were created by the International Commission on Illumination (CIE) in 1931. They resulted from a series of experiments done in the late 1920s by William David Wright using ten observers and John Guild using seven observers. The experimental results were combined into the specification of the CIE RGB color space, from which the CIE XYZ color space was derived. The CIE 1931 color spaces are the first defined quantitative links between distributions of wavelengths in the electromagnetic visible spectrum, and physiologically perceived colors in human color vision. Parsed input and string output formats support all valid CSS forms: color ( xyz x y z / a ) // Color function When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"xyz\" , [ 0 , 0 , 0 ], 1 ) The string representation of the color object and the default string output will be in the color ( xyz x y z / a ) form. >>> Color ( \"xyz\" , [ 0 , 0 , 0 ], 1 ) color(xyz 0 0 0 / 1) >>> Color ( \"xyz\" , [ 0 , 0 , 0 ], 1 ) . to_string () color(xyz 0 0 0) Color(\"xyz\", [0, 0, 0], 1) Color(\"xyz\", [0, 0, 0], 1).to_string() Edit Share Run Cancel Learn about XYZ","title":"XYZ"},{"location":"colors/#xyz-d65","text":"Properties Name: xyz-d65 White Point: D65 Coordinates: Name Range x [0.0, 0.95] * y [0.0, 1.0] * z [0.0, 1.089] * * \u2248 range in relation to sRGB rounded to 3 decimal places. XYZ D65 is the same as XYZ except it uses a D65 white point. Parsed input and string output formats use the color () format with the custom name --xyz-d65 as XYZ D65 is not currently supported in the current CSS spec: color ( --xyz-d65 x y z / a ) // Color function When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"xyz-d65\" , [ 0 , 0 , 0 ], 1 ) The string representation of the color object and the default string output will be in the color ( --xyz x y z / a ) form. >>> Color ( \"xyz-d65\" , [ 0 , 0 , 0 ], 1 ) color(--xyz-d65 0 0 0 / 1) >>> Color ( \"xyz-d65\" , [ 0 , 0 , 0 ], 1 ) . to_string () color(--xyz-d65 0 0 0) Color(\"xyz-d65\", [0, 0, 0], 1) Color(\"xyz-d65\", [0, 0, 0], 1).to_string() Edit Share Run Cancel Learn about XYZ","title":"XYZ D65"},{"location":"colors/#cielab","text":"Properties Name: lab White Point: D50 Coordinates: Name Range lightness [0, 100] * a [-79.287, 93.55] * b [-112.029, 93.388] * * \u2248 range in relation to sRGB rounded to 3 decimal places. The CIELAB color space also referred to as L*a*b* is a color space defined by the International Commission on Illumination (abbreviated CIE) in 1976. It expresses color as three values: L* for perceptual lightness, and a* and b* for the four unique colors of human vision: red, green, blue, and yellow. CIELAB was intended as a perceptually uniform space, where a given numerical change corresponds to similar perceived change in color. While the CIELAB space is not truly perceptually uniform, it nevertheless is useful in industry for detecting small differences in color. Parsed input and string output formats support all valid CSS forms. In addition, we also allow the color () function format using the custom name --lab : lab ( l a b / a ) // Lab function color ( --lab l a b / a ) // Color function When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"lab\" , [ 0 , 0 , 0 ], 1 ) The string representation of the color object will always default to the color ( --lab l a b / a ) form, but the default string output will be the hsl ( h s l / a ) form. >>> Color ( \"lab\" , [ 0 , 0 , 0 ], 1 ) color(--lab 0% 0 0 / 1) >>> Color ( \"lab\" , [ 0 , 0 , 0 ], 1 ) . to_string () lab(0% 0 0) Color(\"lab\", [0, 0, 0], 1) Color(\"lab\", [0, 0, 0], 1).to_string() Edit Share Run Cancel Learn about CIELAB","title":"CIELAB"},{"location":"colors/#cielch","text":"Properties Name: lch White Point: D50 Coordinates: Name Range lightness [0, 100] * chroma [0.0, 131.207] * hue [0, 360) * \u2248 range in relation to sRGB rounded to 3 decimal places. The \"CIELCH\" or \"CIEHLC\" space is a color space based on CIELAB , which uses the polar coordinates C* (chroma, relative saturation) and h\u00b0 (hue angle, angle of the hue in the CIELAB color wheel) instead of the Cartesian coordinates a* and b*. The CIELAB lightness L* remains unchanged. Parsed input and string output formats support all valid CSS forms. In addition, we also allow the color () function format using the custom name --lch : lch ( l c h / a ) // Lch function color ( --lch l c h / a ) // Color function When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"lch\" , [ 0 , 0 , 0 ], 1 ) The string representation of the color object will always default to the color ( --lch l c h / a ) form, but the default string output will be the hsl ( l c h / a ) form. >>> Color ( \"lch\" , [ 0 , 0 , 0 ], 1 ) color(--lch 0% 0 0 / 1) >>> Color ( \"lch\" , [ 0 , 0 , 0 ], 1 ) . to_string () lch(0% 0 0) Color(\"lch\", [0, 0, 0], 1) Color(\"lch\", [0, 0, 0], 1).to_string() Edit Share Run Cancel Learn about CIELCH","title":"CIELCH"},{"location":"colors/#cielab-d65","text":"Properties Name: lab-d65 White Point: D65 Coordinates: Name Range lightness [0, 100] * a [-86.183, 98.234] * b [-107.86, 94.478] * * \u2248 range in relation to sRGB rounded to 3 decimal places. CIELAB D65 is the same as CIELAB except it uses a D65 white point. As a D65 variant of CIELAB is not currently supported in the CSS spec, the parsed input and string output formats use the color () function format using the custom name --lab-d65 : color ( --lab-d65 l a b / a ) // Color function When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"lab-d65\" , [ 0 , 0 , 0 ], 1 ) The string representation of the color object and the default string output use the color ( --lab-d65 l a b / a ) form. >>> Color ( \"lab-d65\" , [ 0 , 0 , 0 ], 1 ) color(--lab-d65 0% 0 0 / 1) >>> Color ( \"lab-d65\" , [ 0 , 0 , 0 ], 1 ) . to_string () color(--lab-d65 0% 0 0) Color(\"lab-d65\", [0, 0, 0], 1) Color(\"lab-d65\", [0, 0, 0], 1).to_string() Edit Share Run Cancel Learn about CIELAB","title":"CIELAB D65"},{"location":"colors/#cielch-d65","text":"Properties Name: lch-d65 White Point: D65 Coordinates: Name Range lightness [0, 100] * chroma [0.0, 133.808] * hue [0, 360) * \u2248 range in relation to sRGB rounded to 3 decimal places. CIELCH D65 is the same as CIELCH except it uses a D65 white point. As a D65 variant of CIELCH is not currently supported in the CSS spec, the parsed input and string output formats use the color () function format using the custom name --lch-d65 : color ( --lch-d65 l c h / a ) // Color function When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"lch-d65\" , [ 0 , 0 , 0 ], 1 ) The string representation of the color object and the default string output use the color ( --lch-d65 l c h / a ) form. >>> Color ( \"lch-d65\" , [ 0 , 0 , 0 ], 1 ) color(--lch-d65 0% 0 0 / 1) >>> Color ( \"lch-d65\" , [ 0 , 0 , 0 ], 1 ) . to_string () color(--lch-d65 0% 0 0) Color(\"lch-d65\", [0, 0, 0], 1) Color(\"lch-d65\", [0, 0, 0], 1).to_string() Edit Share Run Cancel Learn about CIELCH","title":"CIELCH D65"},{"location":"colors/#cieluv","text":"Properties Name: luv White Point: D50 Coordinates: Name Range lightness [0, 100] * a [-84.937, 175.043] * b [-125.882, 87.244] * * \u2248 range in relation to sRGB rounded to 3 decimal places. CIELUV, is a color space adopted by the CIE in 1976, as a simple-to-compute transformation of the 1931 CIE XYZ color space, but which attempted perceptual uniformity. As CIELUV is not currently supported in the CSS spec, the parsed input and string output formats use the color () function format using the custom name --luv : color ( --luv l u v / a ) // Color function When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"luv\" , [ 0 , 0 , 0 ], 1 ) The string representation of the color object and the default string output use the color ( --luv l u v / a ) form. >>> Color ( \"luv\" , [ 0 , 0 , 0 ], 1 ) color(--luv 0% 0 0 / 1) >>> Color ( \"luv\" , [ 0 , 0 , 0 ], 1 ) . to_string () color(--luv 0% 0 0) Color(\"luv\", [0, 0, 0], 1) Color(\"luv\", [0, 0, 0], 1).to_string() Edit Share Run Cancel Learn about CIELUV","title":"CIELUV"},{"location":"colors/#cielchuv","text":"Properties Name: jzczhz White Point: D65 Coordinates: Name Range jz [0, 100] * chroma [0, 176.957] * hue [0 - 360) * \u2248 range in relation to sRGB rounded to 3 decimal places. CIELCH uv is the polar form of CIELUV . As CIELCH uv is not currently supported in the CSS spec, the parsed input and string output formats use the color () function format using the custom name --lchuv : color ( --lchuv l c h / a ) // Color function When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"lchuv\" , [ 0 , 0 , 0 ], 1 ) The string representation of the color object and the default string output use the color ( --lchuv jz cz hz / a ) form. >>> Color ( \"lchuv\" , [ 0 , 0 , 0 ], 1 ) color(--lchuv 0% 0 0 / 1) >>> Color ( \"lchuv\" , [ 0 , 0 , 0 ], 1 ) . to_string () color(--lchuv 0% 0 0) Color(\"lchuv\", [0, 0, 0], 1) Color(\"lchuv\", [0, 0, 0], 1).to_string() Edit Share Run Cancel Learn about CIELCH uv","title":"CIELCHuv"},{"location":"colors/#oklab","text":"Properties Name: oklab White Point: D65 Coordinates: Name Range lightness [0, 1] a [-0.5, 0.5] b [-0.5, 0.5] A new perceptual color space that claims to be simple to use, while doing a good job at predicting perceived lightness, chroma and hue. It is called the Oklab color space, because it is an OK Lab color space. As Oklab is not currently supported in the CSS spec, the parsed input and string output formats use the color () function format using the custom name --oklab : color ( --oklab l a b / a ) // Color function When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"oklab\" , [ 0 , 0 , 0 ], 1 ) The string representation of the color object and the default string output use the color ( --oklab l a b / a ) form. >>> Color ( \"oklab\" , [ 0 , 0 , 0 ], 1 ) color(--oklab 0 0 0 / 1) >>> Color ( \"oklab\" , [ 0 , 0 , 0 ], 1 ) . to_string () color(--oklab 0 0 0) Color(\"oklab\", [0, 0, 0], 1) Color(\"oklab\", [0, 0, 0], 1).to_string() Edit Share Run Cancel Learn about Oklab","title":"Oklab"},{"location":"colors/#oklch","text":"Properties Name: oklch White Point: D65 Coordinates: Name Range lightness [0, 1] chroma [0, 1] hue [0, 360) Oklch is the cylindrical form of Oklab . As Oklch is not currently supported in the CSS spec, the parsed input and string output formats use the color () function format using the custom name --oklch : color ( --oklch l c h / a ) // Color function When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"oklch\" , [ 0 , 0 , 0 ], 1 ) The string representation of the color object and the default string output use the color ( --oklch l c h / a ) form. >>> Color ( \"oklch\" , [ 0 , 0 , 0 ], 1 ) color(--oklch 0 0 0 / 1) >>> Color ( \"oklch\" , [ 0 , 0 , 0 ], 1 ) . to_string () color(--oklch 0 0 0) Color(\"oklch\", [0, 0, 0], 1) Color(\"oklch\", [0, 0, 0], 1).to_string() Edit Share Run Cancel Learn about Oklch","title":"Oklch"},{"location":"colors/#jzazbz","text":"Properties Name: jzazbz White Point: D65 Coordinates: Name Range jz [0.0, 0.222] * az [-0.109, 0.13] * bz [-0.186, 0.135] * * \u2248 range in relation to sRGB rounded to 3 decimal places. Jzazbz is a a color space designed for perceptual uniformity in high dynamic range (HDR) and wide color gamut (WCG) applications. Conceptually it is similar to CIELAB , but claims the following improvements: Perceptual color difference is predicted by Euclidean distance. Perceptually uniform: MacAdam ellipses of just-noticeable-difference ( JND ) are more circular, and closer to the same sizes. Hue linearity: changing saturation or lightness has less shift in hue. As Jzazbz is not currently supported in the CSS spec, the parsed input and string output formats use the color () function format using the custom name --jzazbz : color ( --jzazbz jz az bz / a ) // Color function When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"jzazbz\" , [ 0 , 0 , 0 ], 1 ) The string representation of the color object and the default string output use the color ( --jzazbz jz az bz / a ) form. >>> Color ( \"jzazbz\" , [ 0 , 0 , 0 ], 1 ) color(--jzazbz 0 0 0 / 1) >>> Color ( \"jzazbz\" , [ 0 , 0 , 0 ], 1 ) . to_string () color(--jzazbz 0 0 0) Color(\"jzazbz\", [0, 0, 0], 1) Color(\"jzazbz\", [0, 0, 0], 1).to_string() Edit Share Run Cancel Learn about Jzazbz","title":"Jzazbz"},{"location":"colors/#jzczhz","text":"Properties Name: jzczhz White Point: D65 Coordinates: Name Range jz [0.0, 0.222] * chroma [0.0, 0.190] * hue [0.0, 360.0) * \u2248 range in relation to sRGB rounded to 3 decimal places. JzCzhz is the cylindrical form of Jzazbz . As JzCzhz is not currently supported in the CSS spec, the parsed input and string output formats use the color () function format using the custom name --jzczhz : color ( --jzczhz jz cz hz / a ) // Color function When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"jzczhz\" , [ 0 , 0 , 0 ], 1 ) The string representation of the color object and the default string output use the color ( --jzczhz jz cz hz / a ) form. >>> Color ( \"jzczhz\" , [ 0 , 0 , 0 ], 1 ) color(--jzczhz 0 0 0 / 1) >>> Color ( \"jzczhz\" , [ 0 , 0 , 0 ], 1 ) . to_string () color(--jzczhz 0 0 0) Color(\"jzczhz\", [0, 0, 0], 1) Color(\"jzczhz\", [0, 0, 0], 1).to_string() Edit Share Run Cancel Learn about JzCzhz","title":"JzCzhz"},{"location":"colors/#ictcp","text":"Properties Name: ictcp White Point: D65 Coordinates: Name Range i [0.0, 0.581] * ct [-0.281, 0.277] * cp [-0.161, 0.279] * * \u2248 range in relation to sRGB rounded to 3 decimal places. ICtCp is a color space format with better perceptual uniformity than CIELAB and is used as a part of the color image pipeline in video and digital photography systems for high dynamic range (HDR) and wide color gamut (WCG) imagery. It was developed by Dolby Laboratories from the IPT color space by Ebner and Fairchild. It was designed with the intention to replace YCbCr. As ICtCp is not currently supported in the CSS spec, the parsed input and string output formats use the color () function format using the custom name --ictcp : color ( --ictcp i ct cp / a ) // Color function When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"ictcp\" , [ 0 , 0 , 0 ], 1 ) The string representation of the color object and the default string output use the color ( --ictcp i ct cp / a ) form. >>> Color ( \"ictcp\" , [ 0 , 0 , 0 ], 1 ) color(--ictcp 0 0 0 / 1) >>> Color ( \"ictcp\" , [ 0 , 0 , 0 ], 1 ) . to_string () color(--ictcp 0 0 0) Color(\"ictcp\", [0, 0, 0], 1) Color(\"ictcp\", [0, 0, 0], 1).to_string() Edit Share Run Cancel Learn about ICtCp","title":"ICtCp"},{"location":"colors/#din99o","text":"Properties Name: din99o White Point: D65 Coordinates: Name Range lightness [0, 100] * a [-40.09, 45.501] * b [-40.47, 44.344] * * \u2248 range in relation to sRGB rounded to 3 decimal places. The DIN99 color space system is a further development of the CIELAB color space system developed by the FNF / FNL 2 Colorimetry Working Committee. It takes the CIELAB space (with a D65 illuminant) and compresses it such that the space yields better equidistant using Euclidean distance. The whole color space is essentially modified to better fit the color distancing algorithm opposed to CIELAB which has adapted the color distancing algorithm to better fit the color space, the latest iteration being \u2206E * 00 . As DIN99o is not currently supported in the CSS spec, the parsed input and string output formats use the color () function format using the custom name --din99o : color ( --din99o l u v / a ) // Color function When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"din99o\" , [ 0 , 0 , 0 ], 1 ) The string representation of the color object and the default string output use the color ( --din99o l u v / a ) form. >>> Color ( \"din99o\" , [ 0 , 0 , 0 ], 1 ) color(--din99o 0% 0 0 / 1) >>> Color ( \"din99o\" , [ 0 , 0 , 0 ], 1 ) . to_string () color(--din99o 0% 0 0) Color(\"din99o\", [0, 0, 0], 1) Color(\"din99o\", [0, 0, 0], 1).to_string() Edit Share Run Cancel Learn about DIN99o","title":"DIN99o"},{"location":"colors/#din99o-lch","text":"Properties Name: din99o-lch White Point: D65 Coordinates: Name Range lightness [0, 100] * chroma [0.0, 51.484] * hue [0 - 360) * \u2248 range in relation to sRGB rounded to 3 decimal places. DIN99o Lch is the cylindrical form of DIN99o . As DIN99o Lch is not currently supported in the CSS spec, the parsed input and string output formats use the color () function format using the custom name --din99o-lch : color ( --din99o-lch jz cz hz / a ) // Color function When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"din99o-lch\" , [ 0 , 0 , 0 ], 1 ) The string representation of the color object and the default string output use the color ( --din99o-lch jz cz hz / a ) form. >>> Color ( \"din99o-lch\" , [ 0 , 0 , 0 ], 1 ) color(--din99o-lch 0% 0 0 / 1) >>> Color ( \"din99o-lch\" , [ 0 , 0 , 0 ], 1 ) . to_string () color(--din99o-lch 0% 0 0) Color(\"din99o-lch\", [0, 0, 0], 1) Color(\"din99o-lch\", [0, 0, 0], 1).to_string() Edit Share Run Cancel Learn about DIN99 Lch .info-container {display: inline-block;}","title":"DIN99o Lch"}]}