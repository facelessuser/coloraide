{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Setup Currently in Alpha While ColorAide is very usable, it is currently in an alpha stage. While that doesn't necessarily mean been buggy, it does mean the API could be unstable. Overview ColorAide is a color library for Python. It was written to handle most modern CSS colors that are available and that will be available. Most of the conversion algorithms come straight from the CSS specifications . In the process of developing this library, we also stumbled upon Color.js which is created/maintained by the co-authors of some of the recent CSS color specifications. This project became heavily influenced by Color.js. While our aim was not to port that library, it did leave a clear impression on our API. With ColorAide, you can create colors: >>> from coloraide import Color >>> c = Color ( 'red' ) >>> c . to_string () rgb(255 0 0) Convert colors: >>> from coloraide import Color >>> Color ( 'red' ) . convert ( 'hsl' ) . to_string () hsl(0 100% 50%) Modify colors: >>> from coloraide import Color >>> Color ( 'red' ) . set ( \"lch.chroma\" , 30 ) . to_string () rgb(173.81 114.28 97.198) Mix colors: >>> from coloraide import Color >>> Color ( \"blue\" ) . mix ( \"yellow\" , space = \"lch\" ) . to_string () rgb(255 65.749 107.45) And more! Installation ColorAide can be installed via Python's pip : $ pip install coloraide","title":"Setup"},{"location":"#setup","text":"Currently in Alpha While ColorAide is very usable, it is currently in an alpha stage. While that doesn't necessarily mean been buggy, it does mean the API could be unstable.","title":"Setup"},{"location":"#overview","text":"ColorAide is a color library for Python. It was written to handle most modern CSS colors that are available and that will be available. Most of the conversion algorithms come straight from the CSS specifications . In the process of developing this library, we also stumbled upon Color.js which is created/maintained by the co-authors of some of the recent CSS color specifications. This project became heavily influenced by Color.js. While our aim was not to port that library, it did leave a clear impression on our API. With ColorAide, you can create colors: >>> from coloraide import Color >>> c = Color ( 'red' ) >>> c . to_string () rgb(255 0 0) Convert colors: >>> from coloraide import Color >>> Color ( 'red' ) . convert ( 'hsl' ) . to_string () hsl(0 100% 50%) Modify colors: >>> from coloraide import Color >>> Color ( 'red' ) . set ( \"lch.chroma\" , 30 ) . to_string () rgb(173.81 114.28 97.198) Mix colors: >>> from coloraide import Color >>> Color ( \"blue\" ) . mix ( \"yellow\" , space = \"lch\" ) . to_string () rgb(255 65.749 107.45) And more!","title":"Overview"},{"location":"#installation","text":"ColorAide can be installed via Python's pip : $ pip install coloraide","title":"Installation"},{"location":"color/","text":"The Color Object Creating Colors The Color object can be imported from coloraide . from coloraide import Color Afterwards, colors can be created using various, valid CSS syntax: >>> Color ( \"red\" ), (color(srgb 1 0 0 / 1),) >>> Color ( \"#00ff00\" ), (color(srgb 0 1 0 / 1),) >>> Color ( \"rgb(0 0 255 / 1)\" ) color(srgb 0 0 1 / 1) As shown above, we can use all sorts of valid CSS syntax, and we get the same color red . We can also insert raw data points directly, but notice, when doing this, we are required to enter the data as it is used internally, and in the case for sRGB, the channels are in the range of [0, 1]. Additionally, alpha is always handled as a separate parameter. >>> Color ( \"srgb\" , [ 0.5 , 0 , 1 ], 0.3 ) color(srgb 0.5 0 1 / 0.3) We can also pass in other color objects, which is really only useful if we've subclassed the Color object and want to cast the object between the classes. The same color creation can be preformed from a color's new class method as well. new accepts the same inputs as the class object itself. >>> color1 = Color ( \"red\" ) >>> color1 color(srgb 1 0 0 / 1) >>> color1 . new ( \"blue\" ) color(srgb 0 0 1 / 1) Cloning The clone method is an easy way to duplicate the current color object. Here we clone the green object so we have two. >>> c1 = Color ( \"green\" ) >>> c1 color(srgb 0 0.50196 0 / 1) >>> c1 . clone () color(srgb 0 0.50196 0 / 1) Updating A color can be \"updated\" using another color object. When an update occurs, the current color space is updated with the data from the second color, but the color space does not change. It is basically the equivalent of converting the second color to the color space of the first and then updating all the coordinates (including alpha). The input parameters are identical to the new method, so we can use a color object, a color string, or even raw data points. Here we update the color red to the color blue : >>> Color ( \"red\" ) color(srgb 1 0 0 / 1) >>> Color ( \"red\" ) . update ( Color ( \"blue\" )) color(srgb 0 0 1 / 1) Here we update the sRGB red with the color lch ( 80 % 50 130 ) . >>> Color ( \"red\" ) . update ( \"lch(80% 50 130)\" ) color(srgb 0.60402 0.83978 0.4839 / 1) Mutating \"Mutating\" is similar to updating except that it will update the color and the color space from another color. The input parameters are identical to the new method, so we can use a color object, a color string, or even raw data points. Here the red color object literally becomes an LCH color object with the new color lch ( 80 % 50 130 ) . >>> Color ( \"red\" ) . mutate ( \"lch(80% 50 130)\" ) color(lch 80 50 130 / 1) Converting Colors can be converted to other color spaces as needed. Converting will always return a new color unless in_place is set True , in which case the current color will be mutated to the new converted color. For instance, if we had a color yellow , and we needed to work with it in another color space, such as LAB, we could simply call the convert method with the desired color space. >>> Color ( 'yellow' ) . convert ( \"Lab\" ) color(lab 97.606 -15.761 93.387 / 1) Color Matching Color objects can take in raw data points or a CSS style string input. The string matching logic is exposed via the match method. By default, we can just give it a string, and it will return a ColorMatch object. The ColorMatch object will have the matched color as a Color object, and the start and end points it was located at. >>> Color . match ( \"red\" ) ColorMatch(color=color(srgb 1 0 0 / 1), start=0, end=3) By default it matches at the start of the buffer and returns a color if it finds one. If desired, we can do a fullmatch which requires the entire buffer to match the color. >>> Color . match ( \"red and yellow\" ) ColorMatch(color=color(srgb 1 0 0 / 1), start=0, end=3) >>> Color . match ( \"red and yellow\" , fullmatch = True ) We can also adjust the start position of the search. In this case, by adjusting the start position to 8 characters later, we will match yellow instead of red . >>> Color . match ( \"red and yellow\" , start = 8 ) ColorMatch(color=color(srgb 1 1 0 / 1), start=8, end=14) If desired, we can also filter out the CSS syntax of certain color spaces. In the following example, we will only target HSL colors. >>> Color . match ( \"red and yellow\" , filters = [ \"hsl\" ]) >>> Color . match ( \"hsl(130 30 % 75% )\" , filters = [ \"hsl\" ]) ColorMatch(color=color(hsl 130 30 75 / 1), start=0, end=16) A method to find all colors in a buffer is not provided as looping through all the color spaces and matching all potential colors on every character is not really efficient. What is recommended would be to apply this with some logic to find potential places in the buffer to test, and only test those places. In this example, we construct a regex to find places within the buffer that potentially have a valid color, but we also try and filter out cases that are unfavorable, particularly in HTML or CSS. We don't want to match hex in HTML entities or color names that are part of color variables ( var ( --color-red ) ). >>> import re >>> from coloraide import Color >>> RE_COLOR_START = re . compile ( r \"(?i)(?:\\b(?<![-#&$])(?:color|hsla?|lch|lab|hwb|rgba?)\\(|\\b(?<![-#&$])[\\w]{3,}(?![(-])\\b|(?<![&])#)\" ) >>> text = \"\"\"Red and yellow are colors. So are #000088 and lch(75% 50 50).\"\"\" >>> colors = [] >>> for m in RE_COLOR_START . finditer ( text ): ... start = m . start () ... mcolor = Color . match ( text , start = start ) ... if mcolor is not None : ... colors . append ( mcolor . color ) ... >>> [ x . to_string () for x in colors ] ['rgb(255 0 0)', 'rgb(255 255 0)', 'rgb(0 0 136)', 'lch(75% 50 50)'] Override Default Settings ColorAide has a couple of default settings, such as the default precision for string outputs, default gamut mapping mode, etc. All of these options can be set on-demand when calling certain functions. When not explicitly set, some default is used. If needed, the defaults can be changed for an entire application or library. To do so, simply subclass the Color object and override the defaults. Then the new derived class can be used throughout an application or library. >>> class Color2 ( Color ): ... PRECISION = 3 ... >>> Color ( 'purple' ) . convert ( 'lch' ) . to_string () lch(29.691% 66.836 327.1) >>> Color2 ( 'purple' ) . convert ( 'lch' ) . to_string () lch(29.7% 66.8 327) Properties Description FIT The default gamut mapping method used by the Color object. DELTA_E The default delta E algorithm used for gamut distancing calls internally. PRECISION The default precision for string outputs.","title":"The Color Object"},{"location":"color/#the-color-object","text":"","title":"The Color Object"},{"location":"color/#creating-colors","text":"The Color object can be imported from coloraide . from coloraide import Color Afterwards, colors can be created using various, valid CSS syntax: >>> Color ( \"red\" ), (color(srgb 1 0 0 / 1),) >>> Color ( \"#00ff00\" ), (color(srgb 0 1 0 / 1),) >>> Color ( \"rgb(0 0 255 / 1)\" ) color(srgb 0 0 1 / 1) As shown above, we can use all sorts of valid CSS syntax, and we get the same color red . We can also insert raw data points directly, but notice, when doing this, we are required to enter the data as it is used internally, and in the case for sRGB, the channels are in the range of [0, 1]. Additionally, alpha is always handled as a separate parameter. >>> Color ( \"srgb\" , [ 0.5 , 0 , 1 ], 0.3 ) color(srgb 0.5 0 1 / 0.3) We can also pass in other color objects, which is really only useful if we've subclassed the Color object and want to cast the object between the classes. The same color creation can be preformed from a color's new class method as well. new accepts the same inputs as the class object itself. >>> color1 = Color ( \"red\" ) >>> color1 color(srgb 1 0 0 / 1) >>> color1 . new ( \"blue\" ) color(srgb 0 0 1 / 1)","title":"Creating Colors"},{"location":"color/#cloning","text":"The clone method is an easy way to duplicate the current color object. Here we clone the green object so we have two. >>> c1 = Color ( \"green\" ) >>> c1 color(srgb 0 0.50196 0 / 1) >>> c1 . clone () color(srgb 0 0.50196 0 / 1)","title":"Cloning"},{"location":"color/#updating","text":"A color can be \"updated\" using another color object. When an update occurs, the current color space is updated with the data from the second color, but the color space does not change. It is basically the equivalent of converting the second color to the color space of the first and then updating all the coordinates (including alpha). The input parameters are identical to the new method, so we can use a color object, a color string, or even raw data points. Here we update the color red to the color blue : >>> Color ( \"red\" ) color(srgb 1 0 0 / 1) >>> Color ( \"red\" ) . update ( Color ( \"blue\" )) color(srgb 0 0 1 / 1) Here we update the sRGB red with the color lch ( 80 % 50 130 ) . >>> Color ( \"red\" ) . update ( \"lch(80% 50 130)\" ) color(srgb 0.60402 0.83978 0.4839 / 1)","title":"Updating"},{"location":"color/#mutating","text":"\"Mutating\" is similar to updating except that it will update the color and the color space from another color. The input parameters are identical to the new method, so we can use a color object, a color string, or even raw data points. Here the red color object literally becomes an LCH color object with the new color lch ( 80 % 50 130 ) . >>> Color ( \"red\" ) . mutate ( \"lch(80% 50 130)\" ) color(lch 80 50 130 / 1)","title":"Mutating"},{"location":"color/#converting","text":"Colors can be converted to other color spaces as needed. Converting will always return a new color unless in_place is set True , in which case the current color will be mutated to the new converted color. For instance, if we had a color yellow , and we needed to work with it in another color space, such as LAB, we could simply call the convert method with the desired color space. >>> Color ( 'yellow' ) . convert ( \"Lab\" ) color(lab 97.606 -15.761 93.387 / 1)","title":"Converting"},{"location":"color/#color-matching","text":"Color objects can take in raw data points or a CSS style string input. The string matching logic is exposed via the match method. By default, we can just give it a string, and it will return a ColorMatch object. The ColorMatch object will have the matched color as a Color object, and the start and end points it was located at. >>> Color . match ( \"red\" ) ColorMatch(color=color(srgb 1 0 0 / 1), start=0, end=3) By default it matches at the start of the buffer and returns a color if it finds one. If desired, we can do a fullmatch which requires the entire buffer to match the color. >>> Color . match ( \"red and yellow\" ) ColorMatch(color=color(srgb 1 0 0 / 1), start=0, end=3) >>> Color . match ( \"red and yellow\" , fullmatch = True ) We can also adjust the start position of the search. In this case, by adjusting the start position to 8 characters later, we will match yellow instead of red . >>> Color . match ( \"red and yellow\" , start = 8 ) ColorMatch(color=color(srgb 1 1 0 / 1), start=8, end=14) If desired, we can also filter out the CSS syntax of certain color spaces. In the following example, we will only target HSL colors. >>> Color . match ( \"red and yellow\" , filters = [ \"hsl\" ]) >>> Color . match ( \"hsl(130 30 % 75% )\" , filters = [ \"hsl\" ]) ColorMatch(color=color(hsl 130 30 75 / 1), start=0, end=16) A method to find all colors in a buffer is not provided as looping through all the color spaces and matching all potential colors on every character is not really efficient. What is recommended would be to apply this with some logic to find potential places in the buffer to test, and only test those places. In this example, we construct a regex to find places within the buffer that potentially have a valid color, but we also try and filter out cases that are unfavorable, particularly in HTML or CSS. We don't want to match hex in HTML entities or color names that are part of color variables ( var ( --color-red ) ). >>> import re >>> from coloraide import Color >>> RE_COLOR_START = re . compile ( r \"(?i)(?:\\b(?<![-#&$])(?:color|hsla?|lch|lab|hwb|rgba?)\\(|\\b(?<![-#&$])[\\w]{3,}(?![(-])\\b|(?<![&])#)\" ) >>> text = \"\"\"Red and yellow are colors. So are #000088 and lch(75% 50 50).\"\"\" >>> colors = [] >>> for m in RE_COLOR_START . finditer ( text ): ... start = m . start () ... mcolor = Color . match ( text , start = start ) ... if mcolor is not None : ... colors . append ( mcolor . color ) ... >>> [ x . to_string () for x in colors ] ['rgb(255 0 0)', 'rgb(255 255 0)', 'rgb(0 0 136)', 'lch(75% 50 50)']","title":"Color Matching"},{"location":"color/#override-default-settings","text":"ColorAide has a couple of default settings, such as the default precision for string outputs, default gamut mapping mode, etc. All of these options can be set on-demand when calling certain functions. When not explicitly set, some default is used. If needed, the defaults can be changed for an entire application or library. To do so, simply subclass the Color object and override the defaults. Then the new derived class can be used throughout an application or library. >>> class Color2 ( Color ): ... PRECISION = 3 ... >>> Color ( 'purple' ) . convert ( 'lch' ) . to_string () lch(29.691% 66.836 327.1) >>> Color2 ( 'purple' ) . convert ( 'lch' ) . to_string () lch(29.7% 66.8 327) Properties Description FIT The default gamut mapping method used by the Color object. DELTA_E The default delta E algorithm used for gamut distancing calls internally. PRECISION The default precision for string outputs.","title":"Override Default Settings"},{"location":"contrast/","text":"Contrast Relative Luminance Relative luminance is used to calculate the contrast ratio. To get the luminance, simply call the luminance method: >>> Color ( \"black\" ) . luminance () 0.0 >>> Color ( \"white\" ) . luminance () 0.9999956946808511 >>> Color ( \"blue\" ) . luminance () 0.06063148009104977 Contrast Ratio To get the contrast ratio between two colors, simply pass in the second color: >>> Color ( \"blue\" ) . contrast ( \"red\" ) 2.4628528770460973","title":"Contrast"},{"location":"contrast/#contrast","text":"","title":"Contrast"},{"location":"contrast/#relative-luminance","text":"Relative luminance is used to calculate the contrast ratio. To get the luminance, simply call the luminance method: >>> Color ( \"black\" ) . luminance () 0.0 >>> Color ( \"white\" ) . luminance () 0.9999956946808511 >>> Color ( \"blue\" ) . luminance () 0.06063148009104977","title":"Relative Luminance"},{"location":"contrast/#contrast-ratio","text":"To get the contrast ratio between two colors, simply pass in the second color: >>> Color ( \"blue\" ) . contrast ( \"red\" ) 2.4628528770460973","title":"Contrast Ratio"},{"location":"distance/","text":"Color Distance and Delta E Color Distance ColorAide provides a simple euclidean color distance function. By default, it evaluates the distance in the Lab color space, but it can be configured to evaluate in any color space. It may be less useful in some color spaces compared to others: >>> Color ( \"red\" ) . distance ( \"blue\" , space = \"srgb\" ) 1.4142135623730951 >>> Color ( \"red\" ) . distance ( \"blue\" , space = \"lab\" ) 184.01647404809094 Delta E The delta_e function gives access to various delta E implementations. >>> Color ( \"red\" ) . delta_e ( \"blue\" ) 184.01647404809094 >>> Color ( \"red\" ) . delta_e ( \"blue\" , method = \"2000\" ) 55.79505955791144 The default implementation is Delta E 1976. Originally, when the Lab color space was created, it was thought that it was more perceptually uniform than it actually was. At first, the distance algorithm was a simple euclidean implementation (Delta E 1976), but over time it has been tweaked to make corrections to account for the fact that it is not perfectly uniform. There are areas and industries that still use many of these for different reasons. ColorAide implements the following delta E methods: Name Parameter Name Weighted Parameters CIE76 76 CMC l:c (1984) cmc l=2, c=1 CIE94 94 kl=1, k1=0.045, k2=0.015 CIEDE2000 2000 kl=1, kc=1, kh=1","title":"Color Distance and Delta E"},{"location":"distance/#color-distance-and-delta-e","text":"","title":"Color Distance and Delta E"},{"location":"distance/#color-distance","text":"ColorAide provides a simple euclidean color distance function. By default, it evaluates the distance in the Lab color space, but it can be configured to evaluate in any color space. It may be less useful in some color spaces compared to others: >>> Color ( \"red\" ) . distance ( \"blue\" , space = \"srgb\" ) 1.4142135623730951 >>> Color ( \"red\" ) . distance ( \"blue\" , space = \"lab\" ) 184.01647404809094","title":"Color Distance"},{"location":"distance/#delta-e","text":"The delta_e function gives access to various delta E implementations. >>> Color ( \"red\" ) . delta_e ( \"blue\" ) 184.01647404809094 >>> Color ( \"red\" ) . delta_e ( \"blue\" , method = \"2000\" ) 55.79505955791144 The default implementation is Delta E 1976. Originally, when the Lab color space was created, it was thought that it was more perceptually uniform than it actually was. At first, the distance algorithm was a simple euclidean implementation (Delta E 1976), but over time it has been tweaked to make corrections to account for the fact that it is not perfectly uniform. There are areas and industries that still use many of these for different reasons. ColorAide implements the following delta E methods: Name Parameter Name Weighted Parameters CIE76 76 CMC l:c (1984) cmc l=2, c=1 CIE94 94 kl=1, k1=0.045, k2=0.015 CIEDE2000 2000 kl=1, kc=1, kh=1","title":"Delta E"},{"location":"gamut/","text":"Gamut Mapping Overview Many color spaces have limits the colors they can accurately represent. This is the color gamut. The bounds represent the limits in which a color space can represent a color. Some color spaces are theoretically unbounded, but past a point, the eye can't see them. When moving from a large color space like Lab to a small color space like sRGB, many Lab colors will not fit without mapping the color to one that does fit. This \"fitting\" of the color from one gamut into another is called gamut mapping. Checking Gamut A color can be checked to see if it fits in its own gamut or the gamut of another color space. Some color spaces may have suggested limits for usability purposes, but may not have actual limits. Let's assume we have a color rgb ( 30 % 105 % 0 % ) which is not in its own gamut as the green channel exceeds the sRGB limit of 100% . We can check this via the in_gamut method, and we can see that it is not in gamut. >>> Color ( \"rgb(30 % 105% 0%)\" ) . in_gamut () False We can also test if a color from one color space fits in a completely different color space. In the example below, we can see that the LCH color of lch ( 100 % 50 75 ) is outside the narrow gamut of sRGB. >>> Color ( \"lch(100% 50 75)\" ) . in_gamut ( \"srgb\" ) False Mapping Colors The recommended approach for fitting/mapping a color is to compress the chroma while in the LCH color space (overly simplified). This is the approach that our reference ( colorjs ) chose, so we ported it over here as well. In this example, we will take the color lch ( 100 % 50 75 ) . LCH's gamut is technically unbounded, but if we try to fit it in the sRGB gamut, as noted earlier, it is outside the narrow gamut of sRGB. So, using the fit method, and specifying srgb as the target color space, we can fit it in the sRGB gamut. >>> Color ( \"lch(100% 50 75)\" ) . fit ( \"srgb\" ) color(lch 99.437 5.219 99.729 / 1) If desired, simple clipping can be used instead of the default gamut fitting. Generally this is not recommended, but there are times and places for everything. In this example, we can change the fitting method parameter to clip . Notice the difference when compared to the previous fitting result: >>> Color ( \"lch(100% 50 75)\" ) . fit ( \"srgb\" , method = \"clip\" ) color(lch 95.815 42.312 96.915 / 1) >>> Color ( \"lch(100% 50 75)\" ) . fit ( \"srgb\" ) color(lch 99.437 5.219 99.729 / 1) Gamut fitting will always return a new color unless in_place is set True .","title":"Gamut Mapping"},{"location":"gamut/#gamut-mapping","text":"","title":"Gamut Mapping"},{"location":"gamut/#overview","text":"Many color spaces have limits the colors they can accurately represent. This is the color gamut. The bounds represent the limits in which a color space can represent a color. Some color spaces are theoretically unbounded, but past a point, the eye can't see them. When moving from a large color space like Lab to a small color space like sRGB, many Lab colors will not fit without mapping the color to one that does fit. This \"fitting\" of the color from one gamut into another is called gamut mapping.","title":"Overview"},{"location":"gamut/#checking-gamut","text":"A color can be checked to see if it fits in its own gamut or the gamut of another color space. Some color spaces may have suggested limits for usability purposes, but may not have actual limits. Let's assume we have a color rgb ( 30 % 105 % 0 % ) which is not in its own gamut as the green channel exceeds the sRGB limit of 100% . We can check this via the in_gamut method, and we can see that it is not in gamut. >>> Color ( \"rgb(30 % 105% 0%)\" ) . in_gamut () False We can also test if a color from one color space fits in a completely different color space. In the example below, we can see that the LCH color of lch ( 100 % 50 75 ) is outside the narrow gamut of sRGB. >>> Color ( \"lch(100% 50 75)\" ) . in_gamut ( \"srgb\" ) False","title":"Checking Gamut"},{"location":"gamut/#mapping-colors","text":"The recommended approach for fitting/mapping a color is to compress the chroma while in the LCH color space (overly simplified). This is the approach that our reference ( colorjs ) chose, so we ported it over here as well. In this example, we will take the color lch ( 100 % 50 75 ) . LCH's gamut is technically unbounded, but if we try to fit it in the sRGB gamut, as noted earlier, it is outside the narrow gamut of sRGB. So, using the fit method, and specifying srgb as the target color space, we can fit it in the sRGB gamut. >>> Color ( \"lch(100% 50 75)\" ) . fit ( \"srgb\" ) color(lch 99.437 5.219 99.729 / 1) If desired, simple clipping can be used instead of the default gamut fitting. Generally this is not recommended, but there are times and places for everything. In this example, we can change the fitting method parameter to clip . Notice the difference when compared to the previous fitting result: >>> Color ( \"lch(100% 50 75)\" ) . fit ( \"srgb\" , method = \"clip\" ) color(lch 95.815 42.312 96.915 / 1) >>> Color ( \"lch(100% 50 75)\" ) . fit ( \"srgb\" ) color(lch 99.437 5.219 99.729 / 1) Gamut fitting will always return a new color unless in_place is set True .","title":"Mapping Colors"},{"location":"interpolation/","text":"Color Interpolation Interpolating The interpolate method allows a user to create an interpolation function. This can be used to create a list of gradient colors, or whatever is needed. This function drives most of the features under the interpolation umbrella. The steps and mix functions are both built on top of interpolate . A returned interpolation functions accept an input between 0 - 1, if values are provided out of this range, the color will be extrapolated and the results may be surprising. In this example, we create a an interpolation between rebeccapurple and lch ( 85 % 100 85 ) (color previews are fit to the sRGB gamut). We then step through values of 0.1 , 0.2 , 0.3 , etc. >>> i = Color ( \"rebeccapurple\" ) . interpolate ( \"lch(85% 100 85)\" , space = 'lch' ) >>> [ i ( x / 20 ) . to_string () for x in range ( 20 )] ['rgb(102 51 153)', 'rgb(122.46 48.664 154.44)', 'rgb(142.02 45.34 154.31)', 'rgb(160.75 41.148 152.65)', 'rgb(178.58 36.391 149.5)', 'rgb(195.41 31.73 144.97)', 'rgb(211.11 28.452 139.16)', 'rgb(225.56 28.429 132.21)', 'rgb(238.61 32.963 124.24)', 'rgb(250.16 41.619 115.38)', 'rgb(255 53.083 105.75)', 'rgb(242.32 98.772 107.9)', 'rgb(249.21 108.41 101.4)', 'rgb(254.69 118.96 94.656)', 'rgb(255 130.24 87.774)', 'rgb(255 142.11 80.878)', 'rgb(255 154.42 74.129)', 'rgb(255 167.07 67.761)', 'rgb(255 179.93 62.148)', 'rgb(255 192.91 57.87)'] This allows us to create a range of colors that we can use in a gradient. >>> Color ( \"rebeccapurple\" ) . interpolate ( ... \"lch(85% 100 85)\" , ... space = 'lch' ... ) functools.partial(<function _interpolate at 0x10c1a04c0>, color=color(srgb 0.4 0.2 0.6 / 1), interp=functools.partial(<function interpolate at 0x10c1d7ca0>, coords1=[32.392890284287375, 61.2546310339011, 308.8564260485244, 1.0], coords2=[85.0, 100.0, 445.0, 1.0], create=color(lch 32.393 61.255 308.86 / 1), progress=None, outspace='srgb', premultiplied=False)) If desired, we can target one or more specific channels for mixing which will keep all the other channels constant on the base color. Channels can be any channel associated with the color space in which the interpolation is taking place (including alpha ). In the following example, we have a base color of lch ( 52 % 58 . 1 22 . 7 ) which we mix with lch ( 56 % 49 . 1 257 . 1 ) . We also specify that we want to only mix the hue channel. Applying this logic, we will end up with a range of colors that maintain the same lightness and chroma, but with different hues. We can see as we step through the colors that only the hue is interpolated. >>> Color ( \"lch(52% 58.1 22.7)\" ) . interpolate ( ... \"lch(56% 49.1 257.1)\" , ... space = \"lch\" , ... adjust = [ \"hue\" ] ... ) functools.partial(<function _interpolate at 0x10c1a04c0>, color=color(lch 52 58.1 22.7 / 1), interp=functools.partial(<function interpolate at 0x10c1d7ca0>, coords1=[52.0, 58.1, 382.7, 1.0], coords2=[nan, nan, 257.1, nan], create=color(lch 52 58.1 382.7 / 1), progress=None, outspace='lch', premultiplied=False)) Additionally, hues are special, and we can control the way the interpolation is evaluated. The hue parameter accepts such values as shorter , longer , increasing , decreasing , and specified ( shorter being the default). Below, we can see how the interpolation varies using shorter vs longer . >>> i = Color ( \"lch(52% 58.1 22.7)\" ) . interpolate ( ... \"lch(56% 49.1 257.1)\" , ... space = \"lch\" , ... adjust = [ \"hue\" ] ... ) >>> i ( 0.2477 ) . to_string () lch(52% 58.1 351.59) >>> i = Color ( \"lch(52% 58.1 22.7)\" ) . interpolate ( ... \"lch(56% 49.1 257.1)\" , ... space = \"lch\" , ... adjust = [ \"hue\" ], ... hue = \"longer\" ... ) >>> i ( 0.2477 ) . to_string () lch(52% 58.1 80.761) To help visualize the different hue methods, consider the following evaluation between rebeccapurple and lch ( 85 % 85 805 ) in the table below. Check out the CSS level 4 specification to learn more about each one. shorter : >>> Color ( \"rebeccapurple\" ) . interpolate ( ... \"lch(85% 100 805)\" , ... space = 'lch' , ... hue = \"shorter\" ... ) functools.partial(<function _interpolate at 0x10c1a04c0>, color=color(srgb 0.4 0.2 0.6 / 1), interp=functools.partial(<function interpolate at 0x10c1d7ca0>, coords1=[32.392890284287375, 61.2546310339011, 308.8564260485244, 1.0], coords2=[85.0, 100.0, 445.0, 1.0], create=color(lch 32.393 61.255 308.86 / 1), progress=None, outspace='srgb', premultiplied=False)) longer : >>> Color ( \"rebeccapurple\" ) . interpolate ( ... \"lch(85% 100 805)\" , ... space = 'lch' , ... hue = \"longer\" ... ) functools.partial(<function _interpolate at 0x10c1a04c0>, color=color(srgb 0.4 0.2 0.6 / 1), interp=functools.partial(<function interpolate at 0x10c1d7ca0>, coords1=[32.392890284287375, 61.2546310339011, 308.8564260485244, 1.0], coords2=[85.0, 100.0, 85.0, 1.0], create=color(lch 32.393 61.255 308.86 / 1), progress=None, outspace='srgb', premultiplied=False)) increasing : >>> Color ( \"rebeccapurple\" ) . interpolate ( ... \"lch(85% 100 805)\" , ... space = 'lch' , ... hue = \"increasing\" ... ) functools.partial(<function _interpolate at 0x10c1a04c0>, color=color(srgb 0.4 0.2 0.6 / 1), interp=functools.partial(<function interpolate at 0x10c1d7ca0>, coords1=[32.392890284287375, 61.2546310339011, 308.8564260485244, 1.0], coords2=[85.0, 100.0, 445.0, 1.0], create=color(lch 32.393 61.255 308.86 / 1), progress=None, outspace='srgb', premultiplied=False)) decreasing : >>> Color ( \"rebeccapurple\" ) . interpolate ( ... \"lch(85% 100 805)\" , ... space = 'lch' , ... hue = \"decreasing\" ... ) functools.partial(<function _interpolate at 0x10c1a04c0>, color=color(srgb 0.4 0.2 0.6 / 1), interp=functools.partial(<function interpolate at 0x10c1d7ca0>, coords1=[32.392890284287375, 61.2546310339011, 308.8564260485244, 1.0], coords2=[85.0, 100.0, 85.0, 1.0], create=color(lch 32.393 61.255 308.86 / 1), progress=None, outspace='srgb', premultiplied=False)) specified : >>> Color ( \"rebeccapurple\" ) . interpolate ( ... \"lch(85% 100 805)\" , ... space = 'lch' , ... hue = \"specified\" ... ) functools.partial(<function _interpolate at 0x10c1a04c0>, color=color(srgb 0.4 0.2 0.6 / 1), interp=functools.partial(<function interpolate at 0x10c1d7ca0>, coords1=[32.392890284287375, 61.2546310339011, 308.8564260485244, 1.0], coords2=[85.0, 100.0, 805.0, 1.0], create=color(lch 32.393 61.255 308.86 / 1), progress=None, outspace='srgb', premultiplied=False)) We can also do non-linear interpolation by providing a function. Here we use a function that returns p ** 3 creating the colors (color previews are fit to the sRGB gamut): >>> Color ( \"lch(50% 50 0)\" ) . interpolate ( ... \"lch(90% 50 20)\" , ... progress = lambda p : p ** 3 ... ) functools.partial(<function _interpolate at 0x10c1a04c0>, color=color(lch 50 50 0 / 1), interp=functools.partial(<function interpolate at 0x10c1d7ca0>, coords1=[50.0, 50.0, 0.0, 1.0], coords2=[90.0, 46.98463103929542, 17.101007166283434, 1.0], create=color(lab 50 50 0 / 1), progress=<function <lambda> at 0x118702af0>, outspace='lch', premultiplied=False)) Color Mixing Colors can be mixed together to create new colors. Mixing is built on top of the interpolate function and will return a color between the current and specified color. If colors are requested to be interpolated within a color space smaller than the original, the colors will be gamut mapped into the desired color space. Tip Mix, just like interpolation, also accepts the accept and hue parameters. As an example, if we had the color red and the color blue , and we wanted to mix them, we can just call the mix method, and we'll get: >>> Color ( \"red\" ) . mix ( Color ( \"blue\" )) color(srgb 0.5 0 0.5 / 1) The mix method will mix the two colors in the color space of the color calling the method. If needed, a different color space can be specified with the space parameter. Notice below that this creates a different color. The results of mixing in a different color space may be more desirable as color mixing may be more natural. >>> Color ( \"red\" ) . mix ( Color ( \"blue\" ), space = \"lch\" ) color(srgb 0.96066 -0.3955 0.52583 / 1) By default, colors are mixed at 50%, but the percentage can be controlled. Here we mix the color blue into the color red at 20%. This gives us the color of rgb ( 204 0 51 ) . >>> Color ( \"red\" ) . mix ( Color ( \"blue\" ), 0.2 ) color(srgb 0.8 0 0.2 / 1) Mix can also accept a string and will create the color for us which is great if we don't need to work with the second color afterwards. >>> Color ( \"red\" ) . mix ( \"blue\" , 0.2 ) color(srgb 0.8 0 0.2 / 1) Mixing will always return a new color unless in_place is set True . Steps The steps method creates a list of discrete colors. Like mixing, it is also built on interpolate . The steps to take between the two colors can be configured with the three options, steps (minimum number of steps), max_steps , and max_delta_e (max allowable delta E distance between steps). The default delta E method is delta E 76, which is a simple euclidean distancing in the Lab color space. In this example, we we specify the color color ( display-p3 0 1 0 ) and interpolate steps between red . The result gives us an array of colors (color previews are fit to the sRGB gamut): >>> Color ( \"display-p3\" , [ 0 , 1 , 0 ]) . steps ( ... \"red\" , ... space = \"lch\" , ... out_space = \"srgb\" , ... max_delta_e = 20 , ... steps = 3 , ... max_steps = 15 ... ) [color(srgb -0.5116 1.0183 -0.31067 / 1), color(srgb -0.40808 0.98732 -0.33344 / 1), color(srgb -0.25329 0.95542 -0.34363 / 1), color(srgb 0.20402 0.92252 -0.34587 / 1), color(srgb 0.38266 0.88854 -0.34288 / 1), color(srgb 0.49312 0.85342 -0.33745 / 1), color(srgb 0.57848 0.8171 -0.3309 / 1), color(srgb 0.64924 0.77952 -0.3232 / 1), color(srgb 0.70984 0.74062 -0.3143 / 1), color(srgb 0.80869 0.65863 -0.2927 / 1), color(srgb 0.88414 0.57046 -0.26557 / 1), color(srgb 0.93977 0.4749 -0.23187 / 1), color(srgb 0.97714 0.36901 -0.1894 / 1), color(srgb 0.99711 0.24318 -0.13212 / 1), color(srgb 1 0 0 / 1)] Overlaying Colors The overlay method allows a transparent color to be overlaid on top of another color creating the composite of the two. To perform an overlay, a background color must be provided to the color along with an optional color space. If a color is to be overlaid within a smaller color space, the colors will be mapped to the smaller space. Cylindrical Spaces It is generally recommended to overlay in non-cylindrical spaces, but there is no limitation to do so. In the example below, we take the rgb ( 100 % 0 % 0 % / 0 . 5 ) and overlay it on the color black . This yields the color: rgb ( 127 . 5 0 0 ) . >>> Color ( \"rgb(100 % 0% 0% / 0.5)\" ) . overlay ( \"black\" ) color(srgb 0.5 0 0 / 1) If desired, you can specify a different space to overlay in via the space parameter. Color space can affect the results. >>> Color ( \"rgb(100 % 0% 0% / 0.5)\" ) . overlay ( \"black\" , space = \"display-p3\" ) color(srgb 0.50164 0.03862 0.02838 / 1) A new color will be returned instead of modifying the current color unless in_place is set True . Null Handling Color spaces that have hue coordinates often have rules about when the hue is considered relevant. For instance, in the HSL color space, if saturation is zero, the hue is considered null. This is because the color is \"without color\"; therefore, it has no hue, or the hue is undefined. Many libraries, like d3-color , chroma.js , and color.js , represent null hues with NaN (not a number). This is usually done to make color interpolation easier. Some, like d3-color, are a bit more liberal with NaN and will target special cases that are above and beyond the normal rules to help ensure good interpolation. For instance, they not only mark hue null on HSL colors when saturation is zero, but also when lightness is zero or one hundred (essentially appearing black or white). In fact, they'll mark saturation as NaN when lightness indicates \"black\" or \"white\". ColorAide also uses NaN , or in Python float ( 'nan' ) . In certain situations, when a hue is deemed undefined, the hue value will be set to coloraide.NaN , which is just a constant containing float ( 'nan' ) . When interpolating, if one color's channel has a NaN , the other color's channel will be used as the result. If both colors have a NaN for the same channel, then 0 will be returned. Notice that in this example, because white's saturation is zero, the hue is undefined. Because the hue is undefined, when the color is mixed with a second color ( purple ), the hue of the second color is used. >>> color = Color ( 'white' ) . convert ( 'hsl' ) >>> color . coords () [nan, 0.0, 100.0] >>> color2 = Color ( 'purple' ) . convert ( 'hsl' ) >>> color2 . coords () [300.0, 100.0, 25.098039215686274] >>> color . mix ( color2 , space = \"hsl\" ) color(hsl 300 50 62.549 / 1) This is essentially how the adjust parameter works with interploate , step , and mix . adjust simply ensures that the secondary color has NaN set to specified channels. Technically, any channel can be set to NaN , but it must be done by instantiating a Color object with raw data or by manually setting it via a channel property or accessor. CSS string inputs do not allow the NaN value. >>> from coloraide import NaN >>> Color ( \"srgb\" , [ 1 , NaN , 1 ]) . coords () [1.0, nan, 1.0] >>> Color ( \"red\" ) . set ( 'green' , NaN ) . coords () [1.0, nan, 0.0] When printing to a string, NaN s are always converted to 0 : >>> from coloraide import NaN >>> Color ( \"srgb\" , [ 1 , NaN , 1 ]) color(srgb 1 0 1 / 1) At any time, a channel can be checked for whether it is NaN by using the is_nan method: >>> Color ( \"white\" ) . convert ( 'hsl' ) . is_nan ( 'hue' ) True It can be useful to check whether a channel is NaN as NaN values can't be added, subtracted, multiplied, etc. They will always return NaN unless you directly replace them. >>> color = Color ( \"white\" ) . convert ( 'hsl' ) >>> color . hue = color . hue + 3 >>> color . is_nan ( 'hue' ) True >>> color . hue = 3 >>> color . is_nan ( 'hue' ) False","title":"Color Interpolation"},{"location":"interpolation/#color-interpolation","text":"","title":"Color Interpolation"},{"location":"interpolation/#interpolating","text":"The interpolate method allows a user to create an interpolation function. This can be used to create a list of gradient colors, or whatever is needed. This function drives most of the features under the interpolation umbrella. The steps and mix functions are both built on top of interpolate . A returned interpolation functions accept an input between 0 - 1, if values are provided out of this range, the color will be extrapolated and the results may be surprising. In this example, we create a an interpolation between rebeccapurple and lch ( 85 % 100 85 ) (color previews are fit to the sRGB gamut). We then step through values of 0.1 , 0.2 , 0.3 , etc. >>> i = Color ( \"rebeccapurple\" ) . interpolate ( \"lch(85% 100 85)\" , space = 'lch' ) >>> [ i ( x / 20 ) . to_string () for x in range ( 20 )] ['rgb(102 51 153)', 'rgb(122.46 48.664 154.44)', 'rgb(142.02 45.34 154.31)', 'rgb(160.75 41.148 152.65)', 'rgb(178.58 36.391 149.5)', 'rgb(195.41 31.73 144.97)', 'rgb(211.11 28.452 139.16)', 'rgb(225.56 28.429 132.21)', 'rgb(238.61 32.963 124.24)', 'rgb(250.16 41.619 115.38)', 'rgb(255 53.083 105.75)', 'rgb(242.32 98.772 107.9)', 'rgb(249.21 108.41 101.4)', 'rgb(254.69 118.96 94.656)', 'rgb(255 130.24 87.774)', 'rgb(255 142.11 80.878)', 'rgb(255 154.42 74.129)', 'rgb(255 167.07 67.761)', 'rgb(255 179.93 62.148)', 'rgb(255 192.91 57.87)'] This allows us to create a range of colors that we can use in a gradient. >>> Color ( \"rebeccapurple\" ) . interpolate ( ... \"lch(85% 100 85)\" , ... space = 'lch' ... ) functools.partial(<function _interpolate at 0x10c1a04c0>, color=color(srgb 0.4 0.2 0.6 / 1), interp=functools.partial(<function interpolate at 0x10c1d7ca0>, coords1=[32.392890284287375, 61.2546310339011, 308.8564260485244, 1.0], coords2=[85.0, 100.0, 445.0, 1.0], create=color(lch 32.393 61.255 308.86 / 1), progress=None, outspace='srgb', premultiplied=False)) If desired, we can target one or more specific channels for mixing which will keep all the other channels constant on the base color. Channels can be any channel associated with the color space in which the interpolation is taking place (including alpha ). In the following example, we have a base color of lch ( 52 % 58 . 1 22 . 7 ) which we mix with lch ( 56 % 49 . 1 257 . 1 ) . We also specify that we want to only mix the hue channel. Applying this logic, we will end up with a range of colors that maintain the same lightness and chroma, but with different hues. We can see as we step through the colors that only the hue is interpolated. >>> Color ( \"lch(52% 58.1 22.7)\" ) . interpolate ( ... \"lch(56% 49.1 257.1)\" , ... space = \"lch\" , ... adjust = [ \"hue\" ] ... ) functools.partial(<function _interpolate at 0x10c1a04c0>, color=color(lch 52 58.1 22.7 / 1), interp=functools.partial(<function interpolate at 0x10c1d7ca0>, coords1=[52.0, 58.1, 382.7, 1.0], coords2=[nan, nan, 257.1, nan], create=color(lch 52 58.1 382.7 / 1), progress=None, outspace='lch', premultiplied=False)) Additionally, hues are special, and we can control the way the interpolation is evaluated. The hue parameter accepts such values as shorter , longer , increasing , decreasing , and specified ( shorter being the default). Below, we can see how the interpolation varies using shorter vs longer . >>> i = Color ( \"lch(52% 58.1 22.7)\" ) . interpolate ( ... \"lch(56% 49.1 257.1)\" , ... space = \"lch\" , ... adjust = [ \"hue\" ] ... ) >>> i ( 0.2477 ) . to_string () lch(52% 58.1 351.59) >>> i = Color ( \"lch(52% 58.1 22.7)\" ) . interpolate ( ... \"lch(56% 49.1 257.1)\" , ... space = \"lch\" , ... adjust = [ \"hue\" ], ... hue = \"longer\" ... ) >>> i ( 0.2477 ) . to_string () lch(52% 58.1 80.761) To help visualize the different hue methods, consider the following evaluation between rebeccapurple and lch ( 85 % 85 805 ) in the table below. Check out the CSS level 4 specification to learn more about each one. shorter : >>> Color ( \"rebeccapurple\" ) . interpolate ( ... \"lch(85% 100 805)\" , ... space = 'lch' , ... hue = \"shorter\" ... ) functools.partial(<function _interpolate at 0x10c1a04c0>, color=color(srgb 0.4 0.2 0.6 / 1), interp=functools.partial(<function interpolate at 0x10c1d7ca0>, coords1=[32.392890284287375, 61.2546310339011, 308.8564260485244, 1.0], coords2=[85.0, 100.0, 445.0, 1.0], create=color(lch 32.393 61.255 308.86 / 1), progress=None, outspace='srgb', premultiplied=False)) longer : >>> Color ( \"rebeccapurple\" ) . interpolate ( ... \"lch(85% 100 805)\" , ... space = 'lch' , ... hue = \"longer\" ... ) functools.partial(<function _interpolate at 0x10c1a04c0>, color=color(srgb 0.4 0.2 0.6 / 1), interp=functools.partial(<function interpolate at 0x10c1d7ca0>, coords1=[32.392890284287375, 61.2546310339011, 308.8564260485244, 1.0], coords2=[85.0, 100.0, 85.0, 1.0], create=color(lch 32.393 61.255 308.86 / 1), progress=None, outspace='srgb', premultiplied=False)) increasing : >>> Color ( \"rebeccapurple\" ) . interpolate ( ... \"lch(85% 100 805)\" , ... space = 'lch' , ... hue = \"increasing\" ... ) functools.partial(<function _interpolate at 0x10c1a04c0>, color=color(srgb 0.4 0.2 0.6 / 1), interp=functools.partial(<function interpolate at 0x10c1d7ca0>, coords1=[32.392890284287375, 61.2546310339011, 308.8564260485244, 1.0], coords2=[85.0, 100.0, 445.0, 1.0], create=color(lch 32.393 61.255 308.86 / 1), progress=None, outspace='srgb', premultiplied=False)) decreasing : >>> Color ( \"rebeccapurple\" ) . interpolate ( ... \"lch(85% 100 805)\" , ... space = 'lch' , ... hue = \"decreasing\" ... ) functools.partial(<function _interpolate at 0x10c1a04c0>, color=color(srgb 0.4 0.2 0.6 / 1), interp=functools.partial(<function interpolate at 0x10c1d7ca0>, coords1=[32.392890284287375, 61.2546310339011, 308.8564260485244, 1.0], coords2=[85.0, 100.0, 85.0, 1.0], create=color(lch 32.393 61.255 308.86 / 1), progress=None, outspace='srgb', premultiplied=False)) specified : >>> Color ( \"rebeccapurple\" ) . interpolate ( ... \"lch(85% 100 805)\" , ... space = 'lch' , ... hue = \"specified\" ... ) functools.partial(<function _interpolate at 0x10c1a04c0>, color=color(srgb 0.4 0.2 0.6 / 1), interp=functools.partial(<function interpolate at 0x10c1d7ca0>, coords1=[32.392890284287375, 61.2546310339011, 308.8564260485244, 1.0], coords2=[85.0, 100.0, 805.0, 1.0], create=color(lch 32.393 61.255 308.86 / 1), progress=None, outspace='srgb', premultiplied=False)) We can also do non-linear interpolation by providing a function. Here we use a function that returns p ** 3 creating the colors (color previews are fit to the sRGB gamut): >>> Color ( \"lch(50% 50 0)\" ) . interpolate ( ... \"lch(90% 50 20)\" , ... progress = lambda p : p ** 3 ... ) functools.partial(<function _interpolate at 0x10c1a04c0>, color=color(lch 50 50 0 / 1), interp=functools.partial(<function interpolate at 0x10c1d7ca0>, coords1=[50.0, 50.0, 0.0, 1.0], coords2=[90.0, 46.98463103929542, 17.101007166283434, 1.0], create=color(lab 50 50 0 / 1), progress=<function <lambda> at 0x118702af0>, outspace='lch', premultiplied=False))","title":"Interpolating"},{"location":"interpolation/#color-mixing","text":"Colors can be mixed together to create new colors. Mixing is built on top of the interpolate function and will return a color between the current and specified color. If colors are requested to be interpolated within a color space smaller than the original, the colors will be gamut mapped into the desired color space. Tip Mix, just like interpolation, also accepts the accept and hue parameters. As an example, if we had the color red and the color blue , and we wanted to mix them, we can just call the mix method, and we'll get: >>> Color ( \"red\" ) . mix ( Color ( \"blue\" )) color(srgb 0.5 0 0.5 / 1) The mix method will mix the two colors in the color space of the color calling the method. If needed, a different color space can be specified with the space parameter. Notice below that this creates a different color. The results of mixing in a different color space may be more desirable as color mixing may be more natural. >>> Color ( \"red\" ) . mix ( Color ( \"blue\" ), space = \"lch\" ) color(srgb 0.96066 -0.3955 0.52583 / 1) By default, colors are mixed at 50%, but the percentage can be controlled. Here we mix the color blue into the color red at 20%. This gives us the color of rgb ( 204 0 51 ) . >>> Color ( \"red\" ) . mix ( Color ( \"blue\" ), 0.2 ) color(srgb 0.8 0 0.2 / 1) Mix can also accept a string and will create the color for us which is great if we don't need to work with the second color afterwards. >>> Color ( \"red\" ) . mix ( \"blue\" , 0.2 ) color(srgb 0.8 0 0.2 / 1) Mixing will always return a new color unless in_place is set True .","title":"Color Mixing"},{"location":"interpolation/#steps","text":"The steps method creates a list of discrete colors. Like mixing, it is also built on interpolate . The steps to take between the two colors can be configured with the three options, steps (minimum number of steps), max_steps , and max_delta_e (max allowable delta E distance between steps). The default delta E method is delta E 76, which is a simple euclidean distancing in the Lab color space. In this example, we we specify the color color ( display-p3 0 1 0 ) and interpolate steps between red . The result gives us an array of colors (color previews are fit to the sRGB gamut): >>> Color ( \"display-p3\" , [ 0 , 1 , 0 ]) . steps ( ... \"red\" , ... space = \"lch\" , ... out_space = \"srgb\" , ... max_delta_e = 20 , ... steps = 3 , ... max_steps = 15 ... ) [color(srgb -0.5116 1.0183 -0.31067 / 1), color(srgb -0.40808 0.98732 -0.33344 / 1), color(srgb -0.25329 0.95542 -0.34363 / 1), color(srgb 0.20402 0.92252 -0.34587 / 1), color(srgb 0.38266 0.88854 -0.34288 / 1), color(srgb 0.49312 0.85342 -0.33745 / 1), color(srgb 0.57848 0.8171 -0.3309 / 1), color(srgb 0.64924 0.77952 -0.3232 / 1), color(srgb 0.70984 0.74062 -0.3143 / 1), color(srgb 0.80869 0.65863 -0.2927 / 1), color(srgb 0.88414 0.57046 -0.26557 / 1), color(srgb 0.93977 0.4749 -0.23187 / 1), color(srgb 0.97714 0.36901 -0.1894 / 1), color(srgb 0.99711 0.24318 -0.13212 / 1), color(srgb 1 0 0 / 1)]","title":"Steps"},{"location":"interpolation/#overlaying-colors","text":"The overlay method allows a transparent color to be overlaid on top of another color creating the composite of the two. To perform an overlay, a background color must be provided to the color along with an optional color space. If a color is to be overlaid within a smaller color space, the colors will be mapped to the smaller space. Cylindrical Spaces It is generally recommended to overlay in non-cylindrical spaces, but there is no limitation to do so. In the example below, we take the rgb ( 100 % 0 % 0 % / 0 . 5 ) and overlay it on the color black . This yields the color: rgb ( 127 . 5 0 0 ) . >>> Color ( \"rgb(100 % 0% 0% / 0.5)\" ) . overlay ( \"black\" ) color(srgb 0.5 0 0 / 1) If desired, you can specify a different space to overlay in via the space parameter. Color space can affect the results. >>> Color ( \"rgb(100 % 0% 0% / 0.5)\" ) . overlay ( \"black\" , space = \"display-p3\" ) color(srgb 0.50164 0.03862 0.02838 / 1) A new color will be returned instead of modifying the current color unless in_place is set True .","title":"Overlaying Colors"},{"location":"interpolation/#null-handling","text":"Color spaces that have hue coordinates often have rules about when the hue is considered relevant. For instance, in the HSL color space, if saturation is zero, the hue is considered null. This is because the color is \"without color\"; therefore, it has no hue, or the hue is undefined. Many libraries, like d3-color , chroma.js , and color.js , represent null hues with NaN (not a number). This is usually done to make color interpolation easier. Some, like d3-color, are a bit more liberal with NaN and will target special cases that are above and beyond the normal rules to help ensure good interpolation. For instance, they not only mark hue null on HSL colors when saturation is zero, but also when lightness is zero or one hundred (essentially appearing black or white). In fact, they'll mark saturation as NaN when lightness indicates \"black\" or \"white\". ColorAide also uses NaN , or in Python float ( 'nan' ) . In certain situations, when a hue is deemed undefined, the hue value will be set to coloraide.NaN , which is just a constant containing float ( 'nan' ) . When interpolating, if one color's channel has a NaN , the other color's channel will be used as the result. If both colors have a NaN for the same channel, then 0 will be returned. Notice that in this example, because white's saturation is zero, the hue is undefined. Because the hue is undefined, when the color is mixed with a second color ( purple ), the hue of the second color is used. >>> color = Color ( 'white' ) . convert ( 'hsl' ) >>> color . coords () [nan, 0.0, 100.0] >>> color2 = Color ( 'purple' ) . convert ( 'hsl' ) >>> color2 . coords () [300.0, 100.0, 25.098039215686274] >>> color . mix ( color2 , space = \"hsl\" ) color(hsl 300 50 62.549 / 1) This is essentially how the adjust parameter works with interploate , step , and mix . adjust simply ensures that the secondary color has NaN set to specified channels. Technically, any channel can be set to NaN , but it must be done by instantiating a Color object with raw data or by manually setting it via a channel property or accessor. CSS string inputs do not allow the NaN value. >>> from coloraide import NaN >>> Color ( \"srgb\" , [ 1 , NaN , 1 ]) . coords () [1.0, nan, 1.0] >>> Color ( \"red\" ) . set ( 'green' , NaN ) . coords () [1.0, nan, 0.0] When printing to a string, NaN s are always converted to 0 : >>> from coloraide import NaN >>> Color ( \"srgb\" , [ 1 , NaN , 1 ]) color(srgb 1 0 1 / 1) At any time, a channel can be checked for whether it is NaN by using the is_nan method: >>> Color ( \"white\" ) . convert ( 'hsl' ) . is_nan ( 'hue' ) True It can be useful to check whether a channel is NaN as NaN values can't be added, subtracted, multiplied, etc. They will always return NaN unless you directly replace them. >>> color = Color ( \"white\" ) . convert ( 'hsl' ) >>> color . hue = color . hue + 3 >>> color . is_nan ( 'hue' ) True >>> color . hue = 3 >>> color . is_nan ( 'hue' ) False","title":"Null Handling"},{"location":"manipulation/","text":"Manipulating Colors Reading Coordinates There are various ways to read the current values of color coordinates. Channel properties can be read directly: >>> color = Color ( \"orange\" ) >>> color . red 1.0 Channel values can also be read by using the get method and providing the name of desired channel. >>> color = Color ( \"orange\" ) >>> color . get ( \"green\" ) 0.6470588235294118 All non-alpha coordinates can be read simultaneously by using the coords function. >>> color = Color ( \"orange\" ) >>> color . coords () [1.0, 0.6470588235294118, 0.0] >>> color . alpha 1.0 If a color coordinate is needed from another color space, it can be accessed by passing in the color space followed by the name of the desired coordinate. The necessary conversions will happen behind the scenes and the desired value will be returned. >>> Color ( \"blue\" ) . get ( \"lch.chroma\" ) 131.2175355784631 Modifying Coordinates Channel properties can be modified directly by using the named property. Here we modify red by adjusting its green property: >>> color = Color ( \"red\" ) >>> color . green = 0.5 >>> color . to_string () rgb(255 127.5 0) When doing so, keep in mind, the internal coordinates are being adjusted, and so they must be modified within the range in which the values are stored, and for sRGB, it is in the range of [0, 1]. If desired, the values can be modified with the set method. As these methods return a reference to the class, multiple set operations can be chained together. Chaining the operations together, we can transform white to rgb ( 0 127 . 5 255 ) . >>> Color ( \"white\" ) . set ( \"red\" , 0 ) . set ( \"green\" , 0.5 ) color(srgb 0 0.5 1 / 1) Channels in other color spaces can also be modified with the set function. Here we alter the color blue in the LCH color space and get rgb ( 19 . 409 81 . 163 0 ) . >>> Color ( \"blue\" ) . set ( 'lch.hue' , 130 ) color(srgb -0.25063 0.35695 -0.24773 / 1) Functions can also be used to modify a channel property. Here we do a relative adjustment of the green channel and transform the color pink to rgb ( 255 249 . 6 203 ) . >>> Color ( \"pink\" ) . set ( 'green' , lambda g : g * 1.3 ) color(srgb 1 0.97882 0.79608 / 1) Checking Null Hues Cylindrical colors that offer a hue property can sometimes return NaN for a hue. This is usually because the hue is undefined. For example, the color hsl ( 360 0 % 100 % ) , while assigned a hue, does not actually exhibit any real hue since saturation is 0. Essentially, hue could be set to anything, and it would still have no affect on the actual color. So, ColorAide will actually set hue to NaN (or \"not a number\"). NaN is treated as a zero on output. >>> color = Color ( 'hsl(360 0 % 100% )' ) >>> color color(hsl 0 0 100 / 1) >>> color . coords () [nan, 0.0, 100.0] Because NaN are not numbers, these values will not be included in color interpolation, and these values cannot be added, multiplied, or take part in any real math operations. All math operations performed on NaN simply return NaN . For this reason, it is useful to check if a hue is NaN . This can be done with the is_nan function. You can simply give is_nan the property you wish to check, and it will return either True or False . >>> Color ( 'hsl(360 0 % 100% )' ) . is_nan ( 'hue' ) True This is equivalent to using the math library and comparing the value directly: >>> import math >>> math . isnan ( Color ( 'hsl(360 0 % 100% )' ) . hue ) True","title":"Manipulating Colors"},{"location":"manipulation/#manipulating-colors","text":"","title":"Manipulating Colors"},{"location":"manipulation/#reading-coordinates","text":"There are various ways to read the current values of color coordinates. Channel properties can be read directly: >>> color = Color ( \"orange\" ) >>> color . red 1.0 Channel values can also be read by using the get method and providing the name of desired channel. >>> color = Color ( \"orange\" ) >>> color . get ( \"green\" ) 0.6470588235294118 All non-alpha coordinates can be read simultaneously by using the coords function. >>> color = Color ( \"orange\" ) >>> color . coords () [1.0, 0.6470588235294118, 0.0] >>> color . alpha 1.0 If a color coordinate is needed from another color space, it can be accessed by passing in the color space followed by the name of the desired coordinate. The necessary conversions will happen behind the scenes and the desired value will be returned. >>> Color ( \"blue\" ) . get ( \"lch.chroma\" ) 131.2175355784631","title":"Reading Coordinates"},{"location":"manipulation/#modifying-coordinates","text":"Channel properties can be modified directly by using the named property. Here we modify red by adjusting its green property: >>> color = Color ( \"red\" ) >>> color . green = 0.5 >>> color . to_string () rgb(255 127.5 0) When doing so, keep in mind, the internal coordinates are being adjusted, and so they must be modified within the range in which the values are stored, and for sRGB, it is in the range of [0, 1]. If desired, the values can be modified with the set method. As these methods return a reference to the class, multiple set operations can be chained together. Chaining the operations together, we can transform white to rgb ( 0 127 . 5 255 ) . >>> Color ( \"white\" ) . set ( \"red\" , 0 ) . set ( \"green\" , 0.5 ) color(srgb 0 0.5 1 / 1) Channels in other color spaces can also be modified with the set function. Here we alter the color blue in the LCH color space and get rgb ( 19 . 409 81 . 163 0 ) . >>> Color ( \"blue\" ) . set ( 'lch.hue' , 130 ) color(srgb -0.25063 0.35695 -0.24773 / 1) Functions can also be used to modify a channel property. Here we do a relative adjustment of the green channel and transform the color pink to rgb ( 255 249 . 6 203 ) . >>> Color ( \"pink\" ) . set ( 'green' , lambda g : g * 1.3 ) color(srgb 1 0.97882 0.79608 / 1)","title":"Modifying Coordinates"},{"location":"manipulation/#checking-null-hues","text":"Cylindrical colors that offer a hue property can sometimes return NaN for a hue. This is usually because the hue is undefined. For example, the color hsl ( 360 0 % 100 % ) , while assigned a hue, does not actually exhibit any real hue since saturation is 0. Essentially, hue could be set to anything, and it would still have no affect on the actual color. So, ColorAide will actually set hue to NaN (or \"not a number\"). NaN is treated as a zero on output. >>> color = Color ( 'hsl(360 0 % 100% )' ) >>> color color(hsl 0 0 100 / 1) >>> color . coords () [nan, 0.0, 100.0] Because NaN are not numbers, these values will not be included in color interpolation, and these values cannot be added, multiplied, or take part in any real math operations. All math operations performed on NaN simply return NaN . For this reason, it is useful to check if a hue is NaN . This can be done with the is_nan function. You can simply give is_nan the property you wish to check, and it will return either True or False . >>> Color ( 'hsl(360 0 % 100% )' ) . is_nan ( 'hue' ) True This is equivalent to using the math library and comparing the value directly: >>> import math >>> math . isnan ( Color ( 'hsl(360 0 % 100% )' ) . hue ) True","title":"Checking Null Hues"},{"location":"strings/","text":"Convert to Strings Colors can be translated to strings by using the to_string method. The color class will convert the current color into one of many of the color's CSS formats. >>> Color ( \"srgb\" , [ 0.5 , 0 , 1 ], 0.3 ) . to_string () rgb(127.5 0 255 / 0.3) All color spaces support the following parameters: alpha : set to None by default, alpha will only be shown if less than 100%, but if set to True , alpha will always be shown. Setting to False will cause alpha to be ignored in the output. precision : precision controls the precision of the output values. The name is a little misleading as it will actually adjust the precision and scale of the values. The default is 5. In some cases, like sRGB hex output, precision may not really come into play as hex values are rounded to the nearest whole number anyways. >>> Color ( \"rgb(30.3456 % 75% 100%)\" ) . to_string ( precision = 5 , percent = True ) rgb(30.346% 75% 100%) >>> Color ( \"rgb(30.3456 % 75% 100%)\" ) . to_string ( precision = 4 , percent = True ) rgb(30.35% 75% 100%) >>> Color ( \"rgb(30.3456 % 75% 100%)\" ) . to_string ( precision = 3 , percent = True ) rgb(30.3% 75% 100%) >>> Color ( \"rgb(30.3456 % 75% 100%)\" ) . to_string ( precision = 2 , percent = True ) rgb(30% 75% 100%) >>> Color ( \"rgb(30.3456 % 75% 100%)\" ) . to_string ( precision = 1 , percent = True ) rgb(30% 80% 100%) Providing a precision of 0 will simply enable simple rounding to the nearest whole number. >>> Color ( \"rgb(30.3456 % 75% 100%)\" ) . to_string ( precision = 0 , percent = True ) rgb(30% 75% 100%) Providing a precision of -1 is a special input that will give the highest precision that can be given. Not particularly helpful except to look at the raw decimal number. >>> Color ( \"rgb(30.3456 % 75% 100%)\" ) . to_string ( precision =- 1 , percent = True ) rgb(30.345600000000001017497197608463466167449951171875% 75% 100%) One note though, format of the value matters. Here we output in the range of 0 - 255. We can see that a precision of 1 , in this case, can throw the color out of gamut. So remember to use a sufficient precision for what you are doing and the values you are working in. >>> Color ( \"rgb(30.3456 % 75% 100%)\" ) . to_string ( precision = 1 ) rgb(80 200 300) fit : set to True by default, fit controls whether colors are fit to their gamut or not. Some color spaces are technically unbounded, so no fitting may occur in those color spaces. Additionally, some color formats, like sRGB hex, are always fitted (regardless of the this setting) as they must fit into the gamut or they cannot be translated. >>> Color ( \"rgb(30 % 105% 0%)\" ) . to_string (), ('rgb(138.01 255 98.193)',) >>> Color ( \"rgb(30 % 105% 0%)\" ) . to_string ( fit = False ) rgb(76.5 267.75 0) color : For some color spaces, this is the default output, but for others this format can be explicitly requested by setting color to True . If set to True , this will usually take priority over other format options. >>> Color ( \"rebeccapurple\" ) . to_string ( color = True ) color(srgb 0.4 0.2 0.6) In general, a color in a given color space may share the same options as listed above, but a given color space may also have options unique to itself. sRGB Specific sRGB can output colors to a hex format which is unique compared to HSL and others. Simply enable hex . >>> Color ( \"rebeccapurple\" ) . to_string ( hex = True ) #663399 When converting to hex color format, a color can be compressed in certain cases, enabling compress will compress a hex color if possible. >>> Color ( \"#11223388\" ) . to_string ( hex = True ) #11223388 >>> Color ( \"#11223388\" ) . to_string ( hex = True , compress = True ) #1238 sRGB can also output color names. If a color evaluates to a hex code which also evaluates to a color name in the internal CSS color name mapping, then a color name will be returned. If the color does not match a color name, it will fallback to whatever the other options dictate. Simply enable names . >>> Color ( \"#663399\" ) . to_string ( names = True ) rebeccapurple Comma Format In CSS, there are a number of color spaces that allow a comma format. Those are srgb , hsl , hwb , lch , and lab . Basically, the only formats that do not allow comma format at this time are the colors that only support the color() format. If we want commas, we can force the comma syntax by setting comma to True . This can alter some color space output in other subtle ways. As the comma format is the old legacy approach, when sRGB has commas enabled, it will use rgba instead of the rgb . If using the default space syntax, rgb is always used, even when the color has transparency. >>> Color ( \"rgb(30 75 100 / 20%)\" ) . to_string ( comma = True ) rgba(30, 75, 100, 0.2)","title":"String Output"},{"location":"strings/#convert-to-strings","text":"Colors can be translated to strings by using the to_string method. The color class will convert the current color into one of many of the color's CSS formats. >>> Color ( \"srgb\" , [ 0.5 , 0 , 1 ], 0.3 ) . to_string () rgb(127.5 0 255 / 0.3) All color spaces support the following parameters: alpha : set to None by default, alpha will only be shown if less than 100%, but if set to True , alpha will always be shown. Setting to False will cause alpha to be ignored in the output. precision : precision controls the precision of the output values. The name is a little misleading as it will actually adjust the precision and scale of the values. The default is 5. In some cases, like sRGB hex output, precision may not really come into play as hex values are rounded to the nearest whole number anyways. >>> Color ( \"rgb(30.3456 % 75% 100%)\" ) . to_string ( precision = 5 , percent = True ) rgb(30.346% 75% 100%) >>> Color ( \"rgb(30.3456 % 75% 100%)\" ) . to_string ( precision = 4 , percent = True ) rgb(30.35% 75% 100%) >>> Color ( \"rgb(30.3456 % 75% 100%)\" ) . to_string ( precision = 3 , percent = True ) rgb(30.3% 75% 100%) >>> Color ( \"rgb(30.3456 % 75% 100%)\" ) . to_string ( precision = 2 , percent = True ) rgb(30% 75% 100%) >>> Color ( \"rgb(30.3456 % 75% 100%)\" ) . to_string ( precision = 1 , percent = True ) rgb(30% 80% 100%) Providing a precision of 0 will simply enable simple rounding to the nearest whole number. >>> Color ( \"rgb(30.3456 % 75% 100%)\" ) . to_string ( precision = 0 , percent = True ) rgb(30% 75% 100%) Providing a precision of -1 is a special input that will give the highest precision that can be given. Not particularly helpful except to look at the raw decimal number. >>> Color ( \"rgb(30.3456 % 75% 100%)\" ) . to_string ( precision =- 1 , percent = True ) rgb(30.345600000000001017497197608463466167449951171875% 75% 100%) One note though, format of the value matters. Here we output in the range of 0 - 255. We can see that a precision of 1 , in this case, can throw the color out of gamut. So remember to use a sufficient precision for what you are doing and the values you are working in. >>> Color ( \"rgb(30.3456 % 75% 100%)\" ) . to_string ( precision = 1 ) rgb(80 200 300) fit : set to True by default, fit controls whether colors are fit to their gamut or not. Some color spaces are technically unbounded, so no fitting may occur in those color spaces. Additionally, some color formats, like sRGB hex, are always fitted (regardless of the this setting) as they must fit into the gamut or they cannot be translated. >>> Color ( \"rgb(30 % 105% 0%)\" ) . to_string (), ('rgb(138.01 255 98.193)',) >>> Color ( \"rgb(30 % 105% 0%)\" ) . to_string ( fit = False ) rgb(76.5 267.75 0) color : For some color spaces, this is the default output, but for others this format can be explicitly requested by setting color to True . If set to True , this will usually take priority over other format options. >>> Color ( \"rebeccapurple\" ) . to_string ( color = True ) color(srgb 0.4 0.2 0.6) In general, a color in a given color space may share the same options as listed above, but a given color space may also have options unique to itself.","title":"Convert to Strings"},{"location":"strings/#srgb-specific","text":"sRGB can output colors to a hex format which is unique compared to HSL and others. Simply enable hex . >>> Color ( \"rebeccapurple\" ) . to_string ( hex = True ) #663399 When converting to hex color format, a color can be compressed in certain cases, enabling compress will compress a hex color if possible. >>> Color ( \"#11223388\" ) . to_string ( hex = True ) #11223388 >>> Color ( \"#11223388\" ) . to_string ( hex = True , compress = True ) #1238 sRGB can also output color names. If a color evaluates to a hex code which also evaluates to a color name in the internal CSS color name mapping, then a color name will be returned. If the color does not match a color name, it will fallback to whatever the other options dictate. Simply enable names . >>> Color ( \"#663399\" ) . to_string ( names = True ) rebeccapurple","title":"sRGB Specific"},{"location":"strings/#comma-format","text":"In CSS, there are a number of color spaces that allow a comma format. Those are srgb , hsl , hwb , lch , and lab . Basically, the only formats that do not allow comma format at this time are the colors that only support the color() format. If we want commas, we can force the comma syntax by setting comma to True . This can alter some color space output in other subtle ways. As the comma format is the old legacy approach, when sRGB has commas enabled, it will use rgba instead of the rgb . If using the default space syntax, rgb is always used, even when the color has transparency. >>> Color ( \"rgb(30 75 100 / 20%)\" ) . to_string ( comma = True ) rgba(30, 75, 100, 0.2)","title":"Comma Format"},{"location":"about/changelog/","text":"Changelog 0.1.0a11 FIX : Ensure that when hex , compress , and names is enabled in to_string for srgb that colors will still match the color name if the color can be compressed. 0.1.0a10 FIX : Address two divide by zero cases in HSL algorithm. Was missing some special cases when luminance equals 1 or 0 . 0.1.0a9 FIX : Ensure all cases of hue handling, in regards to gamut mapping, are done the same. 0.1.0a8 NEW : Remove workaround to force cylindrical colors to overlay in non-cylindrical spaces. Allow colors to be overlaid in any color space. Original issues related to allowing cylindrical spaces as been fixed. Overlaying in cylindrical spaces may not make sense, but it is no longer prohibited. FIX : Ensure color comparison will yield true if two channels have NaN . 0.1.0a7 FIX : Fix issue with translation of an input that is compressed hex with a specified alpha. 0.1.0a6 FIX : Don't return detached color spaces from steps . Ensure they are wrapped with a Color object on return. 0.1.0a5 FIX : Fix an issue where update can fail due to a color space detached from a parent. FIX : Adjust fit tolerance to be a little more forgiving, but make an adjustment for in_gmaut in relation to HSL as saturation can be wildly out of range for an sRGB color that is only slightly out of gamut. FIX : Ensure in_gamut handles NaN properly. 0.1.0a4 NEW : Use NaN to track undefined hues. NEW : Remove is_hue_null and add new API function is_nan to test if any channel is currently set to NaN . NEW : Remove get_default from the Color class and instead allow properties that can be overridden when subclassing the Color object. 0.1.0a3 FIX : Color object API was missing the ability to receive the premultiplied argument. 0.1.0a2 NEW : Expose access to srgb-linear color space. This is mainly for development and testing and not listed in docs currently. FIX : Cylindrical spaces, when calling overlay can now request to be overlaid in a different space. This is because alpha composition does not work well in cylindrical spaces. HSL, HSV, and HWB will now request overlay to be done in sRGB, and LCH will request overlay to be done in LAB. FIX : Add support for premultiplied alpha when interpolating via premultiplied option. 0.1.0a1 NEW : Initial alpha release. Library is experimental and API is unstable.","title":"Changelog"},{"location":"about/changelog/#changelog","text":"","title":"Changelog"},{"location":"about/changelog/#010a11","text":"FIX : Ensure that when hex , compress , and names is enabled in to_string for srgb that colors will still match the color name if the color can be compressed.","title":"0.1.0a11"},{"location":"about/changelog/#010a10","text":"FIX : Address two divide by zero cases in HSL algorithm. Was missing some special cases when luminance equals 1 or 0 .","title":"0.1.0a10"},{"location":"about/changelog/#010a9","text":"FIX : Ensure all cases of hue handling, in regards to gamut mapping, are done the same.","title":"0.1.0a9"},{"location":"about/changelog/#010a8","text":"NEW : Remove workaround to force cylindrical colors to overlay in non-cylindrical spaces. Allow colors to be overlaid in any color space. Original issues related to allowing cylindrical spaces as been fixed. Overlaying in cylindrical spaces may not make sense, but it is no longer prohibited. FIX : Ensure color comparison will yield true if two channels have NaN .","title":"0.1.0a8"},{"location":"about/changelog/#010a7","text":"FIX : Fix issue with translation of an input that is compressed hex with a specified alpha.","title":"0.1.0a7"},{"location":"about/changelog/#010a6","text":"FIX : Don't return detached color spaces from steps . Ensure they are wrapped with a Color object on return.","title":"0.1.0a6"},{"location":"about/changelog/#010a5","text":"FIX : Fix an issue where update can fail due to a color space detached from a parent. FIX : Adjust fit tolerance to be a little more forgiving, but make an adjustment for in_gmaut in relation to HSL as saturation can be wildly out of range for an sRGB color that is only slightly out of gamut. FIX : Ensure in_gamut handles NaN properly.","title":"0.1.0a5"},{"location":"about/changelog/#010a4","text":"NEW : Use NaN to track undefined hues. NEW : Remove is_hue_null and add new API function is_nan to test if any channel is currently set to NaN . NEW : Remove get_default from the Color class and instead allow properties that can be overridden when subclassing the Color object.","title":"0.1.0a4"},{"location":"about/changelog/#010a3","text":"FIX : Color object API was missing the ability to receive the premultiplied argument.","title":"0.1.0a3"},{"location":"about/changelog/#010a2","text":"NEW : Expose access to srgb-linear color space. This is mainly for development and testing and not listed in docs currently. FIX : Cylindrical spaces, when calling overlay can now request to be overlaid in a different space. This is because alpha composition does not work well in cylindrical spaces. HSL, HSV, and HWB will now request overlay to be done in sRGB, and LCH will request overlay to be done in LAB. FIX : Add support for premultiplied alpha when interpolating via premultiplied option.","title":"0.1.0a2"},{"location":"about/changelog/#010a1","text":"NEW : Initial alpha release. Library is experimental and API is unstable.","title":"0.1.0a1"},{"location":"about/contributing/","text":"Contributing & Support Become a Sponsor Open source projects take time and money. Help support the project by becoming a sponsor. You can add your support at any tier you feel comfortable with. No amount is too little. We also accept one time contributions via PayPal. GitHub Sponsors PayPal Bug Reports Please read the documentation and search the issue tracker to try and find the answer to your question before posting an issue. When creating an issue on the repository, please provide as much info as possible: Version being used. Operating system. Version of Python. Errors in console. Detailed description of the problem. Examples for reproducing the error. You can post pictures, but if specific text or code is required to reproduce the issue, please provide the text in a plain text format for easy copy/paste. The more info provided, the greater the chance someone will take the time to answer, implement, or fix the issue. Be prepared to answer questions and provide additional information if required. Issues in which the creator refuses to respond to follow up questions will be marked as stale and closed. Reviewing Code Take part in reviewing pull requests and/or reviewing direct commits. Make suggestions to improve the code and discuss solutions to overcome weakness in the algorithm. Answer Questions in Issues Take time and answer questions and offer suggestions to people who've created issues in the issue tracker. Often people will have questions that you might have an answer for. Or maybe you know how to help them accomplish a specific task they are asking about. Feel free to share your experience to help others out. Pull Requests Pull requests are welcome, and a great way to help fix bugs and add new features. Documentation Improvements A ton of time has been spent not only creating and supporting this tool and related extensions, but also spent making this documentation. If you feel it is still lacking, show your appreciation for the tool and/or extensions by helping to improve the documentation.","title":"Contributing &amp; Support"},{"location":"about/contributing/#contributing--support","text":"","title":"Contributing &amp; Support"},{"location":"about/contributing/#become-a-sponsor","text":"Open source projects take time and money. Help support the project by becoming a sponsor. You can add your support at any tier you feel comfortable with. No amount is too little. We also accept one time contributions via PayPal. GitHub Sponsors PayPal","title":"Become a Sponsor "},{"location":"about/contributing/#bug-reports","text":"Please read the documentation and search the issue tracker to try and find the answer to your question before posting an issue. When creating an issue on the repository, please provide as much info as possible: Version being used. Operating system. Version of Python. Errors in console. Detailed description of the problem. Examples for reproducing the error. You can post pictures, but if specific text or code is required to reproduce the issue, please provide the text in a plain text format for easy copy/paste. The more info provided, the greater the chance someone will take the time to answer, implement, or fix the issue. Be prepared to answer questions and provide additional information if required. Issues in which the creator refuses to respond to follow up questions will be marked as stale and closed.","title":"Bug Reports"},{"location":"about/contributing/#reviewing-code","text":"Take part in reviewing pull requests and/or reviewing direct commits. Make suggestions to improve the code and discuss solutions to overcome weakness in the algorithm.","title":"Reviewing Code"},{"location":"about/contributing/#answer-questions-in-issues","text":"Take time and answer questions and offer suggestions to people who've created issues in the issue tracker. Often people will have questions that you might have an answer for. Or maybe you know how to help them accomplish a specific task they are asking about. Feel free to share your experience to help others out.","title":"Answer Questions in Issues"},{"location":"about/contributing/#pull-requests","text":"Pull requests are welcome, and a great way to help fix bugs and add new features.","title":"Pull Requests"},{"location":"about/contributing/#documentation-improvements","text":"A ton of time has been spent not only creating and supporting this tool and related extensions, but also spent making this documentation. If you feel it is still lacking, show your appreciation for the tool and/or extensions by helping to improve the documentation.","title":"Documentation Improvements"},{"location":"about/license/","text":"License ColorAide The MIT License (MIT) Copyright \u00a9 2020 - 2021 Isaac Muse Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"about/license/#license","text":"","title":"License"},{"location":"about/license/#coloraide","text":"The MIT License (MIT) Copyright \u00a9 2020 - 2021 Isaac Muse Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"ColorAide"},{"location":"api/","text":"Color API Color class Color : def __init__ ( self , color , data = None , alpha = util . DEF_ALPHA , * , filters = None , ** kwargs ): The Color class object is a wrapper around the internal color space objects. It provides an API interface to allow users to specify and manipulate colors. Parameters Parameters Defaults Description color A color string, or other Color class object. If given data , a string must be used and should represent the color space to use. data None data accepts a list of numbers representing the coordinates of the color. If provided, color must be a string specifying the color space. alpha 1 alpha accepts a number specifying the alpha channel. Must be used in conjunction with data or it will be ignored. filters None filters accepts a list of color spaces to allow. When None is provided (the default) all supported color spaces are accepted. match @classmethod def match ( cls , string , start = 0 , fullmatch = False , * , filters = None ): The match class method provides access to the color matching interface and allows a user to provide a color string and get back a ColorMatch object. ColorMatch objects contain three properties: color : the Color object. start : the starting point within the string buffer where the color was found. end : the ending point within the string buffer where the color was found. Match does not search the entire buffer, but simply matches at the location specified by start . Return Returns a ColorMatch object. Parameters Parameters Defaults Description string A string representing the color. start 0 Accepts a integer offset into the provided string buffer to start the match. fullmatch False A boolean which defines whether match must match to the end of the string buffer. filters None filters accepts a list of color spaces to allow. When None is provided (the default) all supported color spaces are accepted. new @classmethod def new ( cls , color , data = None , alpha = util . DEF_ALPHA , * , filters = None , ** kwargs ): The new class method exposes the interface of creating new color objects. Using new is the same as using Color() . Return Returns a Color object. Parameters Parameters Defaults Description color A color string, or other Color class object. If given data , a string must be used and should represent the color space to use. data None data accepts a list of numbers representing the coordinates of the color. If provided, color must be a string specifying the color space. alpha 1 alpha accepts a number specifying the alpha channel. Must be used in conjunction with data or it will be ignored. filters None filters accepts a list of color spaces to allow. When None is provided (the default) all supported color spaces are accepted. clone def clone ( self ): The clone method provides a way to create a duplicate of the current Color instance. Return Returns a Color object. update def update ( self , color , data = None , alpha = util . DEF_ALPHA , * , filters = None , ** kwargs ): The update method provides a way to update the underlying color spaces with coordinates from any color space. The methods signature looks just like new and accepts color strings, Color objects, or raw data points specified with a color space string and coordinates. The object itself will be updated and remain in its current color space. Return Returns a reference to the current Color object. Parameters Parameters Defaults Description color A color string, or other Color class object. If given data , a string must be used and should represent the color space to use. data None data accepts a list of numbers representing the coordinates of the color. If provided, color must be a string specifying the color space. alpha 1 alpha accepts a number specifying the alpha channel. Must be used in conjunction with data or it will be ignored. filters None filters accepts a list of color spaces to allow. When None is provided (the default) all supported color spaces are accepted. mutate def mutate ( self , color , data = None , alpha = util . DEF_ALPHA , * , filters = None , ** kwargs ): The mutate method is just like update except that it will not only update the color space, but mutate it to the provided color space. Return Returns a reference to the current Color object. Parameters Parameters Defaults Description color A color string, or other Color class object. If given data , a string must be used and should represent the color space to use. data None data accepts a list of numbers representing the coordinates of the color. If provided, color must be a string specifying the color space. alpha 1 alpha accepts a number specifying the alpha channel. Must be used in conjunction with data or it will be ignored. filters None filters accepts a list of color spaces to allow. When None is provided (the default) all supported color spaces are accepted. space def space ( self ): Retrieves the current color space of the color. Return Returns a string with the name of the current color space. coords def coords ( self ): Returns a list of the color's coordinates. This does not include the alpha channel. Alpha can be accessed via the alpha property or get and set accessors. Return Returns a list of numbers indicating the current coordinate values. to_string def to_string ( self , ** kwargs ): Method that converts the current color to an output format supported by the color space. While a number of the parameters are common, some may be specific to the color space. The usage guide covers color space specific options in more details. Return Returns a string representation of the current color. Parameters Common parameters: Parameters Defaults Description alpha None Boolean or None value which determines whether the output includes alpha . If None (the default) alpha will only be shown if less than 1. If True , alpha will always be shown. If False , alpha will be omitted. precision 5 Integer value that sets precision and scale. Precision and scale will match the value if greater than zero. If 0 , values will be rounded to the nearest integer. If -1 , number will be output at the highest precision. fit True A boolean that controls whether gamut mapping is performed on string creation. By default, colors will be fit to their own color space. This can be disabled by setting to False . color False A boolean that will determine if the color(space coord+ / alpha) format is used for string output. Has highest precedence. sRGB specific parameters: Parameters Defaults Description hex . False String output will be in #RRGGBBAA format. names False Boolean indicating a preference for CSS color names. When translating a color to it's closest hex form, if that hex value matches a CSS color name, that color name will be returned as the output. hex does not have to be True for this to apply. compress False If hex is True and compress is True , hex values will be compressed if possible: #RRGGBBAA \u2192 #RGBA . Space dependent parameters: Parameters Defaults Description comma False If supported by the color space and the current output format, commas will be used instead of space format: rgba(0, 0, 0, 1) \u2192 rgb(0 0 0 /1) . convert def convert ( self , space , * , fit = False , in_place = False ): Converts a Color object from one color space to another. If the current color space matches the specified color space, the object will be cloned. Return Returns a reference to the converted Color object. If in_place is True , the return will be a reference to the current Color object. Parameters Parameters Defaults Description space A string representing the desired final color space. fit False Boolean specifying whether the current color should be gamut mapped into the final, desired color space. in_place False Boolean specifying whether the convert should alter the current Color object or return a new one. luminance def luminance ( self ): Get the relative luminance. Relative luminance is obtained from the Y coordinate in the XYZ color space. Return Returns an float indicating the relative luminance. contrast def contrast ( self , color ): Get the contrast ratio based on the relative luminance between two colors. Return Returns a float indicating the contrast ratio between two colors. Parameters Parameters Defaults Description color A color string or Color object representing a color. distance def distance ( self , color , * , space = util . DEF_DISTANCE_SPACE ): Performs a euclidean distance algorithm on two colors. Return Returns a float indicating euclidean distance between the two colors. Parameters Parameters Defaults Description color A color string or Color object representing a color. space \"lab\" Color space to perform distancing algorithm in. delta_e def delta_e ( self , color , * , method = None , ** kwargs ): Performs a delta E distance algorithm on two colors. Default algorithm that is used is Delta E 1976 ( 76 ). Some methods have additional weighting that can be configured through method specific options which are represented by **kwargs . Available methods: Name Input CIE76 76 CIE94 94 CIEDE2000 2000 CMC l:c (1984) cmc Return Returns a float indicating the delta E distance between the two colors. Parameters Parameters Defaults Description color A color string or Color object representing a color. method None String that specifies the method to use. If None , the default will be used. interpolate def interpolate ( self , color , * , space = \"lab\" , progress = None , out_space = None , adjust = None , hue = util . DEF_HUE_ADJ , premultiplied = False ): The interpolate method creates a function that takes a value between 0 - 1 and interpolates a new color based on the input value. Interpolation can be customized by limiting the interpolation to specific color channels, providing custom interpolation functions, and even adjusting the hue logic used. Hue Evaluation Description shorter Angles are adjusted so that \u03b8\u2082 - \u03b8\u2081 \u2208 [-180, 180]. longer Angles are adjusted so that \u03b8\u2082 - \u03b8\u2081 \u2208 {0, [180, 360)}. increasing Angles are adjusted so that \u03b8\u2082 - \u03b8\u2081 \u2208 [0, 360). decreasing Angles are adjusted so that \u03b8\u2082 - \u03b8\u2081 \u2208 (-360, 0] specified No fixup is performed. Angles are interpolated in the same way as every other component. Parameters Parameters Defaults Description color A color string or Color object representing a color. space \"lab\" Color space to interpolate in. progress None An optional function that that allows for custom logic to perform non-linear interpolation. out_space None Color space that the new color should be in. If None , the color will be in the same color space as the base color. adjust None A list of channel names that should be interpolated. If None , all channels will be interpolated. hue \"shorter\" Define how color spaces which have hue angles are interpolated. Default evaluates between the shortest angle. premultiplied False Use premultiplied alpha when interpolating. steps def steps ( self , color , * , steps = 2 , max_steps = 1000 , max_delta_e = 0 , ** interpolate_args ): Creates an interpolate function and iterates through it with user defined step parameters to produce discrete color steps. Will attempt to provide the minimum number of steps without exceeding max_steps . If max_delta_e is provided, the distance between each stop will be cut in half until there are no colors with a distance greater than the specified max_delta_e . Return List of Color objects. Parameters Parameters Defaults Description color A color string or Color object representing a color. steps 2 Minimum number of steps. max_steps 1000 Maximum number of steps. max_delta_e 0 Maximum delta E distance between the color stops. A value of 0 or less will be ignored. Note All other keyword arguments defined in **interpolate_args will be passed to the interpolate method. mix def mix ( self , color , percent = util . DEF_MIX , * , space = None , in_place = False , ** interpolate_args ): Interpolates between two colors returning a color that represents the mixing of the base color and the provided color mixed at the provided percent , where percent applies to how much the provided color contributes to the the final result. Return Returns a reference to the new Color object or a reference to the current Color if in_place is True . Parameters Parameters Defaults Description color A color string or Color object representing a color. percent 0.5 A numerical value between 0 - 1 representing the percentage at which the parameter color will be mixed. space None A string specifying the color space in which the \"mixing\"/interpolation is done. If None , the base color's color space will be used. in_place False Boolean used to determine if the the current color should be modified \"in place\" or a new Color object should be returned. fit def fit ( self , space = None , * , method = None , in_place = False ): Fits color to the current or specified color gamut. By default, lch-chroma gamut mapping is used. This is essentially an approach that holds lightness and hue constant in the LCH color space while reducing chroma until the color is in gamut. Clipping is done at each step of the way and the color distance measured to see how close our color is to the intended color. The supported gamut mapping methods are: Name Input LCH Chroma lch-chroma Clipping clip Return Returns a reference to the new Color object or a reference to the current Color if in_place is True . Parameters Parameters Defaults Description space None The color space that the color must be mapped to. If space is None , then the current color space will be used. method None String that specifies which gamut mapping method to use. If None , lch-chroma will be used. in_gamut def in_gamut ( self , space = None , * , tolerance = util . DEF_FIT_TOLERANCE ): Checks if the current color is in the current or specified gamut. Parameters Parameters Defaults Description space None The color space that the color must be fit within. If space is None , then the current color space will be used. tolerance 0.000075 Tolerance allowed when checking bounds of color. get def get ( self , name ): Retrieves the coordinate value from the specified channel. Channel must be a channel name in the current color space or a channel name in the specified color space using the syntax: space.channel . Return Returns a numerical value that is stored internally for the specified channel, or a calculated value in the case that a channel in a different color space is requested. Parameters Parameters Defaults Description name Channel name or color space and channel name to retrieve value from. set def set ( self , name , value ): # noqa: A003 Sets the given value to the specified channel. If the name is provided in the form space.channel , the value will be applied to the channel of the specified color space while keeping current color space the same. The value can be a numerical value, a CSS string compatible with the specified color space, or a function that accepts a numerical channel value and returns a numerical channel value. This function returns the current colors reference so that multiple sets can be chained together. Return Returns a reference to the current Color object. Parameters Parameters Defaults Description name Channel name or color space and channel name to retrieve value from. value A numerical value, a string value accepted by the specified color space, or a function. is_nan def is_nan ( self , name ): Retrieves the coordinate value from the specified channel and checks whether the value is NaN . Channel must be a channel name in the current color space or a channel name in the specified color space using the syntax: space.channel . Return Returns a boolean indicating whether the specified color space's channel is NaN . Parameters Parameters Defaults Description name A string indicating what channel property to check. Dynamic Channel Properties Depending on the given color space, channel properties will be available on the color object as well. These are dynamically available depending on what the current color space is. For instance, if the color space is sRGB, the channels red , green , blue , and alpha will all be available. These properties are read and writable. When read, they will return the numerical value stored in the specified channel. When written, they can accept a numerical value or a string value using CSS syntax acceptable for that channel in that color space. For more complex setting operations, or to chain multiple set operations, please use get .","title":"Color API"},{"location":"api/#color-api","text":"","title":"Color API"},{"location":"api/#color","text":"class Color : def __init__ ( self , color , data = None , alpha = util . DEF_ALPHA , * , filters = None , ** kwargs ): The Color class object is a wrapper around the internal color space objects. It provides an API interface to allow users to specify and manipulate colors. Parameters Parameters Defaults Description color A color string, or other Color class object. If given data , a string must be used and should represent the color space to use. data None data accepts a list of numbers representing the coordinates of the color. If provided, color must be a string specifying the color space. alpha 1 alpha accepts a number specifying the alpha channel. Must be used in conjunction with data or it will be ignored. filters None filters accepts a list of color spaces to allow. When None is provided (the default) all supported color spaces are accepted.","title":"Color"},{"location":"api/#match","text":"@classmethod def match ( cls , string , start = 0 , fullmatch = False , * , filters = None ): The match class method provides access to the color matching interface and allows a user to provide a color string and get back a ColorMatch object. ColorMatch objects contain three properties: color : the Color object. start : the starting point within the string buffer where the color was found. end : the ending point within the string buffer where the color was found. Match does not search the entire buffer, but simply matches at the location specified by start . Return Returns a ColorMatch object. Parameters Parameters Defaults Description string A string representing the color. start 0 Accepts a integer offset into the provided string buffer to start the match. fullmatch False A boolean which defines whether match must match to the end of the string buffer. filters None filters accepts a list of color spaces to allow. When None is provided (the default) all supported color spaces are accepted.","title":"match"},{"location":"api/#new","text":"@classmethod def new ( cls , color , data = None , alpha = util . DEF_ALPHA , * , filters = None , ** kwargs ): The new class method exposes the interface of creating new color objects. Using new is the same as using Color() . Return Returns a Color object. Parameters Parameters Defaults Description color A color string, or other Color class object. If given data , a string must be used and should represent the color space to use. data None data accepts a list of numbers representing the coordinates of the color. If provided, color must be a string specifying the color space. alpha 1 alpha accepts a number specifying the alpha channel. Must be used in conjunction with data or it will be ignored. filters None filters accepts a list of color spaces to allow. When None is provided (the default) all supported color spaces are accepted.","title":"new"},{"location":"api/#clone","text":"def clone ( self ): The clone method provides a way to create a duplicate of the current Color instance. Return Returns a Color object.","title":"clone"},{"location":"api/#update","text":"def update ( self , color , data = None , alpha = util . DEF_ALPHA , * , filters = None , ** kwargs ): The update method provides a way to update the underlying color spaces with coordinates from any color space. The methods signature looks just like new and accepts color strings, Color objects, or raw data points specified with a color space string and coordinates. The object itself will be updated and remain in its current color space. Return Returns a reference to the current Color object. Parameters Parameters Defaults Description color A color string, or other Color class object. If given data , a string must be used and should represent the color space to use. data None data accepts a list of numbers representing the coordinates of the color. If provided, color must be a string specifying the color space. alpha 1 alpha accepts a number specifying the alpha channel. Must be used in conjunction with data or it will be ignored. filters None filters accepts a list of color spaces to allow. When None is provided (the default) all supported color spaces are accepted.","title":"update"},{"location":"api/#mutate","text":"def mutate ( self , color , data = None , alpha = util . DEF_ALPHA , * , filters = None , ** kwargs ): The mutate method is just like update except that it will not only update the color space, but mutate it to the provided color space. Return Returns a reference to the current Color object. Parameters Parameters Defaults Description color A color string, or other Color class object. If given data , a string must be used and should represent the color space to use. data None data accepts a list of numbers representing the coordinates of the color. If provided, color must be a string specifying the color space. alpha 1 alpha accepts a number specifying the alpha channel. Must be used in conjunction with data or it will be ignored. filters None filters accepts a list of color spaces to allow. When None is provided (the default) all supported color spaces are accepted.","title":"mutate"},{"location":"api/#space","text":"def space ( self ): Retrieves the current color space of the color. Return Returns a string with the name of the current color space.","title":"space"},{"location":"api/#coords","text":"def coords ( self ): Returns a list of the color's coordinates. This does not include the alpha channel. Alpha can be accessed via the alpha property or get and set accessors. Return Returns a list of numbers indicating the current coordinate values.","title":"coords"},{"location":"api/#to_string","text":"def to_string ( self , ** kwargs ): Method that converts the current color to an output format supported by the color space. While a number of the parameters are common, some may be specific to the color space. The usage guide covers color space specific options in more details. Return Returns a string representation of the current color. Parameters Common parameters: Parameters Defaults Description alpha None Boolean or None value which determines whether the output includes alpha . If None (the default) alpha will only be shown if less than 1. If True , alpha will always be shown. If False , alpha will be omitted. precision 5 Integer value that sets precision and scale. Precision and scale will match the value if greater than zero. If 0 , values will be rounded to the nearest integer. If -1 , number will be output at the highest precision. fit True A boolean that controls whether gamut mapping is performed on string creation. By default, colors will be fit to their own color space. This can be disabled by setting to False . color False A boolean that will determine if the color(space coord+ / alpha) format is used for string output. Has highest precedence. sRGB specific parameters: Parameters Defaults Description hex . False String output will be in #RRGGBBAA format. names False Boolean indicating a preference for CSS color names. When translating a color to it's closest hex form, if that hex value matches a CSS color name, that color name will be returned as the output. hex does not have to be True for this to apply. compress False If hex is True and compress is True , hex values will be compressed if possible: #RRGGBBAA \u2192 #RGBA . Space dependent parameters: Parameters Defaults Description comma False If supported by the color space and the current output format, commas will be used instead of space format: rgba(0, 0, 0, 1) \u2192 rgb(0 0 0 /1) .","title":"to_string"},{"location":"api/#convert","text":"def convert ( self , space , * , fit = False , in_place = False ): Converts a Color object from one color space to another. If the current color space matches the specified color space, the object will be cloned. Return Returns a reference to the converted Color object. If in_place is True , the return will be a reference to the current Color object. Parameters Parameters Defaults Description space A string representing the desired final color space. fit False Boolean specifying whether the current color should be gamut mapped into the final, desired color space. in_place False Boolean specifying whether the convert should alter the current Color object or return a new one.","title":"convert"},{"location":"api/#luminance","text":"def luminance ( self ): Get the relative luminance. Relative luminance is obtained from the Y coordinate in the XYZ color space. Return Returns an float indicating the relative luminance.","title":"luminance"},{"location":"api/#contrast","text":"def contrast ( self , color ): Get the contrast ratio based on the relative luminance between two colors. Return Returns a float indicating the contrast ratio between two colors. Parameters Parameters Defaults Description color A color string or Color object representing a color.","title":"contrast"},{"location":"api/#distance","text":"def distance ( self , color , * , space = util . DEF_DISTANCE_SPACE ): Performs a euclidean distance algorithm on two colors. Return Returns a float indicating euclidean distance between the two colors. Parameters Parameters Defaults Description color A color string or Color object representing a color. space \"lab\" Color space to perform distancing algorithm in.","title":"distance"},{"location":"api/#delta_e","text":"def delta_e ( self , color , * , method = None , ** kwargs ): Performs a delta E distance algorithm on two colors. Default algorithm that is used is Delta E 1976 ( 76 ). Some methods have additional weighting that can be configured through method specific options which are represented by **kwargs . Available methods: Name Input CIE76 76 CIE94 94 CIEDE2000 2000 CMC l:c (1984) cmc Return Returns a float indicating the delta E distance between the two colors. Parameters Parameters Defaults Description color A color string or Color object representing a color. method None String that specifies the method to use. If None , the default will be used.","title":"delta_e"},{"location":"api/#interpolate","text":"def interpolate ( self , color , * , space = \"lab\" , progress = None , out_space = None , adjust = None , hue = util . DEF_HUE_ADJ , premultiplied = False ): The interpolate method creates a function that takes a value between 0 - 1 and interpolates a new color based on the input value. Interpolation can be customized by limiting the interpolation to specific color channels, providing custom interpolation functions, and even adjusting the hue logic used. Hue Evaluation Description shorter Angles are adjusted so that \u03b8\u2082 - \u03b8\u2081 \u2208 [-180, 180]. longer Angles are adjusted so that \u03b8\u2082 - \u03b8\u2081 \u2208 {0, [180, 360)}. increasing Angles are adjusted so that \u03b8\u2082 - \u03b8\u2081 \u2208 [0, 360). decreasing Angles are adjusted so that \u03b8\u2082 - \u03b8\u2081 \u2208 (-360, 0] specified No fixup is performed. Angles are interpolated in the same way as every other component. Parameters Parameters Defaults Description color A color string or Color object representing a color. space \"lab\" Color space to interpolate in. progress None An optional function that that allows for custom logic to perform non-linear interpolation. out_space None Color space that the new color should be in. If None , the color will be in the same color space as the base color. adjust None A list of channel names that should be interpolated. If None , all channels will be interpolated. hue \"shorter\" Define how color spaces which have hue angles are interpolated. Default evaluates between the shortest angle. premultiplied False Use premultiplied alpha when interpolating.","title":"interpolate"},{"location":"api/#steps","text":"def steps ( self , color , * , steps = 2 , max_steps = 1000 , max_delta_e = 0 , ** interpolate_args ): Creates an interpolate function and iterates through it with user defined step parameters to produce discrete color steps. Will attempt to provide the minimum number of steps without exceeding max_steps . If max_delta_e is provided, the distance between each stop will be cut in half until there are no colors with a distance greater than the specified max_delta_e . Return List of Color objects. Parameters Parameters Defaults Description color A color string or Color object representing a color. steps 2 Minimum number of steps. max_steps 1000 Maximum number of steps. max_delta_e 0 Maximum delta E distance between the color stops. A value of 0 or less will be ignored. Note All other keyword arguments defined in **interpolate_args will be passed to the interpolate method.","title":"steps"},{"location":"api/#mix","text":"def mix ( self , color , percent = util . DEF_MIX , * , space = None , in_place = False , ** interpolate_args ): Interpolates between two colors returning a color that represents the mixing of the base color and the provided color mixed at the provided percent , where percent applies to how much the provided color contributes to the the final result. Return Returns a reference to the new Color object or a reference to the current Color if in_place is True . Parameters Parameters Defaults Description color A color string or Color object representing a color. percent 0.5 A numerical value between 0 - 1 representing the percentage at which the parameter color will be mixed. space None A string specifying the color space in which the \"mixing\"/interpolation is done. If None , the base color's color space will be used. in_place False Boolean used to determine if the the current color should be modified \"in place\" or a new Color object should be returned.","title":"mix"},{"location":"api/#fit","text":"def fit ( self , space = None , * , method = None , in_place = False ): Fits color to the current or specified color gamut. By default, lch-chroma gamut mapping is used. This is essentially an approach that holds lightness and hue constant in the LCH color space while reducing chroma until the color is in gamut. Clipping is done at each step of the way and the color distance measured to see how close our color is to the intended color. The supported gamut mapping methods are: Name Input LCH Chroma lch-chroma Clipping clip Return Returns a reference to the new Color object or a reference to the current Color if in_place is True . Parameters Parameters Defaults Description space None The color space that the color must be mapped to. If space is None , then the current color space will be used. method None String that specifies which gamut mapping method to use. If None , lch-chroma will be used.","title":"fit"},{"location":"api/#in_gamut","text":"def in_gamut ( self , space = None , * , tolerance = util . DEF_FIT_TOLERANCE ): Checks if the current color is in the current or specified gamut. Parameters Parameters Defaults Description space None The color space that the color must be fit within. If space is None , then the current color space will be used. tolerance 0.000075 Tolerance allowed when checking bounds of color.","title":"in_gamut"},{"location":"api/#get","text":"def get ( self , name ): Retrieves the coordinate value from the specified channel. Channel must be a channel name in the current color space or a channel name in the specified color space using the syntax: space.channel . Return Returns a numerical value that is stored internally for the specified channel, or a calculated value in the case that a channel in a different color space is requested. Parameters Parameters Defaults Description name Channel name or color space and channel name to retrieve value from.","title":"get"},{"location":"api/#set","text":"def set ( self , name , value ): # noqa: A003 Sets the given value to the specified channel. If the name is provided in the form space.channel , the value will be applied to the channel of the specified color space while keeping current color space the same. The value can be a numerical value, a CSS string compatible with the specified color space, or a function that accepts a numerical channel value and returns a numerical channel value. This function returns the current colors reference so that multiple sets can be chained together. Return Returns a reference to the current Color object. Parameters Parameters Defaults Description name Channel name or color space and channel name to retrieve value from. value A numerical value, a string value accepted by the specified color space, or a function.","title":"set"},{"location":"api/#is_nan","text":"def is_nan ( self , name ): Retrieves the coordinate value from the specified channel and checks whether the value is NaN . Channel must be a channel name in the current color space or a channel name in the specified color space using the syntax: space.channel . Return Returns a boolean indicating whether the specified color space's channel is NaN . Parameters Parameters Defaults Description name A string indicating what channel property to check.","title":"is_nan"},{"location":"api/#dynamic-channel-properties","text":"Depending on the given color space, channel properties will be available on the color object as well. These are dynamically available depending on what the current color space is. For instance, if the color space is sRGB, the channels red , green , blue , and alpha will all be available. These properties are read and writable. When read, they will return the numerical value stored in the specified channel. When written, they can accept a numerical value or a string value using CSS syntax acceptable for that channel in that color space. For more complex setting operations, or to chain multiple set operations, please use get .","title":"Dynamic Channel Properties"},{"location":"colors/","text":"Supported Colors HSV Learn about HSV White Point D65 Coordinates Name Range hue 0 - 360 saturation 0 - 100 value 0 - 100 Supported Inputs >>> Color ( 'hsv' , [ 0 , 0 , 100 ]) color(hsv 0 0 100 / 1) >>> Color ( 'color(hsv 0 0 100)' ) color(hsv 0 0 100 / 1) >>> Color ( 'color(hsv 0 0 % 100% )' ) color(hsv 0 0 100 / 1) sRGB Learn about sRGB White Point D65 Coordinates Name Range red 0 - 1 green 0 - 1 blue 0 - 1 Supported Inputs >>> Color ( \"srgb\" , [ 1 , 1 , 1 ]) color(srgb 1 1 1 / 1) >>> Color ( \"white\" ) color(srgb 1 1 1 / 1) >>> Color ( \"#ffffff\" ) color(srgb 1 1 1 / 1) >>> Color ( \"rgb(100 % 100% 100%)\" ) color(srgb 1 1 1 / 1) >>> Color ( \"rgb(255 255 255)\" ) color(srgb 1 1 1 / 1) >>> Color ( \"rgb(255 255 255 / 1)\" ) color(srgb 1 1 1 / 1) >>> Color ( \"rgba(255, 255, 255, 1)\" ) color(srgb 1 1 1 / 1) >>> Color ( \"rgb(255, 255, 255)\" ) color(srgb 1 1 1 / 1) >>> Color ( 'color(srgb 100 % 100% 100%)' ) color(srgb 1 1 1 / 1) >>> Color ( 'color(srgb 1 1 1 / 1)' ) color(srgb 1 1 1 / 1) HSL Learn about HSL White Point D65 Coordinates Name Range hue 0 - 360 saturation 0 - 100 lightness 0 - 100 Supported Inputs >>> Color ( \"hsl\" , [ 0 , 0 , 100 ]) color(hsl 0 0 100 / 1) >>> Color ( \"hsl(0 0 % 100% )\" ) color(hsl 0 0 100 / 1) >>> Color ( \"hsl(0, 0%, 100%)\" ) color(hsl 0 0 100 / 1) >>> Color ( \"hsl(0 0 % 100% / 1)\" ) color(hsl 0 0 100 / 1) >>> Color ( \"hsla(0, 0%, 100%, 1)\" ) color(hsl 0 0 100 / 1) >>> Color ( \"color(hsl 0 0 % 100% )\" ) color(hsl 0 0 100 / 1) >>> Color ( \"color(hsl 0 0 100 / 1)\" ) color(hsl 0 0 100 / 1) HWB Learn about HWB White Point D65 Coordinates Name Range hue 0 - 360 whiteness 0 - 100 blackness 0 - 100 Supported Inputs >>> Color ( \"hwb\" , [ 0 , 100 , 0 ]) color(hwb 0 100 0 / 1) >>> Color ( \"color(hwb 0 100 0)\" ) color(hwb 0 100 0 / 1) >>> Color ( \"hwb(0 100 % 0% )\" ) color(hwb 0 100 0 / 1) >>> Color ( \"hwb(0, 100%, 0%)\" ) color(hwb 0 100 0 / 1) >>> Color ( \"hwb(0 100 % 0% / 1)\" ) color(hwb 0 100 0 / 1) >>> Color ( \"hwb(0, 100%, 0%, 1)\" ) color(hwb 0 100 0 / 1) >>> Color ( \"color(hwb 0 100 % 0% )\" ) color(hwb 0 100 0 / 1) >>> Color ( \"color(hwb 0 100 0 / 1)\" ) color(hwb 0 100 0 / 1) Lab Learn about Lab White Point D50 Coordinates Name Range lightness 0 - 100 a \u00b1160 - \u00b1160 b \u00b1160 - \u00b1160 Supported Inputs >>> Color ( \"lab\" , [ 100 , 0 , 0 ]) color(lab 100 0 0 / 1) >>> Color ( \"color(lab 100 0 0)\" ) color(lab 100 0 0 / 1) >>> Color ( \"lab(100% 0 0)\" ) color(lab 100 0 0 / 1) >>> Color ( \"lab(100%, 0, 0, 1)\" ) color(lab 100 0 0 / 1) >>> Color ( \"lab(100% 0 0 / 1)\" ) color(lab 100 0 0 / 1) >>> Color ( \"color(lab 100% 0 0)\" ) color(lab 100 0 0 / 1) >>> Color ( \"color(lab 100 0 0 / 1)\" ) color(lab 100 0 0 / 1) LCH Learn about LCH White Point D50 Coordinates Name Range lightness 0 - 100 chroma 0 - 100 hue 0 - 360 Supported Inputs >>> Color ( \"lch\" , [ 100 , 0 , 0 ]) color(lch 100 0 0 / 1) >>> Color ( \"color(lch 100 0 0)\" ) color(lch 100 0 0 / 1) >>> Color ( \"lch(100% 0 0)\" ) color(lch 100 0 0 / 1) >>> Color ( \"lch(100%, 0, 0, 1)\" ) color(lch 100 0 0 / 1) >>> Color ( \"lch(100% 0 0 / 1)\" ) color(lch 100 0 0 / 1) >>> Color ( \"color(lch 100% 0 0)\" ) color(lch 100 0 0 / 1) >>> Color ( \"color(lch 100 0 0 / 1)\" ) color(lch 100 0 0 / 1) XYZ Learn about XYZ White Point D50 Coordinates Name Range x 0 - 1 y 0 - 1 z 0 - 1 Supported Inputs >>> Color ( \"xyz\" , [ 0.96422 , 1 , 0.82521 ]) color(xyz 0.96422 1 0.82521 / 1) >>> Color ( \"color(xyz 0.96422 1 0.82521)\" ) color(xyz 0.96422 1 0.82521 / 1) Display P3 Learn about Display P3 White Point D65 Coordinates Name Range red 0 - 1 green 0 - 1 blue 0 - 1 Supported Inputs >>> Color ( \"display-p3\" , [ 1 , 1 , 1 ]) color(display-p3 1 1 1 / 1) >>> Color ( \"color(display-p3 1 1 1)\" ) color(display-p3 1 1 1 / 1) >>> Color ( \"color(display-p3 100 % 100% 100%)\" ) color(display-p3 1 1 1 / 1) A98 RGB Learn about A98 RGB White Point D65 Coordinates Name Range red 0 - 1 green 0 - 1 blue 0 - 1 Supported Inputs >>> Color ( \"a98-rgb\" , [ 1 , 1 , 1 ]) color(a98-rgb 1 1 1 / 1) >>> Color ( \"color(a98-rgb 1 1 1)\" ) color(a98-rgb 1 1 1 / 1) >>> Color ( \"color(a98-rgb 100 % 100% 100%)\" ) color(a98-rgb 1 1 1 / 1) REC.2020 Learn about REC.2020 White Point D65 Coordinates Name Range red 0 - 1 green 0 - 1 blue 0 - 1 Supported Inputs >>> Color ( \"rec2020\" , [ 1 , 1 , 1 ]) color(rec2020 1 1 1 / 1) >>> Color ( \"color(rec2020 1 1 1)\" ) color(rec2020 1 1 1 / 1) >>> Color ( \"color(rec2020 100 % 100% 100%)\" ) color(rec2020 1 1 1 / 1) ProPhoto Learn about ProPhoto White Point D50 Coordinates Name Range red 0 - 1 green 0 - 1 blue 0 - 1 Supported Inputs >>> Color ( \"prophoto-rgb\" , [ 1 , 1 , 1 ]) color(prophoto-rgb 1 1 1 / 1) >>> Color ( \"color(prophoto-rgb 1 1 1)\" ) color(prophoto-rgb 1 1 1 / 1) >>> Color ( \"color(prophoto-rgb 100 % 100% 100%)\" ) color(prophoto-rgb 1 1 1 / 1)","title":"Supported Colors"},{"location":"colors/#supported-colors","text":"","title":"Supported Colors"},{"location":"colors/#hsv","text":"Learn about HSV White Point D65 Coordinates Name Range hue 0 - 360 saturation 0 - 100 value 0 - 100 Supported Inputs >>> Color ( 'hsv' , [ 0 , 0 , 100 ]) color(hsv 0 0 100 / 1) >>> Color ( 'color(hsv 0 0 100)' ) color(hsv 0 0 100 / 1) >>> Color ( 'color(hsv 0 0 % 100% )' ) color(hsv 0 0 100 / 1)","title":"HSV"},{"location":"colors/#srgb","text":"Learn about sRGB White Point D65 Coordinates Name Range red 0 - 1 green 0 - 1 blue 0 - 1 Supported Inputs >>> Color ( \"srgb\" , [ 1 , 1 , 1 ]) color(srgb 1 1 1 / 1) >>> Color ( \"white\" ) color(srgb 1 1 1 / 1) >>> Color ( \"#ffffff\" ) color(srgb 1 1 1 / 1) >>> Color ( \"rgb(100 % 100% 100%)\" ) color(srgb 1 1 1 / 1) >>> Color ( \"rgb(255 255 255)\" ) color(srgb 1 1 1 / 1) >>> Color ( \"rgb(255 255 255 / 1)\" ) color(srgb 1 1 1 / 1) >>> Color ( \"rgba(255, 255, 255, 1)\" ) color(srgb 1 1 1 / 1) >>> Color ( \"rgb(255, 255, 255)\" ) color(srgb 1 1 1 / 1) >>> Color ( 'color(srgb 100 % 100% 100%)' ) color(srgb 1 1 1 / 1) >>> Color ( 'color(srgb 1 1 1 / 1)' ) color(srgb 1 1 1 / 1)","title":"sRGB"},{"location":"colors/#hsl","text":"Learn about HSL White Point D65 Coordinates Name Range hue 0 - 360 saturation 0 - 100 lightness 0 - 100 Supported Inputs >>> Color ( \"hsl\" , [ 0 , 0 , 100 ]) color(hsl 0 0 100 / 1) >>> Color ( \"hsl(0 0 % 100% )\" ) color(hsl 0 0 100 / 1) >>> Color ( \"hsl(0, 0%, 100%)\" ) color(hsl 0 0 100 / 1) >>> Color ( \"hsl(0 0 % 100% / 1)\" ) color(hsl 0 0 100 / 1) >>> Color ( \"hsla(0, 0%, 100%, 1)\" ) color(hsl 0 0 100 / 1) >>> Color ( \"color(hsl 0 0 % 100% )\" ) color(hsl 0 0 100 / 1) >>> Color ( \"color(hsl 0 0 100 / 1)\" ) color(hsl 0 0 100 / 1)","title":"HSL"},{"location":"colors/#hwb","text":"Learn about HWB White Point D65 Coordinates Name Range hue 0 - 360 whiteness 0 - 100 blackness 0 - 100 Supported Inputs >>> Color ( \"hwb\" , [ 0 , 100 , 0 ]) color(hwb 0 100 0 / 1) >>> Color ( \"color(hwb 0 100 0)\" ) color(hwb 0 100 0 / 1) >>> Color ( \"hwb(0 100 % 0% )\" ) color(hwb 0 100 0 / 1) >>> Color ( \"hwb(0, 100%, 0%)\" ) color(hwb 0 100 0 / 1) >>> Color ( \"hwb(0 100 % 0% / 1)\" ) color(hwb 0 100 0 / 1) >>> Color ( \"hwb(0, 100%, 0%, 1)\" ) color(hwb 0 100 0 / 1) >>> Color ( \"color(hwb 0 100 % 0% )\" ) color(hwb 0 100 0 / 1) >>> Color ( \"color(hwb 0 100 0 / 1)\" ) color(hwb 0 100 0 / 1)","title":"HWB"},{"location":"colors/#lab","text":"Learn about Lab White Point D50 Coordinates Name Range lightness 0 - 100 a \u00b1160 - \u00b1160 b \u00b1160 - \u00b1160 Supported Inputs >>> Color ( \"lab\" , [ 100 , 0 , 0 ]) color(lab 100 0 0 / 1) >>> Color ( \"color(lab 100 0 0)\" ) color(lab 100 0 0 / 1) >>> Color ( \"lab(100% 0 0)\" ) color(lab 100 0 0 / 1) >>> Color ( \"lab(100%, 0, 0, 1)\" ) color(lab 100 0 0 / 1) >>> Color ( \"lab(100% 0 0 / 1)\" ) color(lab 100 0 0 / 1) >>> Color ( \"color(lab 100% 0 0)\" ) color(lab 100 0 0 / 1) >>> Color ( \"color(lab 100 0 0 / 1)\" ) color(lab 100 0 0 / 1)","title":"Lab"},{"location":"colors/#lch","text":"Learn about LCH White Point D50 Coordinates Name Range lightness 0 - 100 chroma 0 - 100 hue 0 - 360 Supported Inputs >>> Color ( \"lch\" , [ 100 , 0 , 0 ]) color(lch 100 0 0 / 1) >>> Color ( \"color(lch 100 0 0)\" ) color(lch 100 0 0 / 1) >>> Color ( \"lch(100% 0 0)\" ) color(lch 100 0 0 / 1) >>> Color ( \"lch(100%, 0, 0, 1)\" ) color(lch 100 0 0 / 1) >>> Color ( \"lch(100% 0 0 / 1)\" ) color(lch 100 0 0 / 1) >>> Color ( \"color(lch 100% 0 0)\" ) color(lch 100 0 0 / 1) >>> Color ( \"color(lch 100 0 0 / 1)\" ) color(lch 100 0 0 / 1)","title":"LCH"},{"location":"colors/#xyz","text":"Learn about XYZ White Point D50 Coordinates Name Range x 0 - 1 y 0 - 1 z 0 - 1 Supported Inputs >>> Color ( \"xyz\" , [ 0.96422 , 1 , 0.82521 ]) color(xyz 0.96422 1 0.82521 / 1) >>> Color ( \"color(xyz 0.96422 1 0.82521)\" ) color(xyz 0.96422 1 0.82521 / 1)","title":"XYZ"},{"location":"colors/#display-p3","text":"Learn about Display P3 White Point D65 Coordinates Name Range red 0 - 1 green 0 - 1 blue 0 - 1 Supported Inputs >>> Color ( \"display-p3\" , [ 1 , 1 , 1 ]) color(display-p3 1 1 1 / 1) >>> Color ( \"color(display-p3 1 1 1)\" ) color(display-p3 1 1 1 / 1) >>> Color ( \"color(display-p3 100 % 100% 100%)\" ) color(display-p3 1 1 1 / 1)","title":"Display P3"},{"location":"colors/#a98-rgb","text":"Learn about A98 RGB White Point D65 Coordinates Name Range red 0 - 1 green 0 - 1 blue 0 - 1 Supported Inputs >>> Color ( \"a98-rgb\" , [ 1 , 1 , 1 ]) color(a98-rgb 1 1 1 / 1) >>> Color ( \"color(a98-rgb 1 1 1)\" ) color(a98-rgb 1 1 1 / 1) >>> Color ( \"color(a98-rgb 100 % 100% 100%)\" ) color(a98-rgb 1 1 1 / 1)","title":"A98 RGB"},{"location":"colors/#rec2020","text":"Learn about REC.2020 White Point D65 Coordinates Name Range red 0 - 1 green 0 - 1 blue 0 - 1 Supported Inputs >>> Color ( \"rec2020\" , [ 1 , 1 , 1 ]) color(rec2020 1 1 1 / 1) >>> Color ( \"color(rec2020 1 1 1)\" ) color(rec2020 1 1 1 / 1) >>> Color ( \"color(rec2020 100 % 100% 100%)\" ) color(rec2020 1 1 1 / 1)","title":"REC.2020"},{"location":"colors/#prophoto","text":"Learn about ProPhoto White Point D50 Coordinates Name Range red 0 - 1 green 0 - 1 blue 0 - 1 Supported Inputs >>> Color ( \"prophoto-rgb\" , [ 1 , 1 , 1 ]) color(prophoto-rgb 1 1 1 / 1) >>> Color ( \"color(prophoto-rgb 1 1 1)\" ) color(prophoto-rgb 1 1 1 / 1) >>> Color ( \"color(prophoto-rgb 100 % 100% 100%)\" ) color(prophoto-rgb 1 1 1 / 1)","title":"ProPhoto"}]}