{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":""},{"location":"#what-is-coloraide","title":"What is ColorAide?","text":"<p>ColorAide is a pure Python, object oriented approach to colors.</p> <pre><code>&gt;&gt;&gt; from coloraide import Color\n&gt;&gt;&gt; Color.steps(['lch(75% 50 0)', 'lch(75% 50 300)'], steps=8, space='lch', hue='longer')\n[color(--lch 75 50 0 / 1), color(--lch 75 50 42.857 / 1), color(--lch 75 50 85.714 / 1), color(--lch 75 50 128.57 / 1), color(--lch 75 50 171.43 / 1), color(--lch 75 50 214.29 / 1), color(--lch 75 50 257.14 / 1), color(--lch 75 50 300 / 1)]\n</code></pre> from coloraide import Color Color.steps(['lch(75% 50 0)', 'lch(75% 50 300)'], steps=8, space='lch', hue='longer') Edit Share Run Cancel <p>ColorAide particularly has a focus on the following:</p> <ul> <li> <p> Accurate colors.</p> </li> <li> <p> Proper round tripping (where reasonable).</p> </li> <li> <p> Be generally easy to pick up for the average user.</p> </li> <li> <p> Support modern CSS color spaces and syntax.</p> </li> <li> <p> Make accessible many new and old non-CSS color spaces.</p> </li> <li> <p> Provide a number of useful utilities such as interpolation, color distancing, blending, gamut mapping, etc.</p> </li> <li> <p> Provide a plugin API to extend supported color spaces and more.</p> </li> <li> <p> Allow users to configure defaults to their liking.</p> </li> </ul> <p>ColorAide is not meant to be the one library to replace all other color libraries. There are many great libraries out there such such as: Colour Science, Colorio, Python Color Math, and many others. Some focus on the scientific aspects of colors and provide a wealth of various spaces, illuminants, access to complex color space visualizers, and numerous esoteric tools. Some are highly focused on speed. Some are powerful, but can be more complex to pick up by the average user.</p> <p>At its heart, ColorAide was designed for convenience, flexibility, and to be very easy to pick up and work with. There are, of course, some trade offs with speed when using a pure Python, object oriented approach, but there are also many advantages as well. ColorAide might not always be the tool for every job, but hopefully it is a great tool all the same.</p>"},{"location":"#installation","title":"Installation","text":"<p>ColorAide can be installed via Python's <code>pip</code>:</p> <pre><code>$ pip install coloraide\n</code></pre>"},{"location":"cat/","title":"Chromatic Adaptation","text":"<p>Chromatic adaptation is the human visual system's ability to adjust to changes in illumination in order to preserve the appearance of object colors. It is responsible for the stable appearance of object colors despite the wide variation of light which might be reflected from an object and observed by our eyes. A chromatic adaptation transform (CAT) emulates this important aspect of color perception in color appearance models.</p> <p>In short, colors look different under different lighting, and CATs are used to predict what a color should look like from one lighting source to another.</p>"},{"location":"cat/#illuminants","title":"Illuminants","text":"<p>Viewing a color in daylight will look different than viewing it by candle light. Color spaces usually define a reference illuminant that clarifies the assumed lighting for the given space. For instance, sRGB is a color space defined with an illuminant of D65 (light in the shade - no direct sunlight - at noon). On the other hand, the ProPhoto RGB space uses a D50 illuminant (direct sunlight at noon).</p> <p></p> <p>When translating a color from one illuminant to another, it is often desirable to represent that color under the new illuminant such that it appears to the eye the same as it did under the original illuminant. CATs are used to predict what the new color under the new illuminant should be in order to fulfill these requirements.</p> <p>For a quick example, we can demonstrate the basic principle when translating a color in the XYZ color space from a D50 illuminant to a D65 illuminant. Below, we can see that the colors look pretty much the same, even though they are now described under different illuminants.</p> <pre><code>&gt;&gt;&gt; d50 = Color('color(xyz-d50 0.11627 0.07261 0.23256 / 1)')\n&gt;&gt;&gt; d65 = d50.convert('xyz-d65')\n&gt;&gt;&gt; d50, d65\n(color(xyz-d50 0.11627 0.07261 0.23256 / 1), color(xyz-d65 0.12413 0.07493 0.30933 / 1))\n</code></pre> d50 = Color('color(xyz-d50 0.11627 0.07261 0.23256 / 1)') d65 = d50.convert('xyz-d65') d50, d65 Edit Share Run Cancel <p>These transforms are usually designed for the XYZ color space as it operates in linear light making it the ideal place to apply the transform. Any color that must go through a CAT to account for differences in illuminants must pass through the XYZ color space. More specifically, ColorAide requires the color to pass through XYZ D65 space as that will trigger the chromatic adaptation. For instance, if a color space such as ProPhoto is being translated to sRGB, ProPhoto will first be transformed to XYZ D50, then XYZ D65 which will trigger the chromatic adaptation, next to Linear sRGB, and lastly sRGB.</p> <p>So, we can actually do this manually and compare the results to what we did above. In order to do this, we need to provide the specified \"white point\" for the source color and the \"white point\" for the destination color along with the XYZ coordinates we wish to transform. ColorAide uses the Bradford CAT by default, so we will specify that CAT for consistency.</p> <pre><code>&gt;&gt;&gt; from coloraide import cat\n&gt;&gt;&gt; Color('color(xyz-d50 0.11627 0.07261 0.23256 / 1)').convert('xyz-d65')[:-1]\n[0.1241272855013134, 0.07493061731402745, 0.3093325898995686]\n&gt;&gt;&gt; Color.chromatic_adaptation(cat.WHITES['2deg'][\"D50\"], cat.WHITES['2deg'][\"D65\"], [0.11627, 0.07261, 0.23256], method='bradford')\n[0.1241272855013134, 0.07493061731402745, 0.3093325898995686]\n</code></pre> from coloraide import cat Color('color(xyz-d50 0.11627 0.07261 0.23256 / 1)').convert('xyz-d65')[:-1] Color.chromatic_adaptation(cat.WHITES['2deg'][\"D50\"], cat.WHITES['2deg'][\"D65\"], [0.11627, 0.07261, 0.23256], method='bradford') Edit Share Run Cancel <p>ColorAide, currently defines the following illuminants for both 2\u02da observer and 10\u02da observer, but most people are probably only concerned with D65 and D50 (2\u02da degree observer) which are the only the illuminants used in the default color spaces provided by ColorAide.</p> Illuminants <code>A</code> <code>B</code> <code>C</code> <code>D50</code> <code>D55</code> <code>D65</code> <code>D75</code> <code>E</code> <code>F2</code> <code>F7</code> <code>F11</code>"},{"location":"cat/#supported-cats","title":"Supported CATs","text":"<p>There are various CATs, all varying in complexity and accuracy. We will not go through all of them and instead will leave that up to the user to research as needed. Suffice it to say, the Bradford CAT is currently the industry standard (in most cases), but there are a variety of options available, and research continues to try and improve upon CATs of the past to come up with better CATs for the future.</p> <p>Currently, ColorAide mainly supports von Kries type CATs (named after an early 20th century color scientist), or CATs that are similar to and/or are built upon the original von Kries CAT. We also do not currently support every known von Kries CAT out there, but a good number are available. In the future, support may be expanded.</p> CAT <code>bradford</code> <code>von-kries</code> <code>xyz-scaling</code> <code>sharp</code> <code>cat02</code> <code>cat16</code> <code>cmccat97</code> <code>cmccat2000</code>"},{"location":"cat/#changing-the-default-cat","title":"Changing the Default CAT","text":"<p>Changing the default CAT is easy and follows the same pattern as the rest of the available class overrides. Simply derive a new <code>Color()</code> class from the original and override the <code>CHROMATIC_ADAPTATION</code> property with the name of the desired CAT. Afterwards, all color transforms will use the specified CAT.</p> <pre><code>&gt;&gt;&gt; class Custom(Color):\n...     CHROMATIC_ADAPTATION = 'cat02'\n... \n&gt;&gt;&gt; d50 = Custom('color(xyz-d50 0.11627 0.07261 0.23256 / 1)')\n&gt;&gt;&gt; d65 = d50.convert('xyz-d65')\n&gt;&gt;&gt; d50, d65\n(color(xyz-d50 0.11627 0.07261 0.23256 / 1), color(xyz-d65 0.12476 0.07614 0.30581 / 1))\n</code></pre> class Custom(Color):     CHROMATIC_ADAPTATION = 'cat02'  d50 = Custom('color(xyz-d50 0.11627 0.07261 0.23256 / 1)') d65 = d50.convert('xyz-d65') d50, d65 Edit Share Run Cancel"},{"location":"color/","title":"The Color Object","text":"<p>The <code>Color</code> object is where all the magic of ColorAide happens and provides access to all the color manipulation methods available. The <code>Color</code> object is used to represent a given color within a particular color space, and in order to perform most operations, you will need to create a color instance to begin.</p> <p>There are a number of ways to instantiate new colors. Here we will cover basic creating, cloning, and updating of the <code>Color</code> class object and a few other class specific topics.</p>"},{"location":"color/#importing","title":"Importing","text":"<p>The <code>Color</code> object contains all the logic to create and manipulate colors. It can be imported from <code>coloraide</code>.</p> <pre><code>from coloraide import Color\n</code></pre> <p>By default, the <code>Color</code> object registers only a subset of the available color spaces and features that are shipped with ColorAide. This keeps the object a bit lighter and provides the more commonly used color spaces and features. Color spaces, additional color distancing algorithms, gamut mapping algorithms, etc. are implemented via plugins. The normal way to get access to these additional spaces and features is to subclass the <code>Color</code> object and resister the desired spaces and features that are needed, but if you just want to explore all that ColorAide offers, you can import the <code>ColorAll</code> object from <code>everything</code>.</p> <pre><code>from coloraide.everything import ColorAll as Color\n</code></pre> <p>Custom Color Objects</p> <p>To add more plugins or tweak color defaults, see Custom Color Classes for more.</p>"},{"location":"color/#creating-colors","title":"Creating Colors","text":"<p>Once the <code>Color</code> class is imported, colors can be created using various forms of input, including: numerical inputs, dictionaries, CSS color strings, and even other <code>Color</code> instances.</p>"},{"location":"color/#numerical-inputs","title":"Numerical Inputs","text":"<p>The quickest way to create a color is by simply specifying the color space, color coordinates, and the optional alpha channel. Numerical inputs require very little processing, but it should be noted that inputs must be specified according to the way the color points are stored. Some people may be aware of the old CSS convention of specifying sRGB colors with a range of 0 - 255, but ColorAide stores these as values between 0 - 1. If transparency is omitted, transparency is assumed to be fully opaque, or a value of 1.</p> <pre><code>&gt;&gt;&gt; Color(\"srgb\", [0.5, 0, 1], 0.3)\ncolor(srgb 0.5 0 1 / 0.3)\n&gt;&gt;&gt; Color(\"srgb\", [0.5, 0, 1])\ncolor(srgb 0.5 0 1 / 1)\n</code></pre> Color(\"srgb\", [0.5, 0, 1], 0.3) Color(\"srgb\", [0.5, 0, 1]) Edit Share Run Cancel"},{"location":"color/#dictionary-inputs","title":"Dictionary Inputs","text":"<p>It may be desired to store and retrieve colors from some serialized format such as JSON. To make this easier, ColorAide allows exporting and importing colors via dictionaries as well.</p> <p>Dictionaries must define the <code>space</code> key and the <code>coords</code> key containing values for all of the color channels. The <code>alpha</code> channel is kept separate and can be omitted, and if so, will be assumed as 1.</p> <pre><code>&gt;&gt;&gt; d = Color('red').to_dict()\n&gt;&gt;&gt; print(d)\n{'space': 'srgb', 'coords': [1.0, 0.0, 0.0], 'alpha': 1.0}\n&gt;&gt;&gt; Color(d)\ncolor(srgb 1 0 0 / 1)\n</code></pre> d = Color('red').to_dict() print(d) Color(d) Edit Share Run Cancel"},{"location":"color/#string-inputs","title":"String Inputs","text":"<p>By default, ColorAide accepts input strings as outlined in the CSS color specification. Accepted syntax includes legacy CSS color formats as defined in CSS Level 3, but also allows for CSS Level 4 Color syntax!</p> <pre><code>&gt;&gt;&gt; Color(\"red\")\ncolor(srgb 1 0 0 / 1)\n&gt;&gt;&gt; Color(\"#00ff00\")\ncolor(srgb 0 1 0 / 1)\n&gt;&gt;&gt; Color(\"rgb(0 0 255 / 1)\")\ncolor(srgb 0 0 1 / 1)\n</code></pre> Color(\"red\") Color(\"#00ff00\") Color(\"rgb(0 0 255 / 1)\") Edit Share Run Cancel <p>ColorAide supports all the color spaces as defined in the CSS Level 4 Color spec, but is not restricted to only supported CSS colors. In order to support color strings for all colors, ColorAide allows for non-CSS color spaces to be represented via the Level 4 CSS <code>color()</code> function. Essentially, we've adopted the <code>color()</code> function as the universal way in which to serialize color strings.</p> <p>It should also be noted that <code>color()</code> can be used to describe any color regardless of whether it is supported in the CSS spec in this way or not. For any color that is not explicitly supported in CSS via the <code>color()</code> function, ColorAide will allow using this form if the color space uses a <code>--</code> prefix for the color space identifier. Check the documentation of the given color space to discover the appropriate CSS identifier name.</p> <pre><code>&gt;&gt;&gt; Color('color(--hsl 130 40% 75% / 0.5)')\ncolor(--hsl 130 0.4 0.75 / 0.5)\n</code></pre> Color('color(--hsl 130 40% 75% / 0.5)') Edit Share Run Cancel"},{"location":"color/#color-instance-inputs","title":"Color Instance Inputs","text":"<p>If another color instance is passed as the input, a new color object will be created using the color data from the input. This essentially clones the passed object.</p> <pre><code>&gt;&gt;&gt; c1 = Color('red')\n&gt;&gt;&gt; c2 = Color(c1)\n&gt;&gt;&gt; c1, c2\n(color(srgb 1 0 0 / 1), color(srgb 1 0 0 / 1))\n</code></pre> c1 = Color('red') c2 = Color(c1)  c1, c2 Edit Share Run Cancel <p>You can also use the <code>new</code> method to generate new colors from already instantiated color objects.</p> <pre><code>&gt;&gt;&gt; color1 = Color(\"red\")\n&gt;&gt;&gt; color1\ncolor(srgb 1 0 0 / 1)\n&gt;&gt;&gt; color1.new(\"blue\")\ncolor(srgb 0 0 1 / 1)\n</code></pre> color1 = Color(\"red\") color1 color1.new(\"blue\") Edit Share Run Cancel <p>Tip</p> <p>If the <code>Color</code> class has be subclassed, this is an easy way to convert between the different subclasses, assuming the registered color spaces are compatible between the two different <code>Color</code> classes.</p>"},{"location":"color/#random","title":"Random","text":"<p>If you'd like to generate a random color, simply call <code>Color.random</code> with a given color space and one will be generated.</p> <pre><code>&gt;&gt;&gt; [Color.random('srgb') for _ in range(10)]\n[color(srgb 0.64395 0.60678 0.13317 / 1), color(srgb 0.27899 0.18527 0.68091 / 1), color(srgb 0.56862 0.49292 0.934 / 1), color(srgb 0.16421 0.78125 0.01643 / 1), color(srgb 0.3173 0.43644 0.49718 / 1), color(srgb 0.55777 0.81277 0.25084 / 1), color(srgb 0.34258 0.40064 0.384 / 1), color(srgb 0.722 0.14603 0.25415 / 1), color(srgb 0.02765 0.98232 0.874 / 1), color(srgb 0.8527 0.06189 0.7625 / 1)]\n</code></pre> [Color.random('srgb') for _ in range(10)] Edit Share Run Cancel <p>Ranges are based on the color space's defined channel range. For color spaces with defined gamuts, the values will be confined to appropriate ranges. For color space's without defined gamuts, the ranges may be quite arbitrary in some cases. For color spaces with no hard, defined gamut, or gamuts that that far exceed practical usage it is recommend to fit the colors to whatever gamut you'd like, or simply use a target space with a clear defined gamut.</p> <pre><code>&gt;&gt;&gt; Color.random('lab').fit('srgb')\ncolor(--lab 61.366 -12.877 -50.926 / 1)\n</code></pre> Color.random('lab').fit('srgb') Edit Share Run Cancel <p>Lastly, if you'd like to further constrain the limits, you can provide a list of constraints. A constraint should be a sequence of two values specifying the minimum and maximum for the channel. If <code>None</code> is provided, that constraint will be ignored. If the list doesn't have enough values, those missing indexes will be ignored. If the list has too many values, those extra values will be ignored.</p> <pre><code>&gt;&gt;&gt; Color.random('srgb', limits=[(0.25, 0.75)] * 3)\ncolor(srgb 0.49155 0.43415 0.46928 / 1)\n</code></pre> Color.random('srgb', limits=[(0.25, 0.75)] * 3) Edit Share Run Cancel"},{"location":"color/#cloning","title":"Cloning","text":"<p>The <code>clone</code> method is an easy way to duplicate the current color object.</p> <p>Here we clone the <code>green</code> color object, giving us two.</p> <pre><code>&gt;&gt;&gt; c1 = Color(\"green\")\n&gt;&gt;&gt; c1\ncolor(srgb 0 0.50196 0 / 1)\n&gt;&gt;&gt; c1.clone()\ncolor(srgb 0 0.50196 0 / 1)\n</code></pre> c1 = Color(\"green\") c1 c1.clone() Edit Share Run Cancel"},{"location":"color/#updating","title":"Updating","text":"<p>A color can be \"updated\" using another color input. When an update occurs, the current color space is updated from the data of the second color, but the color space does not change. Using <code>update</code> is the equivalent of converting the second color to the color space of the first and then updating all the coordinates (including alpha). The input parameters are identical to the <code>new</code> method, so we can use a color object, a color string, dictionary, or even raw data points.</p> <p>Here we update the color <code>red</code> to the color <code>blue</code>:</p> <pre><code>&gt;&gt;&gt; Color(\"red\")\ncolor(srgb 1 0 0 / 1)\n&gt;&gt;&gt; Color(\"red\").update(Color(\"blue\"))\ncolor(srgb 0 0 1 / 1)\n</code></pre> Color(\"red\") Color(\"red\").update(Color(\"blue\")) Edit Share Run Cancel <p>Here we update the sRGB <code>red</code> with the color <code>lch(80% 50 130)</code>.</p> <pre><code>&gt;&gt;&gt; Color(\"red\").update(\"lch(80% 50 130)\")\ncolor(srgb 0.60392 0.8398 0.48396 / 1)\n</code></pre> Color(\"red\").update(\"lch(80% 50 130)\") Edit Share Run Cancel"},{"location":"color/#mutating","title":"Mutating","text":"<p>\"Mutating\" is similar to updating except that it will update the color and the color space from another color. The input parameters are identical to the <code>new</code> method, so we can use a color object, a color string, dictionary, or even raw data points.</p> <p>In this example, the <code>red</code> color object literally becomes the specified CIELCh color of <code>lch(80% 50 130)</code>.</p> <pre><code>&gt;&gt;&gt; Color(\"red\").mutate(\"lch(80% 50 130)\")\ncolor(--lch 80 50 130 / 1)\n</code></pre> Color(\"red\").mutate(\"lch(80% 50 130)\") Edit Share Run Cancel"},{"location":"color/#converting","title":"Converting","text":"<p>Colors can be converted to other color spaces as needed. Converting will always return a new color unless the <code>in_place</code> parameter is set to <code>True</code>, in which case, the current color will be mutated to the new converted color and a reference to itself is returned.</p> <p>For instance, if we had a color <code>yellow</code>, and we needed to work with it in another color space, we could simply call the <code>convert</code> method with the desired color space.</p> <pre><code>&gt;&gt;&gt; Color('yellow').convert(\"lab\")\ncolor(--lab 97.607 -15.75 93.394 / 1)\n</code></pre> Color('yellow').convert(\"lab\") Edit Share Run Cancel Notes on Round Tripping Accuracy <p>In general, ColorAide is careful to provide good round trip conversions where practical. What this means is that we try to maintain a high level of accuracy so that when a color is converted to a different color and then back, that it will be very close, if not exactly, the same. We accomplish this by not not clipping values during conversion and maintaining as high of precision as we can, but there are some cases where the round tripping accuracy cannot be maintained at the same high level, or when round tripping cannot be maintained at all.</p> <ol> <li> <p>One situation that can cause bad round tripping is when one color model cannot properly handle a color due to its    gamut being beyond the conversion algorithms limits.</p> <p>Consider a wide gamut, HDR color space like Jzazbz. When it is converted to HSLuv, whose algorithm clamps any lightness that exceeds the SDR range, the round trip is broken. This is just the nature of the HSLuv algorithm as it adheres to an sRGB gamut that does not support HDR lightness.</p> <pre><code>&gt;&gt;&gt; jz = Color('color(--jzazbz 0.25 0 0)')\n&gt;&gt;&gt; jz\ncolor(--jzazbz 0.25 0 0 / 1)\n&gt;&gt;&gt; hsluv = jz.convert('hsluv')\n&gt;&gt;&gt; hsluv\ncolor(--hsluv none 0 100 / 1)\n&gt;&gt;&gt; hsluv.convert('jzazbz')\ncolor(--jzazbz 0.22207 -0.00016 -0.00012 / 1)\n</code></pre> jz = Color('color(--jzazbz 0.25 0 0)') jz hsluv = jz.convert('hsluv') hsluv hsluv.convert('jzazbz') Edit Share Run Cancel </li> <li> <p>Sometimes, round tripping can be compromised for practical reasons. This does not mean round tripping breaks, but    the high degree of accuracy can drop some. A common case where this happens is with LCh-like color models: LCh,    OkLCh, JzCzhz, etc.</p> <p>By definition, a color within an LCh-like color model is determined to be achromatic when chroma is <code>0</code>. These color models usually calculate chroma by taking a Lab-like color space's <code>a</code> and <code>b</code> components (or some equivalent) and calculating the chroma with <code>chroma = math.sqrt(a ** 2 + b ** 2)</code>. This requires both <code>a</code> and <code>b</code> to be exactly <code>0</code> or chroma will not be <code>0</code>. Many of these Lab-like color spaces do not resolve such that <code>a</code> and <code>b</code> are perfectly <code>0</code>. Due to the complexity of the conversion to these Lab-like color spaces, coupled with inherent issues with floating point arithmetic, you will sometimes get very close to <code>0</code>, but not exactly <code>0</code>.</p> <p>What is more a problem is not that chroma doesn't resolve to <code>0</code>, but that you can get nonsensical hues as chroma gets very close to zero. Because of this, we simply set hue to undefined when chroma is deemed very close for the color model. But this small change can affect the outcome slightly when doing a round trip back to the original color, though, not usually enough to impact the value in any significant, meaningful way.</p> <p>The definition of very close to <code>0</code> can be different from color space to color space, so the impact of such a change can be more significant for certain color spaces.</p> <p>Consider the conversion of the color <code>gray</code> to both Oklab and Jzazbz.</p> <pre><code>&gt;&gt;&gt; c1 = Color('gray').convert('oklab')\n&gt;&gt;&gt; c2 = Color('gray').convert('jzazbz')\n&gt;&gt;&gt; c1, c2\n(color(--oklab 0.59987 0 0 / 1), color(--jzazbz 0.11827 -0.00012 -0.00008 / 1))\n&gt;&gt;&gt; list(c1)\n[0.5998708017229867, -5.551115123125783e-17, 2.2375181041311976e-08, 1.0]\n&gt;&gt;&gt; list(c2)\n[0.11827024942185417, -0.00011630238498622214, -8.474411299219664e-05, 1.0]\n</code></pre> c1 = Color('gray').convert('oklab') c2 = Color('gray').convert('jzazbz') c1, c2 list(c1) list(c2) Edit Share Run Cancel <p>Jzazbz simply doesn't resolve as close to zero as Oklab; therefore, it's cylindrical counter part (JzCzhz) will be more sensitive during the round trip than Oklab's cylindrical counterpart (OkLCh). It should be noted that the difference is still not perceivable to the human eye.</p> <pre><code>&gt;&gt;&gt; jz = Color('gray').convert('jzazbz')\n&gt;&gt;&gt; jz\ncolor(--jzazbz 0.11827 -0.00012 -0.00008 / 1)\n&gt;&gt;&gt; jz2 = jz.convert('jzczhz').convert('jzazbz')\n&gt;&gt;&gt; jz.delta_e(jz2, method='jz')\n0.0002736565909198003\n</code></pre> jz = Color('gray').convert('jzazbz') jz jz2 = jz.convert('jzczhz').convert('jzazbz') jz.delta_e(jz2, method='jz') Edit Share Run Cancel </li> </ol>"},{"location":"color/#color-matching","title":"Color Matching","text":"<p>As previously mentioned, the <code>Color()</code> object can parse CSS style string inputs. The string matching logic is exposed via the <code>match</code> method. We can simply pass <code>match</code> a string, and, if the string is a valid color, a <code>ColorMatch</code> object will be returned. The <code>ColorMatch</code> object has a simple structure that contains the matched <code>color</code> as a <code>Color</code> object, and the <code>start</code> and <code>end</code> points it was located at.</p> <pre><code>&gt;&gt;&gt; Color.match(\"red\")\nColorMatch(color=color(srgb 1 0 0 / 1), start=0, end=3)\n</code></pre> Color.match(\"red\") Edit Share Run Cancel <p>By default it matches at the start of the buffer and returns a color if it finds one. If desired, we can do a <code>fullmatch</code> which requires the entire buffer to match a color.</p> <pre><code>&gt;&gt;&gt; Color.match(\"red and yellow\")\nColorMatch(color=color(srgb 1 0 0 / 1), start=0, end=3)\n&gt;&gt;&gt; Color.match(\"red and yellow\", fullmatch=True)\n</code></pre> Color.match(\"red and yellow\") Color.match(\"red and yellow\", fullmatch=True) Edit Share Run Cancel <p>We can also adjust the start position of the search. In this case, by adjusting the start position to 8 characters later, we will match <code>yellow</code> instead of <code>red</code>.</p> <pre><code>&gt;&gt;&gt; Color.match(\"red and yellow\", start=8)\nColorMatch(color=color(srgb 1 1 0 / 1), start=8, end=14)\n</code></pre> Color.match(\"red and yellow\", start=8) Edit Share Run Cancel <p>A method to find all colors in a buffer is not currently provided as looping through all the color spaces and matching all potential colors on every character is not really efficient. Additionally, some buffers may require additional context that is not available to the match function. If such behavior is desired, it is recommended to apply some additional logic to sniff out areas with high likelihood of having a color.</p> <p>In the following example, we construct a regular expression to find places within the buffer that potentially have a valid color. As the buffer is an HTML document we also want to incorporate some context to avoid matching HTML entities or color names that are part of a CSS variable.</p> <p>Once we've crafted our regular expression, we can search the buffer to find locations in the buffer that are likely to be colors. Then we can run <code>Color.match()</code> on those positions within the buffer to see if we find a valid color. This ends up being much more efficient!</p> <pre><code>&gt;&gt;&gt; import re\n&gt;&gt;&gt; from coloraide import Color\n&gt;&gt;&gt; RE_COLOR_START = re.compile(r\"(?i)(?:\\b(?&lt;![-#&amp;$])(?:color\\((?!\\s*-)|(?:hsla?|lch|lab|hwb|rgba?)\\()|\\b(?&lt;![-#&amp;$])[\\w]{3,}(?![(-])\\b|(?&lt;![&amp;])#)\")\n&gt;&gt;&gt; text = \"\"\"\n... &lt;html&gt;\n... &lt;head&gt;\n... &lt;style&gt;\n... body {\n...     background-color: red;\n...     color: yellow;\n... }\n... &lt;/style&gt;\n... &lt;/head&gt;\n... &lt;body&gt;\n... &lt;p&gt;This is a test &lt;span style=\"background-color: #000088; color: lch(75% 50 50)\"&gt;test&lt;/span&gt;&lt;/p&gt;\n... &lt;/body&gt;\n... &lt;/html&gt;\n... \"\"\"\n&gt;&gt;&gt; colors = []\n&gt;&gt;&gt; for m in RE_COLOR_START.finditer(text):\n...     start = m.start()\n...     mcolor = Color.match(text, start=start)\n...     if mcolor is not None:\n...         colors.append(mcolor.color)\n... \n&gt;&gt;&gt; [x.to_string() for x in colors]\n['rgb(255 0 0)', 'rgb(255 255 0)', 'rgb(0 0 136)', 'lch(75 50 50)']\n</code></pre> import re from coloraide import Color  RE_COLOR_START = re.compile(r\"(?i)(?:\\b(?&lt;![-#&amp;$])(?:color\\((?!\\s*-)|(?:hsla?|lch|lab|hwb|rgba?)\\()|\\b(?&lt;![-#&amp;$])[\\w]{3,}(?![(-])\\b|(?&lt;![&amp;])#)\")  text = \"\"\" &lt;html&gt; &lt;head&gt; &lt;style&gt; body {     background-color: red;     color: yellow; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;This is a test &lt;span style=\"background-color: #000088; color: lch(75% 50 50)\"&gt;test&lt;/span&gt;&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; \"\"\"  colors = [] for m in RE_COLOR_START.finditer(text):     start = m.start()     mcolor = Color.match(text, start=start)     if mcolor is not None:         colors.append(mcolor.color) [x.to_string() for x in colors] Edit Share Run Cancel"},{"location":"color/#custom-color-classes","title":"Custom Color Classes","text":"<p>The <code>Color</code> object was created to be extensible and has implemented various functionalities as plugins. Things like color spaces, distancing algorithms, filters, etc. are all implemented as plugins. In order to keep things light, ColorAide does not register all the of the plugins by default unless the user as imported the <code>ColorAll</code> object.</p> <p>Additionally, ColorAide has implemented a number of defaults that can be tweaked within the <code>Color</code> class to alter how things are handled.</p> <p>Creating a custom class allows for a user to change some of the default settings and add or remove plugins to gain access to more color spaces, distancing algorithms, filters, and other functionality.</p> <p>In general, it is always recommended to subclass the <code>Color</code> object when setting up custom preferences or adding or removing plugins. This prevents modifying the base class which may affect other libraries relying on the module. When <code>Color</code> is subclassed, it is safe to then update global overrides or register and deregister plugins without the worry of affecting the base class.</p>"},{"location":"color/#override-default-settings","title":"Override Default Settings","text":"<p>ColorAide has a number of preferences that can be altered in the <code>Color</code> class. Most of these options can be configured on demand when calling into a related function that uses them, but it may be useful to set them up one time on a new <code>Color</code> object.</p> <pre><code>&gt;&gt;&gt; class Color2(Color):\n...     PRECISION = 3\n... \n&gt;&gt;&gt; Color('rgb(128.12345 0 128.12345)').to_string()\nrgb(128.12 0 128.12)\n&gt;&gt;&gt; Color2('rgb(128.12345 0 128.12345)').to_string()\nrgb(128 0 128)\n</code></pre> class Color2(Color):     PRECISION = 3  Color('rgb(128.12345 0 128.12345)').to_string() Color2('rgb(128.12345 0 128.12345)').to_string() Edit Share Run Cancel Properties Defaults Description <code>FIT</code> <code>\"lch-chroma\"</code> The default gamut mapping method used by the <code>Color</code> object. <code>INTERPOLATE</code> <code>\"oklab\"</code> The default color space used for interpolation. <code>DELTA_E</code> <code>\"76\"</code> The default \u2206E algorithm used. This applies to when <code>delta_e()</code> is called without specifying a method or when using color distancing to separate color when using the interpolation method called <code>steps</code>. <code>PRECISION</code> <code>5</code> The default precision for string outputs. <code>CHROMATIC_ADAPTATION</code> <code>\"bradford\"</code> Chromatic adaptation method used when converting between two color spaces with different white points. See Chromatic Adaptation for more information. <code>HARMONY</code> <code>\"oklch\"</code> Default color space to use for calculating color harmonies. This should be a cylindrical color space. <code>CONTRAST</code> <code>\"wcag21\"</code> Default contrast algorithm."},{"location":"color/#plugins","title":"Plugins","text":"<p>Currently, color spaces, delta E methods, chromatic adaptation, filters, contrast, interpolation, and gamut mapping methods are exposed as plugins. As previously mentioned, <code>Color</code> does not register all plugins, and <code>ColorAll</code> is often more than a user needs by default. Registering exactly what you need is normally the recommend approach when more functionality is required.</p> <p>While we won't go into a lot of details about creating plugins here, we will go over how to register new plugins and deregister existing plugins. To learn more about creating plugins, checkout the plugin documentation.</p> <p>Registration is performed by the <code>register</code> method. It can take a single plugin or a list of plugins. Based on the plugin's type, The Color object will determine how to properly register the plugin. If the plugin attempts to overwrite a plugin already registered with the same name (as dictated by the plugin) the operation will fail. If <code>overwrite</code> is set to <code>True</code>, the overwrite will not fail and the new plugin will be registered with the specified name in place of the existing plugin.</p> <pre><code>&gt;&gt;&gt; from coloraide import Color\n&gt;&gt;&gt; from coloraide.spaces.xyy import xyY\n&gt;&gt;&gt; try:\n...     Color('red').convert('xyy')\n... except:\n...     print('Nope')\n... \nNope\n&gt;&gt;&gt; class Custom(Color): ...\n... \n&gt;&gt;&gt; Custom.register(xyY())\n&gt;&gt;&gt; Custom('red').convert('xyy')\ncolor(--xyy 0.64 0.33 0.21264 / 1)\n</code></pre> from coloraide import Color from coloraide.spaces.xyy import xyY  try:     Color('red').convert('xyy') except:     print('Nope')  class Custom(Color): ...  Custom.register(xyY())  Custom('red').convert('xyy') Edit Share Run Cancel <p>Used in conjunction with default settings override, we can not only change a default \u2206E, but we can alter a \u2206E method's configuration by registering it with different defaults:</p> <pre><code>&gt;&gt;&gt; Color('red').delta_e('blue', method='cmc')\n114.23012812016573\n&gt;&gt;&gt; from coloraide.distance.delta_e_cmc import DECMC\n&gt;&gt;&gt; class Custom(Color):\n...     DELTA_E = \"cmc\"\n... \n&gt;&gt;&gt; Custom.register(DECMC(l=1, c=1), overwrite=True)\n&gt;&gt;&gt; Custom('red').delta_e('blue')\n115.77446003768313\n</code></pre> Color('red').delta_e('blue', method='cmc') from coloraide.distance.delta_e_cmc import DECMC class Custom(Color):     DELTA_E = \"cmc\" Custom.register(DECMC(l=1, c=1), overwrite=True) Custom('red').delta_e('blue') Edit Share Run Cancel <p>If a deregistration is desired, the <code>deregister</code> method can be used. It takes a string that describes the plugin to deregister: <code>category:name</code>.</p> <p>Valid categories are <code>space</code>, <code>delta-e</code>, <code>cat</code>, <code>filter</code>, <code>interpolate</code>, and <code>fit</code>.</p> <p>If the given plugin is not found, an error will be thrown, but if this notification is found to be unnecessary, <code>silent</code> can be enabled and the there will be no error thrown.</p> <pre><code>&gt;&gt;&gt; class Custom(Color): ...\n... \n&gt;&gt;&gt; Custom.deregister('space:lab-d65')\n&gt;&gt;&gt; try:\n...     Custom('red').convert('lab-d65')\n... except ValueError:\n...     print('Could not convert to Lab D65 as it is no longer registered')\n... \nCould not convert to Lab D65 as it is no longer registered\n</code></pre> class Custom(Color): ... Custom.deregister('space:lab-d65') try:     Custom('red').convert('lab-d65') except ValueError:     print('Could not convert to Lab D65 as it is no longer registered') Edit Share Run Cancel <p>Use of <code>*</code> with <code>deregister</code> will remove all plugins. Use of <code>category:*</code> will remove all plugins of that category.</p>"},{"location":"compositing/","title":"Compositing and Blending","text":"<p>Alpha compositing and blending are tied together under the umbrella of compositing. Each is just an aspect of the overall compositing of colors. Blend is run first, followed by alpha compositing.</p> <p>ColorAide implements both alpha compositing and blending as described in the Compositing and Blending Level 1 specification. Alpha composting is based on Porter Duff compositing. By default, the <code>compose</code> method uses the <code>normal</code> blend mode and the <code>source-over</code> Porter Duff operator.</p>"},{"location":"compositing/#blending","title":"Blending","text":"<p>Blending is the aspect of compositing that calculates the mixing of colors where the source element and backdrop overlap. Conceptually, the colors in the source element (top layer) are blended in place with the backdrop (bottom layer).</p> <p>There are various blend modes, the most common is the <code>normal</code> blend mode which is the default blending mode for browsers. The <code>normal</code> blend mode simply returns the top layer's color when one is overlaid onto another.</p> <p> </p> <p>But there are many blend modes that could be used, all of which yield different results. If we were to apply a <code>multiply</code> blend mode, we would get something very different:</p> <p> </p> <p>When composing, the blend mode can be controlled separately in ColorAide. Here, we again use the <code>multiply</code> example and replicate it in ColorAide. To apply blending in ColorAide, simply call <code>compose</code> with a backdrop color, and the calling color will be used as the source.</p> Display P3sRGB <pre><code>&gt;&gt;&gt; c1 = Color('#07c7ed')\n&gt;&gt;&gt; c2 = Color('#fc3d99')\n&gt;&gt;&gt; c1, c2\n(color(srgb 0.02745 0.78039 0.92941 / 1), color(srgb 0.98824 0.23922 0.6 / 1))\n&gt;&gt;&gt; c1.compose(c2, blend='multiply', space=\"display-p3\")\ncolor(srgb 0.33867 0.23261 0.55966 / 1)\n</code></pre> c1 = Color('#07c7ed') c2 = Color('#fc3d99') c1, c2 c1.compose(c2, blend='multiply', space=\"display-p3\") Edit Share Run Cancel <pre><code>&gt;&gt;&gt; c1 = Color('#07c7ed')\n&gt;&gt;&gt; c2 = Color('#fc3d99')\n&gt;&gt;&gt; c1, c2\n(color(srgb 0.02745 0.78039 0.92941 / 1), color(srgb 0.98824 0.23922 0.6 / 1))\n&gt;&gt;&gt; c1.compose(c2, blend='multiply', space=\"srgb\")\ncolor(srgb 0.02713 0.18668 0.55765 / 1)\n</code></pre> c1 = Color('#07c7ed') c2 = Color('#fc3d99') c1, c2 c1.compose(c2, blend='multiply', space=\"srgb\") Edit Share Run Cancel <p>Display Differences</p> <p>As some browsers apply compositing based on the display's current color space, we've provided examples in both sRGB and Display P3 so that the examples can be compared on different displays. Which of the above matches your browser?</p> <p>ColorAide allows you to blend a source over multiple backdrops quite easily as well. Simply send in a list, and the colors will be blended from right to left with the right most color being on the bottom of the stack, and the base color being used as the source (on the very top).</p> <p> </p> Display P3sRGB <pre><code>&gt;&gt;&gt; c1 = Color('#07c7ed')\n&gt;&gt;&gt; c2 = Color('#fc3d99')\n&gt;&gt;&gt; c3 = Color('#f5d311')\n&gt;&gt;&gt; c1, c2, c3\n(color(srgb 0.02745 0.78039 0.92941 / 1), color(srgb 0.98824 0.23922 0.6 / 1), color(srgb 0.96078 0.82745 0.06667 / 1))\n&gt;&gt;&gt; c1.compose([c2, c3], blend='multiply', space=\"display-p3\")\ncolor(srgb 0.32151 0.19137 0.14794 / 1)\n</code></pre> c1 = Color('#07c7ed') c2 = Color('#fc3d99') c3 = Color('#f5d311') c1, c2, c3 c1.compose([c2, c3], blend='multiply', space=\"display-p3\") Edit Share Run Cancel <pre><code>&gt;&gt;&gt; c1 = Color('#07c7ed')\n&gt;&gt;&gt; c2 = Color('#fc3d99')\n&gt;&gt;&gt; c3 = Color('#f5d311')\n&gt;&gt;&gt; c1, c2, c3\n(color(srgb 0.02745 0.78039 0.92941 / 1), color(srgb 0.98824 0.23922 0.6 / 1), color(srgb 0.96078 0.82745 0.06667 / 1))\n&gt;&gt;&gt; c1.compose([c2, c3], blend='multiply', space=\"srgb\")\ncolor(srgb 0.02606 0.15447 0.03718 / 1)\n</code></pre> c1 = Color('#07c7ed') c2 = Color('#fc3d99') c3 = Color('#f5d311') c1, c2, c3 c1.compose([c2, c3], blend='multiply', space=\"srgb\") Edit Share Run Cancel <p>Lastly, if for any reason, it is desired to compose with blending disabled (e.g. just run alpha compositing), then you can simply set <code>blend</code> to <code>False</code>.</p> <p><code>multiply</code> is just one of many blend modes that are offered in ColorAide, check out Blend Modes to learn about other blend modes.</p>"},{"location":"compositing/#alpha-compositing","title":"Alpha Compositing","text":"<p>Alpha compositing or alpha blending is the process of combining one image with a background to create the appearance of partial or full transparency.</p> <p>When dealing with layers, there are many possible ways to handle them:</p> <p></p> <p>Porter Duff compositing covers all possible configurations of layers. Many of these configurations can be useful for all sorts of operations, such as masking. While this library supports all of them, the most commonly used one is <code>source-over</code> which is used to implement simple alpha compositing to simulate semi-transparent layers on top of each other.</p> <p> </p> <p>Given two colors, ColorAide can replicate this behavior and determine the resultant color by applying compositing. We will use the demonstration above and replicate the result in the example below. Below we set the source color to <code>rgb(7 199 237 / 0.5)</code> and the backdrop color to <code>#fc3d99</code> and run it through the <code>compose</code> method. It should be noted that the default blend mode of <code>normal</code> is used in conjunction by default.</p> Display P3sRGB <pre><code>&gt;&gt;&gt; c1 = Color('#07c7ed').set('alpha', 0.5)\n&gt;&gt;&gt; c2 = Color('#fc3d99')\n&gt;&gt;&gt; c1, c2\n(color(srgb 0.02745 0.78039 0.92941 / 0.5), color(srgb 0.98824 0.23922 0.6 / 1))\n&gt;&gt;&gt; c1.compose(c2, space=\"display-p3\")\ncolor(srgb 0.65142 0.53412 0.76833 / 1)\n</code></pre> c1 = Color('#07c7ed').set('alpha', 0.5) c2 = Color('#fc3d99') c1, c2 c1.compose(c2, space=\"display-p3\") Edit Share Run Cancel <pre><code>&gt;&gt;&gt; c1 = Color('#07c7ed').set('alpha', 0.5)\n&gt;&gt;&gt; c2 = Color('#fc3d99')\n&gt;&gt;&gt; c1, c2\n(color(srgb 0.02745 0.78039 0.92941 / 0.5), color(srgb 0.98824 0.23922 0.6 / 1))\n&gt;&gt;&gt; c1.compose(c2, space=\"srgb\")\ncolor(srgb 0.50784 0.5098 0.76471 / 1)\n</code></pre> c1 = Color('#07c7ed').set('alpha', 0.5) c2 = Color('#fc3d99') c1, c2 c1.compose(c2, space=\"srgb\") Edit Share Run Cancel <p>Display Differences</p> <p>As some browsers apply compositing based on the display's current color space, we've provided examples in both sRGB and Display P3 so that the examples can be compared on different displays. Which of the above matches your browser?</p> <p>While the average user will be content with the default alpha compositing, Porter Duff offers many other configurations. If desired, we can change the Porter Duff operator used and apply different composite logic. For instance, in this case we can get the resultant of the backdrop over the source color by setting the <code>operator</code> to <code>destination-over</code>. As the backdrop is fully opaque, we just get the backdrop color unaltered.</p> <p> </p> Display P3sRGB <pre><code>&gt;&gt;&gt; c1 = Color('#07c7ed').set('alpha', 0.5)\n&gt;&gt;&gt; c2 = Color('#fc3d99')\n&gt;&gt;&gt; c1, c2\n(color(srgb 0.02745 0.78039 0.92941 / 0.5), color(srgb 0.98824 0.23922 0.6 / 1))\n&gt;&gt;&gt; c1.compose(c2, operator='destination-over', space=\"display-p3\")\ncolor(srgb 0.98824 0.23922 0.6 / 1)\n</code></pre> c1 = Color('#07c7ed').set('alpha', 0.5) c2 = Color('#fc3d99') c1, c2 c1.compose(c2, operator='destination-over', space=\"display-p3\") Edit Share Run Cancel <pre><code>&gt;&gt;&gt; c1 = Color('#07c7ed').set('alpha', 0.5)\n&gt;&gt;&gt; c2 = Color('#fc3d99')\n&gt;&gt;&gt; c1, c2\n(color(srgb 0.02745 0.78039 0.92941 / 0.5), color(srgb 0.98824 0.23922 0.6 / 1))\n&gt;&gt;&gt; c1.compose(c2, operator='destination-over', space=\"srgb\")\ncolor(srgb 0.98824 0.23922 0.6 / 1)\n</code></pre> c1 = Color('#07c7ed').set('alpha', 0.5) c2 = Color('#fc3d99') c1, c2 c1.compose(c2, operator='destination-over', space=\"srgb\") Edit Share Run Cancel <p>You can also apply alpha compositing to multiple layers at once. Simply send in a list of colors as the backdrop, and the colors will be composed from right to left with the right most color being on the bottom of the stack and the base color (the source) being on the very top.</p> <p>Here we are using the normal blend mode and 50% transparency on all the circles with an opaque white background. We will calculate the center color where all three layers overlap.</p> Display P3sRGB <pre><code>&gt;&gt;&gt; c1 = Color('#07c7ed').set('alpha', 0.5)\n&gt;&gt;&gt; c2 = Color('#fc3d99').set('alpha', 0.5)\n&gt;&gt;&gt; c3 = Color('#f5d311').set('alpha', 0.5)\n&gt;&gt;&gt; bg = Color('white')\n&gt;&gt;&gt; c1, c2, c3, bg\n(color(srgb 0.02745 0.78039 0.92941 / 0.5), color(srgb 0.98824 0.23922 0.6 / 0.5), color(srgb 0.96078 0.82745 0.06667 / 0.5), color(srgb 1 1 1 / 1))\n&gt;&gt;&gt; c1.compose([c2, c3, bg], blend='normal', space=\"display-p3\")\ncolor(srgb 0.63703 0.69225 0.77313 / 1)\n</code></pre> c1 = Color('#07c7ed').set('alpha', 0.5) c2 = Color('#fc3d99').set('alpha', 0.5) c3 = Color('#f5d311').set('alpha', 0.5) bg = Color('white') c1, c2, c3, bg c1.compose([c2, c3, bg], blend='normal', space=\"display-p3\") Edit Share Run Cancel <pre><code>&gt;&gt;&gt; c1 = Color('#07c7ed').set('alpha', 0.5)\n&gt;&gt;&gt; c2 = Color('#fc3d99').set('alpha', 0.5)\n&gt;&gt;&gt; c3 = Color('#f5d311').set('alpha', 0.5)\n&gt;&gt;&gt; bg = Color('white')\n&gt;&gt;&gt; c1, c2, c3, bg\n(color(srgb 0.02745 0.78039 0.92941 / 0.5), color(srgb 0.98824 0.23922 0.6 / 0.5), color(srgb 0.96078 0.82745 0.06667 / 0.5), color(srgb 1 1 1 / 1))\n&gt;&gt;&gt; c1.compose([c2, c3, bg], blend='normal', space=\"srgb\")\ncolor(srgb 0.50588 0.67843 0.74804 / 1)\n</code></pre> c1 = Color('#07c7ed').set('alpha', 0.5) c2 = Color('#fc3d99').set('alpha', 0.5) c3 = Color('#f5d311').set('alpha', 0.5) bg = Color('white') c1, c2, c3, bg c1.compose([c2, c3, bg], blend='normal', space=\"srgb\") Edit Share Run Cancel <p>Lastly, if for any reason, it is desired to run compose with alpha compositing disabled (e.g. just run blending), then you can simply set <code>operator</code> to <code>False</code>.</p> <p>Check out Compositing Operators to learn about the many variations that are supported.</p>"},{"location":"compositing/#complex-compositing","title":"Complex Compositing","text":"<p>We've covered alpha compositing and blending and have demonstrated their use with simple two color examples and  multi-layered examples, but what about different blend modes mixed with alpha compositing?</p> <p>In this example, we will consider three circles, each with a unique color: <code>#07c7ed</code>, <code>#fc3d99</code>, and <code>#f5d311</code>. We apply 50% transparency to all the circles and place them on a <code>white</code> background. We then perform a <code>multiply</code> blend on all the circles but isolate them so the <code>multiply</code> blend does not apply to the background. The circles are all represented with CSS. We will now try and replicate the colors with ColorAide.</p> <p>So in the code below, we work our way from the bottom of the stack to the top. Since the background is isolated from the <code>multiply</code> blending, in each region, we start by performing a <code>normal</code> blend on the bottom circle against the background. We then apply <code>multiply</code> blending on each color that is stacked on top. We've provided both the P3 and sRGB outputs to make it easy to compare in case your browser blends in one instead of the other.</p> Display P3sRGB <pre><code>&gt;&gt;&gt; c1 = Color('#07c7ed').set('alpha', 0.5)\n&gt;&gt;&gt; c2 = Color('#fc3d99').set('alpha', 0.5)\n&gt;&gt;&gt; c3 = Color('#f5d311').set('alpha', 0.5)\n&gt;&gt;&gt; cw2 = c2.compose('white', blend='normal', space='display-p3')\n&gt;&gt;&gt; cw3 = c3.compose('white', blend='normal', space='display-p3')\n&gt;&gt;&gt; r1 = c2.compose(cw3, blend='multiply', space='display-p3')\n&gt;&gt;&gt; r2 = c1.compose(cw2, blend='multiply', space='display-p3')\n&gt;&gt;&gt; r3 = c1.compose(cw3, blend='multiply', space='display-p3')\n&gt;&gt;&gt; r1, r2, r3\n(color(srgb 0.98122 0.58007 0.49257 / 1), color(srgb 0.66117 0.57542 0.77558 / 1), color(srgb 0.61489 0.8159 0.59659 / 1))\n&gt;&gt;&gt; c1.compose([c2, cw3], blend='multiply', space='display-p3')\ncolor(srgb 0.64659 0.52543 0.48429 / 1)\n</code></pre> c1 = Color('#07c7ed').set('alpha', 0.5) c2 = Color('#fc3d99').set('alpha', 0.5) c3 = Color('#f5d311').set('alpha', 0.5)  cw2 = c2.compose('white', blend='normal', space='display-p3') cw3 = c3.compose('white', blend='normal', space='display-p3')  r1 = c2.compose(cw3, blend='multiply', space='display-p3') r2 = c1.compose(cw2, blend='multiply', space='display-p3') r3 = c1.compose(cw3, blend='multiply', space='display-p3')  r1, r2, r3  c1.compose([c2, cw3], blend='multiply', space='display-p3') Edit Share Run Cancel <pre><code>&gt;&gt;&gt; c1 = Color('#07c7ed').set('alpha', 0.5)\n&gt;&gt;&gt; c2 = Color('#fc3d99').set('alpha', 0.5)\n&gt;&gt;&gt; c3 = Color('#f5d311').set('alpha', 0.5)\n&gt;&gt;&gt; cw2 = c2.compose('white', blend='normal', space='srgb')\n&gt;&gt;&gt; cw3 = c3.compose('white', blend='normal', space='srgb')\n&gt;&gt;&gt; r1 = c2.compose(cw3, blend='multiply', space='srgb')\n&gt;&gt;&gt; r2 = c1.compose(cw2, blend='multiply', space='srgb')\n&gt;&gt;&gt; r3 = c1.compose(cw3, blend='multiply', space='srgb')\n&gt;&gt;&gt; r1, r2, r3\n(color(srgb 0.97463 0.56615 0.42667 / 1), color(srgb 0.5107 0.55157 0.77176 / 1), color(srgb 0.50365 0.81339 0.51451 / 1))\n&gt;&gt;&gt; c1.compose([c2, cw3], blend='multiply', space='srgb')\ncolor(srgb 0.50069 0.50399 0.41161 / 1)\n</code></pre> c1 = Color('#07c7ed').set('alpha', 0.5) c2 = Color('#fc3d99').set('alpha', 0.5) c3 = Color('#f5d311').set('alpha', 0.5)  cw2 = c2.compose('white', blend='normal', space='srgb') cw3 = c3.compose('white', blend='normal', space='srgb')  r1 = c2.compose(cw3, blend='multiply', space='srgb') r2 = c1.compose(cw2, blend='multiply', space='srgb') r3 = c1.compose(cw3, blend='multiply', space='srgb')  r1, r2, r3  c1.compose([c2, cw3], blend='multiply', space='srgb') Edit Share Run Cancel <p>Results may vary depending on the browser, but we can see (ignoring rounding differences) that the colors match up. This was performed on Chrome in macOS using a display that uses <code>display-p3</code>.</p> <p></p>"},{"location":"compositing/#blend-modes","title":"Blend Modes","text":""},{"location":"compositing/#normal","title":"Normal","text":"<p>The blending formula simply selects the source color.</p> <p>Specified as <code>'normal'</code>.</p>"},{"location":"compositing/#multiply","title":"Multiply","text":"<p>The source color is multiplied by the destination color and replaces the destination. The resultant color is always at least as dark as either the source or destination color. Multiplying any color with black results in black. Multiplying any color with white preserves the original color.</p> <p>Specified as <code>'multiply'</code>.</p>"},{"location":"compositing/#screen","title":"Screen","text":"<p>Multiplies the complements of the backdrop and source color values, then complements the result. The result color is always at least as light as either of the two constituent colors. Screening any color with white produces white; screening with black leaves the original color unchanged. The effect is similar to projecting multiple photographic slides simultaneously onto a single screen.</p> <p>Specified as <code>'screen'</code>.</p>"},{"location":"compositing/#overlay","title":"Overlay","text":"<p>Multiplies or screens the colors, depending on the backdrop color value. Source colors overlay the backdrop while preserving its highlights and shadows. The backdrop color is not replaced but is mixed with the source color to reflect the lightness or darkness of the backdrop.</p> <p>Specified as <code>'overlay'</code>.</p>"},{"location":"compositing/#darken","title":"Darken","text":"<p>Selects the darker of the backdrop and source colors. The backdrop is replaced with the source where the source is darker; otherwise, it is left unchanged.</p> <p>Specified as <code>'darken'</code>.</p>"},{"location":"compositing/#lighten","title":"Lighten","text":"<p>Selects the lighter of the backdrop and source colors. The backdrop is replaced with the source where the source is lighter; otherwise, it is left unchanged.</p> <p>Specified as <code>'lighten'</code>.</p>"},{"location":"compositing/#color-dodge","title":"Color Dodge","text":"<p>Brightens the backdrop color to reflect the source color. Painting with black produces no changes.</p> <p>Specified as <code>'color-dodge'</code>.</p>"},{"location":"compositing/#color-burn","title":"Color Burn","text":"<p>Darkens the backdrop color to reflect the source color. Painting with white produces no change.</p> <p>Specified as <code>'color-burn'</code>.</p>"},{"location":"compositing/#hard-light","title":"Hard Light","text":"<p>Multiplies or screens the colors, depending on the source color value. The effect is similar to shining a harsh spotlight on the backdrop.</p> <p>Specified as <code>'hard-light'</code>.</p>"},{"location":"compositing/#soft-light","title":"Soft Light","text":"<p>Darkens or lightens the colors, depending on the source color value. The effect is similar to shining a diffused spotlight on the backdrop.</p> <p>Specified as <code>'soft-light'</code>.</p>"},{"location":"compositing/#difference","title":"Difference","text":"<p>Subtracts the darker of the two constituent colors from the lighter color. Painting with white inverts the backdrop color; painting with black produces no change.</p> <p>Specified as <code>'difference'</code>.</p>"},{"location":"compositing/#exclusion","title":"Exclusion","text":"<p>Produces an effect similar to that of the Difference mode but lower in contrast. Painting with white inverts the backdrop color; painting with black produces no change.</p> <p>Specified as <code>'exclusion'</code>.</p>"},{"location":"compositing/#hue","title":"Hue","text":"<p>Creates a color with the hue of the source color and the saturation and luminosity of the backdrop color.</p> <p>Specified as <code>'hue'</code>.</p>"},{"location":"compositing/#saturation","title":"Saturation","text":"<p>Creates a color with the saturation of the source color and the hue and luminosity of the backdrop color. Painting with this mode in an area of the backdrop that is a pure gray (no saturation) produces no change.</p> <p>Specified as <code>'saturation'</code>.</p>"},{"location":"compositing/#luminosity","title":"Luminosity","text":"<p>Creates a color with the luminosity of the source color and the hue and saturation of the backdrop color. This produces an inverse effect to that of the Color mode. This mode is the one you can use to create monochrome \"tinted\" image effects like the ones you can see in different website headers.</p> <p>Specified as <code>'luminosity'</code>.</p>"},{"location":"compositing/#color","title":"Color","text":"<p>Creates a color with the hue and saturation of the source color and the luminosity of the backdrop color. This preserves the gray levels of the backdrop and is useful for coloring monochrome images or tinting color images.</p> <p>Specified as <code>'color'</code>.</p>"},{"location":"compositing/#compositing-operators","title":"Compositing Operators","text":""},{"location":"compositing/#clear","title":"Clear","text":"<p>No regions are enabled.</p> Source Destination Result <p>Specified as <code>'clear'</code>.</p>"},{"location":"compositing/#copy","title":"Copy","text":"<p>Only the source will be present.</p> Source Destination Result <p>Specified as <code>'copy'</code>.</p>"},{"location":"compositing/#destination","title":"Destination","text":"<p>Only the destination will be present.</p> Source Destination Result <p>Specified as <code>'destination'</code>.</p>"},{"location":"compositing/#source-over","title":"Source Over","text":"<p>Source is placed over the destination.</p> Source Destination Result <p>Specified as <code>'source-over'</code>.</p>"},{"location":"compositing/#destination-over","title":"Destination Over","text":"<p>Destination is placed over the source.</p> Source Destination Result <p>Specified as <code>'destination-over'</code>.</p>"},{"location":"compositing/#source-in","title":"Source In","text":"<p>The source that overlaps the destination, replaces the destination.</p> Source Destination Result <p>Specified as <code>'source-in'</code>.</p>"},{"location":"compositing/#destination-in","title":"Destination In","text":"<p>Destination which overlaps the source, replaces the source.</p> Source Destination Result <p>Specified as <code>'destination-in'</code>.</p>"},{"location":"compositing/#source-out","title":"Source Out","text":"<p>Source is placed, where it falls outside of the destination.</p> Source Destination Result <p>Specified as <code>'source-out'</code>.</p>"},{"location":"compositing/#destination-out","title":"Destination Out","text":"<p>Destination is placed, where it falls outside of the source.</p> Source Destination Result <p>Specified as <code>'destination-out'</code>.</p>"},{"location":"compositing/#source-atop","title":"Source Atop","text":"<p>Source which overlaps the destination, replaces the destination. Destination is placed elsewhere.</p> Source Destination Result <p>Specified as <code>'source-atop'</code>.</p>"},{"location":"compositing/#destination-atop","title":"Destination Atop","text":"<p>Destination which overlaps the source replaces the source. Source is placed elsewhere.</p> Source Destination Result <p>Specified as <code>'destination-atop'</code>.</p>"},{"location":"compositing/#xor","title":"XOR","text":"<p>Destination which overlaps the source replaces the source. Source is placed elsewhere.</p> Source Destination Result <p>Specified as <code>'xor'</code>.</p>"},{"location":"compositing/#lighter","title":"Lighter","text":"<p>Display the sum of the source image and destination image.</p> Source Destination Result <p>Specified as <code>'lighter'</code>.</p>  img.trans-bg {   background-color: var(--swatch-bg-color);   background-image: linear-gradient(45deg,var(--swatch-bg-alt-color) 25%,transparent 25%),linear-gradient(-45deg,var(--swatch-bg-alt-color) 25%,transparent 25%),linear-gradient(45deg,transparent 75%,var(--swatch-bg-alt-color) 75%),linear-gradient(-45deg,transparent 75%, var(--swatch-bg-alt-color) 75%);   background-position: 0 0,0 0.49em,0.49em -0.49em,-0.49em 0;   background-size: 1em 1em; }   .info-container {display: inline-block;}"},{"location":"contrast/","title":"Contrast","text":"<p>ColorAide provides a number of utilities related to luminance and contrast.</p>"},{"location":"contrast/#relative-luminance","title":"Relative Luminance","text":"<p>In the CIE XYZ and xyY color spaces, the Y parameter is linear to changes in the volume of light. Specifically this refers to the amount of reflected light where 1.0 is assumed to be a perfect reflector in relation to the reference white.</p> <p>The <code>luminance</code> method exposes access to this value to make it quick and easy to query the relative luminance, or Y parameter from XYZ D65 after converting the current color.</p> <pre><code>&gt;&gt;&gt; Color(\"black\").luminance()\n0.0\n&gt;&gt;&gt; Color(\"white\").luminance()\n1.0\n&gt;&gt;&gt; Color(\"blue\").luminance()\n0.07219231536073371\n</code></pre> Color(\"black\").luminance() Color(\"white\").luminance() Color(\"blue\").luminance() Edit Share Run Cancel <p>Luminance and WCAG 2.1</p> <p>Luminance as described in the WCAG 2.1 spec is essentially the exact same as what the luminance method returns. The only difference is the lower precision by which they calculate the value:</p> <pre><code>&gt;&gt;&gt; r, g, b = Color('purple')[:-1]\n&gt;&gt;&gt; r = r / 12.92 if r &lt;= 0.03928 else ((r + 0.055) / 1.055) ** 2.4\n&gt;&gt;&gt; g = g / 12.92 if g &lt;= 0.03928 else ((g + 0.055) / 1.055) ** 2.4\n&gt;&gt;&gt; b = b / 12.92 if b &lt;= 0.03928 else ((b + 0.055) / 1.055) ** 2.4\n&gt;&gt;&gt; l = (0.2126 * r + 0.7152 * g + 0.0722 * b)\n&gt;&gt;&gt; print(l)\n0.06147707043243851\n&gt;&gt;&gt; Color('purple').convert('xyz-d65')['y']\n0.06148383144929487\n</code></pre> r, g, b = Color('purple')[:-1] r = r / 12.92 if r &lt;= 0.03928 else ((r + 0.055) / 1.055) ** 2.4 g = g / 12.92 if g &lt;= 0.03928 else ((g + 0.055) / 1.055) ** 2.4 b = b / 12.92 if b &lt;= 0.03928 else ((b + 0.055) / 1.055) ** 2.4 l = (0.2126 * r + 0.7152 * g + 0.0722 * b) print(l) Color('purple').convert('xyz-d65')['y'] Edit Share Run Cancel"},{"location":"contrast/#contrast_1","title":"Contrast","text":"<p>There have actually been numerous approaches to determining reliable contrast. ColorAide currently only implements the color contrast ratio as outlined in the WCAG 2.1 spec, but has done so as a plugin to allow for expanding implementations in the future to allow for more reliable approaches as the WCAG 2.1 approach is not without flaws.</p> <p>It should be noted that as we talk about contrast, we will refer to the colors as the text and background as this is generally the context in which such a function is used. The text is always the calling color and the background is the input parameter. Not all contrast algorithms care about such details, but it is important to note as some future algorithms assuredly will.</p> <pre><code>text.contrast(background)\n</code></pre> <p>While in all normal circumstances a negative luminance should not occur, if one does occur, the luminance will be clamped to zero.</p> <p><pre><code># Where `l1` is the lighter luminance and `l2` the darker\ncontrast_ratio = (l1 + 0.05) / (l2 + 0.05)\n</code></pre> To get the this contrast ratio between two colors, simply pass in the second color:</p> <pre><code>&gt;&gt;&gt; Color(\"blue\").contrast(\"red\")\n2.149390533243867\n</code></pre> Color(\"blue\").contrast(\"red\") Edit Share Run Cancel <p>Distancing and Symmetry</p> <p>It should be noted that not all contrast algorithms are symmetrical. Some are order dependent.</p> Methods Symmetrical Description <code>wcag21</code> WCAG 2.1 contrast ratio. <p>To use different methods, simply specify the method via the <code>method</code> parameter:</p> <pre><code>&gt;&gt;&gt; Color(\"blue\").contrast(\"red\", method='wcag21')\n2.149390533243867\n</code></pre> Color(\"blue\").contrast(\"red\", method='wcag21') Edit Share Run Cancel"},{"location":"distance/","title":"Color Distance and Delta E","text":"<p>The difference or distance between two colors allows for a quantified analysis of how far apart two colors are from one another. This metric is of particular interest in the field of color science, but it has practical applications in color libraries working with colors.</p> <p>Usually, color distance is applied to near perceptual uniform color spaces in order to obtain a metric regarding a color's visual, perceptual distance from another color. This can be useful in gamut mapping or even determining that colors are close enough or far enough away from each other.</p>"},{"location":"distance/#color-distance","title":"Color Distance","text":"<p>ColorAide provides a simple euclidean color distance function. By default, it evaluates the distance in the CIELab color space, but it can be configured to evaluate in any color space, such as Oklab, etc. It may be less useful in some color spaces compared to others. Some spaces may not be well suited, such as cylindrical spaces. Some spaces might not be as very perceptually uniform as others requiring more complex algorithms.</p> <pre><code>&gt;&gt;&gt; Color(\"red\").distance(\"blue\", space=\"srgb\")\n1.4142135623730951\n&gt;&gt;&gt; Color(\"red\").distance(\"blue\", space=\"lab\")\n184.0190486209969\n</code></pre> Color(\"red\").distance(\"blue\", space=\"srgb\") Color(\"red\").distance(\"blue\", space=\"lab\") Edit Share Run Cancel"},{"location":"distance/#delta-e","title":"Delta E","text":"<p>The <code>delta_e</code> function gives access to various \u2206E implementations, which are just different algorithms to calculate distance. Some are simply Euclidean distance withing a certain color space, some are far more complex.</p> <p>If no <code>method</code> is specified, the default implementation is \u2206E*ab (CIE76) which uses a simple Euclidean distancing algorithm on the CIELab color space. It is fast, but not as accurate as later iterations of the algorithm as CIELab is not actually as perceptually uniform as it was thought when CIELab was originally developed.</p> <pre><code>&gt;&gt;&gt; Color(\"red\").delta_e(\"blue\")\n176.3084955965824\n</code></pre> Color(\"red\").delta_e(\"blue\") Edit Share Run Cancel <p>When <code>method</code> is set, the specified \u2206E algorithm will be used instead. For instance, below we use \u2206E00 which is a more complex algorithm that accounts for the CIELab's weakness in perceptually uniformity. It does come at the cost of being a little slower.</p> <pre><code>&gt;&gt;&gt; Color(\"red\").delta_e(\"blue\", method=\"2000\")\n52.87819528592645\n</code></pre> Color(\"red\").delta_e(\"blue\", method=\"2000\") Edit Share Run Cancel <p>Distancing and Symmetry</p> <p>It should be noted that not all distancing algorithms are symmetrical. Some are order dependent.</p> <p>Below are all the supported \u2206E methods that are included in the default <code>coloraide.Color</code> object. Follow relevant links to read the specs and find out more about a given \u2206E method.</p> Delta\u00a0E Symmetrical Name Parameters \u2206E*ab\u00a0(CIE76) <code>76</code> \u2206E*cmc\u00a0(CMC\u00a0l:c\u00a0(1984)) <code>cmc</code> <code>l=2, c=1</code> \u2206E*94\u00a0(CIE94) <code>94</code> <code>kl=1, k1=0.045, k2=0.015</code> \u2206E*00\u00a0(CIEDE2000) <code>2000</code> <code>kl=1, kc=1, kh=1</code> \u2206EHyAB\u00a0(HyAB) <code>hyab</code> <code>space=\"lab-d65\"</code> \u2206Eok <code>ok</code> <code>scalar=1</code> <p>The following are also available, but they must be manually registered by creating a custom class, or can be accessed by use <code>coloraide.everything.ColorAll</code> instead of <code>coloraide.Color</code>. The associated color space must be registered as well.</p> Delta\u00a0E Symmetrical Name Parameters \u2206Eitp\u00a0(ICtCp) <code>itp</code> <code>scalar=720</code> \u2206Ez\u00a0(Jzazbz) <code>jz</code> \u2206E99o\u00a0(DIN99o) <code>99o</code>"},{"location":"distance/#finding-closest-color","title":"Finding Closest Color","text":"<p>ColorAide implements a simple way to find the closest color, given a list of colors, to another color. The method is called <code>closest</code> and takes a list of colors that are to be compared to the calling color object. The first color with the smallest distance between the calling color object and itself will be considered the nearest/closest color.</p> <p>Consider the following example. Here we provide a list of colors to compare against <code>red</code>. After comparing all the colors, the closest ends up being <code>maroon</code>.</p> <pre><code>&gt;&gt;&gt; Color('red').closest(['pink', 'yellow', 'green', 'blue', 'purple', 'maroon'])\ncolor(srgb 0.50196 0 0 / 1)\n</code></pre> Color('red').closest(['pink', 'yellow', 'green', 'blue', 'purple', 'maroon']) Edit Share Run Cancel <p>The default distancing method is used if one is not supplied, but others can be used:</p> <pre><code>&gt;&gt;&gt; Color('red').closest(['pink', 'yellow', 'green', 'blue', 'purple', 'maroon'], method='2000')\ncolor(srgb 0.50196 0 0 / 1)\n</code></pre> Color('red').closest(['pink', 'yellow', 'green', 'blue', 'purple', 'maroon'], method='2000') Edit Share Run Cancel"},{"location":"filters/","title":"Filters","text":"<p>ColorAide implements a number of filters implemented as plugins. The first set of filters mirror those found in the W3C Filter Effects Module Level 1 specification, specifically the filters that directly apply to colors. The second set of filters simulate color vision deficiencies.</p>"},{"location":"filters/#w3c-filter-effects","title":"W3C Filter Effects","text":"<p>The following filters are all supported in ColorAide and generally adhere to the specification in regards to behavior. By default, filters are applied in the Linear sRGB color space, but can be applied in sRGB if requested. All other color spaces will throw an error.</p> NormalBrightnessSaturateContrastOpacityInvertHue RotateSepiaGrayscale <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p>In ColorAide, just call the <code>filter</code> method and provide the name of the filter. If <code>amount</code> is not provided, the default according to the W3C spec will be used instead.</p> <pre><code>&gt;&gt;&gt; inputs = ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet']\n&gt;&gt;&gt; colors = Color.steps(inputs, steps=10, space='srgb')\n&gt;&gt;&gt; HtmlRow(colors)\n[color(srgb 1 0 0 / 1), color(srgb 1 0.43137 0 / 1), color(srgb 1 0.76471 0 / 1), color(srgb 1 1 0 / 1), color(srgb 0.33333 0.66797 0 / 1), color(srgb 0 0.33464 0.33333 / 1), color(srgb 0 0 1 / 1), color(srgb 0.19608 0 0.6732 / 1), color(srgb 0.50719 0.16993 0.65098 / 1), color(srgb 0.93333 0.5098 0.93333 / 1)]\n&gt;&gt;&gt; HtmlRow([c.filter('brightness', 0.5).clip() for c in colors])\n[color(srgb 0.73536 0 0 / 1), color(srgb 0.73536 0.30937 0 / 1), color(srgb 0.73536 0.55909 0 / 1), color(srgb 0.73536 0.73536 0 / 1), color(srgb 0.23592 0.48662 0 / 1), color(srgb 0 0.2369 0.23592 / 1), color(srgb 0 0 0.73536 / 1), color(srgb 0.1331 0 0.49054 / 1), color(srgb 0.36617 0.11351 0.47389 / 1), color(srgb 0.68541 0.36812 0.68541 / 1)]\n&gt;&gt;&gt; HtmlRow([c.filter('saturate', 0.5).clip() for c in colors])\n[color(srgb 0.80157 0.35994 0.35994 / 1), color(srgb 0.83354 0.52732 0.43949 / 1), color(srgb 0.90713 0.78242 0.58525 / 1), color(srgb 0.98401 0.98401 0.71113 / 1), color(srgb 0.48389 0.63095 0.42887 / 1), color(srgb 0.20909 0.31673 0.31603 / 1), color(srgb 0.20907 0.20907 0.75859 / 1), color(srgb 0.20327 0.14367 0.51016 / 1), color(srgb 0.43195 0.26768 0.52372 / 1), color(srgb 0.81475 0.59544 0.81475 / 1)]\n&gt;&gt;&gt; HtmlRow([c.filter('contrast', 1.2).clip() for c in colors])\n[color(srgb 1 0 0 / 1), color(srgb 1 0.32661 0 / 1), color(srgb 1 0.7704 0 / 1), color(srgb 1 1 0 / 1), color(srgb 0.09327 0.6534 0 / 1), color(srgb 0 0.09916 0.09327 / 1), color(srgb 0 0 1 / 1), color(srgb 0 0 0.65985 / 1), color(srgb 0.44285 0 0.63233 / 1), color(srgb 0.96674 0.44657 0.96674 / 1)]\n&gt;&gt;&gt; HtmlRow([c.filter('opacity', 0.5).clip() for c in colors])\n[color(srgb 1 0 0 / 0.5), color(srgb 1 0.43137 0 / 0.5), color(srgb 1 0.76471 0 / 0.5), color(srgb 1 1 0 / 0.5), color(srgb 0.33333 0.66797 0 / 0.5), color(srgb 0 0.33464 0.33333 / 0.5), color(srgb 0 0 1 / 0.5), color(srgb 0.19608 0 0.6732 / 0.5), color(srgb 0.50719 0.16993 0.65098 / 0.5), color(srgb 0.93333 0.5098 0.93333 / 0.5)]\n&gt;&gt;&gt; HtmlRow([c.filter('invert', 1).clip() for c in colors])\n[color(srgb 0 1 1 / 1), color(srgb 0 0.92805 1 / 1), color(srgb 0 0.7044 1 / 1), color(srgb 0 0 1 / 1), color(srgb 0.95896 0.79553 1 / 1), color(srgb 1 0.95861 0.95896 / 1), color(srgb 1 1 0 / 1), color(srgb 0.98585 1 0.79133 / 1), color(srgb 0.89586 0.98915 0.8087 / 1), color(srgb 0.41688 0.8946 0.41688 / 1)]\n&gt;&gt;&gt; HtmlRow([c.filter('hue-rotate', 90).clip() for c in colors])\n[color(srgb 0 0.63105 0 / 1), color(srgb 0 0.72828 0 / 1), color(srgb 0 0.91755 0.49164 / 1), color(srgb 0 1 0.93382 / 1), color(srgb 0 0.64804 0.75171 / 1), color(srgb 0.33333 0.26972 0.41556 / 1), color(srgb 1 0 0.41551 / 1), color(srgb 0.6732 0 0.22332 / 1), color(srgb 0.65098 0.14767 0 / 1), color(srgb 0.93333 0.59681 0 / 1)]\n&gt;&gt;&gt; HtmlRow([c.filter('sepia', 1).clip() for c in colors])\n[color(srgb 0.65991 0.6254 0.55828 / 1), color(srgb 0.7438 0.70557 0.63046 / 1), color(srgb 0.91264 0.86683 0.77568 / 1), color(srgb 1 1 0.90933 / 1), color(srgb 0.62309 0.59145 0.52742 / 1), color(srgb 0.32748 0.3096 0.27351 / 1), color(srgb 0.47196 0.44672 0.39732 / 1), color(srgb 0.33214 0.31357 0.27727 / 1), color(srgb 0.45856 0.43394 0.38572 / 1), color(srgb 0.83745 0.79487 0.71097 / 1)]\n&gt;&gt;&gt; HtmlRow([c.filter('grayscale', 1).clip() for c in colors])\n[color(srgb 0.49844 0.49844 0.49844 / 1), color(srgb 0.60475 0.60475 0.60475 / 1), color(srgb 0.79945 0.79945 0.79945 / 1), color(srgb 0.96757 0.96757 0.96757 / 1), color(srgb 0.59093 0.59093 0.59093 / 1), color(srgb 0.2976 0.2976 0.2976 / 1), color(srgb 0.29789 0.29789 0.29789 / 1), color(srgb 0.2104 0.2104 0.2104 / 1), color(srgb 0.33536 0.33536 0.33536 / 1), color(srgb 0.66755 0.66755 0.66755 / 1)]\n</code></pre> inputs = ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet'] colors = Color.steps(inputs, steps=10, space='srgb') HtmlRow(colors) HtmlRow([c.filter('brightness', 0.5).clip() for c in colors]) HtmlRow([c.filter('saturate', 0.5).clip() for c in colors]) HtmlRow([c.filter('contrast', 1.2).clip() for c in colors]) HtmlRow([c.filter('opacity', 0.5).clip() for c in colors]) HtmlRow([c.filter('invert', 1).clip() for c in colors]) HtmlRow([c.filter('hue-rotate', 90).clip() for c in colors]) HtmlRow([c.filter('sepia', 1).clip() for c in colors]) HtmlRow([c.filter('grayscale', 1).clip() for c in colors]) Edit Share Run Cancel"},{"location":"filters/#color-vision-deficiency-simulation","title":"Color Vision Deficiency Simulation","text":"<p>Color blindness or color vision deficiency (CVD) affects approximately 1 in 12 men (8%) and 1 in 200 women. CVD affects millions of people in the world, and many people have no idea that they are color blind and not seeing the full spectrum that others see.</p> <p>CVD simulation allows those who do not suffer with one of the many different variations of color blindness, to simulate what someone with a CVD would see. Keep in mind that these are just approximations, and that a given type of CVD can be quite different from person to person in severity.</p> <p>The human eye has 3 types of cones that are used to perceive colors. Each of these cones can become deficient, either through genetics, or other means. Each type of cone is responsible for perceiving either red, green, or blue colors. A CVD occurs when one or more of these cones are missing or not functioning properly. There are severe cases where one of the three cones will not perceive color at all, and there are others were the cones may just be less sensitive.</p>"},{"location":"filters/#dichromacy","title":"Dichromacy","text":"<p>Dichromacy is a type of CVD that has the characteristics of essentially causing the person to only have two functioning cones for perceiving colors. This essentially flattens the color spectrum into a 2D plane. Protanopia describes the CVD where the cone responsible for red light does not function, deuteranopia describes the CVD affecting the green cone, and tritanopia describes deficiencies with the blue cone.</p> NormalProtanopiaDeuteranopiaTritanopia <p></p> <p></p> <p></p> <p></p> <p>By default, ColorAide uses the Brettel 1997 method to simulate tritanopia and the Vi\u00e9not, Brettel, and Mollon 1999 approach to simulate protanopia and and deuteranopia. While Brettel is probably the best approach for all cases, Vi\u00e9not is much faster and does quite well for protanopia and deuteranopia.</p> <pre><code>&gt;&gt;&gt; inputs = ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet']\n&gt;&gt;&gt; colors = Color.steps(inputs, steps=10, space='srgb')\n&gt;&gt;&gt; HtmlRow(colors)\n[color(srgb 1 0 0 / 1), color(srgb 1 0.43137 0 / 1), color(srgb 1 0.76471 0 / 1), color(srgb 1 1 0 / 1), color(srgb 0.33333 0.66797 0 / 1), color(srgb 0 0.33464 0.33333 / 1), color(srgb 0 0 1 / 1), color(srgb 0.19608 0 0.6732 / 1), color(srgb 0.50719 0.16993 0.65098 / 1), color(srgb 0.93333 0.5098 0.93333 / 1)]\n&gt;&gt;&gt; HtmlRow([c.filter('protan').clip() for c in colors])\n[color(srgb 0.36376 0.36376 0.05572 / 1), color(srgb 0.53494 0.53494 0.04817 / 1), color(srgb 0.79488 0.79488 0.02624 / 1), color(srgb 1 1 0 / 1), color(srgb 0.6419 0.6419 0 / 1), color(srgb 0.31637 0.31637 0.3326 / 1), color(srgb 0 0 1 / 1), color(srgb 0.04466 0.04466 0.67331 / 1), color(srgb 0.2371 0.2371 0.65166 / 1), color(srgb 0.57669 0.57669 0.93469 / 1)]\n&gt;&gt;&gt; HtmlRow([c.filter('deutan').clip() for c in colors])\n[color(srgb 0.57511 0.57511 0 / 1), color(srgb 0.66589 0.66589 0 / 1), color(srgb 0.84206 0.84206 0 / 1), color(srgb 1 1 0 / 1), color(srgb 0.59514 0.59514 0.07745 / 1), color(srgb 0.28277 0.28277 0.33689 / 1), color(srgb 0 0 1 / 1), color(srgb 0.09496 0.09496 0.67268 / 1), color(srgb 0.3161 0.3161 0.64764 / 1), color(srgb 0.67012 0.67012 0.92662 / 1)]\n&gt;&gt;&gt; HtmlRow([c.filter('tritan').clip() for c in colors])\n[color(srgb 1 0 0.3076 / 1), color(srgb 1 0.38816 0.48865 / 1), color(srgb 1 0.71252 0.74852 / 1), color(srgb 1 0.93755 0.94959 / 1), color(srgb 0.44366 0.61688 0.68363 / 1), color(srgb 0.07188 0.32489 0.39021 / 1), color(srgb 0 0.37542 0.5281 / 1), color(srgb 0 0.24684 0.32622 / 1), color(srgb 0.44629 0.295 0.31173 / 1), color(srgb 0.88848 0.58545 0.61964 / 1)]\n</code></pre> inputs = ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet'] colors = Color.steps(inputs, steps=10, space='srgb') HtmlRow(colors) HtmlRow([c.filter('protan').clip() for c in colors]) HtmlRow([c.filter('deutan').clip() for c in colors]) HtmlRow([c.filter('tritan').clip() for c in colors]) Edit Share Run Cancel <p>If desired, any of the three available methods can be used. Brettel is usually considered best option for accuracy. Vi\u00e9not is faster and does quite well for protanopia and deuteranopia, but is not quite as accurate for tritanopia. Machado 2009 has better logic for severity ranges less than 1, but is probably even further off for tritanopia.</p> <pre><code>&gt;&gt;&gt; inputs = ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet']\n&gt;&gt;&gt; colors = Color.steps(inputs, steps=10, space='srgb')\n&gt;&gt;&gt; HtmlRow(colors)\n[color(srgb 1 0 0 / 1), color(srgb 1 0.43137 0 / 1), color(srgb 1 0.76471 0 / 1), color(srgb 1 1 0 / 1), color(srgb 0.33333 0.66797 0 / 1), color(srgb 0 0.33464 0.33333 / 1), color(srgb 0 0 1 / 1), color(srgb 0.19608 0 0.6732 / 1), color(srgb 0.50719 0.16993 0.65098 / 1), color(srgb 0.93333 0.5098 0.93333 / 1)]\n&gt;&gt;&gt; HtmlRow([c.filter('tritan', method='brettel').clip() for c in colors])\n[color(srgb 1 0 0.3076 / 1), color(srgb 1 0.38816 0.48865 / 1), color(srgb 1 0.71252 0.74852 / 1), color(srgb 1 0.93755 0.94959 / 1), color(srgb 0.44366 0.61688 0.68363 / 1), color(srgb 0.07188 0.32489 0.39021 / 1), color(srgb 0 0.37542 0.5281 / 1), color(srgb 0 0.24684 0.32622 / 1), color(srgb 0.44629 0.295 0.31173 / 1), color(srgb 0.88848 0.58545 0.61964 / 1)]\n&gt;&gt;&gt; HtmlRow([c.filter('tritan', method='vienot').clip() for c in colors])\n[color(srgb 1 0 0 / 1), color(srgb 1 0.40333 0.40333 / 1), color(srgb 1 0.71744 0.71744 / 1), color(srgb 1 0.93916 0.93916 / 1), color(srgb 0.42673 0.62628 0.62628 / 1), color(srgb 0.00145 0.33447 0.33447 / 1), color(srgb 0 0.39998 0.39998 / 1), color(srgb 0 0.25904 0.25904 / 1), color(srgb 0.44469 0.29729 0.29729 / 1), color(srgb 0.88533 0.59014 0.59014 / 1)]\n&gt;&gt;&gt; HtmlRow([c.filter('tritan', method='machado').clip() for c in colors])\n[color(srgb 1 0 0.05839 / 1), color(srgb 1 0.28649 0.36958 / 1), color(srgb 1 0.6869 0.65152 / 1), color(srgb 1 0.93208 0.85219 / 1), color(srgb 0.31913 0.64112 0.56532 / 1), color(srgb 0 0.34691 0.33347 / 1), color(srgb 0 0.42038 0.58728 / 1), color(srgb 0 0.26742 0.38855 / 1), color(srgb 0.49244 0.2757 0.40142 / 1), color(srgb 0.95631 0.5535 0.67867 / 1)]\n</code></pre> inputs = ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet'] colors = Color.steps(inputs, steps=10, space='srgb') HtmlRow(colors) HtmlRow([c.filter('tritan', method='brettel').clip() for c in colors]) HtmlRow([c.filter('tritan', method='vienot').clip() for c in colors]) HtmlRow([c.filter('tritan', method='machado').clip() for c in colors]) Edit Share Run Cancel"},{"location":"filters/#anomalous-trichromacy","title":"Anomalous Trichromacy","text":"<p>While Dichromacy is probably the more severe case with only two functional cones, a more common CVD type is anomalous trichromacy. In this case, a person will have three functioning cones, but not all of the cones function with full sensitivity. Sometimes, the sensitivity can be so low, that their ability to perceive color may be close to someone with dichromacy.</p> <p>While dichromacy may be considered a severity 1, a given case of anomalous trichromacy could be anywhere between 0 and 1, where 0 would be no CVD.</p> <p>Like dichromacy, the related deficiencies are named in a similar manner: protanomaly (reduced red sensitivity), deuteranomaly (reduced green sensitivity), and tritanomaly (reduced blue sensitivity).</p> NormalProtanomaly Severity 0.5Protanomaly Severity 0.7Protanomaly Severity 0.9 <p></p> <p></p> <p></p> <p></p> <p>To represent anomalous trichromacy, ColorAide leans on the Machado 2009 approach which has a more nuanced approach to handling severity levels below 1. This approach did not really focus on tritanopia though, and the suggested algorithm for tritanopia should only be considered as an approximation. Instead of relying on the Machado approach for tritanomaly, we instead just use linear interpolation between the severity 1 results and the severity 0 (no CVD) results. With that said, the <code>method</code> can always be overridden to use something other than the defaults.</p> <pre><code>&gt;&gt;&gt; inputs = ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet']\n&gt;&gt;&gt; colors = Color.steps(inputs, steps=10, space='srgb')\n&gt;&gt;&gt; HtmlRow(colors)\n[color(srgb 1 0 0 / 1), color(srgb 1 0.43137 0 / 1), color(srgb 1 0.76471 0 / 1), color(srgb 1 1 0 / 1), color(srgb 0.33333 0.66797 0 / 1), color(srgb 0 0.33464 0.33333 / 1), color(srgb 0 0 1 / 1), color(srgb 0.19608 0 0.6732 / 1), color(srgb 0.50719 0.16993 0.65098 / 1), color(srgb 0.93333 0.5098 0.93333 / 1)]\n&gt;&gt;&gt; HtmlRow([c.filter('protan', 0.75).clip() for c in colors])\n[color(srgb 0.57444 0.36279 0 / 1), color(srgb 0.68557 0.52161 0 / 1), color(srgb 0.89278 0.76762 0 / 1), color(srgb 1 0.96325 0 / 1), color(srgb 0.65314 0.61548 0 / 1), color(srgb 0.2832 0.31636 0.33437 / 1), color(srgb 0 0.31631 1 / 1), color(srgb 0 0.21199 0.68441 / 1), color(srgb 0.14543 0.30324 0.66031 / 1), color(srgb 0.57941 0.62064 0.94276 / 1)]\n&gt;&gt;&gt; HtmlRow([c.filter('deutan', 0.75).clip() for c in colors])\n[color(srgb 0.69457 0.52313 0 / 1), color(srgb 0.77249 0.62491 0 / 1), color(srgb 0.93243 0.81477 0.08507 / 1), color(srgb 1 0.98058 0.16863 / 1), color(srgb 0.62247 0.59458 0.12005 / 1), color(srgb 0.25131 0.29322 0.33527 / 1), color(srgb 0 0.23104 0.9893 / 1), color(srgb 0 0.17352 0.66554 / 1), color(srgb 0.2229 0.32529 0.64248 / 1), color(srgb 0.64769 0.66513 0.92233 / 1)]\n&gt;&gt;&gt; HtmlRow([c.filter('tritan', 0.75).clip() for c in colors])\n[color(srgb 1 0 0.26664 / 1), color(srgb 1 0.39951 0.42724 / 1), color(srgb 1 0.72603 0.65776 / 1), color(srgb 1 0.95367 0.83611 / 1), color(srgb 0.4194 0.63016 0.60019 / 1), color(srgb 0.05755 0.32736 0.37697 / 1), color(srgb 0 0.3268 0.68775 / 1), color(srgb 0 0.21274 0.44656 / 1), color(srgb 0.46246 0.26991 0.4298 / 1), color(srgb 0.89997 0.56774 0.71539 / 1)]\n</code></pre> inputs = ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet'] colors = Color.steps(inputs, steps=10, space='srgb') HtmlRow(colors) HtmlRow([c.filter('protan', 0.75).clip() for c in colors]) HtmlRow([c.filter('deutan', 0.75).clip() for c in colors]) HtmlRow([c.filter('tritan', 0.75).clip() for c in colors]) Edit Share Run Cancel"},{"location":"filters/#usage-details","title":"Usage Details","text":"<p>To use filters, a filter name must be given, followed by an optional amount. If an amount is omitted, suitable default will be used. The exact range a given filter accepts varies depending on the filter. If a value exceeds the filter range , the value will be clamped.</p> Filters Name Default Brightness <code>brightness</code> <code>1</code> Saturation <code>saturate</code> <code>1</code> Contrast <code>contrast</code> <code>1</code> Opacity <code>opacity</code> <code>1</code> Invert <code>invert</code> <code>1</code> Hue\u00a0rotation <code>hue-rotate</code> <code>0</code> Sepia <code>sepia</code> <code>1</code> Grayscale <code>grayscale</code> <code>1</code> Protan <code>protan</code> <code>1</code> Deutan <code>deutan</code> <code>1</code> Tritan <code>tritan</code> <code>1</code> <p>All of the filters that are supported allow filtering in the Linear sRGB color space and will do so by default. Additionally, the W3C filter effects also support filtering in the sRGB color space. The CVD filters are specifically designed to be applied in the Linear sRGB space, and cannot be used in any other color space.</p> <pre><code>&gt;&gt;&gt; inputs = ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet']\n&gt;&gt;&gt; colors = Color.steps(inputs, steps=10, space='srgb')\n&gt;&gt;&gt; HtmlRow(colors)\n[color(srgb 1 0 0 / 1), color(srgb 1 0.43137 0 / 1), color(srgb 1 0.76471 0 / 1), color(srgb 1 1 0 / 1), color(srgb 0.33333 0.66797 0 / 1), color(srgb 0 0.33464 0.33333 / 1), color(srgb 0 0 1 / 1), color(srgb 0.19608 0 0.6732 / 1), color(srgb 0.50719 0.16993 0.65098 / 1), color(srgb 0.93333 0.5098 0.93333 / 1)]\n&gt;&gt;&gt; HtmlRow([c.filter('sepia', 1, space='srgb-linear').clip() for c in colors])\n[color(srgb 0.65991 0.6254 0.55828 / 1), color(srgb 0.7438 0.70557 0.63046 / 1), color(srgb 0.91264 0.86683 0.77568 / 1), color(srgb 1 1 0.90933 / 1), color(srgb 0.62309 0.59145 0.52742 / 1), color(srgb 0.32748 0.3096 0.27351 / 1), color(srgb 0.47196 0.44672 0.39732 / 1), color(srgb 0.33214 0.31357 0.27727 / 1), color(srgb 0.45856 0.43394 0.38572 / 1), color(srgb 0.83745 0.79487 0.71097 / 1)]\n&gt;&gt;&gt; HtmlRow([c.filter('sepia', 1, space='srgb').clip() for c in colors])\n[color(srgb 0.393 0.349 0.272 / 1), color(srgb 0.72473 0.64492 0.50235 / 1), color(srgb 0.98106 0.87359 0.68035 / 1), color(srgb 1 1 0.806 / 1), color(srgb 0.64467 0.57456 0.44736 / 1), color(srgb 0.32034 0.28556 0.22236 / 1), color(srgb 0.189 0.168 0.131 / 1), color(srgb 0.20429 0.18153 0.14152 / 1), color(srgb 0.45304 0.40295 0.31398 / 1), color(srgb 0.93524 0.83226 0.64837 / 1)]\n</code></pre> inputs = ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet'] colors = Color.steps(inputs, steps=10, space='srgb') HtmlRow(colors) HtmlRow([c.filter('sepia', 1, space='srgb-linear').clip() for c in colors]) HtmlRow([c.filter('sepia', 1, space='srgb').clip() for c in colors]) Edit Share Run Cancel <p>Processing Lots of Colors</p> <p>One logical application for filters is to apply them directly to images. If you are performing these operations on millions of pixels, you may notice that ColorAide, with all of its convenience, may not always be the fastest. There is a cost due to the overhead of convenience and a cost due to the pure Python approach as well. With that said, there are tricks that can dramatically make things much faster in most cases!</p> <p><code>functools.lru_cache</code> is your friend in such cases. We actually process all the images on this page with ColorAide to demonstrate the filters. The key to making it a quick and painless process was to cache repetitive operations. When processing images, it is highly likely that you will be performing the same operations on thousands of identical pixels. Caching the work you've already done can speed this process up exponentially.</p> <p>There are certainly some images that could be constructed in such a way to elicit a worse case scenario where the cache would not be able to compensate as well, but for most images, caching dramatically reduces processing time.</p> <p>We can crawl the pixels in a file, and using a simple function like below, we will only process a pixel once (at least until our cache fills and we start having to overwrite existing colors).</p> <pre><code>@lru_cache(maxsize=1024 * 1024)\ndef apply_filter(name, amount, space, method, p, fit):\n\"\"\"Apply filter.\"\"\"\n\n    has_alpha = len(p) &gt; 3\n    color = Color('srgb', [x / 255 for x in p[:3]], p[3] / 255 if has_alpha else 1)\n    if method is not None:\n        # This is a CVD filter that allows specifying the method\n        color.filter(name, amount, space=space, in_place=True, method=method)\n    else:\n        # General filter.\n        color.filter(name, amount, space=space, in_place=True)\n    # Fit the color back into the color gamut and return the results\n    return tuple([int(x * 255) for x in color.fit(method=fit)[:3 if has_alpha else -1]])\n</code></pre> <p>When processing a 4608x2456 image (15,925,248 pixels) during our testing, it turned a ~7 minute process into a ~25 second process*. Using gamut mapping opposed to simple clipping only increases time by to about ~56 seconds. The much smaller images shown on this page process much, much faster.</p> <p>The full script can be viewed here.</p> <p>* Tests were performed using the Pillow library. Results may vary depending on the size of the image, pixel configuration, number of unique pixels, etc. Cache size can be tweaked to optimize the results.</p>  .info-container {display: inline-block;}"},{"location":"gamut/","title":"Gamut Mapping","text":"<p>Many color spaces are designed in such a way that they can only represent colors accurately within a specific range. This range in which a color can accurately be represented is known as the color gamut. While some color spaces are theoretically unbounded, there are many that are designed with distinct ranges.</p> <p>The sRGB and Display P3 color spaces are both RGB color spaces, but they actually can represent a different amount of colors. Display P3 has a wider gamut and allows for greener greens and redder reds, etc. In the image below, we show four different RGB color spaces, each with varying different gamut sizes. Display P3 contains all the colors in sRGB and extends it even further. Rec. 2020, another RGB color space, is even wider. ProPhoto is so wide that it contains colors that the human eye can't even see.</p> <p></p> <p>In order to visually represent a color from a wider gamut color space, such as Display P3, in a more narrow color space, such as sRGB, a suitable color within the more narrow color space must must be selected and be shown in its place. This selecting of a suitable replacement is called gamut mapping.</p> <p>ColorAide defines a couple methods to help identify when a color is outside the gamut bounds of a color space and to help find a suitable, alternative color that is within the gamut.</p>"},{"location":"gamut/#checking-gamut","title":"Checking Gamut","text":"<p>When dealing with colors, it can be important to know whether a color is within its own gamut. The <code>in_gamut</code> function allows for comparing the current color's specified values against the color space's gamut.</p> <p>Let's assume we have a color <code>rgb(30% 105% 0%)</code>. The color is out of gamut due to the green channel exceeding the channel's limit of <code>100%</code>. When we execute <code>in_gamut</code>, we can see that the color is not in its own gamut.</p> <pre><code>&gt;&gt;&gt; Color(\"rgb(30% 105% 0%)\").in_gamut()\nFalse\n</code></pre> Color(\"rgb(30% 105% 0%)\").in_gamut() Edit Share Run Cancel <p>On the other hand, some color spaces do not have a limit. CIELab is one such color space. Sometimes limits will be placed on the color space channels for practicality, but theoretically, there are no bounds. When we check a CIELab color, we will find that it is always considered in gamut.</p> <pre><code>&gt;&gt;&gt; Color(\"lab(200% -20 40 / 1)\").in_gamut()\nTrue\n</code></pre> Color(\"lab(200% -20 40 / 1)\").in_gamut() Edit Share Run Cancel <p>While checking CIELab's own gamut isn't very useful, we can test it against a different color space's gamut. By simply passing in the name of a different color space, the current color will be converted to the provided space and then will run <code>in_gamut</code> on the new color. You could do this manually, but using <code>in_gamut</code> in this manner can be very convenient. In the example below, we can see that the CIELab color of <code>lab(200% -20 40 / 1)</code> is outside the narrow gamut of sRGB.</p> <pre><code>&gt;&gt;&gt; Color(\"lab(200% -20 40 / 1)\").in_gamut('srgb')\nFalse\n</code></pre> Color(\"lab(200% -20 40 / 1)\").in_gamut('srgb') Edit Share Run Cancel"},{"location":"gamut/#tolerance","title":"Tolerance","text":"<p>Generally, ColorAide does not round off values in order to guarantee the best possible values for round tripping, but due to limitations of floating-point arithmetic and precision of conversion algorithms, there can be edge cases where colors don't round trip perfectly. By default, <code>in_gamut</code> allows for a tolerance of <code>0.000075</code> to account for such cases where a color is \"close enough\". If desired, this \"tolerance\" can be adjusted.</p> <p>Let's consider CIELab with a D65 white point. The sRGB round trip through CIELab D65 for <code>white</code> does not perfectly convert back to the original color. This is due to the perils of floating point arithmetic.</p> <pre><code>&gt;&gt;&gt; Color('color(srgb 1 1 1)').convert('lab-d65')[:]\n[100.0, 0.0, 0.0, 1.0]\n&gt;&gt;&gt; Color('color(srgb 1 1 1)').convert('lab-d65').convert('srgb')[:]\n[1.0000000000000002, 0.9999999999999999, 0.9999999999999997, 1.0]\n</code></pre> Color('color(srgb 1 1 1)').convert('lab-d65')[:] Color('color(srgb 1 1 1)').convert('lab-d65').convert('srgb')[:] Edit Share Run Cancel <p>We can see that when using a tolerance of zero, and gamut checking in sRGB, that the color is considered out of gamut. This makes sense as the round trip through CIELab D65 and back is so very close, but ever so slightly off. Depending on what you are doing, this may not be an issue up until you are ready to finalize the color, so sometimes it may be desirable to have some tolerance, and other times not.</p> <pre><code>&gt;&gt;&gt; Color('color(srgb 1 1 1)').convert('lab-d65').convert('srgb')[:]\n[1.0000000000000002, 0.9999999999999999, 0.9999999999999997, 1.0]\n&gt;&gt;&gt; Color('color(srgb 1 1 1)').convert('lab-d65').convert('srgb').in_gamut()\nTrue\n&gt;&gt;&gt; Color('color(srgb 1 1 1)').convert('lab-d65').convert('srgb').in_gamut(tolerance=0)\nFalse\n</code></pre> Color('color(srgb 1 1 1)').convert('lab-d65').convert('srgb')[:] Color('color(srgb 1 1 1)').convert('lab-d65').convert('srgb').in_gamut() Color('color(srgb 1 1 1)').convert('lab-d65').convert('srgb').in_gamut(tolerance=0) Edit Share Run Cancel <p>On the topic of tolerance, lets consider some color models that do not handle out of gamut colors very well. There are some color models that are alternate representations of an existing color space. For instance, the cylindrical spaces HSL, HSV, and HWB are just different color models for the sRGB color space. They are are essentially the sRGB color space, just with cylindrical coordinates that isolate certain attributes of the color space: saturation, whiteness, blackness, etc. So their gamut is exactly the same as the sRGB space, because they are the sRGB color space. So it stands to reason that simply using the sRGB gamut check for them should be sufficient, and if we are using strict tolerance, this would be true.</p> <pre><code>&gt;&gt;&gt; Color('rgb(255 255 255)').in_gamut('srgb', tolerance=0)\nTrue\n&gt;&gt;&gt; Color('hsl(0 0% 100%)').in_gamut('srgb', tolerance=0)\nTrue\n&gt;&gt;&gt; Color('color(--hsv 0 0% 100%)').in_gamut('srgb', tolerance=0)\nTrue\n&gt;&gt;&gt; Color('rgb(255.05 255 255)').in_gamut('srgb', tolerance=0)\nFalse\n&gt;&gt;&gt; Color('hsl(0 0% 100.05%)').in_gamut('srgb', tolerance=0)\nFalse\n&gt;&gt;&gt; Color('color(--hsv 0 0% 100.05%)').in_gamut('srgb', tolerance=0)\nFalse\n</code></pre> Color('rgb(255 255 255)').in_gamut('srgb', tolerance=0) Color('hsl(0 0% 100%)').in_gamut('srgb', tolerance=0) Color('color(--hsv 0 0% 100%)').in_gamut('srgb', tolerance=0) Color('rgb(255.05 255 255)').in_gamut('srgb', tolerance=0) Color('hsl(0 0% 100.05%)').in_gamut('srgb', tolerance=0) Color('color(--hsv 0 0% 100.05%)').in_gamut('srgb', tolerance=0) Edit Share Run Cancel <p>But when we are not using a strict threshold, and we check one of these models only using the sRGB gamut, there are some cases where these cylindrical colors can exhibit coordinates wildly outside of the model's range but still very close to the sRGB gamut.</p> <p>In this example, we have an sRGB color that is extremely close to being in gamut, but when we convert it to HSL, we can see wildly large saturation.</p> <pre><code>&gt;&gt;&gt; hsl = Color('color(srgb 0.9999999999994 1.0000000000002 0.9999999999997)').convert('hsl')\n&gt;&gt;&gt; hsl.to_string(fit=False)\nhsl(142.5 200.06% 100%)\n&gt;&gt;&gt; hsl.in_gamut('srgb')\nTrue\n</code></pre> hsl = Color('color(srgb 0.9999999999994 1.0000000000002 0.9999999999997)').convert('hsl') hsl.to_string(fit=False) hsl.in_gamut('srgb') Edit Share Run Cancel <p>This happens because these cylindrical color models do not represent colors out of gamut in a very sane way. They are simply not designed to extend past the color gamut. So even a slightly out of gamut sRGB color can translate to a value way outside the cylindrical color model's boundaries.</p> <p>For this reason, gamut checks in the HSL, HSV, or HWB models apply tolerance checks on the color's coordinates in the sRGB color space and the respective cylindrical model ensuring we have coordinates that are close to the color's actual gamut and reasonably close to the cylindrical model's constraints as well.</p> <p>So, when using HSL as the gamut check, we can see that it ensures the color is not only very close to the sRGB gamut, but that it is also very close the color model's constraints.</p> <pre><code>&gt;&gt;&gt; hsl = Color('color(srgb 0.9999999999994 1.0000000000002 0.9999999999997)').convert('hsl')\n&gt;&gt;&gt; hsl\ncolor(--hsl 142.5 2.0006 1 / 1)\n&gt;&gt;&gt; hsl.in_gamut('hsl')\nFalse\n</code></pre> hsl = Color('color(srgb 0.9999999999994 1.0000000000002 0.9999999999997)').convert('hsl') hsl hsl.in_gamut('hsl') Edit Share Run Cancel <p>If the Cartesian check is the only desired check, and the strange cylindrical values that are returned are not a problem, <code>srgb</code> can always be specified. <code>tolerance=0</code> can also be used to constrain the check to values exactly in the gamut.</p> <p>HSL has a very tight conversion to and from sRGB, so when an sRGB color is precisely in gamut, it will remain in gamut throughout the conversion to and from HSL, both forwards and backwards. On the other hand, there may be color models that have a looser conversion algorithm. There may be cases where it may be beneficial to increase the threshold.</p>"},{"location":"gamut/#mapping-colors","title":"Mapping Colors","text":"<p>Gamut mapping is the process of taking a color that is out of gamut and adjusting it such that it fits within the gamut. There are various ways to map an out of bound color to an in bound color, each with their own pros and cons. ColorAide offers two methods related to gamut mapping: <code>clip()</code> and <code>fit()</code>. <code>clip()</code> is a dedicated function that performs the speedy, yet naive, approach of simply truncating a color channel's value to fit within the specified gamut, and <code>fit()</code> is a method that allows you to do more advanced gamut mapping approaches that, while slower, generally yield better results.</p> <p>While clipping won't always yield the best results, clipping is still very important and can be used to trim channel noise after certain mathematical operations or even used in other gamut mapping algorithms if used carefully. For this reason, clip has its own dedicated method for quick access: <code>clip()</code>. It can be applied directly to the current color space or can be applied on the gamuts of other color spaces.</p> <pre><code>&gt;&gt;&gt; Color('rgb(270 30 120)').clip()\ncolor(srgb 1 0.11765 0.47059 / 1)\n&gt;&gt;&gt; Color('color(display-p3 1 1 0)').clip('srgb')\ncolor(display-p3 1 1 0.3309 / 1)\n</code></pre> Color('rgb(270 30 120)').clip() Color('color(display-p3 1 1 0)').clip('srgb') Edit Share Run Cancel <p>The <code>fit()</code> method, is the generic gamut mapping method that exposes access to all the different gamut mapping methods available. By default, <code>fit()</code> uses a more advanced method of color mapping that tries to preserve hue and lightness, hue being the attribute the human eye is most sensitive to. If desired, a user can also specify any currently registered gamut mapping algorithm via the <code>method</code> parameter.</p> <pre><code>&gt;&gt;&gt; Color('rgb(270 30 120)').fit()\ncolor(srgb 1 0.18505 0.47435 / 1)\n&gt;&gt;&gt; Color('rgb(270 30 120)').fit(method='clip')\ncolor(srgb 1 0.11765 0.47059 / 1)\n</code></pre> Color('rgb(270 30 120)').fit() Color('rgb(270 30 120)').fit(method='clip') Edit Share Run Cancel <p>Gamut mapping can also be used to fit colors in other gamuts, just like <code>clip()</code>. For instance, fitting a Display P3 color into an sRGB gamut.</p> <pre><code>&gt;&gt;&gt; c1 = Color('color(display-p3 1 1 0)')\n&gt;&gt;&gt; c1.in_gamut('srgb')\nFalse\n&gt;&gt;&gt; c1.fit('srgb')\ncolor(display-p3 0.99859 0.9923 0.32854 / 1)\n&gt;&gt;&gt; c1.in_gamut()\nTrue\n</code></pre> c1 = Color('color(display-p3 1 1 0)') c1.in_gamut('srgb') c1.fit('srgb') c1.in_gamut() Edit Share Run Cancel <p>Caveats when Mapping in Other Spaces</p> <p>When fitting in another color space, results may vary depending on what color space you are in and what color space you are using to fit the color. We went into great depths when discussing gamut checking about how transform functions from one color space to another are not always exact. We also gave quite a number of examples showing cases in which some color spaces were more sensitive to slight deviations outside their gamut than others. This is mainly mentioned as fitting in one color space and round tripping back may not give exact results:</p> <pre><code>&gt;&gt;&gt; Color(\"color(--lch-d65 100 50 75)\").convert('srgb').fit()[:]\n[1.0, 1.0, 1.0, 1.0]\n&gt;&gt;&gt; Color(\"color(--lch-d65 100 50 75)\").fit('srgb').convert('srgb')[:]\n[1.0000000000000002, 0.9999999999999999, 0.9999999999999997, 1.0]\n</code></pre> Color(\"color(--lch-d65 100 50 75)\").convert('srgb').fit()[:] Color(\"color(--lch-d65 100 50 75)\").fit('srgb').convert('srgb')[:] Edit Share Run Cancel <p>While the above case does fit the LCh color within the sRGB color space, and once converted back to LCh, it is technically well within the \"in gamut\" threshold, the conversion can't quite keep it precisely in gamut. Depending on what you are doing and what spaces you are working in, this may be okay, but it may also make sense to fully convert to color space with the gamut you wish to work in and work directly in that space opposed to the indirect fitting of a color in a different color space.</p> <p>There are actually many different ways to gamut map a color. Some are computationally expensive, some are quite simple, and many do really good in some cases and not so well in others. There is probably no perfect gamut mapping method, but some are better than others. ColorAide currently only offers a couple simple methods to gamut map.</p> Method Description <code>clip</code> Simple, naive clipping. <code>lch-chroma</code> Uses a combination of chroma reduction and MINDE in the CIELCh color space to bring a color into gamut. This is the default method used. <code>oklch-chroma</code> Like <code>lch-chroma</code>, but uses the OkLCh color space instead. This is currently what the CSS Color Level 4 specification recommends. <p>CSS Level 4 Gamut Mapping</p> <p>The CSS CSS Color Level 4 specification currently recommends using OkLCh as the gamut mapping color space. <code>oklch-chroma</code> is our implementation of the CSS Level 4 color specification.</p> <p>OkLCh is a very new color space to be used in the field of gamut mapping. While CIELCh is not perfect, its weakness are known. OkLCh does seem to have certain quirks of its own, and may have more that have yet to be discovered. While we have not made <code>oklch-chroma</code> our default yet, we have exposed the algorithm so users can begin exploring it.</p>"},{"location":"gamut/#why-not-just-clip","title":"Why Not Just Clip?","text":"<p>In the past, clipping has been the default way in which out of gamut colors have been handled in web browsers. It is fast, and has generally been fine as most browsers have been constrained to using sRGB. But as modern browsers begin to adopt more wide gamut monitors such as Display P3, and CSS grows to support an assortment of wide and ultra wide color spaces, representing the best intent of an out of gamut color becomes even more important.</p> <p>ColorAide currently uses a default gamut mapping algorithm that performs gamut mapping in the CIELCh color space using chroma reduction coupled with minimum \u2206E (MINDE). This approach is meant to preserve enough of the important attributes of the out of gamut color as is possible, mostly preserving both lightness and hue, hue being the attribute that people are most sensitive to. MINDE is used to abandon chroma reduction and clip the color when the color is very close to being in gamut. MINDE also allows us to catch cases where the geometry of the color space's gamut is such that we may slip by higher chroma options resulting in undesirable, aggressive chroma reduction. While CIELCh is not a perfect color space, and we may use a different color space in the future, this method is generally more accurate that using clipping alone.</p> <p>Below we have an example of using chroma reduction with MINDE. It can be noted that chroma is reduced until we are very close to being in gamut. The MINDE helps us catch the peak of the yellow shape as, otherwise, we would have continued reducing chroma until we were at a very chroma reduced, pale yellow.</p> <p></p> <p>One might see some cases of clipping and think it does a fine job and question why any of this complexity is necessary. In order to demonstrate the differences in gamut mapping vs clipping, see the example below. We start with the color <code>color(display-p3 1 1 0)</code> and interpolate with it in the CIELCh color space reducing just the lightness. This will leave both chroma and hue intact. The Interactive playground below automatically gamut maps the color previews to sRGB, but we'll control the method being used by providing two different <code>Color</code> objects: one that uses <code>lch-chroma</code> (the default) for gamut mapping, and one that uses <code>clip</code>. Notice how clipping, the bottom color set, clips these dark colors and makes them reddish. This is a very undesirable outcome.</p> <pre><code>&gt;&gt;&gt; yellow = Color('color(display-p3 1 1 0)')\n&gt;&gt;&gt; lightness_mask = Color('lch(0% none none)')\n&gt;&gt;&gt; HtmlRow([c.fit() for c in Color.steps([yellow, lightness_mask], steps=10, space='lch')])\n[color(display-p3 1 1 0 / 1), color(display-p3 0.87114 0.87804 0 / 1), color(display-p3 0.75346 0.75577 0 / 1), color(display-p3 0.63626 0.63798 0 / 1), color(display-p3 0.52281 0.52408 0 / 1), color(display-p3 0.41409 0.41421 0 / 1), color(display-p3 0.31048 0.3088 0 / 1), color(display-p3 0.21189 0.20823 0 / 1), color(display-p3 0.12036 0.11138 0 / 1), color(display-p3 0 0 0 / 1)]\n&gt;&gt;&gt; yellow = Color('color(display-p3 1 1 0)')\n&gt;&gt;&gt; lightness_mask = Color('lch(0% none none)')\n&gt;&gt;&gt; HtmlRow([c.clip() for c in Color.steps([yellow, lightness_mask], steps=10, space='lch')])\n[color(display-p3 1 1 0 / 1), color(display-p3 0.86965 0.87865 0 / 1), color(display-p3 0.74183 0.76037 0 / 1), color(display-p3 0.61856 0.64535 0 / 1), color(display-p3 0.50161 0.53384 0 / 1), color(display-p3 0.39311 0.42617 0 / 1), color(display-p3 0.29717 0.32269 0 / 1), color(display-p3 0.22186 0.22377 0 / 1), color(display-p3 0.17897 0.12968 0 / 1), color(display-p3 0.13001 0.03358 0 / 1)]\n</code></pre> # Gamut mapping in LCh yellow = Color('color(display-p3 1 1 0)') lightness_mask = Color('lch(0% none none)') HtmlRow([c.fit() for c in Color.steps([yellow, lightness_mask], steps=10, space='lch')])  # Clipping yellow = Color('color(display-p3 1 1 0)') lightness_mask = Color('lch(0% none none)') HtmlRow([c.clip() for c in Color.steps([yellow, lightness_mask], steps=10, space='lch')]) Edit Share Run Cancel <p>There are times when clipping is simply preferred. It is fast, and if you are just trimming noise off channels, it is very useful, but if the idea is to present an in gamut color that tries to preserve as much of the intent of the original color as possible, other methods may be desired. There are no doubt better gamut methods available than what ColorAide offers currently, and more may be added in the future, but ColorAide can also be extended using 3rd party plugins as well.</p>"},{"location":"harmonies/","title":"Color Harmonies","text":"<p>In color theory, color harmony refers to the property that certain aesthetically pleasing color combinations have. Modern day color theory probably starts with the first color wheel created by Isaac Newton. Based on his observations of light with prisms, he formed probably the first color wheel. From there, many others built upon this work, sometimes with opposing ideas.</p> <p>The original color wheel, while inspired by what was observed by light, was created based on experiments with pigments as well. As most know, in paint, red, yellow, and blue are considered primary colors. Newton thought this translated to light as well and stated they were also the primary colors of light. While this isn't actually true, his work was very important in reshaping how people viewed color.</p> <p>Over time, the color wheel was refined. The traditional model, which we will call an RYB color model, defined 12 colors that made up the wheel: the primary colors, the secondary colors, and the tertiary colors. The secondary colors are created by evenly mixing the primary colors, and the tertiary colors are created by evenly mixing those primary colors with the secondary colors.</p> <p></p> <p>The idea of color harmonies originates from the idea that colors, based on their relative position on the wheel, can form more pleasing color combinations.</p>"},{"location":"harmonies/#which-color-space-is-best-for-color-harmonies","title":"Which Color Space is Best for Color Harmonies?","text":"<p>As we know, these days, there are many color spaces out there: subtractive models, additive models, perceptually uniform models, high dynamic range models, etc. Many color spaces trying to solve specific issues based on the knowledge at the time.</p> <p>The early work that created the first color wheel was based on an RYB color model. In modern TVs and monitors, the RYB color model is not used. Electronic screens create all their colors with light based methods that mix red, green, and blue lights. In addition, the human eye perceives colors using red, green, and blue as well.</p> <p>In reality, we could create a color wheel from any of the various color spaces out there and end up with slightly different results. If we were to compose a color wheel based on the common sRGB color space, we could base it off the 3 primary colors of light. Starting with red (0\u02da), we could extract the colors at evenly spaced degrees, 30\u02da to be exact. This would give us our 12 colors for the sRGB color space.</p> <pre><code>&gt;&gt;&gt; HtmlSteps([Color('hsl', [x, 1, 0.5]) for x in range(0, 360, 30)])\n[color(--hsl 0 1 0.5 / 1), color(--hsl 30 1 0.5 / 1), color(--hsl 60 1 0.5 / 1), color(--hsl 90 1 0.5 / 1), color(--hsl 120 1 0.5 / 1), color(--hsl 150 1 0.5 / 1), color(--hsl 180 1 0.5 / 1), color(--hsl 210 1 0.5 / 1), color(--hsl 240 1 0.5 / 1), color(--hsl 270 1 0.5 / 1), color(--hsl 300 1 0.5 / 1), color(--hsl 330 1 0.5 / 1)]\n</code></pre> HtmlSteps([Color('hsl', [x, 1, 0.5]) for x in range(0, 360, 30)]) Edit Share Run Cancel <p>From this we can construct an sRGB color wheel.</p> <p></p> <p>This is different from the RYB color wheel, and more accurate in relation to how light works, but does it yield better harmonies for colors?</p> <p>If we were to select the perceptually uniform OkLCh color space, and seed it with red's lightness and chroma, we'd get:</p> <pre><code>&gt;&gt;&gt; c = Color('red').convert('oklch', in_place=True)\n&gt;&gt;&gt; HtmlSteps([Color('oklch', [*c[0:2], x]) for x in range(0, 360, 30)])\n[color(--oklch 0.62796 0.25768 0 / 1), color(--oklch 0.62796 0.25768 30 / 1), color(--oklch 0.62796 0.25768 60 / 1), color(--oklch 0.62796 0.25768 90 / 1), color(--oklch 0.62796 0.25768 120 / 1), color(--oklch 0.62796 0.25768 150 / 1), color(--oklch 0.62796 0.25768 180 / 1), color(--oklch 0.62796 0.25768 210 / 1), color(--oklch 0.62796 0.25768 240 / 1), color(--oklch 0.62796 0.25768 270 / 1), color(--oklch 0.62796 0.25768 300 / 1), color(--oklch 0.62796 0.25768 330 / 1)]\n</code></pre> c = Color('red').convert('oklch', in_place=True) HtmlSteps([Color('oklch', [*c[0:2], x]) for x in range(0, 360, 30)]) Edit Share Run Cancel <p>This produces colors with visually more uniform lightness, does that mean these are better?</p> <p>The truth is, what is better or even harmonious can be largely subjective, and everyone has reasons for selecting certain color spaces for a specific task.</p> <p>Many artists swear by the classical color wheel, others are fine with using the sRGB color wheel as it is easy to work with in CSS via the HSL color space, and there are still others that are more interested in perceptually uniform color spaces that aim for more consistent hues and predictable lightness.</p> <p>As far as ColorAide is concerned, we've chosen to use OkLCh as the color space in which we work in. This is based mainly on the fact it keeps hue more consistent than some other options, and it allows us to support a wider gamut than options like HSL.</p> <pre><code>&gt;&gt;&gt; HtmlSteps(Color.steps(['black', 'blue', 'white'], steps=11, space='oklch'))\n[color(srgb 0 0 0 / 1), color(srgb 0 0 0.0861 / 1), color(srgb 0 0 0.2806 / 1), color(srgb 0 0 0.50211 / 1), color(srgb 0 0 0.74321 / 1), color(srgb 0 0 1 / 1), color(srgb 0.13515 0.37566 1.0212 / 1), color(srgb 0.34745 0.558 1.0336 / 1), color(srgb 0.55957 0.71438 1.0355 / 1), color(srgb 0.77677 0.85998 1.0252 / 1), color(srgb 1 1 1 / 1)]\n&gt;&gt;&gt; HtmlSteps(Color.steps(['black', 'blue', 'white'], steps=11, space='hsl'))\n[color(srgb 0 0 0 / 1), color(srgb 0.08 0.08 0.12 / 1), color(srgb 0.12 0.12 0.28 / 1), color(srgb 0.12 0.12 0.48 / 1), color(srgb 0.08 0.08 0.72 / 1), color(srgb 0 0 1 / 1), color(srgb 0.28 0.28 0.92 / 1), color(srgb 0.52 0.52 0.88 / 1), color(srgb 0.72 0.72 0.88 / 1), color(srgb 0.88 0.88 0.92 / 1), color(srgb 1 1 1 / 1)]\n&gt;&gt;&gt; HtmlSteps(Color.steps(['black', 'blue', 'white'], steps=11, space='lch'))\n[color(srgb 0 0 0 / 1), color(srgb 0.09272 0.04797 0.19247 / 1), color(srgb 0.12553 0.06194 0.37252 / 1), color(srgb 0.13832 0.06149 0.56917 / 1), color(srgb 0.11911 0.0451 0.77902 / 1), color(srgb 0 0 1 / 1), color(srgb 0.42597 0.26342 1.0084 / 1), color(srgb 0.60968 0.44766 1.0135 / 1), color(srgb 0.7562 0.62855 1.0144 / 1), color(srgb 0.88411 0.81218 1.0103 / 1), color(srgb 1 1 1 / 1)]\n</code></pre> HtmlSteps(Color.steps(['black', 'blue', 'white'], steps=11, space='oklch')) HtmlSteps(Color.steps(['black', 'blue', 'white'], steps=11, space='hsl')) HtmlSteps(Color.steps(['black', 'blue', 'white'], steps=11, space='lch')) Edit Share Run Cancel <p>While OkLCh is the default, we understand that there are many reasons to use other spaces, so use what you like, we won't judge .</p> <pre><code>&gt;&gt;&gt; HtmlSteps(Color('red').harmony('complement'))\n[color(srgb 1 0 0 / 1), color(srgb -0.56631 0.66342 0.85808 / 1)]\n&gt;&gt;&gt; HtmlSteps(Color('red').harmony('complement', space='hsl'))\n[color(srgb 1 0 0 / 1), color(srgb 0 1 1 / 1)]\n</code></pre> HtmlSteps(Color('red').harmony('complement')) HtmlSteps(Color('red').harmony('complement', space='hsl')) Edit Share Run Cancel"},{"location":"harmonies/#supported-harmonies","title":"Supported Harmonies","text":"<p>ColorAide currently supports 7 theorized color harmonies: monochromatic, complementary, split complementary, analogous, triadic, square, and rectangular. By default, all color harmonies are calculated with the perceptually uniform OkLCh color space, but other color spaces can be used if desired.</p> <p>While we use OkLCh, we will actually visualize the examples in Okhsl. Okhsl is a derivative of OkLCh with the lightness adjusted to match CIELCh and reshaped in a cylindrical form. It is limited to the sRGB gamut only, but it can help visualize better what is happening in a familiar color wheel format. You can see the difference below:</p> OkLCh Color SliceOkhsl Color Slice <p></p> <p></p>"},{"location":"harmonies/#monochromatic","title":"Monochromatic","text":"<p>The monochromatic harmony pairs various tints and shades of a color together to create pleasing color schemes.</p> <p></p> <pre><code>&gt;&gt;&gt; HtmlSteps(Color('red').harmony('mono'))\n[color(srgb 0.50211 0 0 / 1), color(srgb 0.74321 0 0 / 1), color(srgb 1 0 0 / 1), color(srgb 1.0281 0.36963 0.30066 / 1), color(srgb 1.0439 0.5511 0.48294 / 1)]\n</code></pre> HtmlSteps(Color('red').harmony('mono')) Edit Share Run Cancel <p>Achromatic Colors</p> <p>Pure <code>white</code> and <code>black</code> will not be included in a monochromatic color harmony unless the color is achromatic.</p>"},{"location":"harmonies/#complementary","title":"Complementary","text":"<p>Complementary harmonies use a dyad of colors at opposite ends of the color wheel.</p> <p></p> <pre><code>&gt;&gt;&gt; HtmlSteps(Color('red').harmony('complement'))\n[color(srgb 1 0 0 / 1), color(srgb -0.56631 0.66342 0.85808 / 1)]\n</code></pre> HtmlSteps(Color('red').harmony('complement')) Edit Share Run Cancel"},{"location":"harmonies/#split-complementary","title":"Split Complementary","text":"<p>Split Complementary is similar to complementary, but actually uses a triad of colors. Instead of just choosing one complement, it splits and chooses two colors on the opposite side that are close, but not adjacent.</p> <p></p> <pre><code>&gt;&gt;&gt; HtmlSteps(Color('red').harmony('split'))\n[color(srgb 1 0 0 / 1), color(srgb -0.42456 0.56514 1.0654 / 1), color(srgb -0.55785 0.70538 0.55005 / 1)]\n</code></pre> HtmlSteps(Color('red').harmony('split')) Edit Share Run Cancel"},{"location":"harmonies/#analogous","title":"Analogous","text":"<p>Analogous harmonies consists of 3 adjacent colors.</p> <p></p> <pre><code>&gt;&gt;&gt; HtmlSteps(Color('red').harmony('analogous'))\n[color(srgb 1 0 0 / 1), color(srgb 0.93909 0.27571 -0.3354 / 1), color(srgb 0.96207 -0.03685 0.519 / 1)]\n</code></pre> HtmlSteps(Color('red').harmony('analogous')) Edit Share Run Cancel"},{"location":"harmonies/#triadic","title":"Triadic","text":"<p>Triadic draws an equilateral triangle between 3 colors on the color wheel. For instance, the primary colors have triadic harmony.</p> <p></p> <pre><code>&gt;&gt;&gt; HtmlSteps(Color('red').harmony('triad'))\n[color(srgb 1 0 0 / 1), color(srgb -0.35621 0.68224 -0.02255 / 1), color(srgb 0.30803 0.43723 1.1317 / 1)]\n</code></pre> HtmlSteps(Color('red').harmony('triad')) Edit Share Run Cancel"},{"location":"harmonies/#tetradic-square","title":"Tetradic Square","text":"<p>Tetradic color harmonies refer to a group of four colors. One tetradic color harmony can be found by drawing a square between four colors on the color wheel.</p> <p></p> <pre><code>&gt;&gt;&gt; HtmlSteps(Color('red').harmony('square'))\n[color(srgb 1 0 0 / 1), color(srgb 0.48219 0.59813 -0.35229 / 1), color(srgb -0.56631 0.66342 0.85808 / 1), color(srgb 0.63834 0.31074 1.0421 / 1)]\n</code></pre> HtmlSteps(Color('red').harmony('square')) Edit Share Run Cancel"},{"location":"harmonies/#tetradic-rectangular","title":"Tetradic Rectangular","text":"<p>The rectangular tetradic harmony is very similar to the square tetradic harmony except that it draws a rectangle between four colors instead of a square.</p> <p></p> <pre><code>&gt;&gt;&gt; HtmlSteps(Color('red').harmony('rectangle'))\n[color(srgb 1 0 0 / 1), color(srgb 0.93909 0.27571 -0.3354 / 1), color(srgb -0.56631 0.66342 0.85808 / 1), color(srgb -0.42456 0.56514 1.0654 / 1)]\n</code></pre> HtmlSteps(Color('red').harmony('rectangle')) Edit Share Run Cancel"},{"location":"harmonies/#changing-the-default-harmony-color-space","title":"Changing the Default Harmony Color Space","text":"<p>If you'd like to change the <code>Color()</code> class's default harmony color space, it can be done with class override. Simply derive a new <code>Color()</code> class from the original and override the <code>HARMONY</code> property with the name of a suitable cylindrical color space. Afterwards, all color color harmony calculations will use the specified color space unless overridden via the method's <code>space</code> parameter.</p> <pre><code>&gt;&gt;&gt; class Custom(Color):\n...     HARMONY = 'hsl'\n... \n&gt;&gt;&gt; HtmlSteps(Custom('red').harmony('split'))\n[color(srgb 1 0 0 / 1), color(srgb 0 0.5 1 / 1), color(srgb 0 1 0.5 / 1)]\n</code></pre> class Custom(Color):     HARMONY = 'hsl'  HtmlSteps(Custom('red').harmony('split')) Edit Share Run Cancel"},{"location":"interpolation/","title":"Color Interpolation","text":"<p>Interpolation is a type of estimation that finds new data points based on the range of a discrete set of known data points. When used in the context of color, it is finding one or more colors that reside between any two given colors. This is often used to simulate mixing colors, creating gradients, or even create color palettes.</p> <p>ColorAide provides a number of useful utilities based on interpolation.</p>"},{"location":"interpolation/#linear-interpolation","title":"Linear Interpolation","text":"<p>One of the most common, and easiest ways to interpolate data between two points is to use linear interpolation. An easy way of thinking about this concept is to imagine drawing a straight line that connects two colors within a color space. We could then navigate along that line and return colors at different points to simulate mixing colors at various percentages or return the whole range and create a gradient.</p> <p>To further illustrate this point, the example below shows a slice of the Oklab color space at a lightness of 70%. On this 2D plane, we select two colors: <code>oklab(0.7 0.15 0.1)</code> and <code>oklab(0.7 -0.03 -0.12)</code>. We then connect these two colors with a line. We can then select any point on the line to simulate the mixing of these colors. 0% would yield the first color, 100% would yield the second color, and 50% would yield a new color: <code>oklab(0.7 0.06 -0.01)</code>.</p> <p></p> <p>Interpolation performed at 50%</p> <p>The <code>interpolate</code> method allows a user to create a linear interpolation function using two or more colors. By default, a returned interpolation function accepts numerical input in the domain of [0, 1] and will cause a new color between the specified colors to be returned.</p> <p>By default, colors are interpolated in the perceptually uniform Oklab color space, though any supported color space can be used instead. This also applies to all methods that use interpolation, such as <code>steps</code>, <code>mix</code>, etc.</p> <p>As an example, below we create an interpolation between <code>rebeccapurple</code> and <code>lch(85% 100 85)</code>. We then step through values of <code>0.0</code>, <code>0.1</code>, <code>0.2</code>, etc. This returns colors at various positions on the line that connects the two colors, <code>0</code> returning <code>rebeccapurple</code> and <code>1</code> returning <code>lch(85% 100 85)</code>.</p> <pre><code>&gt;&gt;&gt; i = Color.interpolate([\"rebeccapurple\", \"lch(85% 100 85)\"], space='lch')\n&gt;&gt;&gt; [i(x / 10).to_string() for x in range(10 + 1)]\n['rgb(102 51 153)', 'rgb(142.02 45.341 154.32)', 'rgb(178.57 36.395 149.51)', 'rgb(211.1 28.455 139.17)', 'rgb(238.6 32.963 124.25)', 'rgb(255 53.081 105.76)', 'rgb(255 91.068 90.053)', 'rgb(255 123.62 78.434)', 'rgb(255 152.43 69.779)', 'rgb(255 178.23 51.263)', 'rgb(255 204.41 0)']\n</code></pre> i = Color.interpolate([\"rebeccapurple\", \"lch(85% 100 85)\"], space='lch') [i(x / 10).to_string() for x in range(10 + 1)] Edit Share Run Cancel <p>If we create enough steps, we can create a gradient.</p> <pre><code>&gt;&gt;&gt; Color.interpolate(\n...     [\"rebeccapurple\", \"lch(85% 100 85)\"],\n...     space='lch'\n... )\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x10c88dc50&gt;\n</code></pre> Color.interpolate(     [\"rebeccapurple\", \"lch(85% 100 85)\"],     space='lch' ) Edit Share Run Cancel <p>Interpolating in Constrained Gamuts</p> <p>Some color spaces, like sRGB, have a limited gamut, but have extended ranges that allow them to represent out of gamut colors in a sane way. Other models, like HSL, HSV, and HWB have the same limited gamut, but have no sane way to represent out of gamut colors. If colors are requested to be interpolated and are too big to be interpolated in the requested color space and cannot properly be represented in that space or model, the colors will be gamut mapped before interpolation.</p>"},{"location":"interpolation/#piecewise-interpolation","title":"Piecewise Interpolation","text":"<p>Piecewise interpolation takes the idea of linear interpolation and then applies it to multiple colors. As drawing a straight line through a series of points greater than two can be difficult to achieve, piecewise interpolation creates straight lines between each color in a chain of colors.</p> <p></p> <p>When the <code>interpolate</code> method receives more that two colors, the interpolation will utilize piecewise interpolation and interpolation will be broken up between each pair of colors. The function, just like when interpolating between two colors, still operates by default in the domain of [0, 1], only it will now apply to the entire range of colors.</p> <p>Piecewise interpolation simply breaks up a series of data points into segments in order to apply interpolation individually on each segment.</p> <pre><code>&gt;&gt;&gt; Color.interpolate(['black', 'red', 'white'])\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x10c8c6b90&gt;\n</code></pre> Color.interpolate(['black', 'red', 'white']) Edit Share Run Cancel <p>This approach generally works well, but since the placement of colors may not be in a straight line, you will often have pivot points and the transition may not be quite as smooth at these locations.</p>"},{"location":"interpolation/#cubic-spline-interpolation","title":"Cubic Spline Interpolation","text":"<p>Linear interpolation is nice because it is easy to implement, and due to its straight forward nature, pretty fast. With that said, it doesn't always have the smoothest transitions. It turns out that there are other piecewise ways to interpolate that can yield smoother results.</p> <p>Inspired by some efforts seen on the web and in the great JavaScript library Culori, ColorAide implements a number of spline based interpolation methods.</p>"},{"location":"interpolation/#b-spline","title":"B-Spline","text":"<p>B-spline is a piecewise spline similar to Bezier curves. It utilizes \"control points\" that help shape the interpolation path through a series of colors. Like Bezier Curves, the path does not pass through the control points, but it is clamped at the start and end. Essentially, the interpolation path passes through both end colors and bends that path along the way towards the other colors being used as control points.</p> <p>It can be used by specifying <code>bspline</code> as the interpolation method.</p> <pre><code>&gt;&gt;&gt; Color.interpolate(['red', 'green', 'blue', 'orange'], method='bspline')\n&lt;coloraide.interpolate.bspline.InterpolatorBSpline object at 0x10c8b0610&gt;\n</code></pre> Color.interpolate(['red', 'green', 'blue', 'orange'], method='bspline') Edit Share Run Cancel"},{"location":"interpolation/#natural","title":"Natural","text":"<p>The \"natural\" spline is the same as the B-spline approach except an algorithm is applied that uses the colors as data points and calculates new control points such that the interpolation passes through all the data points. This means that the path will pass through all the colors. The resultant spline has the continuity and properties of a natural spline, hence the name.</p> <p>One down side is that it can overshoot or undershoot a bit, and can occasionally cause the interpolation path to pass out of gamut if interpolating on an edge.</p> <p>It can be used by specifying <code>natural</code> as the interpolation method.</p> <pre><code>&gt;&gt;&gt; Color.interpolate(['red', 'green', 'blue', 'orange'], method='natural')\n&lt;coloraide.interpolate.bspline_natural.InterpolatorNaturalBSpline object at 0x10b78ad10&gt;\n</code></pre> Color.interpolate(['red', 'green', 'blue', 'orange'], method='natural') Edit Share Run Cancel"},{"location":"interpolation/#monotone","title":"Monotone","text":"<p>The \"monotone\" spline is a piecewise interpolation spline that passes through all its data points and helps to preserve monotonicity. As far as we are concerned, the important thing to note is that it greatly reduces any overshoot or undershoot in the interpolation.</p> <pre><code>&gt;&gt;&gt; Color.interpolate(['red', 'green', 'blue', 'orange'], method='monotone')\n&lt;coloraide.interpolate.monotone.InterpolatorMonotone object at 0x10c3e2510&gt;\n</code></pre> Color.interpolate(['red', 'green', 'blue', 'orange'], method='monotone') Edit Share Run Cancel"},{"location":"interpolation/#catmull-rom","title":"Catmull-Rom","text":"<p>Catmull-Rom is Not Registered By Default</p> <p></p> <p>Lastly, the Catmull-Rom spline is another \"interpolating\" spline that passes through all of its data points, similar to the \"natural\" spline, but it but does not share the same continuity and properties of a \"natural\" spline.</p> <p>Much like the \"natural\" spline, it can overshoot or undershoot.</p> <p>Catmull-Rom is not registered by default, but can be registered as shown below and then used by specifying <code>catrom</code> as the interpolation method.</p> <pre><code>&gt;&gt;&gt; from coloraide import Color\n&gt;&gt;&gt; from coloraide.interpolate.catmull_rom import CatmullRom\n&gt;&gt;&gt; class Custom(Color): ...\n... \n&gt;&gt;&gt; Custom.register(CatmullRom())\n&gt;&gt;&gt; Custom.interpolate(['red', 'green', 'blue', 'orange'], method='catrom')\n&lt;coloraide.interpolate.catmull_rom.InterpolatorCatmullRom object at 0x10c938cd0&gt;\n</code></pre> from coloraide import Color from coloraide.interpolate.catmull_rom import CatmullRom  class Custom(Color): ...  Custom.register(CatmullRom())  Custom.interpolate(['red', 'green', 'blue', 'orange'], method='catrom') Edit Share Run Cancel"},{"location":"interpolation/#hue-interpolation","title":"Hue Interpolation","text":"<p>In interpolation, hues are handled special allowing us to control the way in which hues are evaluated. By default, the shortest angle between two hues is targeted for interpolation, but the <code>hue</code> option allows us to redefine this behavior in a number of interesting ways: <code>shorter</code>, <code>longer</code>, <code>increasing</code>, <code>decreasing</code>, and <code>specified</code>. Below, we can see how the interpolation varies using <code>shorter</code> vs <code>longer</code> (interpolate between the longest angle).</p> <pre><code>&gt;&gt;&gt; i = Color.interpolate(\n...     [\"lch(52% 58.1 22.7)\", Color(\"lch(56% 49.1 257.1)\").mask(\"hue\", invert=True)],\n...     space=\"lch\"\n... )\n&gt;&gt;&gt; i(0.2477).to_string()\nlch(52 58.1 351.59)\n&gt;&gt;&gt; i = Color.interpolate(\n...     [\"lch(52% 58.1 22.7)\", Color(\"lch(56% 49.1 257.1)\").mask(\"hue\", invert=True)],\n...     space=\"lch\",\n...     hue=\"longer\"\n... )\n&gt;&gt;&gt; i(0.2477).to_string()\nlch(52 58.1 80.761)\n</code></pre> i = Color.interpolate(     [\"lch(52% 58.1 22.7)\", Color(\"lch(56% 49.1 257.1)\").mask(\"hue\", invert=True)],     space=\"lch\" ) i(0.2477).to_string() i = Color.interpolate(     [\"lch(52% 58.1 22.7)\", Color(\"lch(56% 49.1 257.1)\").mask(\"hue\", invert=True)],     space=\"lch\",     hue=\"longer\" ) i(0.2477).to_string() Edit Share Run Cancel <p>To help visualize the different hue methods, consider the following evaluation between <code>rebeccapurple</code> and <code>lch(85% 85 805)</code>. Below we will demonstrate each of the different hue evaluations. To learn more, check out the CSS level 4 specification which describes each one.</p> <p>Interpolating Multiple Colors</p> <p>The algorithm has been tweaked in order to calculate fix-ups of multiple hues such that they are all relative to each other. This is a requirement for interpolation methods that use cubic splines that evaluate many hues at the same time as opposed to linear, piecewise interpolation that only evaluates two hues at any given time.</p> shorterlongerincreasingdecreasingspecified <pre><code>&gt;&gt;&gt; Color.interpolate(\n...     [\"rebeccapurple\", \"lch(85% 100 805)\"],\n...     space='lch',\n...     hue=\"shorter\"\n... )\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x10b78a050&gt;\n</code></pre> Color.interpolate(     [\"rebeccapurple\", \"lch(85% 100 805)\"],     space='lch',     hue=\"shorter\" ) Edit Share Run Cancel <pre><code>&gt;&gt;&gt; Color.interpolate(\n...     [\"rebeccapurple\", \"lch(85% 100 805)\"],\n...     space='lch',\n...     hue=\"longer\"\n... )\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x10c8a3390&gt;\n</code></pre> Color.interpolate(     [\"rebeccapurple\", \"lch(85% 100 805)\"],     space='lch',     hue=\"longer\" ) Edit Share Run Cancel <pre><code>&gt;&gt;&gt; Color.interpolate(\n...     [\"rebeccapurple\", \"lch(85% 100 805)\"],\n...     space='lch',\n...     hue=\"increasing\"\n... )\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x10c3dd2d0&gt;\n</code></pre> Color.interpolate(     [\"rebeccapurple\", \"lch(85% 100 805)\"],     space='lch',     hue=\"increasing\" ) Edit Share Run Cancel <pre><code>&gt;&gt;&gt; Color.interpolate(\n...     [\"rebeccapurple\", \"lch(85% 100 805)\"],\n...     space='lch',\n...     hue=\"decreasing\"\n... )\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x10ac82f10&gt;\n</code></pre> Color.interpolate(     [\"rebeccapurple\", \"lch(85% 100 805)\"],     space='lch',     hue=\"decreasing\" ) Edit Share Run Cancel <pre><code>&gt;&gt;&gt; Color.interpolate(\n...     [\"rebeccapurple\", \"lch(85% 100 805)\"],\n...     space='lch',\n...     hue=\"specified\"\n... )\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x10c777250&gt;\n</code></pre> Color.interpolate(     [\"rebeccapurple\", \"lch(85% 100 805)\"],     space='lch',     hue=\"specified\" ) Edit Share Run Cancel"},{"location":"interpolation/#interpolating-with-alpha","title":"Interpolating with Alpha","text":"<p>Interpolating color channels is pretty straight forward and uses traditional linear interpolation logic, but when introducing transparency to a color, interpolation uses a concept known as premultiplication which alters the normal interpolation process.</p> <p>Premultiplication is a technique that tends to produce better results when two colors have differing transparency. It essentially accounts for the transparency and uses it to weight how may a given color channel will contribute to the interpolation. A more transparent color's channels will naturally contribute less.</p> <p>Consider the following example. Normally, when transitioning to a \"transparent\" color, the colors will be more gray during the transition. This is because <code>transparent</code> is actually black. But when using premultiplication, the transition looks just as one would expect as the transparent color's channels are weighted less due to the high transparency.</p> <pre><code>&gt;&gt;&gt; Color.interpolate(['white', 'transparent'], space='srgb', premultiplied=False)\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x10c3e2ed0&gt;\n&gt;&gt;&gt; Color.interpolate(['white', 'transparent'], space='srgb')\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x10c82f3d0&gt;\n</code></pre> Color.interpolate(['white', 'transparent'], space='srgb', premultiplied=False) Color.interpolate(['white', 'transparent'], space='srgb') Edit Share Run Cancel <p>As a final example, below we have an opaque orange and a blue that is quite transparent. Logically, the blue shouldn't have as big an affect on the overall color as it is so faint, and yet, in the un-premultiplied example, when mixing the colors equally, we see that the resultant color is also equally influenced by the hue of both colors. In the premultiplied example, we see that orange is still quite dominant at 50% as it is fully opaque.</p> <pre><code>&gt;&gt;&gt; Color('orange').mix(Color('blue').set('alpha', 0.25), space='srgb', premultiplied=False)\ncolor(srgb 0.5 0.32353 0.5 / 0.625)\n&gt;&gt;&gt; Color('orange').mix(Color('blue').set('alpha', 0.25), space='srgb')\ncolor(srgb 0.8 0.51765 0.2 / 0.625)\n</code></pre> Color('orange').mix(Color('blue').set('alpha', 0.25), space='srgb', premultiplied=False) Color('orange').mix(Color('blue').set('alpha', 0.25), space='srgb') Edit Share Run Cancel <p>If we interpolate it, we can see the difference in transition.</p> <pre><code>&gt;&gt;&gt; Color.interpolate(['orange', Color('blue').set('alpha', 0.25)], space='srgb', premultiplied=False)\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x10c8c35d0&gt;\n&gt;&gt;&gt; Color.interpolate(['orange', Color('blue').set('alpha', 0.25)], space='srgb')\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x10c8b2c10&gt;\n</code></pre> Color.interpolate(['orange', Color('blue').set('alpha', 0.25)], space='srgb', premultiplied=False) Color.interpolate(['orange', Color('blue').set('alpha', 0.25)], space='srgb') Edit Share Run Cancel <p>There may be some cases where it is desired to use no premultiplication in alpha blending. One could simply be that you need to mimic the same behavior of a system that does not use premultiplied interpolation. If so, simply set <code>premultiplied</code> to <code>False</code> as shown above.</p>"},{"location":"interpolation/#masking","title":"Masking","text":"<p>If desired, we can mask off specific channels that we do not wish to interpolate. Masking works by cloning the color and setting the specified channels as undefined (internally set to <code>NaN</code>). When interpolating, if one color's channel has a <code>NaN</code>, the other color's channel will be used as the result, keeping that channel at a constant value. If both colors have a <code>NaN</code> for the same channel, then <code>NaN</code> will be returned.</p> <p>Magic Behind NaN</p> <p>There are times when <code>NaN</code> values can happen naturally, such as with achromatic colors with hues. To learn more, check out Undefined Handling/NaN Handling.</p> <p>In the following example, we have a base color of <code>lch(52% 58.1 22.7)</code> which we then interpolate with <code>lch(56% 49.1 257.1)</code>. We then mask off the second color's channels except for <code>hue</code>. Applying this logic, we will end up with a range of colors that maintains the same lightness and chroma as the first color, but with different hues. We can see as we step through the colors that only the hue is interpolated.</p> <pre><code>&gt;&gt;&gt; i = Color.interpolate(\n...     [\"lch(52% 58.1 22.7)\", Color(\"lch(56% 49.1 257.1)\").mask(['lightness', 'chroma', 'alpha'])],\n...     space=\"lch\"\n... )\n&gt;&gt;&gt; [i(x/10).to_string() for x in range(10)]\n['lch(52 58.1 22.7)', 'lch(52 58.1 10.14)', 'lch(52 58.1 357.58)', 'lch(52 58.1 345.02)', 'lch(52 58.1 332.46)', 'lch(52 58.1 319.9)', 'lch(52 58.1 307.34)', 'lch(52 58.1 294.78)', 'lch(52 58.1 282.22)', 'lch(52 58.1 269.66)']\n</code></pre> i = Color.interpolate(     [\"lch(52% 58.1 22.7)\", Color(\"lch(56% 49.1 257.1)\").mask(['lightness', 'chroma', 'alpha'])],     space=\"lch\" ) [i(x/10).to_string() for x in range(10)] Edit Share Run Cancel <p>You can also create inverted masks. An inverted mask will mask all except the specified channel.</p> <pre><code>&gt;&gt;&gt; i = Color.interpolate(\n...     [\"lch(52% 58.1 22.7)\", Color(\"lch(56% 49.1 257.1)\").mask('hue', invert=True)],\n...     space=\"lch\"\n... )\n&gt;&gt;&gt; [i(x/10).to_string() for x in range(10)]\n['lch(52 58.1 22.7)', 'lch(52 58.1 10.14)', 'lch(52 58.1 357.58)', 'lch(52 58.1 345.02)', 'lch(52 58.1 332.46)', 'lch(52 58.1 319.9)', 'lch(52 58.1 307.34)', 'lch(52 58.1 294.78)', 'lch(52 58.1 282.22)', 'lch(52 58.1 269.66)']\n</code></pre> i = Color.interpolate(     [\"lch(52% 58.1 22.7)\", Color(\"lch(56% 49.1 257.1)\").mask('hue', invert=True)],     space=\"lch\" ) [i(x/10).to_string() for x in range(10)] Edit Share Run Cancel"},{"location":"interpolation/#easing-functions","title":"Easing Functions","text":"<p>When interpolating, whether using linear interpolation or something like B-Spline interpolation, the transitioning between colors is always linear in time, even if the path to those colors is not. For example, if you are interpolating between 2 colors and you request a <code>0.5</code> point on that line, it will always be in the middle. This is because, no matter how crooked the path, the rate of change on that path is always linear.</p> <p>By default, ColorAide uses linear transitions when interpolating, but there are times that a different, more dynamic transition may be desired. This can be achieved by using the <code>progress</code> parameter on any of the interpolation related functions provided by ColorAide.</p> <p><code>progress</code> accepts an easing function that takes a single <code>time</code> input and returns a new <code>time</code> input. This allows for a user to augment the rate of change when transitioning from one color to another. Inputs are almost always between 0 - 1 unless <code>extrapolate</code> is enabled and the user has manually input a range beyond 0 - 1. Even a change in domain will not affect the range as once the domain is accounted for, internally the domain [0, 1] is used.</p> <p>ColorAide provides 5 basic easing functions out of the box along with <code>cubic_bezier</code> which is used to create all of the aforementioned easing function except <code>linear</code>, which simply returns what is given as an input.</p> <p>Create Your Own Cubic Bezier Easings Online: https://cubic-bezier.com</p> More Common Cubic Bezier Easings <p>The following were all acquired from from https://matthewlein.com/tools/ceaser.js.</p> <pre><code>ease_in_quad = cubic_bezier(0.550, 0.085, 0.680, 0.530)\nease_in_cubic = cubic_bezier(0.550, 0.055, 0.675, 0.190)\nease_in_quart = cubic_bezier(0.895, 0.030, 0.685, 0.220)\nease_in_quint = cubic_bezier(0.755, 0.050, 0.855, 0.060)\nease_in_sine = cubic_bezier(0.470, 0.000, 0.745, 0.715)\nease_in_expo = cubic_bezier(0.950, 0.050, 0.795, 0.035)\nease_in_circ = cubic_bezier(0.600, 0.040, 0.980, 0.335)\nease_in_back = cubic_bezier(0.600, -0.280, 0.735, 0.045)\n\nease_out_quad = cubic_bezier(0.250, 0.460, 0.450, 0.940)\nease_out_cubic = cubic_bezier(0.215, 0.610, 0.355, 1.000)\nease_out_quart = cubic_bezier(0.165, 0.840, 0.440, 1.000)\nease_out_quint = cubic_bezier(0.230, 1.000, 0.320, 1.000)\nease_out_sine = cubic_bezier(0.390, 0.575, 0.565, 1.000)\nease_out_expo = cubic_bezier(0.190, 1.000, 0.220, 1.000)\nease_out_circ = cubic_bezier(0.075, 0.820, 0.165, 1.000)\nease_out_back = cubic_bezier(0.175, 0.885, 0.320, 1.275)\n\nease_in_out_quad = cubic_bezier(0.455, 0.030, 0.515, 0.955)\nease_in_out_cubic = cubic_bezier(0.645, 0.045, 0.355, 1.000)\nease_in_out_quart = cubic_bezier(0.770, 0.000, 0.175, 1.000)\nease_in_out_quint = cubic_bezier(0.860, 0.000, 0.070, 1.000)\nease_in_out_sine = cubic_bezier(0.445, 0.050, 0.550, 0.950)\nease_in_out_expo = cubic_bezier(1.000, 0.000, 0.000, 1.000)\nease_in_out_circ = cubic_bezier(0.785, 0.135, 0.150, 0.860)\nease_in_out_back = cubic_bezier(0.680, -0.550, 0.265, 1.550)\n</code></pre> LinearEaseEase InEase OutEase In/OutCubic Bezier <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p>Here, we are using the default \"ease in\" and \"ease out\" easing functions provided by ColorAide.</p> <pre><code>&gt;&gt;&gt; from coloraide import ease_in, ease_out\n&gt;&gt;&gt; Color.interpolate(\n...     [\"green\", \"blue\"],\n...     progress=ease_in\n... )\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x10c84a010&gt;\n&gt;&gt;&gt; Color.interpolate(\n...     [\"green\", \"blue\"]\n... )\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x10c8a9510&gt;\n&gt;&gt;&gt; Color.interpolate(\n...     [\"green\", \"blue\"],\n...     progress=ease_out\n... )\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x10c8c5d90&gt;\n</code></pre> from coloraide import ease_in, ease_out  Color.interpolate(     [\"green\", \"blue\"],     progress=ease_in ) Color.interpolate(     [\"green\", \"blue\"] ) Color.interpolate(     [\"green\", \"blue\"],     progress=ease_out ) Edit Share Run Cancel <p>Additionally, easing functions can be injected inline which allows a user to control how easing is performed between specific sub-interpolations within piecewise interpolation.</p> <pre><code>&gt;&gt;&gt; Color.interpolate([\"red\", \"green\", ease_out, \"blue\"])\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x10c8a0490&gt;\n</code></pre> Color.interpolate([\"red\", \"green\", ease_out, \"blue\"]) Edit Share Run Cancel <p>ColorAide even lets you apply easing functions to specific channels, though they can only be done this way for the entire operation. This can be done to one or more channels at a time. Below, we apply an exponential \"ease in\" to <code>alpha</code> while allowing all other channels to interpolate normally.</p> <pre><code>&gt;&gt;&gt; ease_in_expo = cubic_bezier(0.950, 0.050, 0.795, 0.035)\n&gt;&gt;&gt; Color.interpolate(\n...     [\"lch(50% 50 0)\", \"lch(90% 50 260 / 0.5)\"],\n...     progress={\n...         'alpha': ease_in_expo\n...     }\n... )\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x10b772050&gt;\n</code></pre> ease_in_expo = cubic_bezier(0.950, 0.050, 0.795, 0.035) Color.interpolate(     [\"lch(50% 50 0)\", \"lch(90% 50 260 / 0.5)\"],     progress={         'alpha': ease_in_expo     } ) Edit Share Run Cancel <p>We can also set all the channels to an easing function via <code>all</code> and then override specific channels. In this case, we exponentially \"ease out\" on all channels except the red channel, which we then force to be linear.</p> <pre><code>&gt;&gt;&gt; ease_out_expo = cubic_bezier(0.190, 1.000, 0.220, 1.000)\n&gt;&gt;&gt; Color.interpolate(\n...     [\"color(srgb 0 1 1)\", \"color(srgb 1 0 0)\"],\n...     progress={\n...         'all': ease_out_expo,\n...         'r': linear\n...     },\n...     space='srgb'\n... )\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x10c77e010&gt;\n</code></pre> ease_out_expo = cubic_bezier(0.190, 1.000, 0.220, 1.000) Color.interpolate(     [\"color(srgb 0 1 1)\", \"color(srgb 1 0 0)\"],     progress={         'all': ease_out_expo,         'r': linear     },     space='srgb' ) Edit Share Run Cancel"},{"location":"interpolation/#color-stops-and-hints","title":"Color Stops and Hints","text":"<p>Color stops are the position where the transition to and from a color starts and ends. By default, color stops are evenly distributed within the domain of [0, 1], but if desired, these color stops can be shifted.</p> <p>To specify color stops, simply wrap a color in a <code>coloraide.stop</code> object and specify the stop position. Stop positions will then cause the transition of the targeted color to be moved.</p> <pre><code>&gt;&gt;&gt; from coloraide import stop\n&gt;&gt;&gt; Color.interpolate(['orange', 'purple', 'green'])\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x10c7e6b50&gt;\n&gt;&gt;&gt; Color.interpolate(['orange', stop('purple', 0.25), 'green'])\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x10b79ce90&gt;\n</code></pre> from coloraide import stop Color.interpolate(['orange', 'purple', 'green']) Color.interpolate(['orange', stop('purple', 0.25), 'green']) Edit Share Run Cancel <p>Color stops follow the rules as laid out in the CSS spec.</p> <p>CSS gradients also have a concept of \"hints\". Hints essentially define the midpoint between two colors. Instead of reinventing the wheel, and further complicating the interface, we've decided to just demonstrate color hints with easing functions. The logic comes directly from the CSS spec.</p> <p>Using the <code>hint</code> function, we can generate a midpoint easing method that moves the middle of the interpolation transition to the specified point which is relative to the two color stops it is between.</p> <pre><code>&gt;&gt;&gt; from coloraide import hint\n&gt;&gt;&gt; Color.interpolate(['orange', 'purple', 'green'])\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x10c3e2090&gt;\n&gt;&gt;&gt; Color.interpolate(['orange', hint(0.75), 'purple', 'green'])\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x10c3e2090&gt;\n</code></pre> from coloraide import hint  Color.interpolate(['orange', 'purple', 'green']) Color.interpolate(['orange', hint(0.75), 'purple', 'green']) Edit Share Run Cancel"},{"location":"interpolation/#mixing","title":"Mixing","text":"<p>Interpolation Options</p> <p>Any options not consumed by <code>mix</code> will be passed to the underlying <code>interpolation</code> function. This includes options like <code>hue</code>, <code>progress</code>, etc.</p> <p>The <code>mix</code> function is built on top of the <code>interpolate</code> function and provides a simple, quick, and intuitive simple mixing of two colors. Just pass in a color to mix with the base color, and you'll get an equal mix of the two.</p> <pre><code>&gt;&gt;&gt; Color(\"red\").mix(Color(\"blue\"))\ncolor(srgb 0.55044 0.32562 0.6365 / 1)\n</code></pre> Color(\"red\").mix(Color(\"blue\")) Edit Share Run Cancel <p>By default, colors are mixed at 50%, but the percentage can be controlled. Here we mix the color <code>blue</code> into the color <code>red</code> at 20%. With <code>blue</code> at 20% and <code>red</code> at 80%, this gives us a more reddish color.</p> <pre><code>&gt;&gt;&gt; Color(\"red\").mix(Color(\"blue\"), 0.2)\ncolor(srgb 0.82084 0.26522 0.37806 / 1)\n</code></pre> Color(\"red\").mix(Color(\"blue\"), 0.2) Edit Share Run Cancel <p>As with all interpolation based functions, if needed, a different color space can be specified with the <code>space</code> parameter or even a different interpolation method via <code>method</code>. <code>mix</code> accepts all the same parameters used in <code>interpolate</code>, though concepts like stops and hints are not allowed with mixing.</p> <pre><code>&gt;&gt;&gt; Color(\"red\").mix(Color(\"blue\"), space=\"hsl\", method='bspline')\ncolor(srgb 1 0 1 / 1)\n</code></pre> Color(\"red\").mix(Color(\"blue\"), space=\"hsl\", method='bspline') Edit Share Run Cancel <p>Mix can also accept a string and will create the color for us which is great if we don't need to work with the second color afterwards.</p> <pre><code>&gt;&gt;&gt; Color(\"red\").mix(\"blue\", 0.2)\ncolor(srgb 0.82084 0.26522 0.37806 / 1)\n</code></pre> Color(\"red\").mix(\"blue\", 0.2) Edit Share Run Cancel <p>Mixing will always return a new color unless <code>in_place</code> is set <code>True</code>.</p>"},{"location":"interpolation/#steps","title":"Steps","text":"<p>Interpolation Options</p> <p>Any options not consumed by <code>mix</code> will be passed to the underlying <code>interpolation</code> function. This includes options like <code>hue</code>, <code>progress</code>, etc.</p> <p>The <code>steps</code> method provides an intuitive interface to create lists of discrete colors. Like mixing, it is also built on <code>interpolate</code>. Just provide two colors, and specify how many <code>steps</code> are wanted.</p> <pre><code>&gt;&gt;&gt; Color.steps([\"red\", \"blue\"], steps=10)\n[color(srgb 1 0 0 / 1), color(srgb 0.90045 0.20791 0.27521 / 1), color(srgb 0.80092 0.27537 0.40045 / 1), color(srgb 0.70118 0.31007 0.50198 / 1), color(srgb 0.60092 0.32459 0.59316 / 1), color(srgb 0.49961 0.32272 0.67882 / 1), color(srgb 0.39631 0.30469 0.76127 / 1), color(srgb 0.28903 0.26729 0.84181 / 1), color(srgb 0.17188 0.19896 0.92122 / 1), color(srgb 0 0 1 / 1)]\n</code></pre> Color.steps([\"red\", \"blue\"], steps=10) Edit Share Run Cancel <p>If desired, multiple colors can be provided, and steps will be returned for all the interpolated segments. When interpolating multiple colors, piecewise interpolation is used (which is covered in more detail later).</p> <pre><code>&gt;&gt;&gt; Color.steps([\"red\", \"orange\", \"yellow\", \"green\"], steps=10)\n[color(srgb 1 0 0 / 1), color(srgb 1.01 0.34365 0.0003 / 1), color(srgb 1.0105 0.50766 0.00032 / 1), color(srgb 1 0.64706 0 / 1), color(srgb 1.009 0.76646 0.00013 / 1), color(srgb 1.0093 0.88367 0.00014 / 1), color(srgb 1 1 0 / 1), color(srgb 0.71561 0.83059 0.00014 / 1), color(srgb 0.42921 0.66463 0.00011 / 1), color(srgb 0 0.50196 0 / 1)]\n</code></pre> Color.steps([\"red\", \"orange\", \"yellow\", \"green\"], steps=10) Edit Share Run Cancel <p>Steps can also be configured to return colors based on a maximum Delta E distance. This means you can ensure the distance between all colors is no greater than a certain value.</p> <p>In this example, we specify the color <code>color(display-p3 0 1 0)</code> and interpolate steps between <code>red</code>. The result gives us an array of colors, where the distance between any two colors should be no greater than the Delta E result of 10.</p> <pre><code>&gt;&gt;&gt; Color.steps(\n...     [Color(\"display-p3\", [0, 1, 0]), \"red\"],\n...     space=\"lch\",\n...     out_space=\"srgb\",\n...     max_delta_e=10\n... )\n[color(srgb -0.5116 1.0183 -0.31067 / 1), color(srgb -0.4504 0.99903 -0.32673 / 1), color(srgb -0.37655 0.97943 -0.33694 / 1), color(srgb -0.27847 0.95946 -0.34286 / 1), color(srgb -0.09291 0.9391 -0.34554 / 1), color(srgb 0.23528 0.91833 -0.34574 / 1), color(srgb 0.34809 0.89715 -0.34401 / 1), color(srgb 0.42823 0.87552 -0.34098 / 1), color(srgb 0.49308 0.85343 -0.33745 / 1), color(srgb 0.54849 0.83088 -0.33349 / 1), color(srgb 0.59727 0.80784 -0.32909 / 1), color(srgb 0.64097 0.7843 -0.32423 / 1), color(srgb 0.6806 0.76025 -0.3189 / 1), color(srgb 0.71679 0.73568 -0.3131 / 1), color(srgb 0.74999 0.71057 -0.30681 / 1), color(srgb 0.78053 0.6849 -0.30002 / 1), color(srgb 0.80865 0.65865 -0.29271 / 1), color(srgb 0.83451 0.6318 -0.28486 / 1), color(srgb 0.85826 0.60433 -0.27644 / 1), color(srgb 0.87999 0.57619 -0.26744 / 1), color(srgb 0.89978 0.54736 -0.25782 / 1), color(srgb 0.9177 0.51777 -0.24752 / 1), color(srgb 0.9338 0.48735 -0.2365 / 1), color(srgb 0.9481 0.456 -0.22467 / 1), color(srgb 0.96064 0.4236 -0.21195 / 1), color(srgb 0.97145 0.38994 -0.19821 / 1), color(srgb 0.98055 0.35476 -0.18326 / 1), color(srgb 0.98796 0.31761 -0.16684 / 1), color(srgb 0.99369 0.27779 -0.14854 / 1), color(srgb 0.99777 0.23405 -0.12767 / 1), color(srgb 1.0002 0.18378 -0.10158 / 1), color(srgb 1.0009 0.11978 -0.06417 / 1), color(srgb 1 0 0 / 1)]\n</code></pre> Color.steps(     [Color(\"display-p3\", [0, 1, 0]), \"red\"],     space=\"lch\",     out_space=\"srgb\",     max_delta_e=10 ) Edit Share Run Cancel <p><code>max_steps</code> can be used to limit the results of <code>max_delta_e</code> in case result balloons to an unexpected size. Obviously, this affects the Delta E between the colors inversely. It should be noted that steps are injected equally between every color when satisfying a max Delta E limit in order to avoid shifting the midpoint. In some cases, in order to satisfy both the <code>max_delta_e</code> and the <code>max_steps</code> requirement, the number of steps may even be clipped such that they are less than the <code>max_steps</code> limit. <code>max_steps</code> is set to <code>1000</code> by default, but can be set to <code>None</code> if no limit is desired.</p> <pre><code>&gt;&gt;&gt; Color.steps(\n...     [Color(\"display-p3\", [0, 1, 0]), \"red\"],\n...     space=\"lch\",\n...     out_space=\"srgb\",\n...     max_delta_e=10,\n...     max_steps=10\n... )\n[color(srgb -0.5116 1.0183 -0.31067 / 1), color(srgb -0.09291 0.9391 -0.34554 / 1), color(srgb 0.49308 0.85343 -0.33745 / 1), color(srgb 0.6806 0.76025 -0.3189 / 1), color(srgb 0.80865 0.65865 -0.29271 / 1), color(srgb 0.89978 0.54736 -0.25782 / 1), color(srgb 0.96064 0.4236 -0.21195 / 1), color(srgb 0.99369 0.27779 -0.14854 / 1), color(srgb 1 0 0 / 1)]\n</code></pre> Color.steps(     [Color(\"display-p3\", [0, 1, 0]), \"red\"],     space=\"lch\",     out_space=\"srgb\",     max_delta_e=10,     max_steps=10 ) Edit Share Run Cancel <p>When specifying a <code>max_delta_e</code>, <code>steps</code> will function as a minimum required steps and will push the delta even smaller if the required steps is greater than the calculated steps via the maximum Delta E limit.</p> <pre><code>&gt;&gt;&gt; Color.steps(\n...     [Color(\"display-p3\", [0, 1, 0]), \"red\"],\n...     space=\"lch\",\n...     out_space=\"srgb\",\n...     max_delta_e=10,\n...     steps=50\n... )\n[color(srgb -0.5116 1.0183 -0.31067 / 1), color(srgb -0.47276 1.0057 -0.32192 / 1), color(srgb -0.42946 0.99307 -0.33039 / 1), color(srgb -0.37992 0.98024 -0.33661 / 1), color(srgb -0.32082 0.96725 -0.341 / 1), color(srgb -0.24447 0.9541 -0.34385 / 1), color(srgb -0.1198 0.94078 -0.34542 / 1), color(srgb 0.15996 0.92729 -0.34592 / 1), color(srgb 0.26558 0.91362 -0.3455 / 1), color(srgb 0.33665 0.89976 -0.34431 / 1), color(srgb 0.3931 0.88572 -0.34248 / 1), color(srgb 0.44104 0.8715 -0.34036 / 1), color(srgb 0.48324 0.85707 -0.33806 / 1), color(srgb 0.52118 0.84244 -0.33557 / 1), color(srgb 0.55582 0.82761 -0.33289 / 1), color(srgb 0.58776 0.81258 -0.33002 / 1), color(srgb 0.61745 0.79733 -0.32696 / 1), color(srgb 0.64519 0.78187 -0.32371 / 1), color(srgb 0.67123 0.76619 -0.32025 / 1), color(srgb 0.69575 0.75029 -0.31659 / 1), color(srgb 0.7189 0.73416 -0.31273 / 1), color(srgb 0.74079 0.7178 -0.30866 / 1), color(srgb 0.76151 0.7012 -0.30437 / 1), color(srgb 0.78113 0.68437 -0.29987 / 1), color(srgb 0.79972 0.66729 -0.29515 / 1), color(srgb 0.81733 0.64995 -0.2902 / 1), color(srgb 0.834 0.63236 -0.28502 / 1), color(srgb 0.84977 0.6145 -0.2796 / 1), color(srgb 0.86467 0.59636 -0.27393 / 1), color(srgb 0.87872 0.57794 -0.26801 / 1), color(srgb 0.89194 0.55922 -0.26182 / 1), color(srgb 0.90434 0.54018 -0.25536 / 1), color(srgb 0.91596 0.52082 -0.2486 / 1), color(srgb 0.92679 0.50111 -0.24154 / 1), color(srgb 0.93686 0.48103 -0.23415 / 1), color(srgb 0.94616 0.46054 -0.22641 / 1), color(srgb 0.95471 0.43961 -0.2183 / 1), color(srgb 0.96252 0.41819 -0.20979 / 1), color(srgb 0.96959 0.39623 -0.20082 / 1), color(srgb 0.97593 0.37364 -0.19136 / 1), color(srgb 0.98155 0.35032 -0.18134 / 1), color(srgb 0.98644 0.32615 -0.17067 / 1), color(srgb 0.99062 0.30093 -0.15926 / 1), color(srgb 0.99409 0.27439 -0.14694 / 1), color(srgb 0.99685 0.24615 -0.13353 / 1), color(srgb 0.99891 0.21556 -0.11841 / 1), color(srgb 1.0002 0.18152 -0.10034 / 1), color(srgb 1.0009 0.14177 -0.07755 / 1), color(srgb 1.0008 0.09013 -0.04535 / 1), color(srgb 1 0 0 / 1)]\n</code></pre> Color.steps(     [Color(\"display-p3\", [0, 1, 0]), \"red\"],     space=\"lch\",     out_space=\"srgb\",     max_delta_e=10,     steps=50 ) Edit Share Run Cancel <p><code>steps</code> uses the color class's default \u2206E method to calculate max \u2206E, the current default \u2206E being \u2206E*ab. While using something like \u2206E*00 is far more accurate, it is a much more expensive operation. If desired, the class's default \u2206E can be changed via subclassing the color object and and changing <code>DELTA_E</code> class variable or by manually specifying the method via the <code>delta_e</code> parameter.</p> \u2206E*ab.\u2206E*00 <pre><code>&gt;&gt;&gt; Color.steps(\n...     [Color(\"display-p3\", [0, 1, 0]), \"red\"],\n...     space=\"lch\",\n...     out_space=\"srgb\",\n...     max_delta_e=10,\n...     delta_e=\"76\"\n... )\n[color(srgb -0.5116 1.0183 -0.31067 / 1), color(srgb -0.4504 0.99903 -0.32673 / 1), color(srgb -0.37655 0.97943 -0.33694 / 1), color(srgb -0.27847 0.95946 -0.34286 / 1), color(srgb -0.09291 0.9391 -0.34554 / 1), color(srgb 0.23528 0.91833 -0.34574 / 1), color(srgb 0.34809 0.89715 -0.34401 / 1), color(srgb 0.42823 0.87552 -0.34098 / 1), color(srgb 0.49308 0.85343 -0.33745 / 1), color(srgb 0.54849 0.83088 -0.33349 / 1), color(srgb 0.59727 0.80784 -0.32909 / 1), color(srgb 0.64097 0.7843 -0.32423 / 1), color(srgb 0.6806 0.76025 -0.3189 / 1), color(srgb 0.71679 0.73568 -0.3131 / 1), color(srgb 0.74999 0.71057 -0.30681 / 1), color(srgb 0.78053 0.6849 -0.30002 / 1), color(srgb 0.80865 0.65865 -0.29271 / 1), color(srgb 0.83451 0.6318 -0.28486 / 1), color(srgb 0.85826 0.60433 -0.27644 / 1), color(srgb 0.87999 0.57619 -0.26744 / 1), color(srgb 0.89978 0.54736 -0.25782 / 1), color(srgb 0.9177 0.51777 -0.24752 / 1), color(srgb 0.9338 0.48735 -0.2365 / 1), color(srgb 0.9481 0.456 -0.22467 / 1), color(srgb 0.96064 0.4236 -0.21195 / 1), color(srgb 0.97145 0.38994 -0.19821 / 1), color(srgb 0.98055 0.35476 -0.18326 / 1), color(srgb 0.98796 0.31761 -0.16684 / 1), color(srgb 0.99369 0.27779 -0.14854 / 1), color(srgb 0.99777 0.23405 -0.12767 / 1), color(srgb 1.0002 0.18378 -0.10158 / 1), color(srgb 1.0009 0.11978 -0.06417 / 1), color(srgb 1 0 0 / 1)]\n</code></pre> Color.steps(     [Color(\"display-p3\", [0, 1, 0]), \"red\"],     space=\"lch\",     out_space=\"srgb\",     max_delta_e=10,     delta_e=\"76\" ) Edit Share Run Cancel <pre><code>&gt;&gt;&gt; Color.steps(\n...     [Color(\"display-p3\", [0, 1, 0]), \"red\"],\n...     space=\"lch\",\n...     out_space=\"srgb\",\n...     max_delta_e=10,\n...     delta_e=\"2000\"\n... )\n[color(srgb -0.5116 1.0183 -0.31067 / 1), color(srgb -0.37655 0.97943 -0.33694 / 1), color(srgb -0.09291 0.9391 -0.34554 / 1), color(srgb 0.34809 0.89715 -0.34401 / 1), color(srgb 0.49308 0.85343 -0.33745 / 1), color(srgb 0.59727 0.80784 -0.32909 / 1), color(srgb 0.6806 0.76025 -0.3189 / 1), color(srgb 0.74999 0.71057 -0.30681 / 1), color(srgb 0.80865 0.65865 -0.29271 / 1), color(srgb 0.85826 0.60433 -0.27644 / 1), color(srgb 0.89978 0.54736 -0.25782 / 1), color(srgb 0.9338 0.48735 -0.2365 / 1), color(srgb 0.96064 0.4236 -0.21195 / 1), color(srgb 0.98055 0.35476 -0.18326 / 1), color(srgb 0.99369 0.27779 -0.14854 / 1), color(srgb 1.0002 0.18378 -0.10158 / 1), color(srgb 1 0 0 / 1)]\n</code></pre> Color.steps(     [Color(\"display-p3\", [0, 1, 0]), \"red\"],     space=\"lch\",     out_space=\"srgb\",     max_delta_e=10,     delta_e=\"2000\" ) Edit Share Run Cancel <p>And much like <code>interpolate</code>, we can use <code>stops</code> and <code>hints</code> and any of the other supported <code>interpolate</code> features as well.</p> <pre><code>&gt;&gt;&gt; Color.steps(['orange', stop('purple', 0.25), 'green'], method='bspline', steps=10)\n[color(srgb 1 0.64706 0 / 1), color(srgb 0.77185 0.43332 0.39421 / 1), color(srgb 0.58315 0.30002 0.43861 / 1), color(srgb 0.50763 0.29361 0.42001 / 1), color(srgb 0.46179 0.31175 0.39515 / 1), color(srgb 0.41587 0.34125 0.36122 / 1), color(srgb 0.36562 0.37769 0.31743 / 1), color(srgb 0.30451 0.41805 0.2607 / 1), color(srgb 0.21829 0.4601 0.18124 / 1), color(srgb 0 0.50196 0 / 1)]\n</code></pre> Color.steps(['orange', stop('purple', 0.25), 'green'], method='bspline', steps=10) Edit Share Run Cancel"},{"location":"interpolation/#domains","title":"Domains","text":"<p>By default, interpolation has an input domain of [0, 1]. This domain applies to an entire interpolation, even ones that span multiple colors. Generally, this is sufficient and can be used to generate color scales, mixes, and steps in any way that a user needs, but there are times where a different domain would be helpful.</p> <p>Consider the use case of generating a color scale in relation to temperature. Temperature doesn't operate on a [0, 1] domain. We may want our color scale to span a particular range of temperature. We may also want to have the color scale align with specific temperature within that range. While the user can certainly craft the logic to translate these data points to a [0, 1] domain and calculate and apply color stops to align the, colors, it would be much more accessible if the user could simply change the domain to work with their data. Luckily, ColorAide is up to the challenge.</p> <pre><code>&gt;&gt;&gt; i = Color.interpolate(\n...     ['blue', 'green', 'yellow', 'orange', 'red'],\n...     domain=[-32, 32, 60, 85, 95]\n... )\n&gt;&gt;&gt; i(-32)\ncolor(srgb 0 0 1 / 1)\n&gt;&gt;&gt; i(47)\ncolor(srgb 0.60439 0.76498 0.00014 / 1)\n&gt;&gt;&gt; i(89)\ncolor(srgb 1.0112 0.47767 0.00035 / 1)\n&gt;&gt;&gt; i\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x10c904d10&gt;\n</code></pre> i = Color.interpolate(     ['blue', 'green', 'yellow', 'orange', 'red'],     domain=[-32, 32, 60, 85, 95] ) i(-32) i(47) i(89) i Edit Share Run Cancel <p>It should be noted that you are not constrained to provide the exact same amount of domain values as you have colors and can have differing amounts, but if you want to align specific colors to certain data points, then it helps.</p> <pre><code>&gt;&gt;&gt; Color.interpolate(\n...     ['blue', 'green', 'yellow', 'orange', 'red'],\n...     domain=[-32, 32, 60, 85, 95]\n... )\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x10c7d2890&gt;\n&gt;&gt;&gt; Color.interpolate(\n...     ['blue', 'green', 'yellow', 'orange', 'red'],\n...     domain=[-32, 95]\n... )\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x10c920150&gt;\n</code></pre> Color.interpolate(     ['blue', 'green', 'yellow', 'orange', 'red'],     domain=[-32, 32, 60, 85, 95] ) Color.interpolate(     ['blue', 'green', 'yellow', 'orange', 'red'],     domain=[-32, 95] ) Edit Share Run Cancel <p>Lastly, domains must be specified in ascending order of values. If a value decreases in magnitude, it will assume the value that comes right before it. This means you cannot put a domain in reverse. If you need to reverse the order, just flip the color order and setup the domain accordingly.</p> <pre><code>&gt;&gt;&gt; i = Color.interpolate(\n...     ['blue', 'green', 'yellow', 'orange', 'red'],\n...     domain=[-32, 32, 60, 20, 95]\n... )\n&gt;&gt;&gt; i.domain\n[-32, 32, 60, 60, 95]\n&gt;&gt;&gt; i\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x10c7e6850&gt;\n</code></pre> i = Color.interpolate(     ['blue', 'green', 'yellow', 'orange', 'red'],     domain=[-32, 32, 60, 20, 95] ) i.domain i Edit Share Run Cancel <p>Custom domains are most useful when working with <code>interpolate</code> directly, but you can use it in other methods like <code>steps</code> as well. As <code>steps</code> does not take a data point inputs like <code>interpolate</code>, we do not need to use the temperature data as an input except to set the domain, but the steps will be generated with the same alignment relative to the domain range.</p> <pre><code>&gt;&gt;&gt; Color.interpolate(\n...     ['blue', 'green', 'yellow', 'orange', 'red'],\n...     domain=[-32, 32, 60, 85, 95]\n... )\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x10c7c7650&gt;\n&gt;&gt;&gt; Color.steps(\n...     ['blue', 'green', 'yellow', 'orange', 'red'],\n...     steps=11,\n...     domain=[-32, 32, 60, 85, 95]\n... )\n[color(srgb 0 0 1 / 1), color(srgb -0.17047 0.28935 0.84567 / 1), color(srgb -0.20985 0.38427 0.69048 / 1), color(srgb -0.20804 0.44124 0.53032 / 1), color(srgb -0.16676 0.47789 0.35262 / 1), color(srgb -0.01414 0.50125 0.04058 / 1), color(srgb 0.51874 0.71524 0.00013 / 1), color(srgb 0.905 0.94335 0.00007 / 1), color(srgb 1.0099 0.86593 0.00015 / 1), color(srgb 1.0038 0.68611 0.00005 / 1), color(srgb 1 0 0 / 1)]\n</code></pre> Color.interpolate(     ['blue', 'green', 'yellow', 'orange', 'red'],     domain=[-32, 32, 60, 85, 95] ) Color.steps(     ['blue', 'green', 'yellow', 'orange', 'red'],     steps=11,     domain=[-32, 32, 60, 85, 95] ) Edit Share Run Cancel <p>Wile you can technically feed <code>domain</code> into <code>mix</code>, it is probably not as useful. It will respect the domain alignment, but mix always accepts a percentage of [0, 1], regardless of the underlying domain.</p>"},{"location":"interpolation/#extrapolation","title":"Extrapolation","text":"<p>By default, ColorAide clamps the entire progress of an interpolation to always be within the domain ([0, 1] by default). In most cases, this is more what most user expects and why this is the default. It should be noted that this does not affect easing functions, as the clamping is done prior to any easing function calls.</p> <p>If it is desired to extrapolate past 0 and 1, <code>extrapolate</code> can set to <code>True</code> on all interpolation methods.</p> <pre><code>&gt;&gt;&gt; Color('red').mix('blue', 0.5)\ncolor(srgb 0.55044 0.32562 0.6365 / 1)\n&gt;&gt;&gt; Color('red').mix('blue', -0.5, extrapolate=True)\ncolor(srgb 1.4512 -0.57257 -0.46028 / 1)\n</code></pre> Color('red').mix('blue', 0.5) Color('red').mix('blue', -0.5, extrapolate=True) Edit Share Run Cancel <p>As a larger example, we can purposely interpolate over a range with values beyond 0 and 1. Here we extended the range to -0.5 and 1.5.</p> <pre><code>&gt;&gt;&gt; offset, factor = 0.25, 1.5\n&gt;&gt;&gt; i = Color.interpolate(['red', 'blue'])\n&gt;&gt;&gt; HtmlGradient([i((r * factor / 100) - offset) for r in range(101)])\n[color(srgb 1 0 0 / 1), color(srgb 1 0 0 / 1), color(srgb 1 0 0 / 1), color(srgb 1 0 0 / 1), color(srgb 1 0 0 / 1), color(srgb 1 0 0 / 1), color(srgb 1 0 0 / 1), color(srgb 1 0 0 / 1), color(srgb 1 0 0 / 1), color(srgb 1 0 0 / 1), color(srgb 1 0 0 / 1), color(srgb 1 0 0 / 1), color(srgb 1 0 0 / 1), color(srgb 1 0 0 / 1), color(srgb 1 0 0 / 1), color(srgb 1 0 0 / 1), color(srgb 1 0 0 / 1), color(srgb 0.99552 0.02344 0.03318 / 1), color(srgb 0.98207 0.07954 0.10229 / 1), color(srgb 0.96863 0.11367 0.14449 / 1), color(srgb 0.95519 0.1393 0.17749 / 1), color(srgb 0.94176 0.16017 0.20551 / 1), color(srgb 0.92832 0.17789 0.23032 / 1), color(srgb 0.91488 0.19332 0.25287 / 1), color(srgb 0.90145 0.20696 0.27372 / 1), color(srgb 0.88802 0.21916 0.29325 / 1), color(srgb 0.87458 0.23017 0.31171 / 1), color(srgb 0.86115 0.24016 0.3293 / 1), color(srgb 0.84771 0.24927 0.34615 / 1), color(srgb 0.83427 0.25759 0.36237 / 1), color(srgb 0.82084 0.26522 0.37806 / 1), color(srgb 0.80739 0.27221 0.39328 / 1), color(srgb 0.79395 0.27862 0.40808 / 1), color(srgb 0.7805 0.2845 0.42252 / 1), color(srgb 0.76705 0.28989 0.43664 / 1), color(srgb 0.75359 0.29482 0.45047 / 1), color(srgb 0.74012 0.29931 0.46403 / 1), color(srgb 0.72665 0.3034 0.47736 / 1), color(srgb 0.71317 0.30709 0.49048 / 1), color(srgb 0.69968 0.31042 0.5034 / 1), color(srgb 0.68619 0.31339 0.51615 / 1), color(srgb 0.67268 0.31601 0.52873 / 1), color(srgb 0.65916 0.3183 0.54117 / 1), color(srgb 0.64563 0.32027 0.55346 / 1), color(srgb 0.63208 0.32193 0.56564 / 1), color(srgb 0.61852 0.32328 0.57769 / 1), color(srgb 0.60495 0.32434 0.58964 / 1), color(srgb 0.59135 0.32509 0.60149 / 1), color(srgb 0.57774 0.32556 0.61324 / 1), color(srgb 0.5641 0.32573 0.62491 / 1), color(srgb 0.55044 0.32562 0.6365 / 1), color(srgb 0.53676 0.32522 0.64802 / 1), color(srgb 0.52304 0.32454 0.65946 / 1), color(srgb 0.5093 0.32357 0.67085 / 1), color(srgb 0.49552 0.32231 0.68217 / 1), color(srgb 0.48171 0.32077 0.69343 / 1), color(srgb 0.46786 0.31892 0.70465 / 1), color(srgb 0.45397 0.31678 0.71582 / 1), color(srgb 0.44003 0.31434 0.72694 / 1), color(srgb 0.42604 0.31158 0.73801 / 1), color(srgb 0.41199 0.3085 0.74905 / 1), color(srgb 0.39788 0.30509 0.76005 / 1), color(srgb 0.38371 0.30134 0.77102 / 1), color(srgb 0.36946 0.29723 0.78196 / 1), color(srgb 0.35512 0.29275 0.79286 / 1), color(srgb 0.3407 0.28788 0.80374 / 1), color(srgb 0.32617 0.2826 0.81459 / 1), color(srgb 0.31152 0.27688 0.82541 / 1), color(srgb 0.29675 0.2707 0.83622 / 1), color(srgb 0.28182 0.26401 0.847 / 1), color(srgb 0.26673 0.25677 0.85776 / 1), color(srgb 0.25145 0.24894 0.86851 / 1), color(srgb 0.23593 0.24046 0.87924 / 1), color(srgb 0.22015 0.23123 0.88995 / 1), color(srgb 0.20405 0.22117 0.90065 / 1), color(srgb 0.18756 0.21016 0.91134 / 1), color(srgb 0.1706 0.19801 0.92201 / 1), color(srgb 0.15303 0.18452 0.93267 / 1), color(srgb 0.13466 0.16934 0.94332 / 1), color(srgb 0.1152 0.15199 0.95397 / 1), color(srgb 0.09414 0.13166 0.9646 / 1), color(srgb 0.07051 0.10682 0.97523 / 1), color(srgb 0.04194 0.0739 0.98585 / 1), color(srgb 0.00985 0.02108 0.99646 / 1), color(srgb 0 0 1 / 1), color(srgb 0 0 1 / 1), color(srgb 0 0 1 / 1), color(srgb 0 0 1 / 1), color(srgb 0 0 1 / 1), color(srgb 0 0 1 / 1), color(srgb 0 0 1 / 1), color(srgb 0 0 1 / 1), color(srgb 0 0 1 / 1), color(srgb 0 0 1 / 1), color(srgb 0 0 1 / 1), color(srgb 0 0 1 / 1), color(srgb 0 0 1 / 1), color(srgb 0 0 1 / 1), color(srgb 0 0 1 / 1), color(srgb 0 0 1 / 1), color(srgb 0 0 1 / 1)]\n&gt;&gt;&gt; i = Color.interpolate(['red', 'blue'], extrapolate=True)\n&gt;&gt;&gt; HtmlGradient([i((r * factor / 100) - offset) for r in range(101)])\n[color(srgb 1.2247 -0.37634 -0.36051 / 1), color(srgb 1.2112 -0.36299 -0.35175 / 1), color(srgb 1.1977 -0.34935 -0.34251 / 1), color(srgb 1.1842 -0.33536 -0.33272 / 1), color(srgb 1.1706 -0.32099 -0.32234 / 1), color(srgb 1.1571 -0.30619 -0.31127 / 1), color(srgb 1.1436 -0.29088 -0.29944 / 1), color(srgb 1.1302 -0.27498 -0.28673 / 1), color(srgb 1.1167 -0.25837 -0.27301 / 1), color(srgb 1.1032 -0.24093 -0.25808 / 1), color(srgb 1.0897 -0.22244 -0.2417 / 1), color(srgb 1.0763 -0.20264 -0.22353 / 1), color(srgb 1.0628 -0.18109 -0.20304 / 1), color(srgb 1.0493 -0.15714 -0.17943 / 1), color(srgb 1.0359 -0.12955 -0.15122 / 1), color(srgb 1.0224 -0.09572 -0.11531 / 1), color(srgb 1.009 -0.04719 -0.06178 / 1), color(srgb 0.99552 0.02344 0.03318 / 1), color(srgb 0.98207 0.07954 0.10229 / 1), color(srgb 0.96863 0.11367 0.14449 / 1), color(srgb 0.95519 0.1393 0.17749 / 1), color(srgb 0.94176 0.16017 0.20551 / 1), color(srgb 0.92832 0.17789 0.23032 / 1), color(srgb 0.91488 0.19332 0.25287 / 1), color(srgb 0.90145 0.20696 0.27372 / 1), color(srgb 0.88802 0.21916 0.29325 / 1), color(srgb 0.87458 0.23017 0.31171 / 1), color(srgb 0.86115 0.24016 0.3293 / 1), color(srgb 0.84771 0.24927 0.34615 / 1), color(srgb 0.83427 0.25759 0.36237 / 1), color(srgb 0.82084 0.26522 0.37806 / 1), color(srgb 0.80739 0.27221 0.39328 / 1), color(srgb 0.79395 0.27862 0.40808 / 1), color(srgb 0.7805 0.2845 0.42252 / 1), color(srgb 0.76705 0.28989 0.43664 / 1), color(srgb 0.75359 0.29482 0.45047 / 1), color(srgb 0.74012 0.29931 0.46403 / 1), color(srgb 0.72665 0.3034 0.47736 / 1), color(srgb 0.71317 0.30709 0.49048 / 1), color(srgb 0.69968 0.31042 0.5034 / 1), color(srgb 0.68619 0.31339 0.51615 / 1), color(srgb 0.67268 0.31601 0.52873 / 1), color(srgb 0.65916 0.3183 0.54117 / 1), color(srgb 0.64563 0.32027 0.55346 / 1), color(srgb 0.63208 0.32193 0.56564 / 1), color(srgb 0.61852 0.32328 0.57769 / 1), color(srgb 0.60495 0.32434 0.58964 / 1), color(srgb 0.59135 0.32509 0.60149 / 1), color(srgb 0.57774 0.32556 0.61324 / 1), color(srgb 0.5641 0.32573 0.62491 / 1), color(srgb 0.55044 0.32562 0.6365 / 1), color(srgb 0.53676 0.32522 0.64802 / 1), color(srgb 0.52304 0.32454 0.65946 / 1), color(srgb 0.5093 0.32357 0.67085 / 1), color(srgb 0.49552 0.32231 0.68217 / 1), color(srgb 0.48171 0.32077 0.69343 / 1), color(srgb 0.46786 0.31892 0.70465 / 1), color(srgb 0.45397 0.31678 0.71582 / 1), color(srgb 0.44003 0.31434 0.72694 / 1), color(srgb 0.42604 0.31158 0.73801 / 1), color(srgb 0.41199 0.3085 0.74905 / 1), color(srgb 0.39788 0.30509 0.76005 / 1), color(srgb 0.38371 0.30134 0.77102 / 1), color(srgb 0.36946 0.29723 0.78196 / 1), color(srgb 0.35512 0.29275 0.79286 / 1), color(srgb 0.3407 0.28788 0.80374 / 1), color(srgb 0.32617 0.2826 0.81459 / 1), color(srgb 0.31152 0.27688 0.82541 / 1), color(srgb 0.29675 0.2707 0.83622 / 1), color(srgb 0.28182 0.26401 0.847 / 1), color(srgb 0.26673 0.25677 0.85776 / 1), color(srgb 0.25145 0.24894 0.86851 / 1), color(srgb 0.23593 0.24046 0.87924 / 1), color(srgb 0.22015 0.23123 0.88995 / 1), color(srgb 0.20405 0.22117 0.90065 / 1), color(srgb 0.18756 0.21016 0.91134 / 1), color(srgb 0.1706 0.19801 0.92201 / 1), color(srgb 0.15303 0.18452 0.93267 / 1), color(srgb 0.13466 0.16934 0.94332 / 1), color(srgb 0.1152 0.15199 0.95397 / 1), color(srgb 0.09414 0.13166 0.9646 / 1), color(srgb 0.07051 0.10682 0.97523 / 1), color(srgb 0.04194 0.0739 0.98585 / 1), color(srgb 0.00985 0.02108 0.99646 / 1), color(srgb -0.01842 -0.04265 1.0071 / 1), color(srgb -0.04278 -0.08883 1.0177 / 1), color(srgb -0.06021 -0.12088 1.0283 / 1), color(srgb -0.07215 -0.1469 1.0389 / 1), color(srgb -0.0805 -0.1694 1.0495 / 1), color(srgb -0.08615 -0.18955 1.0601 / 1), color(srgb -0.08956 -0.20799 1.0707 / 1), color(srgb -0.09096 -0.22514 1.0812 / 1), color(srgb -0.09047 -0.24126 1.0918 / 1), color(srgb -0.08809 -0.25653 1.1024 / 1), color(srgb -0.0837 -0.27111 1.113 / 1), color(srgb -0.07705 -0.28509 1.1236 / 1), color(srgb -0.06766 -0.29855 1.1342 / 1), color(srgb -0.05456 -0.31157 1.1448 / 1), color(srgb -0.0356 -0.32419 1.1554 / 1), color(srgb -0.01177 -0.33646 1.166 / 1), color(srgb 0.01515 -0.34842 1.1766 / 1)]\n</code></pre> offset, factor = 0.25, 1.5 i = Color.interpolate(['red', 'blue']) HtmlGradient([i((r * factor / 100) - offset) for r in range(101)]) i = Color.interpolate(['red', 'blue'], extrapolate=True) HtmlGradient([i((r * factor / 100) - offset) for r in range(101)]) Edit Share Run Cancel <p>Lastly, it is important to note that this affects stops as well, mainly stops applied to interpolation endpoints. When an endpoint is moved inwards via a color stop, the end range of the interpolation is clamped, extending the star and end color. But when extrapolation is enabled, a color stop on an endpoint essentially moves the start and end interpolation. And since there are no other colors on either end to interpolate with, extrapolation occurs.</p> <pre><code>&gt;&gt;&gt; Color.interpolate([stop('red', 0.25), stop('blue', 0.75)])\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x10c77ec10&gt;\n&gt;&gt;&gt; Color.interpolate([stop('red', 0.25), stop('blue', 0.75)], extrapolate=True)\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x10c8b2a50&gt;\n</code></pre> Color.interpolate([stop('red', 0.25), stop('blue', 0.75)]) Color.interpolate([stop('red', 0.25), stop('blue', 0.75)], extrapolate=True) Edit Share Run Cancel"},{"location":"interpolation/#null-handling","title":"Undefined/NaN Handling","text":"<p>Color spaces that have hue coordinates often have rules about when the hue is considered relevant. For instance, in the HSL color space, if saturation is zero, the hue is essentially powerless. This is because the color is \"without color\" or achromatic; therefore, the hue can have no affect on the actual color.</p> <p>ColorAide will generally respect the values a user provides, so if an achromatic HSL color is given a hue of 270 degrees, ColorAide will accept it, but the hue will not affect the color in any meaningful way.</p> <p>During conversions, such context is lost, and if an achromatic color is converted to the color space like HSL, the resultant color will have a hue that is noted as undefined. This is simply because there is no good hue for achromatic colors as they play no part in the color. Any hue is actually incorrect as achromatic colors have no real hue. Instead, colors will be returned with a value that represents that the hue is missing or undefined, or maybe better worded, could not be defined.</p> <p>Many libraries, like d3-color, chroma.js, and color.js, represent null hues with <code>NaN</code> (not a number). This is usually done to make color interpolation easier. Some, like d3-color, are a bit more liberal with <code>NaN</code> and will target special cases that are above and beyond the normal rules to help ensure good interpolation. For instance, they not only mark hue undefined on HSL colors when saturation is zero, but they'll mark saturation as <code>NaN</code> when lightness indicates \"black\" or \"white\".</p> <p>ColorAide also uses <code>NaN</code>, or in Python <code>float('nan')</code>, to represent undefined channels. In certain situations, when a hue is deemed undefined, the hue value will be set to <code>coloraide.NaN</code>, which is just a constant containing <code>float('nan')</code>.</p> <p>When performing linear interpolation, where only two color's channels are ever being evaluated together at a given time, if one color's channel has a <code>NaN</code>, the other color's channel will be used as the result. If both colors have a <code>NaN</code> for the same channel, then <code>NaN</code> will be returned.</p> <p>NaN Handling in B-Spline Interpolation</p> <p><code>NaN</code> handling is a bit different for B-spline interpolation. Linear only evaluates colors at a given time, while B-spline uses a sliding window on four colors. Because the context is much wider and more complicated, <code>NaN</code> values will often get contexts from both side and create a new \"control point\" for the curve using linear interpolation. So the curve will use data from the defined points while ignoring the point that is undefined.</p> <p>Notice that in this example, because white's saturation is zero, the hue is undefined. Because the hue is undefined, when the color is mixed with a second color (<code>green</code>), the hue of the second color is used.</p> <pre><code>&gt;&gt;&gt; color = Color('white').convert('hsl')\n&gt;&gt;&gt; color[:-1]\n[nan, 0.0, 1.0]\n&gt;&gt;&gt; color2 = Color('green').convert('hsl')\n&gt;&gt;&gt; color2[:-1]\n[120.0, 1.0, 0.25098039215686274]\n&gt;&gt;&gt; color.mix(color2, space=\"hsl\")\ncolor(--hsl 120 0.5 0.62549 / 1)\n</code></pre> color = Color('white').convert('hsl') color[:-1] color2 = Color('green').convert('hsl') color2[:-1] color.mix(color2, space=\"hsl\") Edit Share Run Cancel <p>But if we manually set the hue to <code>0</code> instead of <code>NaN</code>, we can see that the mixing goes quite differently.</p> <pre><code>&gt;&gt;&gt; color = Color('white').convert('hsl').set('hue', 0)\n&gt;&gt;&gt; color[:-1]\n[0.0, 0.0, 1.0]\n&gt;&gt;&gt; color2 = Color('green').convert('hsl')\n&gt;&gt;&gt; color2[:-1]\n[120.0, 1.0, 0.25098039215686274]\n&gt;&gt;&gt; color.mix(color2, space=\"hsl\")\ncolor(--hsl 60 0.5 0.62549 / 1)\n</code></pre> color = Color('white').convert('hsl').set('hue', 0) color[:-1] color2 = Color('green').convert('hsl') color2[:-1] color.mix(color2, space=\"hsl\") Edit Share Run Cancel <p>Technically, any channel can be set to <code>NaN</code>. And there are various ways to do this. The Color Manipulation documentation goes into the details of how these <code>Nan</code> values naturally occur and the various ways a user and manipulate them.</p>"},{"location":"manipulation/","title":"Manipulating Colors","text":"<p>Once a <code>Color</code> object is created, you have access to all the color channels. Color channels can be read individually or extracted all at once. Getting and setting color channels is flexible and easy, allowing for intuitive access.</p>"},{"location":"manipulation/#accessing-coordinates","title":"Accessing Coordinates","text":"<p>There are various ways to get and set the current values of color coordinates. Colors can be accessed by channel name or numerical index directly. We can also manipulate colors within different color spaces.</p>"},{"location":"manipulation/#access-by-channel-name","title":"Access By Channel Name","text":"<p>One of the more intuitive ways to access color values is by channel name. Each color space defines the name of each of the available channels. <code>alpha</code> is the one channel name that is always constant no matter the color space.</p> <pre><code>&gt;&gt;&gt; color = Color(\"orange\")\n&gt;&gt;&gt; color\ncolor(srgb 1 0.64706 0 / 1)\n&gt;&gt;&gt; color['r']\n1.0\n&gt;&gt;&gt; color['g']\n0.6470588235294118\n&gt;&gt;&gt; color['b']\n0.0\n&gt;&gt;&gt; color['alpha']\n1.0\n</code></pre> color = Color(\"orange\") color color['r'] color['g'] color['b'] color['alpha'] Edit Share Run Cancel <p>Some channels may be also be recognized using an alias. Check the color space's documentation to learn the recognized channel names and aliases.</p> <pre><code>&gt;&gt;&gt; color = Color(\"orange\")\n&gt;&gt;&gt; color\ncolor(srgb 1 0.64706 0 / 1)\n&gt;&gt;&gt; color['red'] = 0\n&gt;&gt;&gt; color['green'] = 0\n&gt;&gt;&gt; color['blue'] = 1\n&gt;&gt;&gt; color\ncolor(srgb 0 0 1 / 1)\n</code></pre> color = Color(\"orange\") color color['red'] = 0 color['green'] = 0 color['blue'] = 1 color Edit Share Run Cancel"},{"location":"manipulation/#access-by-index","title":"Access By Index","text":"<p>Color channels can also be read or set by index. Channels are always in logical order. This means, for instance, an RGB color space will have its channel in the order of <code>r</code>, <code>g</code>, <code>b</code>, and <code>alpha</code>. The<code>alpha</code> channel always being the last channel in any color space. Check out the color space's documentation to learn more about available channels and the order in which they are stored.</p> <pre><code>&gt;&gt;&gt; color = Color(\"orange\")\n&gt;&gt;&gt; color\ncolor(srgb 1 0.64706 0 / 1)\n&gt;&gt;&gt; color[0]\n1.0\n&gt;&gt;&gt; color[1]\n0.6470588235294118\n&gt;&gt;&gt; color[2]\n0.0\n&gt;&gt;&gt; color[3]\n1.0\n</code></pre> color = Color(\"orange\") color color[0] color[1] color[2] color[3] Edit Share Run Cancel <p>Because a Color object essentially operates similar to a list, negative values are also allowed.</p> <pre><code>&gt;&gt;&gt; color = Color(\"orange\")\n&gt;&gt;&gt; color\ncolor(srgb 1 0.64706 0 / 1)\n&gt;&gt;&gt; color[-1] = 0.5\n&gt;&gt;&gt; color\ncolor(srgb 1 0.64706 0 / 0.5)\n</code></pre> color = Color(\"orange\") color color[-1] = 0.5 color Edit Share Run Cancel"},{"location":"manipulation/#access-by-iteration","title":"Access By Iteration","text":"<p>Color objects can also be treated as an iterable object. This allows us to simply loop through the values.</p> <pre><code>&gt;&gt;&gt; color = Color(\"orange\")\n&gt;&gt;&gt; color\ncolor(srgb 1 0.64706 0 / 1)\n&gt;&gt;&gt; [c for c in color]\n[1.0, 0.6470588235294118, 0.0, 1.0]\n</code></pre> color = Color(\"orange\") color [c for c in color] Edit Share Run Cancel"},{"location":"manipulation/#access-by-slicing","title":"Access By Slicing","text":"<p>As previously mentioned, Color objects operate very similar to lists, and as such, can also be read or set via slicing.</p> <pre><code>&gt;&gt;&gt; color = Color(\"orange\")\n&gt;&gt;&gt; color\ncolor(srgb 1 0.64706 0 / 1)\n&gt;&gt;&gt; color[:-1]\n[1.0, 0.6470588235294118, 0.0]\n&gt;&gt;&gt; color[:-1] = [0, 0, 1]\n&gt;&gt;&gt; color\ncolor(srgb 0 0 1 / 1)\n</code></pre> color = Color(\"orange\") color color[:-1] color[:-1] = [0, 0, 1] color Edit Share Run Cancel"},{"location":"manipulation/#access-by-functions","title":"Access By Functions","text":"<p>Colors can also be accessed and modified in more advanced ways with special access functions <code>get()</code> and <code>set()</code>.</p> <p><code>get()</code> provides access to any channel via the channel name for a given color space, but what sets it apart from other channel access methods is that it can access channels in other color spaces as well.</p> <pre><code>color = Color(\"pink\")\ncolor\ncolor.get('red')\ncolor.get('oklch.hue')\n</code></pre> <p>Like <code>get()</code>, <code>set()</code> is a method that allows for the setting of any color channel via the color channel names. The value can be set via numerical values or functions with more complex logic. </p> <pre><code>&gt;&gt;&gt; color = Color(\"pink\")\n&gt;&gt;&gt; color\ncolor(srgb 1 0.75294 0.79608 / 1)\n&gt;&gt;&gt; color.set('blue', 0.5)\ncolor(srgb 1 0.75294 0.5 / 1)\n&gt;&gt;&gt; color.set('green', lambda g: g * 1.3)\ncolor(srgb 1 0.97882 0.5 / 1)\n</code></pre> color = Color(\"pink\") color color.set('blue', 0.5) color.set('green', lambda g: g * 1.3) Edit Share Run Cancel <p>Since <code>set()</code> returns a reference to the current color object, we can also chain multiple <code>set()</code> operations.</p> <pre><code>&gt;&gt;&gt; color = Color('black')\n&gt;&gt;&gt; color\ncolor(srgb 0 0 0 / 1)\n&gt;&gt;&gt; color.set('red', 1).set('green', 1)\ncolor(srgb 1 1 0 / 1)\n</code></pre> color = Color('black') color color.set('red', 1).set('green', 1) Edit Share Run Cancel <p>Even more interesting is that, like <code>get()</code>, targeted color channels can be from any registered color space.</p> <pre><code>&gt;&gt;&gt; color = Color(\"orange\")\n&gt;&gt;&gt; color\ncolor(srgb 1 0.64706 0 / 1)\n&gt;&gt;&gt; color.set('oklab.lightness', 0.50)\ncolor(srgb 0.61518 0.28886 -0.22143 / 1)\n</code></pre> color = Color(\"orange\") color color.set('oklab.lightness', 0.50) Edit Share Run Cancel <p>When getting/setting a color channel in a different color space than the current color space, the underlying color must be converted to the target color space in order to access the channel. When doing this to get/set multiple channels, this can be a bit inefficient. In order to make such operations more efficient, both <code>get()</code> and <code>set()</code> allow for bulk operations. When performing bulk channel operations, the channels operations are performed in the order they are specified; therefore, it is important to group together channels of the same color space to ensure they are accessed with a single conversion.</p> <p>To get multiple channels, simply provide a list of channels.</p> <pre><code>&gt;&gt;&gt; color = Color('orange')\n&gt;&gt;&gt; color\ncolor(srgb 1 0.64706 0 / 1)\n&gt;&gt;&gt; color.get(['oklch.lightness', 'oklch.hue', 'alpha'])\n[0.7926884308958342, 70.66992049743777, 1.0]\n</code></pre> color = Color('orange') color color.get(['oklch.lightness', 'oklch.hue', 'alpha']) Edit Share Run Cancel <p>To set multiple channels, pass a single dictionary containing the channel names and values.</p> <pre><code>&gt;&gt;&gt; color = Color('orange')\n&gt;&gt;&gt; color\ncolor(srgb 1 0.64706 0 / 1)\n&gt;&gt;&gt; color.set(\n...     {\n...         'oklch.lightness': lambda l: l - l * 0.25,\n...         'oklch.hue': 270\n...     }\n... )\ncolor(srgb 0.34573 0.45438 0.89059 / 1)\n</code></pre> color = Color('orange') color color.set(     {         'oklch.lightness': lambda l: l - l * 0.25,         'oklch.hue': 270     } ) Edit Share Run Cancel <p>New in 1.5: Getting/Setting Multiple Channels</p> Notes on Modifying Coordinates in Other Spaces <p>When setting a color in another color space, the color is converted to the desired space, modified, and then converted back to the original color space. The final value is subject to any rounding errors that may occur in the round trip to and from the specified color space. Also, depending on the transform functions of the spaces involved, and whether the original color is on the edge of its own gamut, this can lead to a color going slightly out of gamut, and if one of the spaces involved in the conversion doesn't handle out of gamut colors with sensible values, you may get something unexpected back.</p> <p>Consider the following example that compares the modification of an HSL color in HWB vs Oklab.</p> <pre><code>&gt;&gt;&gt; Color('hsl(0 0% 50%)').set({'hwb.blackness': 0, 'hwb.whiteness': 100})\ncolor(--hsl none 0 1 / 1)\n&gt;&gt;&gt; Color('hsl(0 0% 50%)').set('oklab.lightness', 1)\ncolor(--hsl 223.91 -1.3211 1 / 1)\n&gt;&gt;&gt; Color('hsl(0 0% 50%)').set('oklab.lightness', 1).convert('srgb')[:]\n[0.9999999929041132, 1.0000000085633445, 1.0000000512914544, 1.0]\n</code></pre> Color('hsl(0 0% 50%)').set({'hwb.blackness': 0, 'hwb.whiteness': 100}) Color('hsl(0 0% 50%)').set('oklab.lightness', 1) Color('hsl(0 0% 50%)').set('oklab.lightness', 1).convert('srgb')[:] Edit Share Run Cancel <p>The above example cleanly converts between HSL and HWB as the conversion between these two is much more precise, but the Oklab example is not quite as precise and returns a color with a saturation that is way out of bounds. This is partly because the Oklab max whiteness isn't exactly <code>1</code>, but more like <code>~0.999...</code>, The HSL model doesn't really represent out of gamut colors in a logical way and, in this case, creates a color with a negative saturation. It looks worse than it really is as when we convert it to sRGB, we see it is barely off. None of this is a bug, it is just the nature of the algorithms we are using to convert, the precision of the floats, and the slight rounding errors that occur when using floating-point arithmetic, etc.</p>"},{"location":"manipulation/#undefined-values","title":"Undefined Values","text":"<p>Colors in general can sometimes have undefined channels. This can actually happen in a number of ways.</p> <ol> <li> <p>Channels can naturally be undefined under certain situations as defined by the color space. For instance, spaces    with hues will have powerless hues when the color is achromatic. This can occur if saturation or chroma is zero.</p> <p>If an achromatic color manually has its hue defined, then the hue is considered defined, though that value will still be powerless during conversions. But lets considered an achromatic color in a rectangular color space being converted to a cylindrical color space with hue. During the conversion process, there is nothing to suggest to the algorithm what the hue should be. For instance, if saturation is zero, one could argue the hue should be <code>0</code>, but that is actually a red hue, and achromatic colors have no hue. In the end, no hue is actually satisfactory, so an undefined hue is applied.</p> <pre><code>&gt;&gt;&gt; color = Color('white').convert('hsl')\n&gt;&gt;&gt; color[:]\n[nan, 0.0, 1.0, 1.0]\n</code></pre> color = Color('white').convert('hsl') color[:] Edit Share Run Cancel </li> <li> <p>When specifying raw data, and an insufficient amount of channel data is provided, the missing channels will be    assumed as undefined, the exception is the <code>alpha</code> channel which is assumed to be <code>1</code> unless explicitly defined or    explicitly set as undefined.</p> <pre><code>&gt;&gt;&gt; Color('srgb', [1])[:]\n[1.0, nan, nan, 1.0]\n&gt;&gt;&gt; Color('srgb', [1, 0, 0], NaN)[:]\n[1.0, 0.0, 0.0, nan]\n</code></pre> Color('srgb', [1])[:] Color('srgb', [1, 0, 0], NaN)[:] Edit Share Run Cancel </li> <li> <p>Undefined values can also occur when a user specifies a channel with the <code>none</code> keyword in CSS syntax. This can also    be done in raw color data by directly passing <code>float('nan')</code> \u2013 the provided <code>NaN</code> constant is essentially an    alias for this.</p> <p>One may question why such a thing would ever be desired, but this can be quite useful when interpolating as undefined channels will not be interpolated. It can be thought of as a way to mask off channels. Checkout the Interpolation section in the documentation to learn more.</p> <pre><code>&gt;&gt;&gt; from coloraide import NaN\n&gt;&gt;&gt; color = Color(\"srgb\", [0.3, NaN, 0.4])\n&gt;&gt;&gt; color[:]\n[0.3, nan, 0.4, 1.0]\n&gt;&gt;&gt; color = Color('rgb(30% none 40%)')\n&gt;&gt;&gt; color[:]\n[0.3, nan, 0.4, 1.0]\n</code></pre> from coloraide import NaN color = Color(\"srgb\", [0.3, NaN, 0.4]) color[:]  color = Color('rgb(30% none 40%)') color[:] Edit Share Run Cancel </li> <li> <p>Lastly, a user can use the <code>mask</code> method which is a quick way to set one or multiple channels as undefined.    Additionally, it returns a clone leaving the original untouched by default.</p> <pre><code>&gt;&gt;&gt; Color('white')[:]\n[1.0, 1.0, 1.0, 1.0]\n&gt;&gt;&gt; Color('white').mask(['red', 'green'])[:]\n[nan, nan, 1.0, 1.0]\n</code></pre> Color('white')[:] Color('white').mask(['red', 'green'])[:] Edit Share Run Cancel <p>The <code>alpha</code> channel can also be masked:</p> <pre><code>&gt;&gt;&gt; Color('white').mask('alpha')[-1]\nnan\n</code></pre> Color('white').mask('alpha')[-1] Edit Share Run Cancel <p>You can also do inverse masks, or masks that apply to every channel not specified.</p> <pre><code>&gt;&gt;&gt; c = Color('white').mask('blue', invert=True)\n&gt;&gt;&gt; c[:]\n[nan, nan, 1.0, nan]\n</code></pre> c = Color('white').mask('blue', invert=True) c[:] Edit Share Run Cancel </li> </ol>"},{"location":"manipulation/#checking-for-undefined-values","title":"Checking for Undefined Values","text":"<p>As previously mentioned, a color channel can be undefined for a number of reasons. And in cases such as interpolation, undefined values can even be useful. On the other hand, sometimes an undefined value may need to be handled special.</p> <p>Undefined values are represented as the float value <code>NaN</code>. And since <code>NaN</code> values are not numbers \u2013 hence the name \"not a number\" \u2013 they don't quite work the same as normal numbers. They don't contribute to math operations like add, multiply, and divide. Any math operation performed with a <code>NaN</code> will simply yield <code>NaN</code>. <code>NaN</code> values are essentially infectious.</p> <p>At first glance, the behavior of <code>NaN</code> values can seem confusing, but it is actually pretty intuitive. If we define a color with an undefined channel, and try to add to that value, what should we get? In reality, if the value is undefined, how could we possibly add to it? The only sane answer is to return <code>NaN</code> again.</p> <pre><code>&gt;&gt;&gt; color = Color('color(srgb 1 none 1)')\n&gt;&gt;&gt; color['green'] + 0.5\nnan\n</code></pre> color = Color('color(srgb 1 none 1)') color['green'] + 0.5 Edit Share Run Cancel <p>Because a <code>NaN</code> may cause surprising results, it can be useful to check if a hue (or any channel) is <code>NaN</code> before applying certain operations where <code>NaN</code> may be undesirable, especially if the color potentially came from an unknown source. To make checking for <code>NaN</code>s easy, the convenience function <code>is_nan</code> has been made available. You can simply give <code>is_nan</code> the property you wish to check, and it will return either return <code>True</code> or <code>False</code>.</p> <pre><code>&gt;&gt;&gt; Color('hsl(none 0% 100%)').is_nan('hue')\nTrue\n</code></pre> Color('hsl(none 0% 100%)').is_nan('hue') Edit Share Run Cancel <p>This is equivalent to using the <code>math</code> library and comparing the value directly:</p> <pre><code>&gt;&gt;&gt; import math\n&gt;&gt;&gt; math.isnan(Color('hsl(none 0% 100%)')['hue'])\nTrue\n</code></pre> import math math.isnan(Color('hsl(none 0% 100%)')['hue']) Edit Share Run Cancel"},{"location":"playground/","title":"Playground","text":"Notebook Submit Cancel"},{"location":"strings/","title":"String Output","text":"<p>ColorAide supports serializing colors in the same formats that it accepts as inputs. This includes all CSS formats for the associated color spaces, and if a color space is not supported in CSS, the <code>color(space ...)</code> format. ColorAide exposes various options to allow users to serialize in the form they most prefer.</p>"},{"location":"strings/#convert-to-strings","title":"Convert to Strings","text":"<p>Colors can be serialized to strings by using the <code>to_string</code> method. The color class will convert the current color into one of the many of CSS formats supported for the given color space.</p> <pre><code>&gt;&gt;&gt; Color(\"srgb\", [0.5, 0, 1], 0.3).to_string()\nrgb(127.5 0 255 / 0.3)\n</code></pre> Color(\"srgb\", [0.5, 0, 1], 0.3).to_string() Edit Share Run Cancel <p>There are a number of options that are common among all color spaces, but there are also some color space specific options. We will only cover the color spaces shipped with ColorAide. It is possible to write a color space plugin that uses very different options.</p>"},{"location":"strings/#common-options","title":"Common Options","text":"<p>All color spaces support the following parameters.</p>"},{"location":"strings/#alpha","title":"Alpha","text":"<p><code>alpha</code> is set to <code>None</code> by default and controls whether the alpha channel is shown in the serialized output. When in the default state, <code>alpha</code> will only be shown if the alpha channel has a value less than 100%, but if set to <code>True</code>, alpha will always be shown. Setting to <code>False</code> will cause alpha to be ignored in the output.</p>"},{"location":"strings/#precision","title":"Precision","text":"<p><code>precision</code> controls the precision of the output values. The name is a little misleading as it will actually adjust the precision and scale of the values. The default is 5. In some cases, like the sRGB hex output, precision may not really come into play as hex values are rounded to the nearest whole number.</p> <pre><code>&gt;&gt;&gt; Color(\"rgb(30.3456% 75% 100%)\").to_string(precision=5, percent=True)\nrgb(30.346% 75% 100%)\n&gt;&gt;&gt; Color(\"rgb(30.3456% 75% 100%)\").to_string(precision=4, percent=True)\nrgb(30.35% 75% 100%)\n&gt;&gt;&gt; Color(\"rgb(30.3456% 75% 100%)\").to_string(precision=3, percent=True)\nrgb(30.3% 75% 100%)\n&gt;&gt;&gt; Color(\"rgb(30.3456% 75% 100%)\").to_string(precision=2, percent=True)\nrgb(30% 75% 100%)\n&gt;&gt;&gt; Color(\"rgb(30.3456% 75% 100%)\").to_string(precision=1, percent=True)\nrgb(30% 80% 100%)\n</code></pre> Color(\"rgb(30.3456% 75% 100%)\").to_string(precision=5, percent=True) Color(\"rgb(30.3456% 75% 100%)\").to_string(precision=4, percent=True) Color(\"rgb(30.3456% 75% 100%)\").to_string(precision=3, percent=True) Color(\"rgb(30.3456% 75% 100%)\").to_string(precision=2, percent=True) Color(\"rgb(30.3456% 75% 100%)\").to_string(precision=1, percent=True) Edit Share Run Cancel <p>Providing a precision of <code>0</code> will simply enable simple rounding to the nearest whole number.</p> <pre><code>&gt;&gt;&gt; Color(\"rgb(30.3456% 75% 100%)\").to_string(precision=0, percent=True)\nrgb(30% 75% 100%)\n</code></pre> Color(\"rgb(30.3456% 75% 100%)\").to_string(precision=0, percent=True) Edit Share Run Cancel <p>Providing a precision of <code>-1</code> is a special input that will give the highest precision that can be given. Not particularly helpful except to look at the raw decimal number.</p> <pre><code>&gt;&gt;&gt; Color(\"rgb(30.3456% 75% 100%)\").to_string(precision=-1, percent=True)\nrgb(30.345600000000001017497197608463466167449951171875% 75% 100%)\n</code></pre> Color(\"rgb(30.3456% 75% 100%)\").to_string(precision=-1, percent=True) Edit Share Run Cancel <p>One note though, format of the value matters. Here we output in the range of 0 - 255. We can see that a precision of <code>1</code>, in this case, can throw the color out of gamut. So remember to use a sufficient precision for what you are doing and the values you are working in.</p> <pre><code>&gt;&gt;&gt; Color(\"rgb(30.3456% 75% 100%)\").to_string(precision=1)\nrgb(80 200 300)\n</code></pre> Color(\"rgb(30.3456% 75% 100%)\").to_string(precision=1) Edit Share Run Cancel"},{"location":"strings/#fit","title":"Fit","text":"<p><code>fit</code> is set to <code>True</code> by default and controls whether colors are fit to their gamut or not. Some color spaces are technically unbounded, so no fitting may occur in those color spaces. Additionally, some color formats, like sRGB hex, are always fitted (regardless of this setting) as they must fit into the gamut or they cannot be translated.</p> <pre><code>&gt;&gt;&gt; Color(\"rgb(30% 105% 0%)\").to_string()\nrgb(109.21 255 60.975)\n&gt;&gt;&gt; Color(\"rgb(30% 105% 0%)\").to_string(fit=False)\nrgb(76.5 267.75 0)\n</code></pre> Color(\"rgb(30% 105% 0%)\").to_string() Color(\"rgb(30% 105% 0%)\").to_string(fit=False) Edit Share Run Cancel <p>Additionally, we can choose a different fitting method by passing <code>fit</code> the name of the method we would like.</p> <pre><code>&gt;&gt;&gt; Color(\"rgb(30% 105% 0%)\").to_string()\nrgb(109.21 255 60.975)\n&gt;&gt;&gt; Color(\"rgb(30% 105% 0%)\").to_string(fit='clip')\nrgb(76.5 255 0)\n</code></pre> Color(\"rgb(30% 105% 0%)\").to_string() Color(\"rgb(30% 105% 0%)\").to_string(fit='clip') Edit Share Run Cancel"},{"location":"strings/#color","title":"Color","text":"<p><code>color</code>, for some color spaces, is the default output, but for others this format can be explicitly requested by setting <code>color</code> to <code>True</code>. If set to <code>True</code>, this will take priority over other format options.</p> <pre><code>&gt;&gt;&gt; Color(\"rebeccapurple\").to_string(color=True)\ncolor(srgb 0.4 0.2 0.6)\n</code></pre> Color(\"rebeccapurple\").to_string(color=True) Edit Share Run Cancel"},{"location":"strings/#none","title":"None","text":"<p>Colors that have undefined channels are internally represented with <code>NaN</code>. On output, these can be displayed as <code>none</code> per the most recent CSS spec. These are very new, so most browsers do not support them. This is disabled by default until a time when this behavior is common enough. <code>NaN</code> values will not survive fitting unless a color channel is naturally undefined. An example would be a hue when the color has saturation or chroma set to zero.</p> <pre><code>&gt;&gt;&gt; Color('hsl(none 0% 30%)').to_string(none=True)\nhsl(none 0% 30%)\n</code></pre> Color('hsl(none 0% 30%)').to_string(none=True) Edit Share Run Cancel <p>The one exception is that legacy <code>rgb()</code>, <code>rgba()</code>, <code>hsl()</code>, and <code>hsla()</code> forms (comma separated) do not support <code>none</code> per the CSS spec.</p>"},{"location":"strings/#format-specific-options","title":"Format Specific Options","text":"<p>These options may occur in various color spaces depending on the CSS output format.</p>"},{"location":"strings/#comma","title":"Comma","text":"<p>In CSS, there are a few color spaces that allow a comma format: <code>srgb</code> and <code>hsl</code>. ColorAide allows these to be read in and to be output in their legacy comma format. These are the only formats that ship with comma support.</p> <p>If we want commas, we can force the comma syntax by setting <code>comma</code> to <code>True</code>. This can alter some color space output in other subtle ways. As the comma format is the old legacy approach, when sRGB has commas enabled, it will use <code>rgba</code> instead of <code>rgb</code>. If using the non-comma syntax, <code>rgb</code> is always used, even when the color has transparency.</p> <pre><code>&gt;&gt;&gt; Color(\"rgb(30 75 100 / 20%)\").to_string(comma=True)\nrgba(30, 75, 100, 0.2)\n</code></pre> Color(\"rgb(30 75 100 / 20%)\").to_string(comma=True) Edit Share Run Cancel"},{"location":"strings/#percent","title":"Percent","text":"<p>RGB, CIELab, CIELCh, Oklab, and OkLCh can receive and output colors with optional percents for certain channels. This will output those channels in the range of [0%,100%] instead of their usual numeric value.</p> <pre><code>&gt;&gt;&gt; Color(\"rebeccapurple\").to_string(percent=True)\nrgb(40% 20% 60%)\n&gt;&gt;&gt; Color(\"rebeccapurple\").convert('lab').to_string(percent=True)\nlab(32.393% 30.738% -38.153%)\n</code></pre> Color(\"rebeccapurple\").to_string(percent=True) Color(\"rebeccapurple\").convert('lab').to_string(percent=True) Edit Share Run Cancel"},{"location":"strings/#srgb-specific-options","title":"sRGB Specific Options","text":"<p>These options are currently specific to the sRGB color space.</p>"},{"location":"strings/#hex","title":"Hex","text":"<p>sRGB can output colors to a hex format which is unique compared to HSL and others. Simply enable <code>hex</code>.</p> <pre><code>&gt;&gt;&gt; Color(\"rebeccapurple\").to_string(hex=True)\n#663399\n</code></pre> Color(\"rebeccapurple\").to_string(hex=True) Edit Share Run Cancel"},{"location":"strings/#upper","title":"Upper","text":"<p>You can force hex to output in uppercase.</p> <pre><code>&gt;&gt;&gt; Color(\"red\").to_string(hex=True)\n#ff0000\n&gt;&gt;&gt; Color(\"red\").to_string(hex=True, upper=True)\n#FF0000\n</code></pre> Color(\"red\").to_string(hex=True) Color(\"red\").to_string(hex=True, upper=True) Edit Share Run Cancel"},{"location":"strings/#compress","title":"Compress","text":"<p>When converting to the hex color format, a color can be compressed in certain cases. Enabling <code>compress</code> will compress a hex color if possible.</p> <pre><code>&gt;&gt;&gt; Color(\"#11223388\").to_string(hex=True)\n#11223388\n&gt;&gt;&gt; Color(\"#11223388\").to_string(hex=True, compress=True)\n#1238\n</code></pre> Color(\"#11223388\").to_string(hex=True) Color(\"#11223388\").to_string(hex=True, compress=True) Edit Share Run Cancel"},{"location":"strings/#names","title":"Names","text":"<p>sRGB can also output color names. If a color evaluates to a hex code which also evaluates to a color name in the internal CSS color name mapping, then a color name will be returned. If the color does not match a color name, it will fallback to whatever the other options dictate.</p> <pre><code>&gt;&gt;&gt; Color(\"#663399\").to_string(names=True)\nrebeccapurple\n</code></pre> Color(\"#663399\").to_string(names=True) Edit Share Run Cancel"},{"location":"about/acknowledgments/","title":"Acknowledgments","text":"<p>All projects gain help and inspiration from somewhere, and we wanted to document the places in which we we gathered knowledge, ideas, and help.</p>"},{"location":"about/acknowledgments/#projects","title":"Projects","text":""},{"location":"about/acknowledgments/#colorjs","title":"Color.js","text":"<p>When we began writing ColorAide, we wanted a simple interface to deal with different colors. We also wanted to support CSS colors which a lot of people are familiar with. We had a number of questions about the CSS spec and stumbled on Color.js, a JavaScript library developed and maintained by the co-authors of the CSS spec. We found Color.js and its authors helped clarify a number of confusing points. Additionally, their library did end up heavily inspiring many aspects of our own API as its approach very much aligned with the direction we had already started down.</p>"},{"location":"about/acknowledgments/#culori","title":"Culori","text":"<p>The Culori library helped inspire the use of cubic splines as interpolation methods.</p>"},{"location":"about/acknowledgments/#references","title":"References","text":"<p>When researching color vision deficiencies, aside from the usual scientific papers, a couple of sites were found to be quite helpful.</p> <ul> <li>daltonlens.org was particularly helpful. As it comes from the perspective of an actual   Protan, it provided reviews on various algorithm's and explained in great depth some approaches and why they were   preferred over others.</li> <li>ixora.io was another useful site   that went into great details specifically about the Vi\u00e9not approach.</li> </ul>"},{"location":"about/changelog/","title":"Changelog","text":""},{"location":"about/changelog/#15","title":"1.5","text":"<ul> <li>NEW: Formally add support for Python 3.11.</li> <li>NEW: Add support for custom domains when interpolating.</li> <li>NEW: <code>set()</code> can now take a dictionary of channels and values and set multiple channels at once.</li> <li>NEW: <code>get()</code> can now take a list of channels and will return a list of those channel values.</li> <li>ENHANCE: Simplify some type annotation syntax.</li> <li>ENHANCE: Some minor performance enhancements.</li> <li>FIX: Fix OkLCh CSS parsing.</li> </ul>"},{"location":"about/changelog/#14","title":"1.4","text":"<ul> <li>NEW: A color space can now declare its dynamic range. By default, spaces are assumed to be SDR, but can declare   themselves as HDR, or something else. This allows ColorAide to make decisions based on a color's dynamic range.</li> <li>NEW: Add channel aliases for IPT and IPT-like color spaces (IgPgTg and ICtCp): <code>intensity</code>, <code>protan</code>, and   <code>tritan</code>.</li> <li>FIX: The ICtCp and oRGB space would return the Lab-ish equivalents for <code>a</code> and <code>b</code> in reverse order if calling   <code>Labish.labish_names</code>. This was not actually called anywhere in the code, but is now fixed for any future cases that   may require calling it.</li> <li>FIX: Undefined channels should be ignored when clipping a color.</li> <li>FIX: Do not apply SDR shortcuts in gamut mapping when fitting in a non-SDR color gamut, such as HDR.</li> </ul>"},{"location":"about/changelog/#13","title":"1.3","text":"<ul> <li>ENHANCE: Color vision deficiency filters can now be instantiated with different default methods for severe and   anomalous cases.</li> <li>FIX: Fix premultiplication handling when using <code>compose</code>.</li> </ul>"},{"location":"about/changelog/#12","title":"1.2","text":"<ul> <li>NEW: Add new monotone interpolation method.</li> <li>ENHANCE: Better extrapolation past end of spline.</li> <li>FIX: Small speed up in natural spline calculation.</li> <li>FIX: Fix import that should have been relative, not absolute.</li> </ul>"},{"location":"about/changelog/#11","title":"1.1","text":"<ul> <li>NEW: Slight refactor of interpolation plugin so that common code does not need to be duplicated, and the   <code>interpolate</code> method no longer needs to accept an <code>easing</code> parameter as the plugin class exposes a new <code>ease</code> method   to automatically acquire the proper, specified easing function and apply it.</li> <li>NEW: Functions built upon interpolation can now use a new <code>extrapolate</code> parameter to enable extrapolation if   interpolation inputs exceed 0 - 1. <code>point</code> will be passed to <code>Interpolator.interpolate</code> un-clamped if <code>extrapolate</code> is   enabled. If a particular interpolation plugin needs to do additional work to handle extrapolation, they can check   <code>self.extrapolate</code> to know whether extrapolation is enabled.</li> <li>NEW: Implement and provide the following easing functions as described in the CSS Easing Level 1 spec:   <code>cubic_bezier</code>, <code>ease</code>, <code>ease_in</code>, <code>ease_out</code>, and <code>ease_in_out</code>. Also provide a simple <code>linear</code> easing function.</li> <li>New: Add <code>natural</code> and <code>catrom</code> cubic spline options for interpolation. The <code>catrom</code> (Catmull-Rom) spline requires   the plugin to be registered in order to use it.</li> <li>FIX: Due to floating point math, B-spline could sometimes return an interpolation of fully opaque colors with an   imperceptible amount of transparency. If alpha is very close (<code>1e-6</code>) to being opaque, just round it to opaque.</li> <li>FIX: An easing function's output should not be clamped, only the input, and that only needs to occur on the   the outer range of an entire interpolation.</li> </ul>"},{"location":"about/changelog/#10","title":"1.0","text":"<p>Stable Release!</p> <p>Checkout migration guide if you were an early adopter.</p> <ul> <li>NEW: Bezier interpolation dropped for B-spline which provides much better interpolation.</li> <li>NEW: All new interpolation methods now supports hue fix-ups: <code>shorter</code>, <code>longer</code>, <code>increasing</code>, <code>decreasing</code>,   and <code>specified</code>.</li> <li>NEW: Interpolation is now exposed as a plugin to allow for expansion.</li> <li>FIX: Fixed an issue related to premultiplication and undefined alpha channels.</li> </ul>"},{"location":"about/changelog/#10rc1","title":"1.0rc1","text":"<p>Plugin Refactor</p> <p>For more flexibility there was one final rework of plugins. Registering requires all plugins to be instantiated before being passed into <code>Color.register</code>, but this allows a user redefine some defaults of certain plugins.</p> <p><code>coloraide.ColorAll</code> was moved to <code>coloraide.everythng.ColorAll</code> to avoid allocating plugins when they are not desired.</p> <p>In the process, we also renamed a number of plugin classes for consistency and predictability, details found below.</p> <ul> <li> <p>NEW: Updated some class names for consistency and predictability. <code>XyY</code> \u2192 <code>xyY</code>, <code>Din99o</code> \u2192 <code>DIN99o</code>, <code>SRGB</code>   \u2192 <code>sRGB</code>, and <code>ORGB</code> \u2192 <code>oRGB</code>.</p> <p>Lastly, <code>LCh</code> should be the default casing convention. This convention will be followed unless a spec mentions   otherwise. Changes: <code>Lch</code> \u2192 <code>LCh</code>, <code>LchD65</code> \u2192 <code>LChD65</code>, <code>Oklch</code> \u2192 <code>OkLCh</code>, <code>Lchuv</code> \u2192 <code>LChuv</code>, <code>Lch99o</code> \u2192   <code>LCh99o</code>, <code>LchChroma</code> \u2192 <code>LChChroma</code>, <code>OklchChroma</code> \u2192 <code>OkLChChroma</code>, and <code>Lchish</code> \u2192 <code>LChish</code>.</p> </li> <li> <p>NEW: Updated migration guide with recent plugin changes.</p> </li> <li>NEW: <code>coloraide.ColorAll</code> renamed and moved to <code>coloraide.everything.ColorAll</code>. This prevents unnecessary   inclusion and allocation of objects that are not desired.</li> <li>NEW: Default <code>Color</code> object now only registers <code>bradford</code> CAT by default, all others must be registered   separately, or <code>coloraide.everything.Color</code> could be used.</li> <li> <p>NEW: All plugin classes must be instantiated when being registered. This allows some plugins to be instantiated   with different defaults. This allows some plugins to be configured with different defaults.</p> <pre><code># Before change:\nColor.register([Plugin1, Plugin2])\n\n# After change:\nColor.register([Plugin1(), Plugin2(optional_parm=True)])\n</code></pre> </li> <li> <p>FIX: Negative luminance is now clamped during contrast calculations.</p> </li> </ul>"},{"location":"about/changelog/#10b3","title":"1.0b3","text":"<ul> <li>FIX: Fixed the bad <code>CAT16</code> matrix for chromatic adaptation.</li> <li>FIX: Small fix related to how <code>CAT</code> plugin classes are defined for better abstraction.</li> <li>FIX: Restrict optional keywords in <code>Color.register()</code> and <code>Color.deregister()</code> to keyword only parameters.</li> </ul>"},{"location":"about/changelog/#10b2","title":"1.0b2","text":"<p>Breaking Changes</p> <p>1.0b2 only introduces one more last breaking change that was forgotten in 1.0b1.</p> <ul> <li>BREAK: Remove <code>filters</code> parameter on new class instantiation.</li> <li>NEW: Added new migration guide to the documentation to help early adopters move to the 1.0 release.</li> <li>NEW: Added HPLuv space described in the HSLuv spec.</li> <li>NEW: Added new color spaces: ACES 2065-1, ACEScg, ACEScc, and ACEScct.</li> <li>NEW: Contrast is now exposed as a plugin to allow for future expansion of approaches. While there is currently   only one approach, methods can be selected via the <code>method</code> attribute.</li> <li>NEW: Add new <code>random</code> method for generating a random color for a given color space.</li> </ul>"},{"location":"about/changelog/#10b1","title":"1.0b1","text":"<p>Breaking Changes</p> <p>1.0b1 introduces a number of breaking changes. As we are very close to releasing the first stable release, we've taken opportunity to address any issues related to speed and usability. While this is unfortunate for early adopters, we feel that in the long run that these changes will make ColorAide a better library. We've also added new a new Bezier interpolation method and added many more color spaces!</p> <ul> <li> <p>BREAK: The <code>coloraide.Color</code> object now only registers a subset of the available color spaces and \u2206E algorithms in   order to create a lighter default color object. <code>coloraide.ColorAll</code> has been provided for a quick way to get access   to all available color spaces and plugins. Generally, it is recommend to subclass <code>Color</code> and register just what is   desired.</p> </li> <li> <p>BREAK: Reworked interpolation:</p> <ul> <li><code>interpolate</code> and <code>steps</code> functions are now <code>@classmethod</code>s. This alleviates the awkward handling of interpolating   colors greater than 2. Before, the first color always had to be an instance and then the rest had to be fed into   that instance, now the the methods can be called from the base class or an instance with all the colors fed in   via a list. Only the colors in the list will be evaluated during interpolation.</li> <li><code>Piecewise</code> object has been removed.</li> <li><code>stop</code> objects are used to wrap colors to apply a new color stop.</li> <li>easing functions can be supplied in the middle of two colors via the list input.</li> <li><code>hint</code> function has been provided to simulate CSS color hinting. <code>hint</code> returns an easing function that modifies   the midpoint to the specified point between two color stops.</li> <li>A new bezier interpolation method has been provided. When using <code>interpolate</code>, <code>steps</code>, or <code>mix</code> the interpolation   style can be changed via the <code>method</code> parameter. <code>bezier</code> and <code>linear</code> are available with <code>linear</code> being the   default.</li> </ul> </li> <li> <p>BREAK: Dictionary input/output now matches the following format (where alpha is optional):</p> <pre><code>{\"space\": \"name\", \"coords\": [0, 0, 0], \"alpha\": 1}\n</code></pre> <p>This allows for quicker processing and less complexity dealing with channel names and aliases.</p> </li> <li> <p>BREAK: The CSS Level 4 Color spec has accepted our proposed changes to the gamut mapping algorithm. With this   change, the <code>oklch-chroma</code> gamut mapping algorithm is now compliant with the CSS spec, and <code>css-color-4</code> is no longer   needed. If you were experimenting with <code>css-color-4</code>, please use <code>oklch-chroma</code> instead. The algorithm is faster and   does not have the color banding issue that <code>css-color-4</code> had, and it is now exactly the same as the CSS spec.</p> </li> <li> <p>BREAK: New breaking change. Refactor of <code>Space</code> plugins. <code>Space</code> plugins are no longer instantiated which cuts   down on overhead lending to better performance. <code>BOUNDS</code> and <code>CHANNEL_NAMES</code> attributes were combined into one   attribute called <code>CHANNELS</code> which serves the same purpose as the former attributes. <code>Space</code> plugins also no longer   need to define channel property accessors as those are handled through <code>CHANNELS</code> in a more generic way. This is a   breaking change for any custom plugins.</p> <p>Additionally, the <code>Space</code> plugin's <code>null_adjust</code> method has been renamed as <code>normalize</code> matching its functionality and usage in regards to the <code>Color</code> object. It no longer accepts color coordinates and alpha channel coordinates separately, but will receive them as a single list and return them as such.</p> </li> <li> <p>BREAK: <code>Color</code>'s <code>fit</code> and <code>clip</code> methods now perform the operation in place, modifying the current color   directly. The <code>in_place</code> parameter has been removed. To create a new color when performing these actions, simply clone   the color first: <code>color.clone().clip()</code>.</p> </li> <li> <p>BREAK: Remove deprecated dynamic properties which helps to increase speed by removing overhead on class property   access.</p> </li> <li> <p>BREAK: Remove deprecated dynamic properties which helps to increase speed by removing overhead on class property   access. Use indexing instead: <code>color['red']</code> or <code>color[0]</code>.</p> </li> <li> <p>BREAK: Remove deprecated <code>coords()</code> method. Use indexing and slices instead: <code>color[:-1]</code>.</p> </li> <li> <p>NEW: Update <code>lch()</code>, <code>lab()</code>, <code>oklch()</code>, and <code>oklab()</code> to optionally support percentages for lightness, chroma, a,   and b. Lightness is no longer enforced to be a percentage in the CSS syntax and these spaces will serialize as a   number by default instead. Optionally, these forms can force a percentage output via the <code>to_string</code> method when using   the <code>percentage</code> option. Percent ranges roughly correspond with the Display P3 gamut per the CSS specification.</p> <p>Additionally, CSS color spaces using the <code>color()</code> format as an input will translate using these same ranges if the channels are percentages. <code>hue</code> will also be respected and treated as 0 - 360 when using a percentage.</p> <p>Non-CSS color spaces will also respect their defined ranges when using percentages in the <code>color()</code> form.</p> </li> <li> <p>NEW: Add <code>silent</code> option to <code>deregister</code> so that if a proper category is specified, and the plugin does not exit,   the operation will not throw an error.</p> </li> <li> <p>NEW: Add new color spaces: <code>display-p3-linear</code>, <code>a98-rgb-linear</code>, <code>rec2020-linear</code>, <code>prophoto-rgb-linear</code>, and   <code>rec2100pq</code>, <code>hsi</code>, <code>rlab</code>, <code>hunter-lab</code>, <code>xyy</code>, <code>prismatic</code>, <code>orgb</code>, <code>cmy</code>, <code>cmyk</code>, <code>ipt</code>, and <code>igpgtg</code>.</p> </li> <li> <p>NEW: Monochromatic color harmony must also be performed in a cylindrical color space to make achromatic detection   easier. This means all color harmonies now must be performed under a cylindrical color space.</p> </li> <li> <p>NEW: Use Lab D65 for \u2206E 2000, \u2206E 76, \u2206E HyAB, Euclidean distance, and LCh D65 for LCh Chroma gamut mapping. Lab   D65 is far more commonly used for the aforementioned \u2206E methods. LCh Chroma gamut mapping, which uses \u2206E 2000 needs to   use the same D65 white point to avoid wasting conversion time.</p> </li> <li> <p>FIX: Better handling of monochromatic harmonies that are near white or black.</p> </li> <li> <p>FIX: Small fix to <code>steps</code> \u2206E logic.</p> </li> </ul>"},{"location":"about/changelog/#0181","title":"0.18.1","text":"<ul> <li>FIX: Fix issue where when generating steps with a <code>max_delta_e</code>, the \u2206E was reduced too much causing additional,   unnecessary steps along with longer processing time.</li> </ul>"},{"location":"about/changelog/#0180","title":"0.18.0","text":"<ul> <li>NEW: Allow dictionary input to use aliases in the dictionary.</li> <li>FIX: If too many channels are given to a color space via raw data, ensure the operation fails.</li> <li>FIX: Sync up achromatic logic of the Okhsl and Okhsv <code>normalize</code> function with the actual conversion algorithm.</li> <li>FIX: Regression that caused <code>cat16</code> not to work due to a misnamed variable.</li> </ul>"},{"location":"about/changelog/#0170","title":"0.17.0","text":"<p>Interpolations Are Now Premultiplied</p> <p>ColorAide has moved to make premultiplication the default for interpolation methods such as <code>mix</code>, <code>steps</code>, and <code>interpolate</code>. The aim is to provide more accurate interpolation when using transparent colors. In cases where premultiplication is not desired, it can be disabled by setting it to <code>False</code>. There are real reasons to do so as it may be desirous to mimic an old implementation that has always used naive interpolation of transparent colors.</p> <p>Additionally, in the past, premultiplication was not really documented as it had not been fully tested. Premultiplication is now covered in the documentation.</p> <ul> <li>NEW: All mixing/interpolation methods will use <code>premultiply=True</code> by default.</li> <li>NEW: Allow aliases in interpolation's progress mappings.</li> <li>FIX: Fix premultiplication when alpha is undefined.</li> <li>FIX: Fix some potential issues in some matrix math logic.</li> <li>FIX: <code>Piecewise()</code> object didn't default all the non-required parameters to <code>None</code> as documented.</li> </ul>"},{"location":"about/changelog/#0160","title":"0.16.0","text":"<p>Deprecations</p> <p>In interest of speed, and due to the overhead inflicted on every class attribute access, we've decided to deprecate dynamic properties. This includes dynamic color properties (e.g. <code>Color.red</code>) and dynamic \u2206E methods (e.g. <code>Color.delta_e_2000()</code>). As far as color channel coordinate access is concerned, we've reworked a faster more useful approach. \u2206E already has a suitable replacement and will be the only approach moving forward.</p> <ol> <li> <p>Use of <code>delta_e_&lt;method&gt;</code> is deprecated. Users should use the already available <code>delta_e(color, method=name)</code>    approach when using non-default \u2206E methods.</p> </li> <li> <p>Color channel access has changed. Dynamic channel properties have been deprecated. Usage of <code>Color.coords()</code> has    also been deprecated. All channels can now easily be accessed with indexing. <code>Color.get()</code> and <code>Color.set()</code>    have not changed.</p> <ul> <li>You can index with numbers: <code>Color[0]</code>.</li> <li>You can index with channel names: <code>Color['red']</code>.</li> <li>You can slice to get specific color coordinates: <code>Color[:-1]</code>.</li> <li>You can get all coordinates: <code>Color[:]</code> or <code>list(Color)</code>.</li> <li>You can even iterate coordinates: <code>[c for c in Color]</code>.</li> <li>Indexing also supports assignment: <code>Color[0] = 1</code> or <code>Color[:3] = [1, 1, 1]</code>.</li> </ul> </li> </ol> <p>Please consider updating usage to utilize the suggested approaches. The aforementioned methods will be removed sometime before the 1.0 release.</p> <ul> <li>NEW: <code>Color</code> objects are now indexable and channels can be retrieved using either numbers or strings, e.g.,   <code>Color[0]</code> or <code>Color['red']</code>. Slicing and assignments via slicing are also supported:   <code>Color1[:] = Color2[:]</code>.</li> <li>NEW: <code>Color.coords()</code>, dynamic color properties, and dynamic \u2206E methods are all deprecated.</li> <li>NEW: Input method names for distancing, gamut mapping, compositing, and space methods are now case sensitive.   There were inconsistencies in some places, so it was opted to make all case sensitive.</li> <li>NEW: The ability to create color harmonies has been added via the new <code>harmony()</code> method. Also, the default color   space used to calculate color harmonies can be overridden by the class property <code>HARMONY</code>.</li> <li>NEW: Add new support for filters added via the <code>filter()</code> method. Filters include the W3C Filter Effects Level 1   and color vision deficiency simulation.</li> <li>NEW: Some performance enhancements in conversions.</li> <li>NEW: Chromatic adaptation is now exposed as a plugin. New CAT plugins can be created externally and registered.</li> <li>FIX: Okhsl and Okhsv handling of achromatic values during conversion.</li> </ul>"},{"location":"about/changelog/#0151","title":"0.15.1","text":"<ul> <li>FIX: Fix an issue related to matching colors in a buffer at a given offset.</li> </ul>"},{"location":"about/changelog/#0150","title":"0.15.0","text":"<p>Warning</p> <p>No changes in the public API have changed, but type annotations have. If you were importing type annotations, you will have to update them.</p> <p>Also, if any undocumented math related methods were accessed (for plugins or otherwise) they've been moved to <code>coloraide.algebra</code></p> <ul> <li>NEW: A number of performance improvements.</li> <li>NEW: Regenerate all matrices with our own matrix tools so that there is consistency between precision of   pre-generated matrices and on-the-fly matrix generation. Reduces some noise in a few color space transforms.</li> <li>NEW: Changes to type annotations. <code>Mutable&lt;type&gt;</code>, where type is either <code>Matrix</code>, <code>Vector</code>, or <code>Array</code>, are simply   known as <code>&lt;type&gt;</code>. Types previously specified as <code>&lt;type&gt;</code>, where type is either <code>Matrix</code>, <code>Vector</code>, or <code>Array</code>, are   now known as <code>&lt;type&gt;Like</code>. The types are expected to be mutable lists, anything else is noted as \"like\".</li> <li>NEW: All matrix and math utilities have been moved to <code>coloraide.algebra</code>.</li> <li>FIX: Fix rare issue where precision adjustment could fail.</li> <li>FIX: Fix matrix <code>divide</code> logic when dividing a number or vector by a matrix. There are no actual usage of these   cases in the code but they were fixed in case they are used in the future.</li> </ul>"},{"location":"about/changelog/#0141","title":"0.14.1","text":"<ul> <li>FIX: Fix bug related to parsing strings without full matching.</li> </ul>"},{"location":"about/changelog/#0140","title":"0.14.0","text":"<p>Note</p> <p>No changes should break existing color space plugins. Moved objects and references are still also available in old locations, and new functionality is implemented in such a way as to not break existing plugins, but plugins should be updated as sometime before the 1.0 release, such legacy access will be removed.</p> <ul> <li>NEW: Faster parsing. Instead of parsing <code>color(space ...)</code> each time it is evaluated for a different color space,   parse it generically and then associate it with a given registered color space. If a color spaces wishes to opt out of   the <code>color(space ...)</code> input format, the space should set <code>COLOR_FORMAT</code> to <code>False</code>. This means there is no need to   call <code>super.match()</code> when overriding <code>Color.match()</code> to ensure support for the <code>color(space ...)</code> format as it will be   handled unless <code>COLOR_FORMAT</code> is turned off. <code>DEFAULT_MATCH</code> usage should also be discontinued as it now does nothing.</li> <li>NEW: Other speed optimizations.</li> <li>NEW: All CSS parsing and serialization is now contained in a single module at <code>coloraide.css</code>. This simplifies   the current color space classes greatly when it comes to supporting CSS specific formats.</li> <li>NEW: Move our white space mapping to the <code>cat</code> module as it makes more sense there.</li> <li>NEW: <code>GamutBound</code>, <code>GamutUnbound</code>, and associated flags are now contained under <code>coloraide.gamut.bounds</code>.</li> <li>NEW: <code>normalize</code> will also remove masked values to properly adjust the color.</li> <li>FIX: Compositing and blending should not \"fit\" colors before applying, it is only specified that the range should   be clamped at the end of blending.</li> <li>FIX: Fix issue where a subclassed <code>Color()</code> object could not recognize the base class or other subclasses.</li> </ul>"},{"location":"about/changelog/#0130","title":"0.13.0","text":"<ul> <li>NEW: Add new <code>closest</code> method that takes a list of colors and returns the one that is closet to the calling color   object.</li> <li>NEW: CSS color syntax no longer allows for forgiving channels in <code>color()</code>. This means that when a channel other   than alpha is omitted, we will no longer treat them as undefined. Instead, the color will simply fail to parse.   Raw data channels also must specify all channels.</li> <li>NEW: Clamp lower bounds of chroma at the channel level.</li> <li>NEW: <code>coloraide.spaces.WHITES</code> is now a 2 deep dictionary containing both 2\u02da and 10\u02da observer variants of white   points.</li> <li>NEW: Color space plugins now specify <code>WHITE</code> as a tuple with the x and y chromaticity coordinates. This allows a   space to specify unknown white points if desired.</li> <li>FIX: Fix <code>longer</code> hue interpolation when <code>\u03b81 - \u03b82 = 0</code>. The spec is wrong in this case, and interpolation should   still occur the long way around instead of keeping hue constant.</li> <li>FIX: Reduce redundancy in some CSS parsing patterns.</li> <li>FIX: Minor performance improvements.</li> <li>FIX: Legacy <code>rgb()</code>, <code>rgba()</code>, <code>hsl()</code>, and <code>hsla()</code> comma separated forms in CSS do not support <code>none</code>, only the   new space separated forms do.</li> <li>FIX: Ensure <code>py.typed</code> is installed with package so that type annotations work properly.</li> </ul>"},{"location":"about/changelog/#0120","title":"0.12.0","text":"<ul> <li>NEW: Add a gamut mapping variant that matches the CSS Color Level 4 spec.</li> <li>FIX: Fix precision rounding issue.</li> </ul>"},{"location":"about/changelog/#0110","title":"0.11.0","text":"<p>Breaking Changes</p> <ol> <li> <p>Prior to 0.11.0, if you specified a cylindrical space directly, ColorAide would normalize undefined hues the same    way that the conversion algorithm did. In the below case, saturation is zero, so the hue was declared undefined.</p> <pre><code>&gt;&gt;&gt; Color('hsl(270 0% 50%)')\ncolor(--hsl none 0 0.5 / 1)\n</code></pre> <p>We should not have been doing this, and it made some cases of interpolation a bit confusing. It is no longer done as the hues are in fact specified by the user, even if they are powerless in relation to contributing to the rendered color. When a cylindrical color is converted or if a user declares the channel as undefined with <code>none</code> or some other way, then the channel will be declared undefined, because in these cases, they truly are.</p> <pre><code>&gt;&gt;&gt; Color('white').convert('hsl')\ncolor(--hsl none 0 1 / 1)\n&gt;&gt;&gt; Color('color(--hsl none 0 0.5)')\ncolor(--hsl none 0 0.5)\n</code></pre> <p>If you are working directly in a cylindrical color space and ever wish to force the normalization of color hues as undefined when the color meets the usual requirements as specified by the color space's current rules, just call <code>normalize</code> on the color and it will apply the same logic that occurs during the conversion process.</p> <pre><code>&gt;&gt;&gt; Color('hsl(270 0% 50%)').normalize()\ncolor(--hsl none 0 0.5 / 1)\n</code></pre> </li> <li> <p>If you relied on commas in CSS forms that did not support them, this behavior is no longer allowed. It was    thought that CSS may consider allowing comma formats in formats like <code>hwb()</code>, etc., and it was considered, but    ultimately the decision was to avoid adding such support. We've updated our input and output support to reflect    this. Color spaces can always be subclassed and have this support added back, if desired, but will not be shipped    as the default anymore.</p> </li> <li>The D65 form of Luv and LChuv is now the only supported Luv based color spaces by default now. D50 Luv and LChuv    have been dropped and <code>luv</code> and <code>lchuv</code> now refers to the D65 version. In most places, the D65 is the most common    used white space as most monitors are calibrated for this white point. The only reason CIELab and CIELCh are D50    by default is that CSS requires it. Anyone interested in using Luv with a different white point can easily    subclass the current Luv and create a new plugin color space that uses the new white point.</li> <li>Renamed DIN99o LCh identifier to the short name of <code>lch99o</code>.</li> </ol> <ul> <li>NEW: ColorAide now only ships with the D65 version Luv and LChuv as D65, in most places is the expected white   space. Now, the identifier <code>luv</code> and <code>lchuv</code> will refer to the D65 version of the respective color spaces. D50   variants are no longer available by default.</li> <li>NEW: Add the HSLuv color space.</li> <li>NEW: DIN99o LCh identifier was renamed from <code>din99o-lch</code> to <code>lch99o</code>. To use in CSS <code>color()</code> form, use   <code>--lch99o</code>.</li> <li>NEW: Refactor chroma reduction/MINDE logic to cut processing time in half. Gamut mapping results remain very   similar.</li> <li>NEW: Be more strict with CSS inputs and outputs. <code>hwb()</code>, <code>lab()</code>, <code>lch()</code>, <code>oklab()</code>, and <code>oklch()</code> no longer   support comma string formats.</li> <li>NEW: Officially drop Python 3.6 support.</li> <li>FIX: Do not assume user defined, powerless hues as undefined. If they are defined by the user, they should be   respected, even if they have no effect on the current color. This helps to ensure interpolations acts in an   unsurprising way. If a user manually specifies the channel with <code>none</code>, then it will be considered undefined, or if   the color goes through a conversion to a space that cannot pick an appropriate hue, they will also be undefined.</li> </ul>"},{"location":"about/changelog/#0100","title":"0.10.0","text":"<ul> <li>NEW: Switch back to using CIELCh for gamut mapping (<code>lch-chroma</code>). There are still some edge cases that make   <code>oklch-chroma</code> less desirable.</li> <li>FIX: Fix an issue where when attempting to generate steps some \u2206E distance apart, the maximum step range was not   respected and could result in large hangs.</li> </ul>"},{"location":"about/changelog/#090","title":"0.9.0","text":"<p>Breaking Changes</p> <p>Custom gamut mapping plugins no longer return coordinates and require the method to update the passed in color.</p> <ul> <li>NEW: Improved, faster gamut mapping algorithm.</li> <li>NEW: FIT plugins (gamut mapping) no longer return coordinates but should modify the color passed in.</li> <li>NEW: Expose default interpolation space as a class variable that can be controlled when creating a custom class   via class inheritance.</li> <li>NEW: Colors can now directly specify the \u2206E method that is used when interpolating color steps and using   <code>max_delta_e</code> via the new <code>delta_e</code> argument. If the <code>delta_e</code> parameter is omitted, the color object's default \u2206E   method will be used.</li> <li>NEW: Oklab is now the default interpolation color space.</li> <li>NEW: Interpolation will now avoid fitting colors that are out of gamut unless the color space cannot represent   out of gamut colors. Currently, all of the RGB colors (<code>srgb</code>, <code>display-p3</code>, etc.) all support extended ranges, but   the HSL, HWB, and HSV color models for <code>srgb</code> (including spaces such as <code>okhsl</code> and <code>okhsv</code>) do not support extended   ranges and will still be gamut mapped.</li> <li>FIX: Remove some incorrect code from the gamut mapping algorithm that would shortcut the mapping to reduce chroma   to zero.</li> </ul>"},{"location":"about/changelog/#080","title":"0.8.0","text":"<p>Breaking Changes</p> <p>The use of <code>xyz</code> as the color space name has been changed in favor of <code>xyz-d65</code>. This better matches the CSS specification. As we are still in a prerelease state, we have not provided any backwards compatibility.</p> <p>CSS color input strings in the form <code>color(xyz x y z)</code> will continue to be accepted as CSS will allow both the <code>xyz</code> and the <code>xyz-d65</code> identifier, but output serialization will prefer the <code>color(xyz-d65 x y z)</code> form as using <code>xyz</code> is an alias for <code>xyz-d65</code>.</p> <p>Again, this breaking change only affects operations where the color space \"name\" is used in the API to specify usage of a specific color space in order to create a color, convert, mutate, interpolate, etc.</p> <pre><code>Color('red').convert('xyz')      # Bad\nColor('red').convert('xyz-d65')  # Okay\n\nColor('xyz' [0, 0, 0])      # Bad\nColor('xyz-d65' [0, 0, 0])  # Okay\n\nColor('red').interpolate('green', space='xyz')      # Bad\nColor('red').interpolate('green', space='xyz-d65')  # Okay\n\n# No changes to CSS inputs\nColor('color(xyz 0 0 0)')      # Okay\nColor('color(xyz-d65 0 0 0)')  # Okay\n</code></pre> <ul> <li>NEW: Add the official CSS syntax <code>oklab()</code> and <code>oklch()</code> for the Oklab and OkLCh color spaces respectively.</li> <li>NEW: Custom fit plugin's <code>fit</code> method now allows additional <code>kwargs</code> in its signature. The API will accept   <code>kwargs</code> allowing a custom fit plugin to have configurable parameters. None of the current built-in plugins provide   additional parameters, but this is provided in case it is found useful in the future.</li> <li>NEW: XYZ D65 space will now be known as <code>xyz-d65</code>, not <code>xyz</code>. Per the CSS specification, we also ensure XYZ D65   color space serializes as <code>xyz-d65</code> instead of the alias <code>xyz</code>. CSS input string format will still accept the <code>xyz</code>   identifier as this is defined in the CSS specification as an alias for <code>xyz-d65</code>, but when serializing a color to a   string, the <code>xyz-d65</code> will be used as the preferred form.</li> <li>NEW: By default, gamut mapping is done with <code>oklch-chroma</code> which matches the current CSS specification. If   desired, the old way (<code>lch-chroma</code>) can manually be specified or set as the default by subclassing <code>Color</code> and setting   <code>FIT</code> to <code>lch-chroma</code>.</li> <li>FIX: Ensure the <code>convert</code> method's <code>fit</code> parameter is typed appropriately and is documented correctly.</li> </ul>"},{"location":"about/changelog/#070","title":"0.7.0","text":"<ul> <li>NEW: Formally expose <code>srgb-linear</code> as a valid color space.</li> <li>NEW: Distance plugins and gamut mapping plugins now use <code>classmethod</code> instead of <code>staticmethod</code>. This allows for   inheritance from other classes and the overriding of plugin options included as class members.</li> <li>NEW: Tweak LCh chroma gamut mapping threshold.</li> <li>FIX: Issue where it is possible, when generating steps, to cause a shift in midpoint of colors if exceeding the   maximum steps. Ensure that no stops are injected if injecting a stop between every color would exceed the max steps.</li> </ul>"},{"location":"about/changelog/#060","title":"0.6.0","text":"<ul> <li>NEW: Update spaces such that they provide a single conversion point which simplifies color space API and   centralizes all conversion logic allowing us to pull chromatic adaptation out of spaces.</li> <li>NEW: <code>color()</code> output format never uses percent when serializing, but will optionally accept percent as input.</li> <li>NEW: Slight refactor of color space, delta E, and gamut mapping plugins. All now specify there name via the   property <code>NAME</code> instead of methods <code>space()</code> for color spaces and <code>name()</code> for other plugins.</li> <li>NEW: Restructure source structure by flattening out some directories and better organizing source files. This   changes some import paths.</li> <li>NEW: Color spaces do not specify <code>alpha</code> in <code>CHANNEL_NAMES</code> as the <code>alpha</code> name cannot be changed.</li> <li>NEW: Color space objects do not need a constant to track number of color channels.</li> </ul>"},{"location":"about/changelog/#050","title":"0.5.0","text":"<ul> <li>NEW: Add type annotations and refactor code to better accommodate the type annotations. Public API not really   affected, but a bit of the internals have changed.</li> <li>FIX: Fix issue where <code>compose</code>, if <code>backdrop</code> list is empty, would not respect <code>in_place</code> option.</li> </ul>"},{"location":"about/changelog/#040","title":"0.4.0","text":"<ul> <li>NEW: Officially support Python 3.10.</li> <li>NEW: Slightly more accurate Oklab matrix calculation.</li> <li>NEW: Exported dictionary form can now be used as a normal color input in functions like <code>contrast</code>, <code>interpolate</code>,   etc.</li> <li>NEW: Color objects will accept a dictionary mapping when <code>alpha</code> is not specified. When this occurs, <code>alpha</code> is   assumed to be <code>1</code>.</li> <li>FIX: Fix an object compare issue.</li> </ul>"},{"location":"about/changelog/#030","title":"0.3.0","text":"<p>Breaking Changes</p> <p>XYZ changes below will cause breakage as <code>xyz</code> now refers to XYZ with D65 instead of D50. Also, CSS identifiers changed per the recent specification change.</p> <ul> <li>NEW: When calling <code>dir()</code> on <code>Color()</code>, ensure dynamic methods are in the list.</li> <li>NEW: <code>xyz</code> now refers to XYZ D65. CSS <code>color()</code> function now specifies D65 color as either   <code>color(xyz x y z)</code> or <code>color(xyz-d65 x y z)</code>. XYZ D50 is now specified as   <code>color(xyz-D50 x y z)</code>.</li> <li>NEW: Add CIELuv and CIELChuv D65 variants.</li> </ul>"},{"location":"about/changelog/#020","title":"0.2.0","text":"<ul> <li>NEW: Provide dedicated <code>clip</code> method. <code>clip</code> is still a specifiable method under the <code>fit</code> function. It is also   a reserved name under <code>fit</code> and cannot be overridden via plugins or be removed.</li> <li>NEW: Add more conversion shortcuts to OK family of color spaces.</li> <li>FIX: Fix an issue where the shorter conversion path wasn't always taken as convert couldn't find to/from methods   if the color space name had <code>-</code> in it.</li> </ul>"},{"location":"about/changelog/#010","title":"0.1.0","text":"<p>First non-alpha prerelease. Notable changes from the last alpha listed below.</p> <p>Breaking Changes</p> <p>There are some breaking changes if coming from the previous alpha releases. All sRGB cylindrical spaces' non-hue data ranges are no longer scaled to 0 - 100, but use 0 - 1. Hue ranges have not changed.</p> <ul> <li>NEW: By accepting HSL, HSV, and HWB as non-hue channels as 0-100, we do lose a little precision, so for 1.0, we   are switching to accepting and returning raw data values between 0 - 1. We've kept hue between 0 - 360 as it is easier   for users to deal with hues between 0 - 360. Doing this will also match the new color spaces Okhsl and Okhsv that   need to be kept at 0 - 1 to get better rounding.</li> <li>NEW: We do not currently restrict percentages anymore in <code>color()</code> functions. There is no hard rules   that we need to at this time and no currently specified spaces that do this in the CSS specification. This is relaxed   for now until some future time when it becomes clear we must.</li> <li>NEW: New <code>okhsl</code> and <code>okhsv</code> color space.</li> <li>NEW: All color channels now accept the <code>none</code> keyword to specify an undefined channel. They can also optionally   output CSS strings with the keyword.</li> <li>NEW: Interpolation will return an undefined channel if both colors have that channel set to undefined.</li> <li>NEW: Provide a way to dump a color object to a simple dictionary and have the <code>Color()</code> object accept that   dictionary to recreate the color object.</li> <li>NEW: Provide <code>cat16</code> chromatic adaptation.</li> <li>NEW: Add <code>normalize</code> method to force channel normalization (evaluation of channels and setting undefined as   appropriate).</li> <li>NEW: Interpolated and composited colors will normalize undefined channels when returning a color.</li> <li>NEW: Jzazbz now also has an alias for <code>az</code> and <code>bz</code> channels as <code>a</code> and <code>b</code> respectively.</li> <li>FIX: Fix an attribute \"get\" issue where attributes that were not present on the <code>Color()</code> object appeared to be   present when using <code>hasattr()</code>.</li> <li>FIX: More accurate Oklab matrix.</li> </ul>"},{"location":"about/contributing/","title":"Contributing &amp; Support","text":"<p>There are many ways to help support this project, regardless of skills and abilities. If you enjoy this project and want to get involved, consider checking out one of the various ways below. Feel free to get creative, there may be other ways to contribute in which we have not thought of!</p>"},{"location":"about/contributing/#become-a-sponsor","title":"Become a Sponsor","text":"<p>Open source projects take time and money. Help support the project by becoming a sponsor. You can add your support at any tier you feel comfortable with. No amount is too little. We also accept one time contributions via PayPal.</p> <p> GitHub Sponsors  PayPal</p>"},{"location":"about/contributing/#bug-reports","title":"Bug Reports","text":"<ol> <li> <p>Please read the documentation and search the issue tracker to try and find the answer to your question   before posting an issue.</p> </li> <li> <p>When creating an issue on the repository, please provide as much info as possible:</p> <ul> <li>Version being used.</li> <li>Operating system.</li> <li>Version of Python.</li> <li>Errors in console.</li> <li>Detailed description of the problem.</li> <li>Examples for reproducing the error.  You can post pictures, but if specific text or code is required to reproduce   the issue, please provide the text in a plain text format for easy copy/paste.</li> </ul> <p>The more info provided, the greater the chance someone will take the time to answer, implement, or fix the issue.</p> </li> <li> <p>Be prepared to answer questions and provide additional information if required.  Issues in which the creator refuses   to respond to follow up questions will be marked as stale and closed.</p> </li> </ol>"},{"location":"about/contributing/#reviewing-code","title":"Reviewing Code","text":"<p>Take part in reviewing pull requests and/or reviewing direct commits.  Make suggestions to improve the code and discuss solutions to overcome weakness in the algorithm.</p>"},{"location":"about/contributing/#answer-questions-in-issues","title":"Answer Questions in Issues","text":"<p>Take time and answer questions and offer suggestions to people who've created issues in the issue tracker. Often people will have questions that you might have an answer for.  Or maybe you know how to help them accomplish a specific task they are asking about. Feel free to share your experience to help others out.</p>"},{"location":"about/contributing/#pull-requests","title":"Pull Requests","text":"<p>Pull requests are welcome, and a great way to help fix bugs and add new features.</p>"},{"location":"about/contributing/#documentation-improvements","title":"Documentation Improvements","text":"<p>A ton of time has been spent not only creating and supporting this tool and related extensions, but also spent making this documentation.  If you feel it is still lacking, show your appreciation for the tool and/or extensions by helping to improve the documentation.</p>"},{"location":"about/license/","title":"License","text":"<p>MIT License</p> <p>Copyright \u00a9 2020 - 2023 Isaac Muse</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"about/releases/1.0/","title":"1.0 Migration Notes","text":"<p>ColorAide has been a constantly evolving project. As we've pushed for a stable release, the 1.0 milestone was no exception. For any of the early adopters, there are a number of things to be aware of when migrating to 1.0. In this guide, we'll cover the changes most likely to impact users.</p>"},{"location":"about/releases/1.0/#plugins","title":"Plugins","text":"<p>Plugins have gone through a number of reworks. In 1.0, we now require all plugins to be registered as instances. Prior to 1.0 plugins were just passed in un-instantiated. Some plugins were used as static classes almost, and some (color spaces) were instantiated on the creation of every color.</p> <p>In 1.0, all plugins are required to be instantiated prior to registration. This gives the user the opportunity to specify any alternative defaults if desired.</p> <pre><code>&gt;&gt;&gt; Color('red').delta_e('blue', method='cmc')\n114.23012812016573\n&gt;&gt;&gt; from coloraide.distance.delta_e_cmc import DECMC\n&gt;&gt;&gt; class Custom(Color):\n...     DELTA_E = \"cmc\"\n... \n&gt;&gt;&gt; Custom.register(DECMC(l=1, c=1), overwrite=True)\n&gt;&gt;&gt; Custom('red').delta_e('blue')\n115.77446003768313\n</code></pre> Color('red').delta_e('blue', method='cmc') from coloraide.distance.delta_e_cmc import DECMC class Custom(Color):     DELTA_E = \"cmc\" Custom.register(DECMC(l=1, c=1), overwrite=True) Custom('red').delta_e('blue') Edit Share Run Cancel"},{"location":"about/releases/1.0/#plugin-renames","title":"Plugin Renames","text":"<p>ColorAide had some inconsistencies when it came to some plugin names. For instance, we would use variations of <code>Lch</code>, <code>LCH</code>, etc. This made it more difficult to predict how a plugin was named, and remember it. In this case appropriate casing is usually <code>LCh</code>. All plugins referring to <code>LCh</code> were renamed to be more consistent.</p> <p>Outside of LCh related classes, there were a few additional renames to better match the color space of interest's real name.</p> Old\u00a0Name New\u00a0Name <code>Lch</code> <code>LCh</code> <code>LchD65</code> <code>LChD65</code> <code>Oklch</code> <code>OkLCh</code> <code>Lchuv</code> <code>LChuv</code> <code>Lch99o</code> <code>LCh99o</code> <code>LchChroma</code> <code>LChChroma</code> <code>OklchChroma</code> <code>OkLChchroma</code> <code>Lchish</code> <code>LChish</code> <code>XyY</code> <code>xyY</code> <code>Din99o</code> <code>DIN99o</code> <code>SRGB</code> <code>sRGB</code> <code>SRGBLinear</code> <code>sRGBLinear</code> <code>ORGB</code> <code>oRGB</code>"},{"location":"about/releases/1.0/#default-plugins","title":"Default Plugins","text":"<p>Over the course of development, we've added a good number of color spaces. With the 1.0 release, it was decided to have the default <code>Color</code> object not register all available color spaces out of the box as the amount of color spaces has grown quite substantially.</p> <p>As not all color spaces are registered by default, \u2206E plugins tied to color spaces no longer registered by default will also not be registered by default.</p> <p>Lastly, since the <code>bradford</code> CAT is the default, it was deemed unnecessary to register all the other CAT plugins by default.</p> <p>With all of that said, all of the exiting plugins are still available and can be included if/when needed. If any of the plugins that are no longer registered by default are needed, there are a couple of options:</p> <ol> <li> <p>The recommended way is to just subclass the <code>Color</code> object and cherry pick the plugins that are needed. When    classing, all the plugins registered in the base will be copied over to the derived class. Then we can just pass    in the instantiated plugins.</p> <pre><code>&gt;&gt;&gt; from coloraide import Color as Base\n&gt;&gt;&gt; from coloraide.spaces.jzazbz import Jzazbz\n&gt;&gt;&gt; from coloraide.distance.delta_e_z import DEZ\n&gt;&gt;&gt; class Color(Base): ...\n... \n&gt;&gt;&gt; Color.register([Jzazbz(), DEZ()])\n&gt;&gt;&gt; Color('red').convert('jzazbz')\ncolor(--jzazbz 0.13438 0.11789 0.11188 / 1)\n&gt;&gt;&gt; Color('red').delta_e('blue', method='jz')\n0.3396038842016558\n</code></pre> from coloraide import Color as Base from coloraide.spaces.jzazbz import Jzazbz from coloraide.distance.delta_e_z import DEZ  class Color(Base): ...  Color.register([Jzazbz(), DEZ()])  Color('red').convert('jzazbz') Color('red').delta_e('blue', method='jz') Edit Share Run Cancel </li> <li> <p>We also provide a new color object derived from <code>Color</code> that includes all color spaces called <code>ColorAll</code>. This    object won't be as light, but will provide quick and easy access to everything ColorAide offers. By default, it    registers every plugin. It can be found under <code>coloraide.everything</code>.</p> <pre><code>&gt;&gt;&gt; from coloraide.everything import ColorAll as Color\n&gt;&gt;&gt; Color('purple').convert('hunter-lab')\ncolor(--hunter-lab 24.796 50.842 -35.444 / 1)\n</code></pre> from coloraide.everything import ColorAll as Color  Color('purple').convert('hunter-lab') Edit Share Run Cancel </li> </ol>"},{"location":"about/releases/1.0/#dynamic-propertiesfunctions-and-coordinate-access","title":"Dynamic Properties/Functions and Coordinate Access","text":"<p>Prior to 1.0, ColorAide's <code>Color</code> object had color channel properties that would magically mutate based on what the current color space was that the object currently held. While cool, this added overhead to every class attribute access. In an effort to dramatically reduce unnecessary overhead, this feature had to be rethought.</p> <p>Additionally, \u2206E methods were also added dynamically. For instance, if we had the \u2206E 2000 distancing plugin registered, we'd have access to \u2206E via <code>Color.delta_e_2000</code> or <code>Color.delta_e(color, method='2000')</code>. Again, the overhead to magically provide these properties the way we were posed the same problem as what was seen with dynamic color channel properties</p> <p>Additionally, the <code>Color</code> object used to have a <code>coords()</code> function to get all the non-alpha color channels. This function was not really problematic, but as we decided a solution for the dynamic properties, it became apparent that we would no longer need such a function.</p> <p>1.0 removed the overhead of magic dynamic properties and functions. In particular, we decided to approach color channel access in a new and different way.</p> <p>Moving forward, the <code>Color</code> object is now iterable and indexable. Channels can be directly indexed via channel names or numerical indexes. You can even use slices:</p> <pre><code>&gt;&gt;&gt; color = Color('orange')\n&gt;&gt;&gt; color\ncolor(srgb 1 0.64706 0 / 1)\n&gt;&gt;&gt; color['blue']\n0.0\n&gt;&gt;&gt; color[0]\n1.0\n&gt;&gt;&gt; color[:-1]\n[1.0, 0.6470588235294118, 0.0]\n</code></pre> color = Color('orange') color color['blue'] color[0] color[:-1] Edit Share Run Cancel <p><code>Color</code> objects are also iterable, so you can just loop them as well, or cast the object as a list.</p> <pre><code>&gt;&gt;&gt; for channel in Color('orange'):\n...     print(channel)\n... \n1.0\n0.6470588235294118\n0.0\n1.0\n&gt;&gt;&gt; list(Color('green'))\n[0.0, 0.5019607843137255, 0.0, 1.0]\n</code></pre> for channel in Color('orange'):     print(channel) list(Color('green')) Edit Share Run Cancel <p>Setting channels is just as easy and can be done by indexing channels with names, numerical indexes, or even slices.</p> <pre><code>&gt;&gt;&gt; color = Color('transparent')\n&gt;&gt;&gt; color[:] = [1, 0, 0, 0.5]\n&gt;&gt;&gt; color\ncolor(srgb 1 0 0 / 0.5)\n</code></pre> color = Color('transparent') color[:] = [1, 0, 0, 0.5] color Edit Share Run Cancel <p>As far as \u2206E methods are concerned, we already had two different ways to approach this, so we simply removed the dynamic functions. To access any of the different \u2206E methods, simply call the generic <code>delta_e</code> function and provide the <code>method</code>.</p> <pre><code>&gt;&gt;&gt; Color('red').delta_e('green', method='2000')\n72.18053591241998\n</code></pre> Color('red').delta_e('green', method='2000') Edit Share Run Cancel"},{"location":"about/releases/1.0/#gamut-mapping-and-clipping","title":"Gamut Mapping and Clipping","text":"<p>During our path to 1.0, we noticed that when performing gamut mapping and clipping, in most cases, we were performing them \"in place\" instead of the default which generated new <code>Color</code> instances. There are times when we occasionally wanted a new instance of the color when fitting a color to its gamut, but that turned out to not be the norm.</p> <p>Generating new instances obviously will create more overhead, and in some cases, such as color mixing, returning a new color opposed to mutating the existing one makes a lot more sense, but with gamut mapping and clipping, for efficiency, we were often forcing \"in place\" operations.</p> <p>1.0 now does gamut mapping and clipping in place by default. With this change, the <code>in_place</code> parameter is not longer available for <code>fit()</code> and <code>clip()</code>.</p> <p>So, if migrating to 1.0, if you were calling <code>fit()</code> and <code>clip()</code> directly, a few changes will need to be made. If you'd like to do an in place gamut correction, simply call the function. If you'd like to generate a new instance, clone the color first.</p> <pre><code>&gt;&gt;&gt; color1 = Color('display-p3', [1, 1, 0])\n&gt;&gt;&gt; color1.fit('srgb')\ncolor(display-p3 0.99859 0.9923 0.32854 / 1)\n&gt;&gt;&gt; color1\ncolor(display-p3 0.99859 0.9923 0.32854 / 1)\n&gt;&gt;&gt; color2 = Color('display-p3', [0, 1, 0])\n&gt;&gt;&gt; color3 = color2.clone().fit('srgb')\n&gt;&gt;&gt; color2, color3\n(color(display-p3 0 1 0 / 1), color(display-p3 0.45742 0.98328 0.29762 / 1))\n</code></pre> color1 = Color('display-p3', [1, 1, 0]) color1.fit('srgb') color1 color2 = Color('display-p3', [0, 1, 0]) color3 = color2.clone().fit('srgb') color2, color3 Edit Share Run Cancel"},{"location":"about/releases/1.0/#dictionary-output","title":"Dictionary Output","text":"<p>The dictionary format for input and output as been simplified for the 1.0 release. Prior to 1.0, the <code>Color</code> object used to export color dictionaries with the space name and each channel under an individually named key:</p> <pre><code>{'space': 'srgb', 'r': 1, 'g': 0, 'b': 0, 'alpha': 1}\n</code></pre> <p>This required more overhead, particularly when parsing to handle channel alias and the like. For 1.0, we've streamlined the format to export the data with all color coordinates under <code>coords</code> and the alpha channel still under <code>alpha</code>. This makes streamlines the process of handling dictionaries as inputs and outputting them when requested, in turn, improving performance.</p> <pre><code>&gt;&gt;&gt; d = Color('rebeccapurple').to_dict()\n&gt;&gt;&gt; d\n{'space': 'srgb', 'coords': [0.4, 0.2, 0.6], 'alpha': 1.0}\n&gt;&gt;&gt; Color(d)\ncolor(srgb 0.4 0.2 0.6 / 1)\n</code></pre> d = Color('rebeccapurple').to_dict() d Color(d) Edit Share Run Cancel"},{"location":"about/releases/1.0/#interpolation","title":"Interpolation","text":"<p>Interpolation was an area we were generally unhappy with, so it was majorly overhauled.</p> <p>Prior to 1.0, interpolation could be a bit awkward. Interpolation used to require the first color in the interpolation to be the calling object, and all the rest had to be fed in.</p> <pre><code>Color('red').interpolate(['blue', 'green', 'orange'])\n</code></pre> <p>When performing a simple mix, this felt natural and made sense:</p> <pre><code>Color('red').mix('blue', 0.25)\n</code></pre> <p>But with long chains of colors, this just felt cumbersome. To remedy this, we changed the <code>interpolate</code> and <code>steps</code> methods to <code>@classmethods</code>. We left <code>mix</code> as is since with two colors it feels natural.</p> <p>So moving forward, <code>interpolate</code> and <code>steps</code> will execute interpolations from class methods.</p> <pre><code>&gt;&gt;&gt; Color.interpolate(['red', 'blue', 'green', 'orange'])\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x10c9c2850&gt;\n&gt;&gt;&gt; Color.steps(['red', 'blue', 'green', 'orange'], steps=10)\n[color(srgb 1 0 0 / 1), color(srgb 0.70118 0.31007 0.50198 / 1), color(srgb 0.39631 0.30469 0.76127 / 1), color(srgb 0 0 1 / 1), color(srgb -0.20255 0.35952 0.74044 / 1), color(srgb -0.19845 0.45628 0.46971 / 1), color(srgb 0 0.50196 0 / 1), color(srgb 0.46864 0.56246 0.00026 / 1), color(srgb 0.7411 0.61106 0.00031 / 1), color(srgb 1 0.64706 0 / 1)]\n</code></pre> Color.interpolate(['red', 'blue', 'green', 'orange']) Color.steps(['red', 'blue', 'green', 'orange'], steps=10) Edit Share Run Cancel <p>This means that you do not have to call the function from an instantiated object, and if you do, the instantiated color that is making the call will not be included in the interpolation. Only the colors in the list are considered during the interpolation.</p> <pre><code>&gt;&gt;&gt; Color('white').interpolate(['red', 'blue', 'green', 'orange'])\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x10ca0d590&gt;\n</code></pre> Color('white').interpolate(['red', 'blue', 'green', 'orange']) Edit Share Run Cancel <p>This will make even more sense as we highlight the other changes.</p> <p>Another problem we faced was the awkwardness of color stops and easing functions. Before we used to have a <code>Piecewise</code> object that you'd wrap a channel in to create color stops or inject easing functions and other various behaviors between colors, but it had to be applied on the second color in the chain, and this didn't quite work for the first color. If you wanted to add a stop to the first color, you then had to use a special <code>stop</code> parameter\u2026it was unintuitive.</p> <pre><code>from coloraide import Piecewise\nColor('red').interpolate(['blue', Piecewise('orange', 0.75, progress=lambda t: t * 3), 'purple'], stop=0.25)\n</code></pre> <p>In 1.0, we simplified things greatly. Since <code>interpolate</code> and <code>steps</code> now require that all colors must be in the input list if they are to be considered for interpolation, we can process them all in a consistent and more intuitive manner.</p> <p>As before, <code>steps</code> and <code>interpolate</code> allow you to set function parameters to generally control the behavior for the entire interpolation across all colors. You can also still add easing functions via <code>progress</code> which will also affect the entire interpolation by default, but now you can inject easing functions directly between colors which will only be applied between those two colors.</p> <pre><code>&gt;&gt;&gt; Color.interpolate(['red', lambda t: t * 3, 'orange', 'purple'])\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x10ca00cd0&gt;\n</code></pre> Color.interpolate(['red', lambda t: t * 3, 'orange', 'purple']) Edit Share Run Cancel <p>You can also directly wrap any color in the list with <code>stop</code> to change the color stop position. Since the first color is now treated like all the other colors, there is no need for the <code>stop</code> function parameter either.</p> <pre><code>&gt;&gt;&gt; from coloraide import stop\n&gt;&gt;&gt; Color.interpolate([stop('red', 0.25), stop('orange', 0.75), 'purple'])\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x10ca1f210&gt;\n</code></pre> from coloraide import stop Color.interpolate([stop('red', 0.25), stop('orange', 0.75), 'purple']) Edit Share Run Cancel <p>And if you are familiar with CSS color hinting, which essentially alters the midpoint between two color stops, we've added a <code>hint</code> function which takes a new relative midpoint and returns a midpoint easing function which essentially acts the same as CSS interpolation hints.</p> <pre><code>&gt;&gt;&gt; from coloraide import hint\n&gt;&gt;&gt; Color.interpolate(['yellow', 'pink'])\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x10ca39f50&gt;\n&gt;&gt;&gt; Color.interpolate(['yellow', hint(0.25), 'pink'])\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x10ca0e810&gt;\n</code></pre> from coloraide import hint Color.interpolate(['yellow', 'pink']) Color.interpolate(['yellow', hint(0.25), 'pink']) Edit Share Run Cancel <p>All of this makes for a less confusing experience when using interpolation. Additionally, all of the changes simplified the logic allowing us to even add a new interpolation method!</p> <pre><code>&gt;&gt;&gt; Color.interpolate(['red', 'blue', 'green', 'orange'], method='bspline')\n&lt;coloraide.interpolate.bspline.InterpolatorBSpline object at 0x10ca02fd0&gt;\n</code></pre> Color.interpolate(['red', 'blue', 'green', 'orange'], method='bspline') Edit Share Run Cancel"},{"location":"about/releases/1.0/#color-space-filters","title":"Color Space Filters","text":"<p>In the beginning, the <code>Color</code> space object was created with a naive filtering system. It added a little overhead, but the real issue was the fact that it only filtered inputs through <code>new</code>, <code>match</code>, and through normal instantiation. It did not filter through almost any other method that accepted inputs. It was decided to leave color filtering up to the user.</p> <pre><code>&gt;&gt;&gt; c = Color('display-p3', [1, 1, 0])\n&gt;&gt;&gt; try:\n...     if c.space() not in ['srgb', 'hsl', 'hwb']:\n...         raise ValueError('Invalid Color Space')\n... except ValueError as e:\n...     print(e)\n... \nInvalid Color Space\n</code></pre> c = Color('display-p3', [1, 1, 0]) try:     if c.space() not in ['srgb', 'hsl', 'hwb']:         raise ValueError('Invalid Color Space') except ValueError as e:     print(e) Edit Share Run Cancel"},{"location":"api/","title":"Color API","text":""},{"location":"api/#nan","title":"<code>coloraide.NaN</code>","text":"Description <code>NaN</code> is a convenience constant for <code>float('nan')</code>. Import path <p><code>NaN</code> is imported from the <code>coloraide</code> library:</p> <pre><code>from coloraide import NaN\n</code></pre>"},{"location":"api/#stop","title":"<code>coloraide.stop</code>","text":"<pre><code>class stop(\n    color,\n    s\n):\n</code></pre> Description <code>stop</code> objects are used in <code>interpolate</code> methods. They allow a user to control specify a color stop for a given color during the interpolation process. Import Path <p><code>stop</code> is imported from <code>coloraide</code> library:</p> <pre><code>from coloraide import stop\n</code></pre> Parameters Parameters Defaults Description <code>color</code> A color string, a dictionary describing the color, or another <code>Color</code> class object. <code>value</code> A numerical value specifying the new color stop for the given color."},{"location":"api/#hint","title":"<code>coloraide.hint</code>","text":"<pre><code>class hint(\n    mid,\n):\n</code></pre> Description <code>hint</code> returns an easing function that adjust the midpoint between two color stops. Import Path <p><code>hint</code> is imported from <code>coloraide</code> library:</p> <pre><code>from coloraide import hint\n</code></pre> Parameters Parameters Defaults Description <code>mid</code> A numerical value, relative to the two color stops it occurs between, that will be used as the new midpoint."},{"location":"api/#color","title":"<code>coloraide.Color</code>","text":"<pre><code>class Color:\n    def __init__(\n        self,\n        color,\n        data=None,\n        alpha=util.DEF_ALPHA,\n        *,\n        filters=None, **kwargs\n    ):\n</code></pre> Description The <code>Color</code> class object is a wrapper around the internal color space objects. <code>Color</code> is the base Color object and only registers a select number of color spaces. It provides an API interface to allow users to specify and manipulate colors. Color objects can be iterated, which will return each color channel. They are also indexable by channel name or by channel index. Import path <p><code>Color</code> is imported from the <code>coloraide</code> library:</p> <pre><code>from coloraide import Color\n</code></pre> Parameters Parameters Defaults Description <code>color</code> A color string, a dictionary describing the color, or another <code>Color</code> class object. If given <code>data</code>, a string must be used and should represent the color space to use. <code>data</code> <code>None</code> <code>data</code> accepts a list of numbers representing the coordinates of the color. If provided, <code>color</code> must be a string specifying the color space. <code>alpha</code> <code>1</code> <code>alpha</code> accepts a number specifying the <code>alpha</code> channel. Must be used in conjunction with <code>data</code> or it will be ignored. <code>filters</code> <code>None</code> <code>filters</code> accepts a list of color spaces to allow. When <code>None</code> is provided (the default) all supported color spaces are accepted."},{"location":"api/#colorall","title":"<code>coloraide.everything.ColorAll</code>","text":"<pre><code>class ColorAll(Color):\n    def __init__(\n        self,\n        color,\n        data=None,\n        alpha=util.DEF_ALPHA,\n        *,\n        filters=None, **kwargs\n    ):\n</code></pre> Description The <code>ColorAll</code> class object is derived from <code>Color</code> and extends the registered color spaces to include all offered by ColorAide. Import path <p><code>ColorAll</code> is imported from the <code>coloraide</code> library:</p> <pre><code>from coloraide.everything import ColorAll\n</code></pre> Parameters Parameters Defaults Description <code>color</code> A color string, a dictionary describing the color, or another <code>ColorAll</code> class object. If given <code>data</code>, a string must be used and should represent the color space to use. <code>data</code> <code>None</code> <code>data</code> accepts a list of numbers representing the coordinates of the color. If provided, <code>color</code> must be a string specifying the color space. <code>alpha</code> <code>1</code> <code>alpha</code> accepts a number specifying the <code>alpha</code> channel. Must be used in conjunction with <code>data</code> or it will be ignored. <code>filters</code> <code>None</code> <code>filters</code> accepts a list of color spaces to allow. When <code>None</code> is provided (the default) all supported color spaces are accepted."},{"location":"api/#register","title":"<code>Color.register</code>","text":"<pre><code>@classmethod\ndef register(\n    cls,\n    plugin,\n    *,\n    overwrite=False,\n    silent=False\n):\n</code></pre> Description Register a plugin(s). Parameters Parameters Defaults Description <code>plugin</code> A plugin object or list of plugin objects to register. <code>overwrite</code> <code>False</code> <code>overwrite</code> will avoid allow an already registered plugin to be overwritten if the plugin to register specifies a <code>name</code> that is already used for registration. <code>silent</code> <code>False</code> <code>silent</code> will avoid throwing an error if the <code>name</code> is already found in the specified category."},{"location":"api/#deregister","title":"<code>Color.deregister</code>","text":"<pre><code>@classmethod\ndef deregister(\n    cls,\n    plugin,\n    *,\n    silent=False\n):\n</code></pre> Description Remove an already registered plugin(s). Parameters Parameters Defaults Description <code>plugin</code> A string or list of strings that describe the plugin to be removed. Strings should be in the format <code>category:name</code> where <code>category</code> is either <code>space</code>, <code>delta-e</code>, or <code>fit</code> and <code>name</code> is the name the plugin was registered under. <code>*</code> will remove all plugins and <code>category:*</code> will remove all within a specific category. <code>silent</code> <code>False</code> <code>silent</code> will avoid throwing an error if the <code>name</code> can not be found in the specified category."},{"location":"api/#match","title":"<code>Color.match</code>","text":"<pre><code>@classmethod\ndef match(\n    cls,\n    string,\n    start=0,\n    fullmatch=False,\n    *,\n    filters=None\n):\n</code></pre> Description <p>The <code>match</code> class method provides access to the color matching interface and allows a user to provide a color string and get back a <code>ColorMatch</code> object. <code>ColorMatch</code> objects contain three properties:</p> <pre><code>class ColorMatch:\n    def __init__(\n        self,\n        color,\n        start,\n        end\n    ):\n</code></pre> <ol> <li><code>color</code>: the <code>Color</code> object.</li> <li><code>start</code>: the starting point within the string buffer where the color was found.</li> <li><code>end</code>: the ending point within the string buffer where the color was found.</li> </ol> <p>Match does not search the entire buffer, but simply matches at the location specified by <code>start</code>.</p> Parameters Parameters Defaults Description <code>string</code> A string representing the color. <code>start</code> <code>0</code> Accepts an integer offset into the provided string buffer to start the match. <code>fullmatch</code> <code>False</code> A boolean which defines whether match must match to the end of the string buffer. <code>filters</code> <code>None</code> <code>filters</code> accepts a list of color spaces to allow. When <code>None</code> is provided (the default) all supported color spaces are accepted. Return Returns a <code>ColorMatch</code> object."},{"location":"api/#new","title":"<code>Color.new</code>","text":"<pre><code>def new(\n    self,\n    color,\n    data=None,\n    alpha=util.DEF_ALPHA,\n    *,\n    filters=None,\n    **kwargs\n):\n</code></pre> Description The <code>new</code> class method exposes the interface of creating new color objects. Using <code>new</code> is the same as using <code>Color()</code>. Parameters Parameters Defaults Description <code>color</code> A color string, or other <code>Color</code> class object. If given <code>data</code>, a string must be used and should represent the color space to use. <code>data</code> <code>None</code> <code>data</code> accepts a list of numbers representing the coordinates of the color. If provided, <code>color</code> must be a string specifying the color space. <code>alpha</code> <code>1</code> <code>alpha</code> accepts a number specifying the <code>alpha</code> channel. Must be used in conjunction with <code>data</code> or it will be ignored. <code>filters</code> <code>None</code> <code>filters</code> accepts a list of color spaces to allow. When <code>None</code> is provided (the default) all supported color spaces are accepted. Return Returns a <code>Color</code> object."},{"location":"api/#random","title":"<code>Color.random</code>","text":"<pre><code>@classmethod\ndef random(\n    cls,\n    space,\n    *,\n    limits=None\n):\n</code></pre> Description Generate a random color in the provided <code>space</code>. The color space's channel range will be used as a limit for the channel. For color spaces with no clearly defined gamut, these values can be arbitrary. In such cases, it may be advisable to fit the returned color space to a displayable gamut. Parameters Parameters Defaults Description <code>space</code> The color space name in which to generate a random color in. <code>limits</code> <code>None</code> An optional list of constraints for various color channels. Each entry should either be a sequence contain a minimum and maximum value, or should be <code>None</code>. <code>None</code> values will be ignored and the color space's specified channel range will be used instead. Any missing entries will be treated as <code>None</code>. Return Returns a <code>Color</code> object."},{"location":"api/#clone","title":"<code>Color.clone</code>","text":"<pre><code>def clone(\n    self\n):\n</code></pre> Description The <code>clone</code> method provides a way to create a duplicate of the current <code>Color</code> instance. Return Returns a <code>Color</code> object."},{"location":"api/#update","title":"<code>Color.update</code>","text":"<pre><code>def update(\n    self,\n    color,\n    data=None,\n    alpha=util.DEF_ALPHA,\n    *,\n    filters=None,\n    **kwargs\n):\n</code></pre> Description The <code>update</code> method provides a way to update the underlying color spaces with coordinates from any color space. The methods signature looks just like <code>new</code> and accepts color strings, <code>Color</code> objects, or raw data points specified with a color space string and coordinates. The object itself will be updated and remain in its current color space. Parameters Parameters Defaults Description <code>color</code> A color string, or other <code>Color</code> class object. If given <code>data</code>, a string must be used and should represent the color space to use. <code>data</code> <code>None</code> <code>data</code> accepts a list of numbers representing the coordinates of the color. If provided, <code>color</code> must be a string specifying the color space. <code>alpha</code> <code>1</code> <code>alpha</code> accepts a number specifying the <code>alpha</code> channel. Must be used in conjunction with <code>data</code> or it will be ignored. <code>filters</code> <code>None</code> <code>filters</code> accepts a list of color spaces to allow. When <code>None</code> is provided (the default) all supported color spaces are accepted. Return Returns a reference to the current <code>Color</code> object."},{"location":"api/#mutate","title":"<code>Color.mutate</code>","text":"<pre><code>def mutate(\n    self,\n    color,\n    data=None,\n    alpha=util.DEF_ALPHA,\n    *,\n    filters=None,\n    **kwargs\n):\n</code></pre> Description The <code>mutate</code> method is just like <code>update</code> except that it will not only update the color space, but mutate it to the provided color space. Parameters Parameters Defaults Description <code>color</code> A color string, or other <code>Color</code> class object. If given <code>data</code>, a string must be used and should represent the color space to use. <code>data</code> <code>None</code> <code>data</code> accepts a list of numbers representing the coordinates of the color. If provided, <code>color</code> must be a string specifying the color space. <code>alpha</code> <code>1</code> <code>alpha</code> accepts a number specifying the <code>alpha</code> channel. Must be used in conjunction with <code>data</code> or it will be ignored. <code>filters</code> <code>None</code> <code>filters</code> accepts a list of color spaces to allow. When <code>None</code> is provided (the default) all supported color spaces are accepted. Return Returns a reference to the current <code>Color</code> object."},{"location":"api/#convert","title":"<code>Color.convert</code>","text":"<pre><code>def convert(\n    self,\n    space,\n    *,\n    fit=False,\n    in_place=False\n):\n</code></pre> Description Converts a <code>Color</code> object from one color space to another. If the current color space matches the specified color space, the object will be cloned. Parameters Parameters Defaults Description <code>space</code> A string representing the desired final color space. <code>fit</code> <code>False</code> Parameter specifying whether the current color should be gamut mapped into the final, desired color space. If set to <code>True</code>, the color will be gamut mapped using the default gamut mapping method. If set to a string, the string will be interpreted as the name of the gamut mapping method to be used. <code>in_place</code> <code>False</code> Boolean specifying whether the convert should alter the current <code>Color</code> object or return a new one. Return Returns a reference to the converted <code>Color</code> object. If <code>in_place</code> is <code>True</code>, the return will be a reference to the current <code>Color</code> object."},{"location":"api/#space","title":"<code>Color.space</code>","text":"<pre><code>def space(\n    self\n):\n</code></pre> Description Retrieves the current color space of the color. Return Returns a string with the name of the current color space."},{"location":"api/#normalize","title":"<code>Color.normalize</code>","text":"<pre><code>def to_dict(\n    self\n):\n</code></pre> Description Force normalization of a color's channels by cleaning up channels that shouldn't be undefined and setting any channels to undefined if they meet the specific color's criteria dictating such, e.g., hue is undefined in HSL when saturation is zero. Normalize modifies the current color in place. Return Returns a reference to the current <code>Color</code> object after normalizing the channels for undefined hues."},{"location":"api/#to_dict","title":"<code>Color.to_dict</code>","text":"<pre><code>def to_dict(\n    self,\n    **kwargs\n):\n</code></pre> Description Dump the color object to a simple dictionary. Return A dictionary containing the color space name, the channel name with their respective values."},{"location":"api/#to_string","title":"<code>Color.to_string</code>","text":"<pre><code>def to_string(\n    self,\n    **kwargs\n):\n</code></pre> Description Method that converts the current color to an output format supported by the color space. While a number of the parameters are common, some may be specific to the color space. The usage guide covers color space specific options in more details. Parameters <p>Common parameters:</p> Parameters Defaults Description <code>alpha</code> <code>None</code> Boolean or <code>None</code> value which determines whether the output includes <code>alpha</code>. If <code>None</code> (the default) alpha will only be shown if less than 1. If <code>True</code>, alpha will always be shown. If <code>False</code>, alpha will be omitted. <code>precision</code> <code>5</code> Integer value that sets precision and scale. Precision and scale will match the value if greater than zero. If <code>0</code>, values will be rounded to the nearest integer. If <code>-1</code>, number will be output at the highest precision. <code>fit</code> <code>True</code> A boolean that controls whether gamut mapping is performed on string creation. By default, colors will be fit to their own color space. This can be disabled by setting to <code>False</code>. <code>color</code> <code>False</code> A boolean that will determine if the <code>color(space coord+ / alpha)</code> format is used for string output. Has highest precedence. <p>sRGB specific parameters:</p> Parameters Defaults Description <code>hex</code>. <code>False</code> String output will be in <code>#RRGGBBAA</code> format. <code>names</code> <code>False</code> Boolean indicating a preference for CSS color names. When translating a color to it's closest hex form, if that hex value matches a CSS color name, that color name will be returned as the output. <code>hex</code> does not have to be <code>True</code> for this to apply. <code>compress</code> <code>False</code> If <code>hex</code> is <code>True</code> and <code>compress</code> is <code>True</code>, hex values will be compressed if possible: <code>#RRGGBBAA</code> \u2192 <code>#RGBA</code>. <p>Space dependent parameters:</p> Parameters Defaults Description <code>comma</code> <code>False</code> If supported by the color space and the current output format, commas will be used instead of space format: <code>rgba(0, 0, 0, 1)</code> \u2192 <code>rgb(0 0 0 /1)</code>. Return Returns a string representation of the current color."},{"location":"api/#luminance","title":"<code>Color.luminance</code>","text":"<pre><code>def luminance(\n    self\n):\n</code></pre> Description Get the relative luminance. Relative luminance is obtained from the Y coordinate in the XYZ color space. XYZ, in this case, has a D65 white point. Return Returns an float indicating the relative luminance."},{"location":"api/#colorcontrast","title":"<code>Color.contrast</code>","text":"<pre><code>def contrast(\n    self,\n    color\n):\n</code></pre> Description Get the contrast ratio based on the relative luminance between two colors. Parameters Parameters Defaults Description <code>color</code> A color string or <code>Color</code> object representing a color. Return Returns a float indicating the contrast ratio between two colors."},{"location":"api/#distance","title":"<code>Color.distance</code>","text":"<pre><code>def distance(\n    self,\n    color,\n    *,\n    space=util.DEF_DISTANCE_SPACE\n):\n</code></pre> Description Performs a euclidean distance algorithm on two colors. Parameters Parameters Defaults Description <code>color</code> A color string or <code>Color</code> object representing a color. <code>space</code> <code>\"lab\"</code> Color space to perform distancing algorithm in. Return Returns a float indicating euclidean distance between the two colors."},{"location":"api/#delta_e","title":"<code>Color.delta_e</code>","text":"<pre><code>def delta_e(\n    self,\n    color,\n    *,\n    method=None,\n    **kwargs\n):\n</code></pre> Description <p>Performs a delta E distance algorithm on two colors. Default algorithm that is used is Delta E 1976 (<code>76</code>). Some methods have additional weighting that can be configured through method specific options which are represented by <code>**kwargs</code>.</p> <p>Available methods:</p> Name Input Parameters \u2206E*ab\u00a0(CIE76) <code>76</code> \u2206E*cmc\u00a0(CMC\u00a0l:c\u00a0(1984)) <code>cmc</code> <code>l=2, c=1</code> \u2206E*94\u00a0(CIE94) <code>94</code> <code>kl=1, k1=0.045, k2=0.015</code> \u2206E*00 \u00a0(CIEDE2000) <code>2000</code> <code>kl=1, kc=1, kh=1</code> \u2206Eitp\u00a0(ICtCp) <code>itp</code> <code>scalar=720</code> \u2206Ez\u00a0(Jzazbz) <code>jz</code> \u2206E99o\u00a0(DIN99o) <code>99o</code> \u2206EHyAB\u00a0(HyAB) <code>hyab</code> <code>space=\"lab\"</code> \u2206Eok <code>ok</code> <code>scalar=1</code> Parameters Parameters Defaults Description <code>color</code> A color string or <code>Color</code> object representing a color. <code>method</code> <code>None</code> String that specifies the method to use. If <code>None</code>, the default will be used. <code>**kwargs</code> Any distancing specific parameters to pass to \u2206E method. Return Returns a float indicating the delta E distance between the two colors."},{"location":"api/#closest","title":"<code>color.closest</code>","text":"<pre><code>def closest(\n    self,\n    colors,\n    *,\n    method=None,\n    **kwargs\n):\n</code></pre> Description Given a list of colors, calculates the closest color to the calling color object. Parameters Parameters Defaults Description <code>colors</code> A list of color strings, <code>Color</code> object, or dictionary representing a color. <code>method</code> <code>None</code> String that specifies the method of color distancing to use. <code>**kwargs</code> Any distancing specific parameters to pass to \u2206E method. Return The <code>Color</code> that is closest to the calling color object. In the off chance that an empty list is passed in <code>None</code> will be returned."},{"location":"api/#mask","title":"<code>color.mask</code>","text":"<pre><code>def mask\n    self,\n    channels,\n    invert=False,\n    in_place=False\n):\n</code></pre> Description The <code>mask</code> method will set any and all specified channels to <code>NaN</code>. If <code>invert</code> is set to <code>True</code>, <code>mask</code> will set any and all channels not specified to <code>NaN</code>. Parameters Parameters Defaults Description <code>channel</code> A string specifying a channel, or a list of strings specifying multiple channels. Specified channels will be masked (or the only channels not masked if <code>invert</code> is <code>True</code>). <code>invert</code> <code>False</code> Use inverse masking logic and mask all channels that are not specified. <code>in_place</code> <code>False</code> Boolean used to determine if the current color should be modified \"in place\" or a new <code>Color</code> object should be returned. Return Returns a reference to the masked <code>Color</code> object. If <code>in_place</code> is <code>True</code>, the return will be a reference to the current <code>Color</code> object."},{"location":"api/#interpolate","title":"<code>Color.interpolate</code>","text":"<pre><code>@classmethod\ndef interpolate(\n    cls,\n    colors,\n    *,\n    stop=0,\n    space=\"lab\",\n    progress=None,\n    out_space=None,\n    hue=util.DEF_HUE_ADJ,\n    premultiplied=True,\n    extrapolate=False,\n    method='linear'\n):\n</code></pre> Description <p>The <code>interpolate</code> method creates a function that takes a value between 0 - 1 and interpolates a new color based on the input value.</p> <p>If more than one color is provided, the returned function will span the interpolations between all the provided colors with the same range of 0 - 1.</p> <p>Interpolation can be customized by limiting the interpolation to specific color channels, providing custom interpolation functions, and even adjusting the hue logic used.</p> <p><code>stop</code> objects can wrapped around colors to specify new color stops and easing functions can be placed between colors to alter the transition progress between the two colors.</p> Hue\u00a0Evaluation Description <code>shorter</code> Angles are adjusted so that \u03b8\u2082 - \u03b8\u2081 \u2208 [-180, 180]. <code>longer</code> Angles are adjusted so that \u03b8\u2082 - \u03b8\u2081 \u2208 {0, [180, 360)}. <code>increasing</code> Angles are adjusted so that \u03b8\u2082 - \u03b8\u2081 \u2208 [0, 360). <code>decreasing</code> Angles are adjusted so that \u03b8\u2082 - \u03b8\u2081 \u2208 (-360, 0] <code>specified</code> No fixup is performed. Angles are interpolated in the same way as every other component. <p>The method of interpolation to can also be selected via the <code>method</code> parameter.</p> Method Description <code>linear</code> An linear interpolation that employs piecewise logic to interpolate between two or more colors. <code>bspline</code> An interpolation method that employs cubic B-spline curves to calculate an interpolation path through multiple colors. <code>natural</code> A natural interpolation spline based on the cubic B-spline curve. <code>monotone</code> An interpolation method that utilizes a monotonic cubic spline based on the Hermite spline. <code>catrom</code> Interpolation based on the Catmull-Rom cubic spline. Parameters Parameters Defaults Description <code>color</code> A list of color strings, <code>Color</code> objects, dictionaries representing a color, <code>stop</code> objects, or easing functions. <code>space</code> <code>\"lab\"</code> Color space to interpolate in. <code>progress</code> <code>None</code> An optional function that that allows for custom logic to perform non-linear interpolation. <code>out_space</code> <code>None</code> Color space that the new color should be in. If <code>None</code>, the color will be in the same color space as the base color. <code>hue</code> <code>\"shorter\"</code> Define how color spaces which have hue angles are interpolated. Default evaluates between the shortest angle. <code>premultiplied</code> <code>True</code> Use premultiplied alpha when interpolating. <code>extrapolate</code> <code>False</code> Interpolations should extrapolate when values exceed the domain range ([0, 1] by default). <code>domain</code> <code>None</code> A list of numbers defining the domain range of the interpolation. <code>method</code> <code>\"linear\"</code> The interpolation method to use. Return Returns a function that takes a range from <code>[0..1]</code>. The function returns a reference to the interpolated <code>Color</code> object."},{"location":"api/#steps","title":"<code>Color.steps</code>","text":"<pre><code>def steps(\n    self,\n    color,\n    *,\n    steps=2,\n    max_steps=1000,\n    max_delta_e=0,\n    delta_e=None,\n    **interpolate_args\n):\n</code></pre> Description <p>Creates an <code>interpolate</code> function and iterates through it with user defined step parameters to produce discrete color steps. Will attempt to provide the minimum number of <code>steps</code> without exceeding <code>max_steps</code>. If <code>max_delta_e</code> is provided, the distance between each stop will be cut in half until there are no colors with a distance greater than the specified <code>max_delta_e</code>. The default \u2206E method is used by default, but it can be changed with the <code>delta_e</code> parameter.</p> <p>If more than one color is provided, the steps will be returned from the interpolations between all the provided colors.</p> <p>Like <code>interpolate</code>, the default interpolation space is <code>lab</code>.</p> Parameters Parameters Defaults Description <code>color</code> A list of color strings, <code>Color</code> objects, dictionaries representing a color, <code>stop</code> objects, or easing functions. <code>steps</code> <code>2</code> Minimum number of steps. <code>max_steps</code> <code>1000</code> Maximum number of steps. <code>max_delta_e</code> <code>0</code> Maximum delta E distance between the color stops. A value of <code>0</code> or less will be ignored. <code>delta_e</code> <code>None</code> A string indicating which \u2206E method to use. If nothing is supplied, the class object's current default \u2206E method will be used. <code>**interpolate_args</code> See\u00a0<code>interpolate</code> Keyword arguments defined in <code>interpolate</code>. Return List of <code>Color</code> objects."},{"location":"api/#mix","title":"<code>Color.mix</code>","text":"<pre><code>def mix(\n    self,\n    color,\n    percent=util.DEF_MIX,\n    *,\n    in_place=False,\n    **interpolate_args\n):\n</code></pre> Description Interpolates between two colors returning a color that represents the mixing of the base color and the provided <code>color</code> mixed at the provided <code>percent</code>, where <code>percent</code> applies to how much the provided <code>color</code> contributes to the the final result. Parameters Parameters Defaults Description <code>color</code> A color string or <code>Color</code> object representing a color. <code>percent</code> <code>0.5</code> A numerical value between 0 - 1 representing the percentage at which the parameter <code>color</code> will be mixed. <code>in_place</code> <code>False</code> Boolean used to determine if the the current color should be modified \"in place\" or a new <code>Color</code> object should be returned. <code>**interpolate_args</code> See\u00a0<code>interpolate</code> Keyword arguments defined in <code>interpolate</code>. Return Returns a reference to the new <code>Color</code> object or a reference to the current <code>Color</code> if <code>in_place</code> is <code>True</code>."},{"location":"api/#cvd","title":"<code>Color.filter</code>","text":"<pre><code>def filter(\n    self,\n    name,\n    amount=None,\n    *,\n    space='srgb-linear',\n    in_place=False,\n    **kwargs: Any\n):\n</code></pre> Description <p>Apply a color filter to alter a given color. Filters are based on the W3C Filter Effects and behave in the same manner. Colors are evaluated in the sRGB Linear color space unless otherwise specified via the <code>space</code> parameter. No other color space will be accepted except sRGB and sRGB Linear.</p> <p>An <code>amount</code> can be provided to adjust how much the color is filtered. Any clamping that occurs with the <code>amount</code> parameter, and related ways in which <code>amount</code> are applied, follow the W3C Filter Effects spec.</p> <p>Some filters, such as CVDs, may take additional arguments via <code>kwargs</code>.</p> Filters Name Default Brightness <code>brightness</code> <code>1</code> Saturation <code>saturate</code> <code>1</code> Contrast <code>contrast</code> <code>1</code> Opacity <code>opacity</code> <code>1</code> Invert <code>invert</code> <code>1</code> Hue\u00a0rotation <code>hue-rotate</code> <code>0</code> Sepia <code>sepia</code> <code>1</code> Grayscale <code>grayscale</code> <code>1</code> Protanopia\u00a0CVD <code>protan</code> <code>1</code> Deuteranopia\u00a0CVD <code>deutan</code> <code>1</code> Tritanopia\u00a0CVD <code>tritan</code> <code>1</code> Parameters Parameters Defaults Description <code>name</code> The name of the filter that should be applied. <code>amount</code> See\u00a0above A numerical value adjusting to what degree the filter is applied. Input range can vary depending on the filter being used. Default can also dependent on the filter being used. <code>space</code> <code>None</code> Controls the algorithm used for simulating the given CVD. <code>in_place</code> <code>False</code> Boolean used to determine if the the current color should be modified \"in place\" or a new <code>Color</code> object should be returned. <code>**kwargs</code> Additional filter specific parameters. <p>CVDs also take an optional <code>method</code> parameter that allows for specifying the CVD algorithm to use.</p> Simulation\u00a0Approach Name Brettel 1997 <code>brettel</code> Vi\u00e9not, Brettel, and Mollon 1999 <code>vienot</code> Machado 2009 <code>machado</code> Return Returns a reference to the new <code>Color</code> object or a reference to the current <code>Color</code> if <code>in_place</code> is <code>True</code>."},{"location":"api/#harmony","title":"<code>Color.harmony</code>","text":"<pre><code>def harmony(\n    self,\n    name,\n    *,\n    space\n):\n</code></pre> Description <p>The <code>harmony</code> method uses the current color and returns a set of harmonious colors (including the current color). The color harmonies are based on the classical color harmonies of color theory. By default, harmonious colors are performed under the perceptually uniform OkLCh color space, but other cylindrical color spaces can be used.</p> Harmony Name Monochromatic <code>mono</code> Complementary <code>complement</code> Split\u00a0Complement <code>split</code> Analogous <code>analogous</code> Triadic <code>triad</code> Tetradic\u00a0Square <code>square</code> Tetradic\u00a0Rectangle <code>rectangle</code> Parameters Parameters Defaults Description <code>name</code> Name of the color harmony to use. <code>space</code> <code>'oklch'</code> Color space under which the harmonies will be calculated. Must be a cylindrical space unless using <code>mono</code> which can take non cylindrical spaces. Return Returns a list of <code>Color</code> objects."},{"location":"api/#compose","title":"<code>Color.compose</code>","text":"<pre><code>def compose(\n    self,\n    backdrop,\n    *,\n    blend=None,\n    operator=None,\n    space=None,\n    out_space=None,\n    in_place=False\n):\n</code></pre> Description <p>Apply compositing which consists of a blend mode and a Porter Duff operator for alpha compositing. The current color is treated as the source (top layer) and the provided color as the backdrop (bottom layer). Colors will be composited in the <code>srgb</code> color space unless otherwise specified.</p> <p>Colors should generally be RGB-ish colors (sRGB, Display P3, A98 RGB, etc.). Some non-RGB-ish colors may work okay, with the defaults, but many the algorithm is really designed for RGB-ish colors. Non-RGB-ish colors are likely to provide nonsense results.</p> <p>Supported blend modes are:</p> Blend Modes <code>normal</code> <code>multiply</code> <code>darken</code> <code>lighten</code> <code>burn</code> <code>dodge</code> <code>screen</code> <code>overlay</code> <code>hard-light</code> <code>exclusion</code> <code>difference</code> <code>soft-light</code> <code>hue</code> <code>saturation</code> <code>luminosity</code> <code>color</code> <code>color</code> <code>hue</code> <code>saturation</code> <code>luminosity</code> <p>Supported Port Duff operators are:</p> Operators <code>clear</code> <code>copy</code> <code>destination</code> <code>source-over</code> <code>destination-over</code> <code>source-in</code> <code>destination-in</code> <code>source-out</code> <code>destination-out</code> <code>source-atop</code> <code>destination-atop</code> <code>xor</code> <code>lighter</code> Parameters Parameters Defaults Description <code>backdrop</code> A background color represented with either a string or <code>Color</code> object. <code>blend</code> <code>None</code> A blend mode to use to use when compositing. Values should be a string specifying the name of the blend mode to use. If <code>None</code>, <code>normal</code> will be used. If <code>False</code>, blending will be skipped. <code>operator</code> <code>None</code> A Porter Duff operator to use for alpha compositing. Values should be a string specifying the name of the operator to use. If <code>None</code>, <code>source-over</code> will be used. If <code>False</code>, alpha compositing will be skipped. <code>space</code> <code>None</code> A color space to perform the overlay in. If <code>None</code>, the base color's space will be used. <code>out_space</code> <code>None</code> A color space to output the resultant color to. <code>in_place</code> <code>False</code> Boolean used to determine if the the current color should be modified \"in place\" or a new <code>Color</code> object should be returned. Return Returns a reference to the new <code>Color</code> object or a reference to the current <code>Color</code> if <code>in_place</code> is <code>True</code>."},{"location":"api/#clip","title":"<code>Color.clip</code>","text":"<pre><code>def clip(\n    self,\n    space=None\n)\n</code></pre> Description Performs simple clipping on color channels that are out of gamut. Parameters Parameters Defaults Description <code>space</code> <code>None</code> The color space that the color must be mapped to. If space is <code>None</code>, then the current color space will be used. Return Returns a reference to the current <code>Color</code> after fitting its coordinates to the specified gamut."},{"location":"api/#fit","title":"<code>Color.fit</code>","text":"<pre><code>def fit(\n    self,\n    space=None,\n    *,\n    method=None,\n    **kwargs\n):\n</code></pre> Description <p>Fits color to the current or specified color gamut.</p> <p>By default, <code>oklch-chroma</code> gamut mapping is used. This is essentially an approach that holds lightness and hue constant in the OkLCh color space while reducing chroma until the color is in gamut. Clipping is done at each step of the way and the color distance measured to see how close our color is to the intended color.</p> <p>The supported gamut mapping methods are:</p> Name Input Clipping <code>clip</code> OkLCh Chroma <code>oklch-chroma</code> LCh Chroma <code>lch-chroma</code> Parameters <p>Some methods could have additional parameters to configure the behavior, these would be done through <code>**kwargs</code>. None of built-in gamut mapping methods currently have additional parameters.</p> Parameters Defaults Description <code>space</code> <code>None</code> The color space that the color must be mapped to. If space is <code>None</code>, then the current color space will be used. <code>method</code> <code>None</code> String that specifies which gamut mapping method to use. If <code>None</code>, <code>oklch-chroma</code> will be used. Return Returns a reference to the current <code>Color</code> after fitting its coordinates to the specified gamut."},{"location":"api/#in_gamut","title":"<code>Color.in_gamut</code>","text":"<pre><code>def in_gamut(\n    self,\n    space=None,\n    *,\n    tolerance=util.DEF_FIT_TOLERANCE\n):\n</code></pre> Description Checks if the current color is in the current or specified gamut. Parameters Parameters Defaults Description <code>space</code> <code>None</code> The color space that the color must be fit within. If space is <code>None</code>, then the current color space will be used. <code>tolerance</code> <code>0.000075</code> Tolerance allowed when checking bounds of color. Return Returns a boolean indicating whether the color is in the specified gamut."},{"location":"api/#get","title":"<code>Color.get</code>","text":"<pre><code>def get(\n    self,\n    name\n):\n</code></pre> Description Retrieves the coordinate value from the specified channel. Channel must be a channel name in the current color space or a channel name in the specified color space using the syntax: <code>space.channel</code>. Parameters Parameters Defaults Description <code>name</code> Channel name or color space and channel name to retrieve value from. Return Returns a numerical value that is stored internally for the specified channel, or a calculated value in the case that a channel in a different color space is requested."},{"location":"api/#set","title":"<code>Color.set</code>","text":"<pre><code>def set(\n    self,\n    name,\n    value\n):\n</code></pre> Description <p>Sets the given value to the specified channel. If the <code>name</code> is provided in the form <code>space.channel</code>, the value will be applied to the channel of the specified color space while keeping current color space the same.</p> <p>The <code>value</code> can be a numerical value, a CSS string compatible with the specified color space, or a function that accepts a numerical channel value and returns a numerical channel value.</p> <p>This function returns the current colors reference so that multiple sets can be chained together.</p> Parameters Parameters Defaults Description <code>name</code> A string containing a channel name or color space and channel separated by a <code>.</code> specifying the what channel to set. If <code>value</code> is omitted, <code>name</code> can also be a dictionary containing multiple channels, each specifying their own value to set. <code>value</code> A numerical value, a string value accepted by the specified color space, or a function. Return Returns a reference to the current <code>Color</code> object."},{"location":"api/#is_nan","title":"<code>Color.is_nan</code>","text":"<pre><code>def is_nan(\n    self,\n    name\n):\n</code></pre> Description Retrieves the coordinate value from the specified channel and checks whether the value is <code>NaN</code>. Channel must be a channel name in the current color space or a channel name in the specified color space using the syntax: <code>space.channel</code>. Parameters Parameters Defaults Description <code>name</code> A string indicating what channel property to check. Return Returns a boolean indicating whether the specified color space's channel is <code>NaN</code>."},{"location":"api/#white","title":"<code>Color.white</code>","text":"<pre><code>def white(\n    self\n):\n</code></pre> Description Retrieves the white point for the current color's color space. Return Returns a set of XYZ coordinates that align with the white point for the given color space."},{"location":"api/#colorchromatic_adaptation","title":"<code>Color.chromatic_adaptation</code>","text":"<pre><code>@classmethod\ndef chromatic_adaptation(\n    cls,\n    w1,\n    w2,\n    xyz,\n    *,\n    method=None\n):\n</code></pre> Description A class method that converts an XYZ set of coordinates between a two given white points. The first white point must match the white point of that the coordinates are currently using and the second white point must be the desired white point to use. <code>method</code> dictates the method of chromatic adaptation to use. Parameters Parameters Defaults Description <code>w1</code> Current white point of the XYZ coordinates. <code>w2</code> Desired white point of the XYZ coordinates. <code>xyz</code> The XYZ coordinates to adapt. <code>method</code> <code>None</code> The method of chromatic adaptation to use. If not specified, the current class's default method will be used. Return Returns a set of XYZ coordinates that have been chromatically adapted to the desired white point."},{"location":"api/#xy","title":"<code>Color.xy</code>","text":"<pre><code>def xy(\n    self\n):\n</code></pre> Description Retrieves the CIE 1931 (x, y) chromaticity coordinates for a given color. Return Returns a tuple of CIE 1931 (x, y) chromaticity points for the given color."},{"location":"api/#xy","title":"<code>Color.uv</code>","text":"<pre><code>def uv(\n    self,\n    mode='1976'\n):\n</code></pre> Description Retrieves the UCS 1960 (u, v) chromaticity coordinates for a given color or the CIE 1976 UCS (u', v') chromaticity coordinates, the latter being the default. Parameters Parameters Defaults Description <code>mode</code> <code>'1976'</code> A string indicating what mode to use. <code>1976</code> refers to the (u', v') points as described by CIE 1976 UCS and <code>1960</code> describes the (u, v) points as documented by CIE 1960 UCS. Return Returns a tuple of (u, v) \u2013 either 1976 (u', v') or 1960 (u, v) \u2013 chromaticity points for the given color."},{"location":"colors/","title":"Color Spaces","text":"<p>ColorAide aims to support all the color spaces and models currently offered in modern CSS, such as sRGB, Display P3, CIELab, Oklab, etc. We also include a number of color spaces that are not available in CSS.</p> <p>ColorAide registers a subset of the offered color spaces by default. But additional color spaces can be registered by subclassing the <code>Color</code> object and then registering any additional required plugins, such as color spaces.</p> <p>Everything but the Kitchen Sink</p> <p>It is not generally recommended to register all possible color spaces (and plugins in general). The suggested approach is to cherry pick additional color spaces as needed by simply subclassing <code>Color</code> and then registering the desired plugins, but if desired <code>coloraide.everything.ColorAll</code> already includes all plugins and can be imported to get access to every supported plugin.</p>"},{"location":"colors/#default-color-spaces","title":"Default Color Spaces","text":"<p>While ColorAide supports a lot of color spaces, it is rare that a user would ever need every color space implemented by ColorAide available at all times, so to keep the Color object lighter, and color matching logic quicker, the <code>coloraide.Color</code> object does not register all color spaces by default.</p> Default Color\u00a0Spaces XYZ\u00a0D65 XYZ\u00a0D50 Linear sRGB Linear Display\u00a0P3 Linear A98\u00a0RGB Linear Rec.\u00a02020 Linear ProPhoto\u00a0RGB sRGB Display\u00a0P3 A98\u00a0RGB Rec.\u00a02020 ProPhoto\u00a0RGB HSL HSV HWB Lab LCh Lab\u00a0D65 LCh\u00a0D65 Oklab OkLCh"},{"location":"colors/#color-space-map","title":"Color Space Map","text":"<p>When registering a plugin, it is important that all required plugins in the conversion path are registered as well. Below we've provided a diagram of all available color spaces and how they translate to one another.</p> <p>Click any of the color spaces to jump to the related documentation.</p> <pre><code>flowchart TB\n\n    acescc --- acescg ---- xyz-d65\n        acescct --- acescg\n\n    aces2065-1 --- xyz-d65\n\n    oklch --- oklab ----- xyz-d65\n        okhsl --- oklab\n        okhsv --- oklab\n\n    display-p3 --- display-p3-linear --- xyz-d65\n\n    a98-rgb --- a98-rgb-linear --- xyz-d65\n\n    hwb --- hsv --- hsl --- srgb --- srgb-linear ----- xyz-d65\n        orgb --- srgb\n        prismatic --- srgb\n        hsi --- srgb\n        cmy --- srgb\n        cmyk --- srgb\n\n    rec2020 --- rec2020-linear --- xyz-d65\n        rec2100pq --- rec2020-linear\n\n    prophoto-rgb --- prophoto-rgb-linear --- xyz-d50 ----- xyz-d65\n        lch --- lab --- xyz-d50\n\n    xyz-d65 --- lab-d65 --- lch-d65\n\n    xyz-d65 --- jzazbz --- jzczhz\n\n    xyz-d65 --- ipt\n\n    xyz-d65 --- ictcp\n\n    xyz-d65 --- igpgtg\n\n    xyz-d65 --- din99o --- lch99o\n\n    xyz-d65 --- hunter-lab\n\n    xyz-d65 --- rlab\n\n    xyz-d65 --- luv --- lchuv\n        luv --- hsluv\n        luv --- hpluv\n\n    xyz-d65 --- xyy\n\n    xyz-d65(XYZ D65)\n    xyz-d50(XYZ D50)\n    rec2020(Rec. 2020)\n    rec2020-linear(Linear Rec. 2020)\n    rec2100pq(Rec. 2100 PQ)\n    srgb-linear(Linear sRGB)\n    srgb(sRGB)\n    hsl(HSL)\n    hsv(HSV)\n    hwb(HWB)\n    display-p3-linear(Linear Display P3)\n    display-p3(Display P3)\n    a98-rgb-linear(Linear A98 RGB)\n    a98-rgb(A98 RGB)\n    prophoto-rgb-linear(Linear ProPhoto RGB)\n    prophoto-rgb(ProPhoto RGB)\n    lab(Lab)\n    lch(LCh)\n    lab-d65(Lab D65)\n    lch-d65(LCh D65)\n    oklab(Oklab)\n    oklch(OkLCh)\n    okhsl(Okhsl)\n    okhsv(Okhsv)\n    luv(Luv)\n    lchuv(LChuv)\n    hsluv(HSLuv)\n    hpluv(HPLuv)\n    din99o(DIN99o)\n    lch99o(DIN99o LCh)\n    jzazbz(Jzazbz)\n    jzczhz(JzCzhz)\n    ictcp(ICtCp)\n    orgb(oRGB)\n    ipt(IPT)\n    igpgtg(IgPgTg)\n    hunter-lab(Hunter Lab)\n    rlab(RLAB)\n    hsi(HSI)\n    cmy(CMY)\n    cmyk(CMYK)\n    xyy(xyY)\n    prismatic(Prismatic)\n    aces2065-1(ACES2065-1)\n    acescg(ACEScg)\n    acescc(ACEScc)\n    acescct(ACEScct)\n\n    click xyz-d65 \"./xyz_d65/\" _self\n    click xyz-d50 \"./xyz_d50/\" _self\n    click rec2020 \"./rec2020/\" _self\n    click rec2020-linear \"./rec2020_linear/\" _self\n    click rec2100pq \"./rec2100pq/\" _self\n    click srgb-linear \"./srgb_linear/\" _self\n    click srgb \"./srgb/\" _self\n    click hsl \"./hsl/\" _self\n    click hsv \"./hsv/\" _self\n    click hwb \"./hwb/\" _self\n    click display-p3-linear \"./display_p3_linear/\" _self\n    click display-p3 \"./display_p3/\" _self\n    click a98-rgb-linear \"./a98_rgb_linear/\" _self\n    click a98-rgb \"./a98_rgb/\" _self\n    click prophoto-rgb-linear \"./prophoto_rgb_linear/\" _self\n    click prophoto-rgb \"./prophoto_rgb/\" _self\n    click lab \"./lab/\" _self\n    click lch \"./lch/\" _self\n    click lab-d65 \"./lab_d65/\" _self\n    click lch-d65 \"./lch_d65/\" _self\n    click oklab \"./oklab/\" _self\n    click oklch \"./oklch/\" _self\n    click okhsl \"./okhsl/\" _self\n    click okhsv \"./okhsv/\" _self\n    click luv \"./luv/\" _self\n    click lchuv \"./lchuv/\" _self\n    click hsluv \"./hsluv/\" _self\n    click hpluv \"./hpluv/\" _self\n    click din99o \"./din99o/\" _self\n    click lch99o \"./lch99o/\" _self\n    click jzazbz \"./jzazbz/\" _self\n    click jzczhz \"./jzczhz/\" _self\n    click ictcp \"./ictcp/\" _self\n    click orgb \"./orgb/\" _self\n    click ipt \"./ipt/\" _self\n    click igpgtg \"./igpgtg/\" _self\n    click hunter-lab \"./hunter_lab/\" _self\n    click rlab \"./rlab/\" _self\n    click hsi \"./hsi/\" _self\n    click cmy \"./cmy/\" _self\n    click cmyk \"./cmyk/\" _self\n    click xyy \"./xyy/\" _self\n    click prismatic \"./prismatic/\" _self\n    click aces2065-1 \"./aces2065_1/\" _self\n    click acescg \"./acescg/\" _self\n    click acescc \"./acescc/\" _self\n    click acescct \"./acescct/\" _self</code></pre>"},{"location":"colors/a98_rgb/","title":"A98 RGB","text":"<p>The A98 RGB color space is registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>a98-rgb</code></p> <p>White Point: D65</p> <p>Coordinates:</p> Name Range* <code>r</code> [0, 1] <code>g</code> [0, 1] <code>b</code> [0, 1] <p>* Range denotes in gamut colors, but the color space supports an extended range beyond the gamut.</p> <p></p> <p>CIE 1931 xy Chromaticity \u2013 Adobe\u00ae RGB 1998 Chromaticities</p> <p>The Adobe\u00ae RGB (1998) color space or opRGB is a color space developed by Adobe Systems\u00ae, Inc. in 1998. It was designed to encompass most of the colors achievable on CMYK color printers, but by using RGB primary colors on a device such as a computer display. The Adobe\u00ae RGB (1998) color space encompasses roughly 50% of the visible colors specified by the CIELab color space - improving upon the gamut of the sRGB color space, primarily in cyan-green hues.</p> <p>A98 RGB is an Adobe\u00ae 98 Compatible color space.</p> <p>Learn about A98 RGB</p>"},{"location":"colors/a98_rgb/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>r</code> <code>red</code> <code>g</code> <code>green</code> <code>b</code> <code>blue</code>"},{"location":"colors/a98_rgb/#inputoutput","title":"Input/Output","text":"<p>Parsed input and string output formats support all valid CSS forms:</p> <pre><code>color(a98-rgb r g b / a)  // Color function\n</code></pre> <p>When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used:</p> <pre><code>Color(\"a98-rgb\", [0, 0, 0], 1)\n</code></pre> <p>The string representation of the color object and the default string output will be in the <code>color(a98-rgb r g b / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color('a98-rgb', [0.85859, 0, 0])\ncolor(a98-rgb 0.85859 0 0 / 1)\n&gt;&gt;&gt; Color('a98-rgb', [0.91489, 0.64117, 0.15031]).to_string()\ncolor(a98-rgb 0.91489 0.64117 0.15031)\n</code></pre> Color('a98-rgb', [0.85859, 0, 0]) Color('a98-rgb', [0.91489, 0.64117, 0.15031]).to_string() Edit Share Run Cancel"},{"location":"colors/a98_rgb/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.a98_rgb import A98RGB\n\nclass Color(Base): ...\n\nColor.register(A98RGB())\n</code></pre>"},{"location":"colors/a98_rgb_linear/","title":"Linear A98 RGB","text":"<p>The Linear A98 RGB color space is registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>a98-rgb-linear</code></p> <p>White Point: D65</p> <p>Coordinates:</p> Name Range* <code>r</code> [0, 1] <code>g</code> [0, 1] <code>b</code> [0, 1] <p>* Range denotes in gamut colors, but the color space supports an extended range beyond the gamut.</p> <p></p> <p>CIE 1931 xy Chromaticity \u2013 Adobe\u00ae RGB 1998 Chromaticities</p> <p>The Linear A98 RGB space is the same as A98 RGB except that the transfer function is linear-light (there is no gamma-encoding).</p> <p>Learn about A98 RGB</p>"},{"location":"colors/a98_rgb_linear/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>r</code> <code>red</code> <code>g</code> <code>green</code> <code>b</code> <code>blue</code>"},{"location":"colors/a98_rgb_linear/#inputoutput","title":"Input/Output","text":"<p>Linear A98 RGB is not supported via the CSS spec and the parser input and string output only supports the <code>color()</code> function format using the custom name <code>--a98-rgb-linear</code>:</p> <pre><code>color(--a98-rgb-linear r g b / a)  // Color function\n</code></pre> <p>When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used:</p> <pre><code>Color(\"a98-rgb-linear\", [0, 0, 0], 1)\n</code></pre> <p>The string representation of the color object and the default string output will be in the <code>color(--a98-rgb-linear r g b / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"a98-rgb\", [0.71513, 0, 0])\ncolor(a98-rgb 0.71513 0 0 / 1)\n&gt;&gt;&gt; Color(\"a98-rgb-linear\", [0.82231, 0.37626, 0.01549]).to_string()\ncolor(--a98-rgb-linear 0.82231 0.37626 0.01549)\n</code></pre> Color(\"a98-rgb\", [0.71513, 0, 0]) Color(\"a98-rgb-linear\", [0.82231, 0.37626, 0.01549]).to_string() Edit Share Run Cancel"},{"location":"colors/a98_rgb_linear/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.a98_rgb_linear import A98RGBLinear\n\nclass Color(Base): ...\n\nColor.register(A98RGBLinear())\n</code></pre>"},{"location":"colors/aces2065_1/","title":"ACES 2065-1","text":"<p>The ACES 2065-1 color space is not registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>aces2065-1</code></p> <p>White Point: D60</p> <p>Coordinates:</p> Name Range <code>r</code> [0, 65504] <code>g</code> [0, 65504] <code>b</code> [0, 65504] <p></p> <p>CIE 1931 xy Chromaticity \u2013 ACES AP0 Chromaticities</p> <p>ACES 2065-1 is a linear color space that uses a set of primaries known as AP0 and has the widest gamut of all the ACES color spaces and fully encompasses the entire visible spectrum. It is meant primarily as an archival format due to its ability to encapsulate all visible colors. Typically, this is the color space you would use to transfer images/animations between production studios.</p> <p>While it is considered an RGB color space, it also has enormous dynamic range with channels being able to well exceed the traditional range of 1.</p> <p>Learn about ACES 2065-1</p>"},{"location":"colors/aces2065_1/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>r</code> <code>red</code> <code>g</code> <code>green</code> <code>b</code> <code>blue</code>"},{"location":"colors/aces2065_1/#inputoutput","title":"Input/Output","text":"<p>ACES 2065-1 is not supported via the CSS spec and the parser input and string output only supports the <code>color()</code> function format using the custom name <code>--aces2065-1</code>:</p> <pre><code>color(--aces2065-1 r g b / a)  // Color function\n</code></pre> <p>When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used:</p> <pre><code>Color(\"aces2065-1\", [0, 0, 0], 1)\n</code></pre> <p>The string representation of the color object and the default string output will be in the <code>color(--aces2065-1 r g b / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"aces2065-1\", [0.43963, 0.08978, 0.01754])\ncolor(--aces2065-1 0.43963 0.08978 0.01754 / 1)\n&gt;&gt;&gt; Color(\"aces2065-1\", [0.58374, 0.39584, 0.05951]).to_string()\ncolor(--aces2065-1 0.58374 0.39584 0.05951)\n</code></pre> Color(\"aces2065-1\", [0.43963, 0.08978, 0.01754]) Color(\"aces2065-1\", [0.58374, 0.39584, 0.05951]).to_string() Edit Share Run Cancel"},{"location":"colors/aces2065_1/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.aces2065_1 import ACES20651\n\nclass Color(Base): ...\n\nColor.register(ACES20651())\n</code></pre>"},{"location":"colors/acescc/","title":"ACEScc","text":"<p>The ACEScc color space is not registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>acescc</code></p> <p>White Point: D60</p> <p>Coordinates:</p> Name Range* <code>r</code> [-0.0729,\u00a01.468] <code>g</code> [-0.0729,\u00a01.468] <code>b</code> [-0.0729,\u00a01.468] <p>* Ranges are approximate and have been rounded.</p> <p>ACEScc is a color space based on the API primaries and is primarily used for color grading. It is a logarithmic color space, unlike ACEScg, and maps black at 0 and white at 1.</p> <p>Learn about ACEScc</p>"},{"location":"colors/acescc/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>r</code> <code>red</code> <code>g</code> <code>green</code> <code>b</code> <code>blue</code>"},{"location":"colors/acescc/#inputoutput","title":"Input/Output","text":"<p>ACEScc is not supported via the CSS spec and the parser input and string output only supports the <code>color()</code> function format using the custom name <code>--acescc</code>:</p> <pre><code>color(--acescc r g b / a)  // Color function\n</code></pre> <p>When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used:</p> <pre><code>Color(\"acescc\", [1, 0, 0], 1)\n</code></pre> <p>The string representation of the color object and the default string output will be in the <code>color(--acescc r g b / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color('acescc', [0.51451, 0.33604, 0.23515])\ncolor(--acescc 0.51451 0.33604 0.23515 / 1)\n&gt;&gt;&gt; Color('acescc', [0.53009, 0.48237, 0.32561]).to_string()\ncolor(--acescc 0.53009 0.48237 0.32561)\n</code></pre> Color('acescc', [0.51451, 0.33604, 0.23515]) Color('acescc', [0.53009, 0.48237, 0.32561]).to_string() Edit Share Run Cancel"},{"location":"colors/acescc/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.acescc import ACEScc\n\nclass Color(Base): ...\n\nColor.register(ACEScc())\n</code></pre>"},{"location":"colors/acescct/","title":"ACEScct","text":"<p>The ACEScc color space is not registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>acescct</code></p> <p>White Point: D60</p> <p>Coordinates:</p> Name Range* <code>r</code> [-0.3584,\u00a01.468] <code>g</code> [-0.3584,\u00a01.468] <code>b</code> [-0.3584,\u00a01.468] <p>* Ranges are approximate and rounded to 3 decimal places.</p> <p>ACEScct is very similar to ACEScc except that it adds a \"toe\" or a gamma curve in the dark region of the color space. This encoding is more appropriate for legacy color correction operators.</p> <p>Learn about ACEScct</p>"},{"location":"colors/acescct/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>r</code> <code>red</code> <code>g</code> <code>green</code> <code>b</code> <code>blue</code>"},{"location":"colors/acescct/#inputsoutput","title":"Inputs/Output","text":"<p>ACEScct is not supported via the CSS spec and the parser input and string output only supports the <code>color()</code> function format using the custom name <code>--acescct</code>:</p> <pre><code>color(--acescct r g b / a)  // Color function\n</code></pre> <p>When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used:</p> <pre><code>Color(\"acescct\", [1, 0, 0], 1)\n</code></pre> <p>The string representation of the color object and the default string output will be in the <code>color(--acescct r g b / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"acescct\", [0.51451, 0.33604, 0.23515])\ncolor(--acescct 0.51451 0.33604 0.23515 / 1)\n&gt;&gt;&gt; Color(\"acescct\", [0.53009, 0.48237, 0.32561]).to_string()\ncolor(--acescct 0.53009 0.48237 0.32561)\n</code></pre> Color(\"acescct\", [0.51451, 0.33604, 0.23515]) Color(\"acescct\", [0.53009, 0.48237, 0.32561]).to_string() Edit Share Run Cancel"},{"location":"colors/acescct/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.acescct import ACEScct\n\nclass Color(Base): ...\n\nColor.register(ACEScct())\n</code></pre>"},{"location":"colors/acescg/","title":"ACEScg","text":"<p>The ACEScg color space is not registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>acescg</code></p> <p>White Point: D60</p> <p>Coordinates:</p> Name Range <code>r</code> [0, 65504] <code>g</code> [0, 65504] <code>b</code> [0, 65504] <p></p> <p>CIE 1931 xy Chromaticity \u2013 ACES AP1 Chromaticities</p> <p>ACEScg is a color space often used by CG artists. It is \"scene-referred\" or linear. It doesn't have as wide a color gamut as ACES 2065-1 as it uses a different set of primaries called AP1, but it is far larger than most other color spaces one might use and has an enormous dynamic range.</p> <p>Learn about ACEScg</p>"},{"location":"colors/acescg/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>r</code> <code>red</code> <code>g</code> <code>green</code> <code>b</code> <code>blue</code>"},{"location":"colors/acescg/#inputoutput","title":"Input/Output","text":"<p>ACEScg is not supported via the CSS spec and the parser input and string output only supports the <code>color()</code> function format using the custom name <code>--acescg</code>:</p> <pre><code>color(--acescg r g b / a)  // Color function\n</code></pre> <p>When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used:</p> <pre><code>Color(\"acescg\", [1, 0, 0], 1)\n</code></pre> <p>The string representation of the color object and the default string output will be in the <code>color(--acescg r g b / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"acescg\", [0.6131, 0.07019, 0.02062])\ncolor(--acescg 0.6131 0.07019 0.02062 / 1)\n&gt;&gt;&gt; Color(\"acescg\", [0.74085, 0.41498, 0.06184]).to_string()\ncolor(--acescg 0.74085 0.41498 0.06184)\n</code></pre> Color(\"acescg\", [0.6131, 0.07019, 0.02062]) Color(\"acescg\", [0.74085, 0.41498, 0.06184]).to_string() Edit Share Run Cancel"},{"location":"colors/acescg/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.acescg import ACEScg\n\nclass Color(Base): ...\n\nColor.register(ACEScg())\n</code></pre>"},{"location":"colors/cmy/","title":"CMY","text":"<p>The CMY color space is not registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>cmy</code></p> <p>White Point: D65</p> <p>Coordinates:</p> Name Range* <code>c</code> [0, 1] <code>m</code> [0, 1] <code>y</code> [0, 1] <p>* Range denotes in gamut colors, but the color space supports an extended range beyond the gamut.</p> <p></p> <p>The sRGB gamut represented within the CMY color space.</p> <p>The CMY color model is a subtractive color model in which cyan, magenta and yellow pigments or dyes are added together in various ways to reproduce a broad array of colors. The name of the model comes from the initials of the three subtractive primary colors: cyan, magenta, and yellow.</p> <p>The CMY color space, as ColorAide Extras has chosen to implement it, is directly calculated from the sRGB color space, and as such, is based off the sRGB primaries.</p> <p>Learn more.</p>"},{"location":"colors/cmy/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>c</code> <code>cyan</code> <code>m</code> <code>magenta</code> <code>y</code> <code>yellow</code>"},{"location":"colors/cmy/#inputoutput","title":"Input/Output","text":"<p>CMY is not currently supported in the CSS spec, the parsed input and string output formats use the <code>color()</code> function format using the custom name <code>--cmy</code>:</p> <pre><code>color(--cmy c m y / a)  // Color function\n</code></pre> <p>The string representation of the color object and the default string output use the <code>color(--cmy c m y / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"cmy\", [0, 1, 1])\ncolor(--cmy 0 1 1 / 1)\n&gt;&gt;&gt; Color(\"cmy\", [0, 0.35294, 1]).to_string()\ncolor(--cmy 0 0.35294 1)\n</code></pre> Color(\"cmy\", [0, 1, 1]) Color(\"cmy\", [0, 0.35294, 1]).to_string() Edit Share Run Cancel"},{"location":"colors/cmy/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.cmy import CMY\n\nclass Color(Base): ...\n\nColor.register(CMY())\n</code></pre>"},{"location":"colors/cmyk/","title":"CMYK","text":"<p>The CMYK color space is not registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>cmyk</code></p> <p>White Point: D65</p> <p>Coordinates:</p> Name Range* <code>c</code> [0, 1] <code>m</code> [0, 1] <code>y</code> [0, 1] <code>k</code> [0, 1] <p>* Range denotes in gamut colors, but the color space supports an extended range beyond the gamut.</p> <p>The CMYK color model is a just like CMY except that it adds an additional channel <code>k</code> to control blackness.</p> <p>The CMYK color space, as ColorAide Extras has chosen to implement it, is directly calculated from the sRGB color space, and as such, is based off the sRGB primaries.</p> <p>Learn more.</p>"},{"location":"colors/cmyk/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>c</code> <code>cyan</code> <code>m</code> <code>magenta</code> <code>y</code> <code>yellow</code> <code>k</code> <code>black</code>"},{"location":"colors/cmyk/#inputoutput","title":"Input/Output","text":"<p>CMY is not currently supported in the CSS spec, the parsed input and string output formats use the <code>color()</code> function format using the custom name <code>--cmyk</code>:</p> <pre><code>color(--cmyk c m y k / a)  // Color function\n</code></pre> <p>The string representation of the color object and the default string output use the <code>color(--cmyk c m y k / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"cmyk\", [0, 1, 1, 0])\ncolor(--cmyk 0 1 1 0 / 1)\n&gt;&gt;&gt; Color(\"cmyk\", [0, 0.35294, 1, 0]).to_string()\ncolor(--cmyk 0 0.35294 1 0)\n</code></pre> Color(\"cmyk\", [0, 1, 1, 0]) Color(\"cmyk\", [0, 0.35294, 1, 0]).to_string() Edit Share Run Cancel"},{"location":"colors/cmyk/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.cmyk import CMYK\n\nclass Color(Base): ...\n\nColor.register(CMYK())\n</code></pre>"},{"location":"colors/din99o/","title":"DIN99o","text":"<p>The DIN99o color space is not registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>din99o</code></p> <p>White Point: D65</p> <p>Coordinates:</p> Name Range* <code>l</code> [0, 100] <code>a</code> [-55, 55] <code>b</code> [-55, 55] <p>* Space is not bound to the range and is only used as a reference to define percentage inputs/outputs in relation to the Display P3 color space.</p> <p></p> <p>The sRGB gamut represented within the DIN99o color space.</p> <p>The DIN99 color space system is a further development of the CIELab color space system developed by the FNF / FNL 2 Colorimetry Working Committee. It takes the CIELab space (with a D65 illuminant) and compresses it such that the space yields better equidistant using Euclidean distance. The whole color space is essentially modified to better fit the color distancing algorithm opposed to CIELab which has adapted the color distancing algorithm to better fit the color space, the latest iteration being \u2206E*00.</p> <p>Learn about DIN99o</p>"},{"location":"colors/din99o/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>l</code> <code>lightness</code> <code>a</code> <code>b</code>"},{"location":"colors/din99o/#inputoutput","title":"Input/Output","text":"<p>As DIN99o is not currently supported in the CSS spec, the parsed input and string output formats use the <code>color()</code> function format using the custom name <code>--din99o</code>:</p> <pre><code>color(--din99o l u v / a)  // Color function\n</code></pre> <p>When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used:</p> <pre><code>Color(\"din99o\", [0, 0, 0], 1)\n</code></pre> <p>The string representation of the color object and the default string output use the <code>color(--din99o l u v / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"din99o\", [57.289, 39.498, 30.518])\ncolor(--din99o 57.289 39.498 30.518 / 1)\n&gt;&gt;&gt; Color(\"din99o\", [77.855, 16.444, 40.318]).to_string()\ncolor(--din99o 77.855 16.444 40.318)\n</code></pre> Color(\"din99o\", [57.289, 39.498, 30.518]) Color(\"din99o\", [77.855, 16.444, 40.318]).to_string() Edit Share Run Cancel"},{"location":"colors/din99o/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.din99o import DIN99o\n\nclass Color(Base): ...\n\nColor.register(DIN99o())\n</code></pre>"},{"location":"colors/display_p3/","title":"Display P3","text":"<p>The Display P3 color space is registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>display-p3</code></p> <p>White Point: D65</p> <p>Coordinates:</p> Name Range* <code>r</code> [0, 1] <code>g</code> [0, 1] <code>b</code> [0, 1] <p>* Range denotes in gamut colors, but the color space supports an extended range beyond the gamut.</p> <p></p> <p>CIE 1931 xy Chromaticity \u2013 Display P3 Chromaticities</p> <p>Display P3 is a combination of the DCI-P3 color gamut with the D65 white point together with the sRGB gamma curve. It originated from the DCI-P3 color gamut's implementation in digital cinema projectors, as this standard offers more vibrant greens and reds than the traditional sRGB color gamut.</p> <p>Learn about Display P3</p>"},{"location":"colors/display_p3/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>r</code> <code>red</code> <code>g</code> <code>green</code> <code>b</code> <code>blue</code>"},{"location":"colors/display_p3/#inputoutput","title":"Input/Output","text":"<p>Parsed input and string output formats support all valid CSS forms:</p> <pre><code>color(display-p3 r g b / a)  // Color function\n</code></pre> <p>When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used:</p> <pre><code>Color(\"display-p3\", [0, 0, 0], 1)\n</code></pre> <p>The string representation of the color object and the default string output will be in the <code>color(display-p3 r g b / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color('display-p3', [0.91749, 0.20029, 0.13856])\ncolor(display-p3 0.91749 0.20029 0.13856 / 1)\n&gt;&gt;&gt; Color('display-p3', [0.94965, 0.6629, 0.23297]).to_string()\ncolor(display-p3 0.94965 0.6629 0.23297)\n</code></pre> Color('display-p3', [0.91749, 0.20029, 0.13856]) Color('display-p3', [0.94965, 0.6629, 0.23297]).to_string() Edit Share Run Cancel"},{"location":"colors/display_p3/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.display_p3 import DisplayP3\n\nclass Color(Base): ...\n\nColor.register(DisplayP3())\n</code></pre>"},{"location":"colors/display_p3_linear/","title":"Linear Display P3","text":"<p>The Linear Display P3 color space is registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>--display-p3-linear</code></p> <p>White Point: D65</p> <p>Coordinates:</p> Name Range* <code>r</code> [0, 1] <code>g</code> [0, 1] <code>b</code> [0, 1] <p>* Range denotes in gamut colors, but the color space supports an extended range beyond the gamut.</p> <p></p> <p>CIE 1931 xy Chromaticity \u2013 Display P3 Chromaticities</p> <p>The Linear Display P3 space is the same as Display P3 except that the transfer function is linear-light (there is no gamma-encoding).</p> <p>Learn about Display P3</p>"},{"location":"colors/display_p3_linear/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>r</code> <code>red</code> <code>g</code> <code>green</code> <code>b</code> <code>blue</code>"},{"location":"colors/display_p3_linear/#inputoutput","title":"Input/Output","text":"<p>Linear Display P3 is not supported via the CSS spec and the parser input and string output only supports the <code>color()</code> function format using the custom name <code>--display-p3-linear</code>:</p> <pre><code>color(--display-p3-linear r g b / a)  // Color function\n</code></pre> <p>When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used:</p> <pre><code>Color(\"display-p3-linear\", [0, 0, 0], 1)\n</code></pre> <p>The string representation of the color object and the default string output will be in the <code>color(--display-p3-linear r g b / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"display-p3-linear\", [0.82246, 0.03319, 0.01708])\ncolor(--display-p3-linear 0.82246 0.03319 0.01708 / 1)\n&gt;&gt;&gt; Color(\"display-p3-linear\", [0.88926, 0.39697, 0.04432]).to_string()\ncolor(--display-p3-linear 0.88926 0.39697 0.04432)\n</code></pre> Color(\"display-p3-linear\", [0.82246, 0.03319, 0.01708]) Color(\"display-p3-linear\", [0.88926, 0.39697, 0.04432]).to_string() Edit Share Run Cancel"},{"location":"colors/display_p3_linear/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.display_p3_linear import DisplayP3\n\nclass Color(Base): ...\n\nColor.register(DisplayP3Linear())\n</code></pre>"},{"location":"colors/hpluv/","title":"HPLuv","text":"<p>The HPLuv color space is not registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>hpluv</code></p> <p>Color CSS ID: <code>--hpluv</code></p> <p>White Point: D65</p> <p>Coordinates:</p> Name Range <code>h</code> [0, 360) <code>p</code> [0, 100] <code>l</code> [0, 100] <p></p> <p>HSLuv color space in 3D</p> <p>HPLuv is similar to HSLuv but takes as many colors as it can from CIELChuv without distorting the chroma. This ends up reducing the gamut to a subset of the sRGB gamut. In the end, only more pastel colors remain.</p> <p>Learn about HSLuv</p>"},{"location":"colors/hpluv/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>h</code> <code>hue</code> <code>s</code> <code>perpendiculars</code> <code>l</code> <code>lightness</code>"},{"location":"colors/hpluv/#inputsoutput","title":"Inputs/Output","text":"<p>HPLuv is not currently supported in the CSS spec, the parsed input and string output formats use the <code>color()</code> function format using the custom name <code>--hpluv</code>:</p> <pre><code>color(--hpluv h p l / a)  // Color function\n</code></pre> <p>When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used:</p> <pre><code>Color(\"hpluv\", [0, 0, 0], 1)\n</code></pre> <p>The string representation of the color object and the default string output use the <code>color(--hpluv h p l / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"hpluv\", [23.881, 100, 53.237])\ncolor(--hpluv 23.881 100 53.237 / 1)\n&gt;&gt;&gt; Color(\"hpluv\", [49.45, 100, 74.934]).to_string()\ncolor(--hpluv 49.45 100 74.934)\n</code></pre> Color(\"hpluv\", [23.881, 100, 53.237]) Color(\"hpluv\", [49.45, 100, 74.934]).to_string() Edit Share Run Cancel"},{"location":"colors/hpluv/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.hpluv import HSPLuv\n\nclass Color(Base): ...\n\nColor.register(HPLuv())\n</code></pre>"},{"location":"colors/hsi/","title":"HSI","text":"<p>The HSI color space is not registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>hsi</code></p> <p>White Point: D65</p> <p>Coordinates:</p> Name Range <code>h</code> [0, 360) <code>s</code> [0, 1] <code>i</code> [0, 1] <p></p> <p>The sRGB gamut represented within the HSI color space.</p> <p>The HSI model is similar to models like HSL and HSV except that it uses I for intensity instead of Lightness or Value. It does not attempt to \"fill\" a cylinder by its definition of saturation leading to a very different look when we plot it.</p> <p></p> <p>Learn more.</p>"},{"location":"colors/hsi/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>h</code> <code>hue</code> <code>s</code> <code>saturation</code> <code>i</code> <code>intensity</code>"},{"location":"colors/hsi/#inputoutput","title":"Input/Output","text":"<p>The HSI space is not currently supported in the CSS spec, the parsed input and string output formats use the <code>color()</code> function format using the custom name <code>--hsi</code>:</p> <pre><code>color(--hsi h s i / a)  // Color function\n</code></pre> <p>The string representation of the color object and the default string output use the <code>color(--hsi h s i / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"hsi\", [0, 1, 0.33333])\ncolor(--hsi 0 1 0.33333 / 1)\n&gt;&gt;&gt; Color(\"hsi\", [38.824, 1, 0.54902]).to_string()\ncolor(--hsi 38.824 1 0.54902)\n</code></pre> Color(\"hsi\", [0, 1, 0.33333]) Color(\"hsi\", [38.824, 1, 0.54902]).to_string() Edit Share Run Cancel"},{"location":"colors/hsi/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.hsi import HSI\n\nclass Color(Base): ...\n\nColor.register(HSI())\n</code></pre>"},{"location":"colors/hsl/","title":"HSL","text":"<p>The HSL color space is registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>hsl</code></p> <p>White Point:   D65</p> <p>Coordinates:</p> Name Range <code>h</code> [0, 360) <code>s</code> [0, 1] <code>l</code> [0, 1] <p></p> <p>HSL color space in 3D</p> <p>HSL is an alternative representations of the RGB color model, designed in the 1970s by computer graphics researchers to more closely align with the way human vision perceives color-making attributes. In these models, colors of each hue are arranged in a radial slice, around a central axis of neutral colors which ranges from black at the bottom to white at the top.</p> <p>HSL models the way different paints mix together to create color in the real world, with the lightness dimension resembling the varying amounts of black or white paint in the mixture.</p> <p>Learn about HSL</p>"},{"location":"colors/hsl/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>h</code> <code>hue</code> <code>s</code> <code>saturation</code> <code>l</code> <code>lightness</code>"},{"location":"colors/hsl/#inputoutput","title":"Input/Output","text":"<p>Parsed input and string output formats support all valid CSS forms. In addition, we also allow the <code>color()</code> function format using the custom name <code>--hsl</code>:</p> <pre><code>hsl(h s l / a)          // HSL function\nhsl(h, s, l)            // Legacy HSL function\nhsla(h, s, l, a)        // Legacy HSLA function\ncolor(--hsl h s l / a)  // Color function\n</code></pre> <p>When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used:</p> <pre><code>Color(\"hsl\", [0, 0, 0], 1)\n</code></pre> <p>The string representation of the color object will always default to the <code>color(--hsl h s l / a)</code> form, but the default string output will be the <code>hsl(h s l / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"hsl\", [0, 1, 0.5])\ncolor(--hsl 0 1 0.5 / 1)\n&gt;&gt;&gt; Color(\"hsl\", [38.824, 1, 0.5], ).to_string()\nhsl(38.824 100% 50%)\n&gt;&gt;&gt; Color(\"hsl\", [60, 1, 0.5]).to_string(comma=True)\nhsl(60, 100%, 50%)\n&gt;&gt;&gt; Color(\"hsl\", [120, 1, 0.25098]).to_string(color=True)\ncolor(--hsl 120 1 0.25098)\n</code></pre> Color(\"hsl\", [0, 1, 0.5]) Color(\"hsl\", [38.824, 1, 0.5], ).to_string() Color(\"hsl\", [60, 1, 0.5]).to_string(comma=True) Color(\"hsl\", [120, 1, 0.25098]).to_string(color=True) Edit Share Run Cancel"},{"location":"colors/hsl/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.hsl import HSL\n\nclass Color(Base): ...\n\nColor.register(HSL())\n</code></pre>"},{"location":"colors/hsluv/","title":"HSLuv","text":"<p>The HSLuv color space is not registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>hsluv</code></p> <p>White Point: D65</p> <p>Coordinates:</p> Name Range <code>h</code> [0, 360) <code>s</code> [0, 100] <code>l</code> [0, 100] <p></p> <p>HSLuv color space in 3D</p> <p>HSLuv is a human-friendly alternative to HSL. It was formerly known as \"HUSL\" and is a variation of the CIELChuv color space, where the chroma component is replaced by a saturation component which allows you to span all the available chroma as a percentage. HSLuv is constrained to the sRGB gamut.</p> <p>Learn about HSLuv</p>"},{"location":"colors/hsluv/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>h</code> <code>hue</code> <code>s</code> <code>saturation</code> <code>l</code> <code>lightness</code>"},{"location":"colors/hsluv/#inputoutput","title":"Input/Output","text":"<p>HSLuv is not currently supported in the CSS spec, the parsed input and string output formats use the <code>color()</code> function format using the custom name <code>--hsluv</code>:</p> <pre><code>color(--hsluv h s l / a)  // Color function\n</code></pre> <p>When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used:</p> <pre><code>Color(\"hsluv\", [0, 0, 0], 1)\n</code></pre> <p>The string representation of the color object and the default string output use the <code>color(--hsluv h s l / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"hsluv\", [12.177, 100, 53.237])\ncolor(--hsluv 12.177 100 53.237 / 1)\n&gt;&gt;&gt; Color(\"hsluv\", [44.683, 100, 74.934]).to_string()\ncolor(--hsluv 44.683 100 74.934)\n</code></pre> Color(\"hsluv\", [12.177, 100, 53.237]) Color(\"hsluv\", [44.683, 100, 74.934]).to_string() Edit Share Run Cancel"},{"location":"colors/hsluv/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.hsluv import HSLuv\n\nclass Color(Base): ...\n\nColor.register(HSLuv())\n</code></pre>"},{"location":"colors/hsv/","title":"HSV","text":"<p>The HSV color space is registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>hsv</code></p> <p>White Point: D65</p> <p>Coordinates:</p> Name Range <code>h</code> [0, 360) <code>s</code> [0, 1] <code>v</code> [0, 1] <p></p> <p>HSV color space in 3D</p> <p>HSV is a color space similar to the modern RGB and CMYK models. The HSV color space has three components: hue, saturation and value. 'Value' is sometimes substituted with 'brightness' and then it is known as HSB. HSV models how colors appear under light.</p> <p>Learn about HSV</p>"},{"location":"colors/hsv/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>h</code> <code>hue</code> <code>s</code> <code>saturation</code> <code>v</code> <code>value</code>"},{"location":"colors/hsv/#inputoutput","title":"Input/Output","text":"<p>HSV is not supported via the CSS spec and the parser input and string output only supports the <code>color()</code> function format using the custom name <code>--hsv</code>:</p> <pre><code>color(--hsv 0 0% 0% / 1)\n</code></pre> <p>When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used:</p> <pre><code>Color(\"hsv\", [0, 0, 0], 1)\n</code></pre> <p>The string representation of the color object and default string output will always use the <code>color(hsv h s v / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"hsv\", [0, 1, 1])\ncolor(--hsv 0 1 1 / 1)\n&gt;&gt;&gt; Color(\"hsv\", [38.824, 1, 1]).to_string()\ncolor(--hsv 38.824 1 1)\n</code></pre> Color(\"hsv\", [0, 1, 1]) Color(\"hsv\", [38.824, 1, 1]).to_string() Edit Share Run Cancel"},{"location":"colors/hsv/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.hsv import HSV\n\nclass Color(Base): ...\n\nColor.register(HSV())\n</code></pre>"},{"location":"colors/hunter_lab/","title":"Hunter Lab","text":"<p>The Hunter Lab color space is not registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>hunter-lab</code></p> <p>White Point: D65</p> <p>Coordinates:</p> Name Range <code>l</code> [0, 100] <code>a</code> [-210, 210] <code>b</code> [-210, 210] <p>* Space is not bound to the range and is only used as a reference to define percentage inputs/outputs in relation to the Display P3 color space.</p> <p></p> <p>The sRGB gamut represented within the Hunter Lab color space.</p> <p>The Hunter Lab color space, defined in 1948 by Richard S. Hunter, is another color space referred to as \"Lab\". Like CIELab, it was also designed to be computed via simple formulas from the CIE XYZ space, but to be more perceptually uniform than CIE XYZ. Hunter named his coordinates L, a, and b. The CIE named the coordinates for CIELab as L, a, b* to distinguish them from Hunter's coordinates.</p> <p>Learn more.</p>"},{"location":"colors/hunter_lab/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>l</code> <code>lightness</code> <code>a</code> <code>b</code>"},{"location":"colors/hunter_lab/#inputoutput","title":"Input/Output","text":"<p>The Hunter Lab space is not currently supported in the CSS spec, the parsed input and string output formats use the <code>color()</code> function format using the custom name <code>--hunter-lab</code>:</p> <pre><code>color(--hunter-lab l a b / a)  // Color function\n</code></pre> <p>The string representation of the color object and the default string output use the <code>color(--hunter-lab l a b / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"hunter-lab\", [46.113, 82.672, 28.408])\ncolor(--hunter-lab 46.113 82.672 28.408 / 1)\n&gt;&gt;&gt; Color(\"hunter-lab\", [69.407, 23.266, 40.946]).to_string()\ncolor(--hunter-lab 69.407 23.266 40.946)\n</code></pre> Color(\"hunter-lab\", [46.113, 82.672, 28.408]) Color(\"hunter-lab\", [69.407, 23.266, 40.946]).to_string() Edit Share Run Cancel"},{"location":"colors/hunter_lab/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.hunter_lab import HunterLab\n\nclass Color(Base): ...\n\nColor.register(HunterLab())\n</code></pre>"},{"location":"colors/hwb/","title":"HWB","text":"<p>The HWB color space is registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>hwb</code></p> <p>White Point: D65</p> <p>Coordinates:</p> Name Range <code>h</code> [0, 360) <code>w</code> [0, 1] <code>b</code> [0, 1] <p></p> <p>HWB color space in 3D</p> <p>HWB is a cylindrical-coordinate representation of points in an RGB color model, similar to HSL and HSV. It was developed by HSV's creator Alvy Ray Smith in 1996 to address some of the issues with HSV. HWB was designed to be more intuitive for humans to use and slightly faster to compute. The first coordinate, H (Hue), is the same as the Hue coordinate in HSL and HSV. W and B stand for Whiteness and Blackness respectively and range from 0-100% (or 0-1). The mental model is that the user can pick a main hue and then \"mix\" it with white and/or black to produce the desired color.</p> <p>Learn about HWB</p>"},{"location":"colors/hwb/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>h</code> <code>hue</code> <code>w</code> <code>whiteness</code> <code>b</code> <code>blackness</code>"},{"location":"colors/hwb/#inputoutput","title":"Input/Output","text":"<p>Parsed input and string output formats support all valid CSS forms. In addition, we also allow the <code>color()</code> function format using the custom name <code>--hwb</code>:</p> <pre><code>hwb(h w b / a)          // HWB function\ncolor(--hwb h w b / a)  // Color function\n</code></pre> <p>When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used:</p> <pre><code>Color(\"hwb\", [0, 0, 100], 1)\n</code></pre> <p>The string representation of the color object will always default to the <code>color(--hwb h w b / a)</code> form, but the default string output will be the <code>hwb(h s l / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"hwb\", [0, 0, 0])\ncolor(--hwb 0 0 0 / 1)\n&gt;&gt;&gt; Color(\"hwb\", [38.824, 0, 0]).to_string()\nhwb(38.824 0% 0%)\n</code></pre> Color(\"hwb\", [0, 0, 0]) Color(\"hwb\", [38.824, 0, 0]).to_string() Edit Share Run Cancel"},{"location":"colors/hwb/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.hwb import HWB\n\nclass Color(Base): ...\n\nColor.register(HWB())\n</code></pre>"},{"location":"colors/ictcp/","title":"ICtCp","text":"<p>The ICtCp color space is not registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>ictcp</code></p> <p>White Point: D65</p> <p>Coordinates:</p> Name Range* <code>i</code> [0, 1] <code>ct</code> [-0.5, 0.5] <code>cp</code> [-0.5, 0.5] <p>* Space is not bound to the range but is specified to enclose the full range of an HDR BT.2020 gamut and is used to define percentage inputs/outputs.</p> <p></p> <p>The sRGB gamut represented within the ICtCp color space.</p> <p>ICtCp is a color space format with better perceptual uniformity than CIELab and is used as a part of the color image pipeline in video and digital photography systems for high dynamic range (HDR) and wide color gamut (WCG) imagery. It was developed by Dolby Laboratories from the IPT color space by Ebner and Fairchild. It was designed with the intention to replace YCbCr.</p> <p>Learn about ICtCp</p>"},{"location":"colors/ictcp/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>i</code> <code>intensity</code> <code>ct</code> <code>tritan</code> <code>cp</code> <code>protan</code>"},{"location":"colors/ictcp/#inputoutput","title":"Input/Output","text":"<p>As ICtCp is not currently supported in the CSS spec, the parsed input and string output formats use the <code>color()</code> function format using the custom name <code>--ictcp</code>:</p> <pre><code>color(--ictcp i ct cp / a)  // Color function\n</code></pre> <p>When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used:</p> <pre><code>Color(\"ictcp\", [0, 0, 0], 1)\n</code></pre> <p>The string representation of the color object and the default string output use the <code>color(--ictcp i ct cp / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"ictcp\", [0.42785, -0.11574, 0.2788])\ncolor(--ictcp 0.42785 -0.11574 0.2788 / 1)\n&gt;&gt;&gt; Color(\"ictcp\", [0.50497, -0.20797, 0.11077]).to_string()\ncolor(--ictcp 0.50497 -0.20797 0.11077)\n</code></pre> Color(\"ictcp\", [0.42785, -0.11574, 0.2788]) Color(\"ictcp\", [0.50497, -0.20797, 0.11077]).to_string() Edit Share Run Cancel"},{"location":"colors/ictcp/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.ictcp import ICtCp\n\nclass Color(Base): ...\n\nColor.register(ICtCp())\n</code></pre>"},{"location":"colors/igpgtg/","title":"IgPgTg","text":"<p>The IgPgTg color space is not registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>ipt</code></p> <p>White Point: D65</p> <p>Coordinates:</p> Name Range <code>ig</code> [0, 1] <code>pg</code> [-1, 1] <code>tg</code> [-1, 1] <p>* Space is not bound to the range and is only used as a reference to define percentage inputs/outputs.</p> <p></p> <p>The sRGB gamut represented within the IgPgTg color space.</p> <p>IgPgTg uses the same structure as IPT, an established hue-uniform color space utilized in gamut mapping applications. While IPT was fit to visual data on the perceived hue, IgPgTg was optimized based on evidence linking the peak wavelength of Gaussian-shaped light spectra to their perceived hues.</p> <p>Learn more.</p>"},{"location":"colors/igpgtg/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>ig</code> <code>intensity</code> <code>pg</code> <code>protan</code> <code>tg</code> <code>tritan</code>"},{"location":"colors/igpgtg/#inputoutput","title":"Input/Output","text":"<p>The IgPgTg space is not currently supported in the CSS spec, the parsed input and string output formats use the <code>color()</code> function format using the custom name <code>--igpgtg</code>:</p> <pre><code>color(--igpgtg ig pg tg / a)  // Color function\n</code></pre> <p>The string representation of the color object and the default string output use the <code>color(--igpgtg ig pg tg / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"igpgtg\", [0.54834, 0.15366, 0.43674])\ncolor(--igpgtg 0.54834 0.15366 0.43674 / 1)\n&gt;&gt;&gt; Color(\"igpgtg\", [0.73238, 0.0397, 0.32108]).to_string()\ncolor(--igpgtg 0.73238 0.0397 0.32108)\n</code></pre> Color(\"igpgtg\", [0.54834, 0.15366, 0.43674]) Color(\"igpgtg\", [0.73238, 0.0397, 0.32108]).to_string() Edit Share Run Cancel"},{"location":"colors/igpgtg/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.igpgtg import IgPgTg\n\nclass Color(Base): ...\n\nColor.register(IgPgTg())\n</code></pre>"},{"location":"colors/ipt/","title":"IPT","text":"<p>The IPT color space is not registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>ipt</code></p> <p>White Point: D65</p> <p>Coordinates:</p> Name Range* <code>i</code> [0, 1] <code>p</code> [-1, 1] <code>t</code> [-1, 1] <p>* Space is not bound to the range and is only used as a reference to define percentage inputs/outputs.</p> <p></p> <p>The sRGB gamut represented within the IPT color space.</p> <p>Ebner and Fairchild addressed the issue of non-constant lines of hue in their color space dubbed IPT. The IPT color space converts D65-adapted XYZ data (XD65, YD65, ZD65) to long-medium-short cone response data (LMS) using an adapted form of the Hunt-Pointer-Estevez matrix (MHPE(D65)).</p> <p>The IPT color appearance model excels at providing a formulation for hue where a constant hue value equals a constant perceived hue independent of the values of lightness and chroma (which is the general ideal for any color appearance model, but hard to achieve). It is therefore well-suited for gamut mapping implementations.</p> <p>Learn more.</p>"},{"location":"colors/ipt/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>i</code> <code>intensity</code> <code>p</code> <code>protan</code> <code>t</code> <code>tritan</code> <p>Inputs</p> <p>The IPT space is not currently supported in the CSS spec, the parsed input and string output formats use the <code>color()</code> function format using the custom name <code>--ipt</code>:</p> <pre><code>color(--ipt i p t / a)  // Color function\n</code></pre> <p>The string representation of the color object and the default string output use the <code>color(--ipt i p t / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"ipt\", [0.45616, 0.62086, 0.44282])\ncolor(--ipt 0.45616 0.62086 0.44282 / 1)\n&gt;&gt;&gt; Color(\"ipt\", [0.64877, 0.189, 0.5303]).to_string()\ncolor(--ipt 0.64877 0.189 0.5303)\n</code></pre> Color(\"ipt\", [0.45616, 0.62086, 0.44282]) Color(\"ipt\", [0.64877, 0.189, 0.5303]).to_string() Edit Share Run Cancel"},{"location":"colors/ipt/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.ipt import IPT\n\nclass Color(Base): ...\n\nColor.register(IPT())\n</code></pre>"},{"location":"colors/jzazbz/","title":"Jzazbz","text":"<p>The Jzazbz color space is not registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>jzazbz</code></p> <p>White Point: D65</p> <p>Coordinates:</p> Name Range* <code>jz</code> [0, 1] <code>az</code> [-0.5, 0.5] <code>bz</code> [-0.5, 0.5] <p>* Space is not bound to the range but is specified to enclose the full range of an HDR BT.2020 gamut and is used to define percentage inputs/outputs.</p> <p></p> <p>The sRGB gamut represented within the Jzazbz color space.</p> <p>Jzazbz is a a color space designed for perceptual uniformity in high dynamic range (HDR) and wide color gamut (WCG) applications. Conceptually it is similar to CIELab, but claims the following improvements:</p> <ul> <li>Perceptual color difference is predicted by Euclidean distance.</li> <li>Perceptually uniform: MacAdam ellipses of just-noticeable-difference (JND) are more circular, and closer to the same   sizes.</li> <li>Hue linearity: changing saturation or lightness has less shift in hue.</li> </ul> <p>Learn about Jzazbz</p>"},{"location":"colors/jzazbz/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>jz</code> <code>lightness</code> <code>az</code> <code>a</code> <code>bz</code> <code>b</code>"},{"location":"colors/jzazbz/#inputoutput","title":"Input/Output","text":"<p>As Jzazbz is not currently supported in the CSS spec, the parsed input and string output formats use the <code>color()</code> function format using the custom name <code>--jzazbz</code>:</p> <pre><code>color(--jzazbz jz az bz / a)  // Color function\n</code></pre> <p>When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used:</p> <pre><code>Color(\"jzazbz\", [0, 0, 0], 1)\n</code></pre> <p>The string representation of the color object and the default string output use the <code>color(--jzazbz jz az bz / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"jzazbz\", [0.13438, 0.11789, 0.11188])\ncolor(--jzazbz 0.13438 0.11789 0.11188 / 1)\n&gt;&gt;&gt; Color(\"jzazbz\", [0.16937, 0.0312, 0.12308]).to_string()\ncolor(--jzazbz 0.16937 0.0312 0.12308)\n</code></pre> Color(\"jzazbz\", [0.13438, 0.11789, 0.11188]) Color(\"jzazbz\", [0.16937, 0.0312, 0.12308]).to_string() Edit Share Run Cancel"},{"location":"colors/jzazbz/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.jzazbz import Jzazbz\n\nclass Color(Base): ...\n\nColor.register(Jzazbz())\n</code></pre>"},{"location":"colors/jzczhz/","title":"JzCzhz","text":"<p>The JzCzhz color space is not registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>jzczhz</code></p> <p>White Point: D65</p> <p>Coordinates:</p> Name Range <code>jz</code> [0, 1] <code>cz</code> [0, 0.5] <code>hz</code> [0, 360) <p>* Space is not bound to the range but is specified to enclose the full range of an HDR BT.2020 gamut and is used to define percentage inputs/outputs.</p> <p></p> <p>The sRGB gamut represented within the JzCzhz color space.</p> <p>JzCzhz is the cylindrical form of Jzazbz.</p> <p>Learn about JzCzhz</p>"},{"location":"colors/jzczhz/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>jz</code> <code>lightness</code> <code>cz</code> <code>chroma</code> <code>hz</code> <code>hue</code>"},{"location":"colors/jzczhz/#inputoutput","title":"Input/Output","text":"<p>As JzCzhz is not currently supported in the CSS spec, the parsed input and string output formats use the <code>color()</code> function format using the custom name <code>--jzczhz</code>:</p> <pre><code>color(--jzczhz jz cz hz / a)  // Color function\n</code></pre> <p>When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used:</p> <pre><code>Color(\"jzczhz\", [0, 0, 0], 1)\n</code></pre> <p>The string representation of the color object and the default string output use the <code>color(--jzczhz jz cz hz / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"jzczhz\", [0.13438, 0.16252, 43.502])\ncolor(--jzczhz 0.13438 0.16252 43.502 / 1)\n&gt;&gt;&gt; Color(\"jzczhz\", [0.16937, 0.12698, 75.776]).to_string()\ncolor(--jzczhz 0.16937 0.12698 75.776)\n</code></pre> Color(\"jzczhz\", [0.13438, 0.16252, 43.502]) Color(\"jzczhz\", [0.16937, 0.12698, 75.776]).to_string() Edit Share Run Cancel"},{"location":"colors/jzczhz/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.jzczhz import JzCzhz\n\nclass Color(Base): ...\n\nColor.register(JzCzhz())\n</code></pre>"},{"location":"colors/lab/","title":"LAB D50","text":"<p>The Lab D50 color space is registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>lab</code></p> <p>White Point: D50</p> <p>Coordinates:</p> Name Range* <code>l</code> [0, 100] <code>a</code> [-125, 125] <code>b</code> [-125, 125] <p>* Space is not bound to the range and is only used as a reference to define percentage inputs/outputs in relation to the Display P3 color space.</p> <p></p> <p>The sRGB gamut represented within the CIELab D50 color space.</p> <p>The CIELab color space also referred to as L*a*b* is a color space defined by the International Commission on Illumination (abbreviated CIE) in 1976. It expresses color as three values: L* for perceptual lightness, and a* and b* for the four unique colors of human vision: red, green, blue, and yellow. CIELab was intended as a perceptually uniform space, where a given numerical change corresponds to similar perceived change in color. While the CIELab space is not truly perceptually uniform, it nevertheless is useful in industry for detecting small differences in color.</p> <p>Learn about CIELab</p>"},{"location":"colors/lab/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>l</code> <code>lightness</code> <code>a</code> <code>b</code>"},{"location":"colors/lab/#inputoutput","title":"Input/Output","text":"<p>Parsed input and string output formats support all valid CSS forms. In addition, we also allow the <code>color()</code> function format using the custom name <code>--lab</code>:</p> <pre><code>lab(l a b / a)          // Lab function\ncolor(--lab l a b / a)  // Color function\n</code></pre> <p>When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used:</p> <pre><code>Color(\"lab\", [0, 0, 0], 1)\n</code></pre> <p>The string representation of the color object will always default to the <code>color(--lab l a b / a)</code> form, but the default string output will be the <code>lab(l a b / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"lab\", [54.291, 80.805, 69.891])\ncolor(--lab 54.291 80.805 69.891 / 1)\n&gt;&gt;&gt; Color(\"lab\", [75.59, 27.516, 79.121]).to_string()\nlab(75.59 27.516 79.121)\n&gt;&gt;&gt; Color(\"lab\", [97.607, -15.75, 93.394]).to_string(percent=True)\nlab(97.607% -12.6% 74.715%)\n&gt;&gt;&gt; Color(\"lab\", [46.278, -47.552, 48.586]).to_string(color=True)\ncolor(--lab 46.278 -47.552 48.586)\n</code></pre> Color(\"lab\", [54.291, 80.805, 69.891]) Color(\"lab\", [75.59, 27.516, 79.121]).to_string() Color(\"lab\", [97.607, -15.75, 93.394]).to_string(percent=True) Color(\"lab\", [46.278, -47.552, 48.586]).to_string(color=True) Edit Share Run Cancel"},{"location":"colors/lab/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.lab import Lab\n\nclass Color(Base): ...\n\nColor.register(Lab())\n</code></pre>"},{"location":"colors/lab_d65/","title":"Lab D65","text":"<p>The Lab D65 color space is registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>lab-d65</code></p> <p>White Point: D65</p> <p>Coordinates:</p> Name Range* <code>l</code> [0, 100] <code>a</code> [-130, 130] <code>b</code> [-130, 130] <p>* Space is not bound to the range and is only used as a reference to define percentage inputs/outputs in relation to the Display P3 color space.</p> <p></p> <p>The sRGB gamut represented within the CIELab D50 color space.</p> <p>CIELab D65 is the same as CIELab except it uses a D65 white point.</p> <p>Learn about CIELab</p>"},{"location":"colors/lab_d65/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>l</code> <code>lightness</code> <code>a</code> <code>b</code>"},{"location":"colors/lab_d65/#inputoutput","title":"Input/Output","text":"<p>As a D65 variant of CIELab is not currently supported in the CSS spec, the parsed input and string output formats use the <code>color()</code> function format using the custom name <code>--lab-d65</code>:</p> <pre><code>color(--lab-d65 l a b / a)  // Color function\n</code></pre> <p>When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used:</p> <pre><code>Color(\"lab-d65\", [0, 0, 0], 1)\n</code></pre> <p>The string representation of the color object and the default string output use the <code>color(--lab-d65 l a b / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"lab-d65\", [53.237, 80.09, 67.203])\ncolor(--lab-d65 53.237 80.09 67.203 / 1)\n&gt;&gt;&gt; Color(\"lab-d65\", [74.934, 23.927, 78.953]).to_string()\ncolor(--lab-d65 74.934 23.927 78.953)\n</code></pre> Color(\"lab-d65\", [53.237, 80.09, 67.203]) Color(\"lab-d65\", [74.934, 23.927, 78.953]).to_string() Edit Share Run Cancel"},{"location":"colors/lab_d65/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.lab_d65 import LabD65\n\nclass Color(Base): ...\n\nColor.register(LabD65())\n</code></pre>"},{"location":"colors/lch/","title":"LCh D50","text":"<p>The LCh D50 color space is registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>lch</code></p> <p>White Point: D50</p> <p>Coordinates:</p> Name Range* <code>l</code> [0, 100] <code>c</code> [0, 150] <code>h</code> [0, 360) <p>* Space is not bound to the range and is only used as a reference to define percentage inputs/outputs in relation to the Display P3 color space.</p> <p></p> <p>The sRGB gamut represented within the CIELCh D50 color space.</p> <p>The \"CIELCh\" space is a color space based on CIELab, which uses the polar coordinates C* (chroma, relative saturation) and h\u00b0 (hue angle, angle of the hue in the CIELab color wheel) instead of the Cartesian coordinates a* and b*. The CIELab lightness L* remains unchanged.</p> <p>Learn about CIELCh</p>"},{"location":"colors/lch/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>l</code> <code>lightness</code> <code>c</code> <code>chroma</code> <code>h</code> <code>hue</code>"},{"location":"colors/lch/#inputoutput","title":"Input/Output","text":"<p>Parsed input and string output formats support all valid CSS forms. In addition, we also allow the <code>color()</code> function format using the custom name <code>--lch</code>:</p> <pre><code>lch(l c h / a)          // LCh function\ncolor(--lch l c h / a)  // Color function\n</code></pre> <p>When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used:</p> <pre><code>Color(\"lch\", [0, 0, 0], 1)\n</code></pre> <p>The string representation of the color object will always default to the <code>color(--lch l c h / a)</code> form, but the default string output will be the <code>lch(l c h / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"lch\", [54.291, 106.84, 40.858])\ncolor(--lch 54.291 106.84 40.858 / 1)\n&gt;&gt;&gt; Color(\"lch\", [75.59, 83.769, 70.824]).to_string()\nlch(75.59 83.769 70.824)\n&gt;&gt;&gt; Color(\"lch\", [97.607, 94.712, 99.572]).to_string(percent=True)\nlch(97.607% 63.141% 99.572)\n&gt;&gt;&gt; Color(\"lch\", [46.278, 67.984, 134.38]).to_string(color=True)\ncolor(--lch 46.278 67.984 134.38)\n</code></pre> Color(\"lch\", [54.291, 106.84, 40.858]) Color(\"lch\", [75.59, 83.769, 70.824]).to_string() Color(\"lch\", [97.607, 94.712, 99.572]).to_string(percent=True) Color(\"lch\", [46.278, 67.984, 134.38]).to_string(color=True) Edit Share Run Cancel"},{"location":"colors/lch/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.lch import LCh\n\nclass Color(Base): ...\n\nColor.register(LCh())\n</code></pre>"},{"location":"colors/lch99o/","title":"DIN99o LCh","text":"<p>The DIN99o LCh color space is not registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>lch99o</code></p> <p>White Point: D65</p> <p>Coordinates:</p> Name Range* <code>l</code> [0, 100] <code>c</code> [0, 60] <code>h</code> [0, 360) <p>* Space is not bound to the range and is only used as a reference to define percentage inputs/outputs in relation to the Display P3 color space.</p> <p></p> <p>The sRGB gamut represented within the DIN99o LCh color space.</p> <p>DIN99o LCh is the cylindrical form of DIN99o.</p> <p>Learn about DIN99o LCh</p>"},{"location":"colors/lch99o/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>l</code> <code>lightness</code> <code>c</code> <code>chroma</code> <code>h</code> <code>hue</code>"},{"location":"colors/lch99o/#inputoutput","title":"Input/Output","text":"<p>As DIN99o LCh is not currently supported in the CSS spec, the parsed input and string output formats use the <code>color()</code> function format using the custom name <code>--lch99o</code>:</p> <pre><code>color(--lch99o jz cz hz / a)  // Color function\n</code></pre> <p>When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used:</p> <pre><code>Color(\"lch99o\", [0, 0, 0], 1)\n</code></pre> <p>The string representation of the color object and the default string output use the <code>color(--lch99o jz cz hz / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"lch99o\", [57.289, 49.915, 37.692])\ncolor(--lch99o 57.289 49.915 37.692 / 1)\n&gt;&gt;&gt; Color(\"lch99o\", [77.855, 43.543, 67.811]).to_string()\ncolor(--lch99o 77.855 43.543 67.811)\n</code></pre> Color(\"lch99o\", [57.289, 49.915, 37.692]) Color(\"lch99o\", [77.855, 43.543, 67.811]).to_string() Edit Share Run Cancel"},{"location":"colors/lch99o/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.lch99o import LCh99o\n\nclass Color(Base): ...\n\nColor.register(LCh99o())\n</code></pre>"},{"location":"colors/lch_d65/","title":"LCh D65","text":"<p>The LCh D65 color space is registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>lch-d65</code></p> <p>White Point: D65</p> <p>Coordinates:</p> Name Range* <code>l</code> [0, 100] <code>c</code> [0, 160] <code>h</code> [0, 360) <p>* Space is not bound to the range and is only used as a reference to define percentage inputs/outputs in relation to the Display P3 color space.</p> <p></p> <p>The sRGB gamut represented within the CIELCh D65 color space.</p> <p>CIELCh D65 is the same as CIELCh except it uses a D65 white point.</p> <p>Learn about CIELCh</p>"},{"location":"colors/lch_d65/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>l</code> <code>lightness</code> <code>c</code> <code>chroma</code> <code>h</code> <code>hue</code>"},{"location":"colors/lch_d65/#inputoutput","title":"Input/Output","text":"<p>As a D65 variant of CIELCh is not currently supported in the CSS spec, the parsed input and string output formats use the <code>color()</code> function format using the custom name <code>--lch-d65</code>:</p> <pre><code>color(--lch-d65 l c h / a)  // Color function\n</code></pre> <p>When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used:</p> <pre><code>Color(\"lch-d65\", [0, 0, 0], 1)\n</code></pre> <p>The string representation of the color object and the default string output use the <code>color(--lch-d65 l c h / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"lch-d65\", [53.237, 104.55, 40])\ncolor(--lch-d65 53.237 104.55 40 / 1)\n&gt;&gt;&gt; Color(\"lch-d65\", [74.934, 82.499, 73.14]).to_string()\ncolor(--lch-d65 74.934 82.499 73.14)\n</code></pre> Color(\"lch-d65\", [53.237, 104.55, 40]) Color(\"lch-d65\", [74.934, 82.499, 73.14]).to_string() Edit Share Run Cancel"},{"location":"colors/lch_d65/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.lch_d65 import LChD65\n\nclass Color(Base): ...\n\nColor.register(LChD65())\n</code></pre>"},{"location":"colors/lchuv/","title":"LChuv","text":"<p>The LCHuv color space is not registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>lchuv</code></p> <p>White Point: D65</p> <p>Coordinates:</p> Name Range* <code>l</code> [0, 100] <code>c</code> [0, 220] <code>h</code> [0, 360) <p>* Space is not bound to the range and is only used as a reference to define percentage inputs/outputs in relation to the Display P3 color space.</p> <p></p> <p>The sRGB gamut represented within the CIELChuv color space.</p> <p>CIELuv is not an intuitive space to work with directly and instead is often converted to cylindrical coordinates with hues represented as degrees and a chroma and lightness channel. The shape of the color space doesn't really change, just how the colors are manipulated.</p> <p>Learn about CIELChuv</p>"},{"location":"colors/lchuv/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>l</code> <code>lightness</code> <code>c</code> <code>chroma</code> <code>h</code> <code>hue</code>"},{"location":"colors/lchuv/#inputoutput","title":"Input/Output","text":"<p>As CIELChuv is not currently supported in the CSS spec, the parsed input and string output formats use the <code>color()</code> function format using the custom name <code>--lchuv</code>:</p> <pre><code>color(--lchuv l c h / a)  // Color function\n</code></pre> <p>When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used:</p> <pre><code>Color(\"lchuv\", [0, 0, 0], 1)\n</code></pre> <p>The string representation of the color object and the default string output use the <code>color(--lchuv l c h / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"lchuv\", [53.237, 179.04, 12.177])\ncolor(--lchuv 53.237 179.04 12.177 / 1)\n&gt;&gt;&gt; Color(\"lchuv\", [74.934, 105.26, 44.683]).to_string()\ncolor(--lchuv 74.934 105.26 44.683)\n</code></pre> Color(\"lchuv\", [53.237, 179.04, 12.177]) Color(\"lchuv\", [74.934, 105.26, 44.683]).to_string() Edit Share Run Cancel"},{"location":"colors/lchuv/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.lchuv import LChuv\n\nclass Color(Base): ...\n\nColor.register(LChuv())\n</code></pre>"},{"location":"colors/luv/","title":"Luv","text":"<p>The Luv color space is not registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>luv</code></p> <p>White Point: D65</p> <p>Coordinates:</p> Name Range* <code>l</code> [0, 100] <code>u</code> [-215, 215] <code>v</code> [-215, 215] <p>* Space is not bound to the range and is only used as a reference to define percentage inputs/outputs in relation to the Display P3 color space.</p> <p></p> <p>The sRGB gamut represented within the CIELuv D65 color space.</p> <p>CIELuv is similar to CIELab as they were both developed in 1976 as perceptually uniform color spaces, both are derived from the color experiments in 1931 that brought us the XYZ color space, and neither are truly perceptually uniform.</p> <p>The difference between the two comes from their intent. CIELab attempted to create a space that aligned well with human vision. CIELuv, on the other hand, was designed to be an easier-to-compute transformation of the 1931 CIE XYZ color space.</p> <p>CIELab is more commonly used in subtractive color applications (printed pages, dyes, etc.), while CIELuv is better suited in additive color applications such as display colorimetry (monitors, TVs, etc.).</p> <p>Learn about CIELuv</p>"},{"location":"colors/luv/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>l</code> <code>lightness</code> <code>u</code> <code>v</code>"},{"location":"colors/luv/#inputoutput","title":"Input/Output","text":"<p>As CIELuv D65 is not currently supported in the CSS spec, the parsed input and string output formats use the <code>color()</code> function format using the custom name <code>--luv</code>:</p> <pre><code>color(--luv l u v / a)  // Color function\n</code></pre> <p>When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used:</p> <pre><code>Color(\"luv\", [0, 0, 0], 1)\n</code></pre> <p>The string representation of the color object and the default string output use the <code>color(--luv l u v / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"luv\", [53.237, 175.01, 37.765])\ncolor(--luv 53.237 175.01 37.765 / 1)\n&gt;&gt;&gt; Color(\"luv\", [74.934, 74.839, 74.014]).to_string()\ncolor(--luv 74.934 74.839 74.014)\n</code></pre> Color(\"luv\", [53.237, 175.01, 37.765]) Color(\"luv\", [74.934, 74.839, 74.014]).to_string() Edit Share Run Cancel"},{"location":"colors/luv/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.luv import Luv\n\nclass Color(Base): ...\n\nColor.register(Luv())\n</code></pre>"},{"location":"colors/okhsl/","title":"Okhsl","text":"<p>The Okhsl color space is not registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>okhsl</code></p> <p>White Point: D65</p> <p>Coordinates:</p> Name Range <code>h</code> [0, 360) <code>s</code> [0, 1] <code>l</code> [0, 1] <p></p> <p>Okhsl color space in 3D</p> <p>Okhsl is a another color space created by Bj\u00f6rn Ottosson. It is based off his early work and leverages the Oklab color space. The aim was to create a color space that was better suited for being used in color pickers than the current HSL.</p> <p>Learn about Okhsv</p>"},{"location":"colors/okhsl/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>h</code> <code>hue</code> <code>s</code> <code>saturation</code> <code>l</code> <code>lightness</code>"},{"location":"colors/okhsl/#inputoutput","title":"Input/Output","text":"<p>Okhsl is not currently supported in the CSS spec, the parsed input and string output formats use the <code>color()</code> function format using the custom name <code>--okhsl</code>:</p> <pre><code>color(--okhsl h s l / a)  // Color function\n</code></pre> <p>When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used:</p> <pre><code>Color(\"okhsl\", [0, 0, 0], 1)\n</code></pre> <p>The string representation of the color object and the default string output use the <code>color(--okhsl h s l / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"okhsl\", [0, 0, 0], 1)\ncolor(--okhsl 0 0 0 / 1)\n&gt;&gt;&gt; Color(\"okhsl\", [0, 0, 0], 1).to_string()\ncolor(--okhsl 0 0 0)\n</code></pre> Color(\"okhsl\", [0, 0, 0], 1) Color(\"okhsl\", [0, 0, 0], 1).to_string() Edit Share Run Cancel"},{"location":"colors/okhsl/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.okhsl import Okhsl\n\nclass Color(Base): ...\n\nColor.register(Okhsl())\n</code></pre>"},{"location":"colors/okhsv/","title":"Okhsv","text":"<p>The Okhsv color space is not registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>okhsv</code></p> <p>White Point: D65</p> <p>Coordinates:</p> Name Range <code>h</code> [0, 360) <code>s</code> [0, 1] <code>v</code> [0, 1] <p></p> <p>Okhsv color space in 3D</p> <p>Okhsv is a color space created by Bj\u00f6rn Ottosson. It is based off his early work and leverages the Oklab color space. The aim was to create a color space that was better suited for being used in color pickers than the current HSV.</p> <p>Learn about Okhsv</p> ColorAide Details"},{"location":"colors/okhsv/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>h</code> <code>hue</code> <code>s</code> <code>saturation</code> <code>v</code> <code>value</code>"},{"location":"colors/okhsv/#inputoutput","title":"Input/Output","text":"<p>Okhsv is not currently supported in the CSS spec, the parsed input and string output formats use the <code>color()</code> function format using the custom name <code>--okhsv</code>:</p> <pre><code>color(--okhsv h s l / a)  // Color function\n</code></pre> <p>When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used:</p> <pre><code>Color(\"okhsv\", [0, 0, 0], 1)\n</code></pre> <p>The string representation of the color object and the default string output use the <code>color(--okhsv h s l / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"okhsv\", [29.234, 1, 1])\ncolor(--okhsv 29.234 1 1 / 1)\n&gt;&gt;&gt; Color(\"okhsv\", [70.67, 1, 1]).to_string()\ncolor(--okhsv 70.67 1 1)\n</code></pre> Color(\"okhsv\", [29.234, 1, 1]) Color(\"okhsv\", [70.67, 1, 1]).to_string() Edit Share Run Cancel"},{"location":"colors/okhsv/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.okhsv import Okhsv\n\nclass Color(Base): ...\n\nColor.register(Okhsv())\n</code></pre>"},{"location":"colors/oklab/","title":"Oklab","text":"<p>The Oklab color space is registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>oklab</code></p> <p>White Point: D65</p> <p>Coordinates:</p> Name Range* <code>l</code> [0, 1] <code>a</code> [-0.4, 0.4] <code>b</code> [-0.4, 0.4] <p>* Space is not bound to the range and is only used as a reference to define percentage inputs/outputs in relation to the Display P3 color space.</p> <p></p> <p>The sRGB gamut represented within the Oklab color space.</p> <p>A new perceptual color space that claims to be simple to use, while doing a good job at predicting perceived lightness, chroma and hue. It is called the Oklab color space, because it is an OK Lab color space.</p> <p>Learn about Oklab</p>"},{"location":"colors/oklab/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>l</code> <code>lightness</code> <code>a</code> <code>b</code>"},{"location":"colors/oklab/#inputoutput","title":"Input/Output","text":"<p>Oklab is not currently supported in the CSS spec, the parsed input and string output formats use the <code>color()</code> function format using the custom name <code>--oklab</code>:</p> <pre><code>oklab(l a b / a)          // Oklab function\ncolor(--oklab l a b / a)  // Color function\n</code></pre> <p>When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used:</p> <pre><code>Color(\"oklab\", [0, 0, 0], 1)\n</code></pre> <p>The string representation of the color object will always default to the <code>color(--oklab l a b / a)</code> form, but the default string output will be the <code>oklab(l a b / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"oklab\", [0.62796, 0.22486, 0.12585])\ncolor(--oklab 0.62796 0.22486 0.12585 / 1)\n&gt;&gt;&gt; Color(\"oklab\", [0.79269, 0.05661, 0.16138]).to_string()\noklab(0.79269 0.05661 0.16138)\n&gt;&gt;&gt; Color(\"oklab\", [0.96798, -0.07137, 0.19857]).to_string(percent=True)\noklab(96.798% -17.842% 49.643%)\n&gt;&gt;&gt; Color(\"oklab\", [0.51975, -0.1403, 0.10768]).to_string(color=True)\ncolor(--oklab 0.51975 -0.1403 0.10768)\n</code></pre> Color(\"oklab\", [0.62796, 0.22486, 0.12585]) Color(\"oklab\", [0.79269, 0.05661, 0.16138]).to_string() Color(\"oklab\", [0.96798, -0.07137, 0.19857]).to_string(percent=True) Color(\"oklab\", [0.51975, -0.1403, 0.10768]).to_string(color=True) Edit Share Run Cancel"},{"location":"colors/oklab/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.oklab import Oklab\n\nclass Color(Base): ...\n\nColor.register(Oklab())\n</code></pre>"},{"location":"colors/oklch/","title":"OkLCh","text":"<p>The OkLCh color space is registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>oklch</code></p> <p>White Point: D65</p> <p>Coordinates:</p> Name Range* <code>l</code> [0, 1] <code>c</code> [0, 0.4] <code>h</code> [0, 360) <p>* Space is not bound to the range and is only used as a reference to define percentage inputs/outputs in relation to the Display P3 color space.</p> <p></p> <p>The sRGB gamut represented within the OkLCh color space.</p> <p>OkLCh is the cylindrical form of Oklab.</p> <p>Learn about OkLCh</p>"},{"location":"colors/oklch/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>l</code> <code>lightness</code> <code>c</code> <code>chroma</code> <code>h</code> <code>hue</code>"},{"location":"colors/oklch/#inputoutput","title":"Input/Output","text":"<p>Oklab is not currently supported in the CSS spec, the parsed input and string output formats use the <code>color()</code> function format using the custom name <code>--oklch</code>:</p> <pre><code>oklch(l c h / a)          // OkLCh function\ncolor(--oklch l c h / a)  // Color function\n</code></pre> <p>The string representation of the color object will always default to the <code>color(--oklch l c h / a)</code> form, but the default string output will be the <code>oklch(l a b / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"oklch\", [0.62796, 0.25768, 29.234])\ncolor(--oklch 0.62796 0.25768 29.234 / 1)\n&gt;&gt;&gt; Color(\"oklch\", [0.79269, 0.17103, 70.67]).to_string()\noklch(0.79269 0.17103 70.67)\n&gt;&gt;&gt; Color(\"oklch\", [0.96798, 0.21101, 109.77]).to_string(percent=True)\noklch(96.798% 52.753% 109.77)\n&gt;&gt;&gt; Color(\"oklch\", [0.51975, 0.17686, 142.5]).to_string(color=True)\ncolor(--oklch 0.51975 0.17686 142.5)\n</code></pre> Color(\"oklch\", [0.62796, 0.25768, 29.234]) Color(\"oklch\", [0.79269, 0.17103, 70.67]).to_string() Color(\"oklch\", [0.96798, 0.21101, 109.77]).to_string(percent=True) Color(\"oklch\", [0.51975, 0.17686, 142.5]).to_string(color=True) Edit Share Run Cancel"},{"location":"colors/oklch/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.oklch import OkLCh\n\nclass Color(Base): ...\n\nColor.register(OkLCh())\n</code></pre>"},{"location":"colors/orgb/","title":"oRGB","text":"<p>The oRGB color space is not registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>orgb</code></p> <p>White Point: D65</p> <p>Coordinates:</p> Name Range* <code>l</code> [0, 1] <code>cyb</code> [-1, 1] <code>crg</code> [-1, 1] <p>* Range denotes in gamut colors, but the color space supports an extended range beyond the gamut.</p> <p></p> <p>The sRGB gamut represented within the oRGB color space.</p> <p>A new color model that is based on opponent color theory. Like HSV, it is designed specifically for computer graphics. However, it is also designed to work well for computational applications such as color transfer, where HSV falters. Despite being geared towards computation, oRGB's natural axes facilitate HSV-style color selection and manipulation. oRGB also allows for new applications such as a quantitative cool-to-warm metric, intuitive color manipulations and variations, and simple gamut mapping. This new color model strikes a balance between simplicity and the computational qualities of color spaces such as CIELab.</p> <p>Learn more.</p>"},{"location":"colors/orgb/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>l</code> <code>luma</code> <code>cyb</code> <code>crb</code>"},{"location":"colors/orgb/#inputoutput","title":"Input/Output","text":"<p>The oRGB space is not currently supported in the CSS spec, the parsed input and string output formats use the <code>color()</code> function format using the custom name <code>--orgb</code>:</p> <pre><code>color(--orgb l cyb crb / a)  // Color function\n</code></pre> <p>The string representation of the color object and the default string output use the <code>color(--orgb l cyb crg / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"orgb\", [0.299, 0.00002, 0.99998])\ncolor(--orgb 0.299 0.00002 0.99998 / 1)\n&gt;&gt;&gt; Color(\"orgb\", [0.67882, 0.75654, 0.4464]).to_string()\ncolor(--orgb 0.67882 0.75654 0.4464)\n</code></pre> Color(\"orgb\", [0.299, 0.00002, 0.99998]) Color(\"orgb\", [0.67882, 0.75654, 0.4464]).to_string() Edit Share Run Cancel"},{"location":"colors/orgb/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.orgb import oRGB\n\nclass Color(Base): ...\n\nColor.register(oRGB())\n</code></pre>"},{"location":"colors/prismatic/","title":"Prismatic","text":"<p>The oRGB color space is not registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>prismatic</code></p> <p>White Point: D65</p> <p>Coordinates:</p> Name Range <code>l</code> [0, 1] <code>r</code> [0, 1] <code>g</code> [0, 1] <code>b</code> [0, 1] <p></p> <p>Prismatic Illustrations</p> <p>The Prismatic model introduces a simple transform of the RGB color cube into a light/dark dimension and a 2D hue. The hue is a normalized (barycentric)triangle with pure red, green, and blue at the vertices, often called the Maxwell Color Triangle.  Each cross section of the space is the same barycentric triangle, and the light/dark dimension runs zero to one for each hue so the whole color volume takes the form of a prism.</p> <p>Learn more.</p>"},{"location":"colors/prismatic/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>l</code> <code>lightness</code> <code>r</code> <code>red</code> <code>g</code> <code>green</code> <code>b</code> <code>blue</code>"},{"location":"colors/prismatic/#inputoutput","title":"Input/Output","text":"<p>The Prismatic space is not currently supported in the CSS spec, the parsed input and string output formats use the <code>color()</code> function format using the custom name <code>--prismatic</code>:</p> <pre><code>color(--prismatic l r g b / a)  // Color function\n</code></pre> <p>The string representation of the color object and the default string output use the <code>color(--prismatic l r g b / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"prismatic\", [1, 1, 0, 0])\ncolor(--prismatic 1 1 0 0 / 1)\n&gt;&gt;&gt; Color(\"prismatic\", [1, 0.60714, 0.39286, 0], 1).to_string()\ncolor(--prismatic 1 0.60714 0.39286 0)\n</code></pre> Color(\"prismatic\", [1, 1, 0, 0]) Color(\"prismatic\", [1, 0.60714, 0.39286, 0], 1).to_string() Edit Share Run Cancel"},{"location":"colors/prismatic/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.prismatic import Prismatic\n\nclass Color(Base): ...\n\nColor.register(Prismatic())\n</code></pre>"},{"location":"colors/prophoto_rgb/","title":"ProPhoto","text":"<p>The ProPhoto color space is registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>prophoto-rgb</code></p> <p>White Point: D50</p> <p>Coordinates:</p> Name Range* <code>r</code> [0, 1] <code>g</code> [0, 1] <code>b</code> [0, 1] <p>* Range denotes in gamut colors, but the color space supports an extended range beyond the gamut.</p> <p></p> <p>CIE 1931 xy Chromaticity \u2013 ProPhoto RGB Chromaticities</p> <p>The ProPhoto RGB color space, also known as ROMM RGB (Reference Output Medium Metric), is an output referred RGB color space developed by Kodak. It offers an especially large gamut designed for use with photographic output in mind. The ProPhoto RGB color space encompasses over 90% of possible surface colors in the CIE L*a*b* color space, and 100% of likely occurring real-world surface colors documented by Pointer in 1980.</p> <p>Learn about ProPhoto</p>"},{"location":"colors/prophoto_rgb/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>r</code> <code>red</code> <code>g</code> <code>green</code> <code>b</code> <code>blue</code>"},{"location":"colors/prophoto_rgb/#inputoutput","title":"Input/Output","text":"<p>Parsed input and string output formats support all valid CSS forms:</p> <pre><code>color(prophoto-rgb r g b / a)  // Color function\n</code></pre> <p>When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used:</p> <pre><code>Color(\"prophoto-rgb\", [0, 0, 0], 1)\n</code></pre> <p>The string representation of the color object and the default string output will be in the <code>color(prophoto-rgb r g b / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"prophoto-rgb\", [0.78951, 0.62329, 0.21172], 1)\ncolor(prophoto-rgb 0.78951 0.62329 0.21172 / 1)\n&gt;&gt;&gt; Color(\"prophoto-rgb\", [0.70225, 0.27572, 0.10355]).to_string()\ncolor(prophoto-rgb 0.70225 0.27572 0.10355)\n</code></pre> Color(\"prophoto-rgb\", [0.78951, 0.62329, 0.21172], 1) Color(\"prophoto-rgb\", [0.70225, 0.27572, 0.10355]).to_string() Edit Share Run Cancel"},{"location":"colors/prophoto_rgb/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.prophoto_rgb import ProPhotoRGB\n\nclass Color(Base): ...\n\nColor.register(ProPhotoRGB())\n</code></pre>"},{"location":"colors/prophoto_rgb_linear/","title":"Linear ProPhoto","text":"<p>The Linear ProPhoto color space is registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>prophoto-rgb-linear</code></p> <p>White Point: D50</p> <p>Coordinates:</p> Name Range* <code>r</code> [0, 1] <code>g</code> [0, 1] <code>b</code> [0, 1] <p>* Range denotes in gamut colors, but the color space supports an extended range beyond the gamut.</p> <p></p> <p>CIE 1931 xy Chromaticity \u2013 ProPhoto RGB Chromaticities</p> <p>The Linear ProPhoto space is the same as ProPhoto except that the transfer function is linear-light (there is no gamma-encoding).</p> <p>Learn about ProPhoto</p>"},{"location":"colors/prophoto_rgb_linear/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>r</code> <code>red</code> <code>g</code> <code>green</code> <code>b</code> <code>blue</code>"},{"location":"colors/prophoto_rgb_linear/#inputoutput","title":"Input/Output","text":"<p>Linear ProPhoto is not supported via the CSS spec and the parser input and string output only supports the <code>color()</code> function format using the custom name <code>--prophoto-rgb-linear</code>:</p> <pre><code>color(--prophoto-rgb-linear r g b / a)  // Color function\n</code></pre> <p>When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used:</p> <pre><code>Color(\"prophoto-rgb-linear\", [0, 0, 0], 1)\n</code></pre> <p>The string representation of the color object and the default string output will be in the <code>color(--prophoto-rgb-linear r g b / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"prophoto-rgb-linear\", [0.52928, 0.09837, 0.01688])\ncolor(--prophoto-rgb-linear 0.52928 0.09837 0.01688 / 1)\n&gt;&gt;&gt; Color(\"prophoto-rgb-linear\", [0.6535, 0.42702, 0.06115]).to_string()\ncolor(--prophoto-rgb-linear 0.6535 0.42702 0.06115)\n</code></pre> Color(\"prophoto-rgb-linear\", [0.52928, 0.09837, 0.01688]) Color(\"prophoto-rgb-linear\", [0.6535, 0.42702, 0.06115]).to_string() Edit Share Run Cancel"},{"location":"colors/prophoto_rgb_linear/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.prophoto_rgb_linear import ProPhotoRGBLinear\n\nclass Color(Base): ...\n\nColor.register(ProPhotoRGBLinear())\n</code></pre>"},{"location":"colors/rec2020/","title":"REC. 2020","text":"<p>The Rec. 2020 color space is registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>rec2020</code></p> <p>White Point: D65</p> <p>Coordinates:</p> Name Range* <code>r</code> [0, 1] <code>g</code> [0, 1] <code>b</code> [0, 1] <p>* Range denotes in gamut colors, but the color space supports an extended range beyond the gamut.</p> <p></p> <p>CIE 1931 xy Chromaticity \u2013 Rec. 2020 Chromaticities</p> <p>ITU-R Recommendation BT.2020, more commonly known by the abbreviations Rec. 2020 or BT.2020, defines various aspects of ultra-high-definition television (UHDTV) with standard dynamic range (SDR) and wide color gamut (WCG), including picture resolutions, frame rates with progressive scan, bit depths, color primaries, RGB and luma-chroma color representations, chroma subsamplings, and an opto-electronic transfer function. The color is used in 4k and 8k UHDTV.</p> <p>Learn about REC.2020</p>"},{"location":"colors/rec2020/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>r</code> <code>red</code> <code>g</code> <code>green</code> <code>b</code> <code>blue</code>"},{"location":"colors/rec2020/#inputoutput","title":"Input/Output","text":"<p>Parsed input and string output formats support all valid CSS forms:</p> <pre><code>color(rec2020 r g b / a)  // Color function\n</code></pre> <p>When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used:</p> <pre><code>Color(\"rec2020\", [0, 0, 0], 1)\n</code></pre> <p>The string representation of the color object and the default string output will be in the <code>color(rec2020 r g b / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"rec2020\", [0.79198, 0.23098, 0.07376])\ncolor(rec2020 0.79198 0.23098 0.07376 / 1)\n&gt;&gt;&gt; Color(\"rec2020\", [0.86727, 0.64078, 0.18496]).to_string()\ncolor(rec2020 0.86727 0.64078 0.18496)\n</code></pre> Color(\"rec2020\", [0.79198, 0.23098, 0.07376]) Color(\"rec2020\", [0.86727, 0.64078, 0.18496]).to_string() Edit Share Run Cancel"},{"location":"colors/rec2020/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.rec2020 import Rec2020\n\nclass Color(Base): ...\n\nColor.register(Rec2020())\n</code></pre>"},{"location":"colors/rec2020_linear/","title":"Linear REC. 2020","text":"<p>The Linear Rec. 2020 color space is registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>rec2020-linear</code></p> <p>White Point: D65</p> <p>Coordinates:</p> Name Range* <code>r</code> [0, 1] <code>g</code> [0, 1] <code>b</code> [0, 1] <p>* Range denotes in gamut colors, but the color space supports an extended range beyond the gamut.</p> <p></p> <p>CIE 1931 xy Chromaticity \u2013 Rec. 2020 Chromaticities</p> <p>The Linear Rec. 2020 space is the same as Rec. 2020 except that the transfer function is linear-light (there is no gamma-encoding).</p> <p>Learn about REC.2020</p>"},{"location":"colors/rec2020_linear/#channel-aliases","title":"Channel Aliases:**","text":"Channels Aliases <code>r</code> <code>red</code> <code>g</code> <code>green</code> <code>b</code> <code>blue</code>"},{"location":"colors/rec2020_linear/#inputoutput","title":"Input/Output","text":"<p>Linear Rec. 2020 is not supported via the CSS spec and the parser input and string output only supports the <code>color()</code> function format using the custom name <code>--rec2020-linear</code>:</p> <pre><code>color(--rec2020-linear r g b / a)  // Color function\n</code></pre> <p>When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used:</p> <pre><code>Color(\"rec2020-linear\", [0, 0, 0], 1)\n</code></pre> <p>The string representation of the color object and the default string output will be in the <code>color(--rec2020-linear r g b / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"rec2020-linear\", [0.79198, 0.23098, 0.07376])\ncolor(--rec2020-linear 0.79198 0.23098 0.07376 / 1)\n&gt;&gt;&gt; Color(\"rec2020-linear\", [0.86727, 0.64078, 0.18496]).to_string()\ncolor(--rec2020-linear 0.86727 0.64078 0.18496)\n</code></pre> Color(\"rec2020-linear\", [0.79198, 0.23098, 0.07376]) Color(\"rec2020-linear\", [0.86727, 0.64078, 0.18496]).to_string() Edit Share Run Cancel"},{"location":"colors/rec2020_linear/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.rec2020_linear import Rec2020Linear\n\nclass Color(Base): ...\n\nColor.register(Rec2020Linear())\n</code></pre>"},{"location":"colors/rec2100pq/","title":"REC. 2100 PQ","text":"<p>The Rec. 2100 PQ is not registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>rec2100pq</code></p> <p>White Point: D65</p> <p>Coordinates:</p> Name Range <code>r</code> [0, 1] <code>g</code> [0, 1] <code>b</code> [0, 1] <p></p> <p>CIE 1931 xy Chromaticity \u2013 Rec. 2100 Chromaticities (Same as Rec. 2020)</p> <p>BT.2100, more commonly known by the abbreviations Rec. 2100 or BT.2100, introduced high-dynamic-range television (HDR-TV) by recommending the use of the perceptual quantizer (PQ) or hybrid log\u2013gamma (HLG) transfer functions instead of the traditional \"gamma\" previously used for SDR-TV. Rec. 2100 PQ specifically uses the perceptual quantizer.</p> <p>The actual gamut of Rec. 2100 uses the same wide color gamut of Rec. 2020, but the color space itself supports an HDR range.</p> <p>Learn about REC.2020</p>"},{"location":"colors/rec2100pq/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>r</code> <code>red</code> <code>g</code> <code>green</code> <code>b</code> <code>blue</code>"},{"location":"colors/rec2100pq/#inputoutput","title":"Input/Output","text":"<p>Rec. 2100 PQ is not supported via the CSS spec and the parser input and string output only supports the <code>color()</code> function format using the custom name <code>--rec2100pq</code>:</p> <pre><code>color(--rec2100pq r g b / a)  // Color function\n</code></pre> <p>When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used:</p> <pre><code>Color(\"rec2100pq\", [0, 0, 0], 1)\n</code></pre> <p>The string representation of the color object and the default string output will be in the <code>color(--rec2100pq r g b / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"rec2100pq\", [0.53255, 0.32702, 0.22007], 1)\ncolor(--rec2100pq 0.53255 0.32702 0.22007 / 1)\n&gt;&gt;&gt; Color(\"rec2100pq\", [0.55101, 0.49099, 0.30009], 1).to_string()\ncolor(--rec2100pq 0.55101 0.49099 0.30009)\n</code></pre> Color(\"rec2100pq\", [0.53255, 0.32702, 0.22007], 1) Color(\"rec2100pq\", [0.55101, 0.49099, 0.30009], 1).to_string() Edit Share Run Cancel"},{"location":"colors/rec2100pq/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.rec2100pq import Rec2100PQ\n\nclass Color(Base): ...\n\nColor.register(Rec2100PQ())\n</code></pre>"},{"location":"colors/rlab/","title":"RLAB","text":"<p>The RLAB color space is not registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>rlab</code></p> <p>White Point: D65</p> <p>Coordinates:</p> Name Range <code>l</code> [0, 100] <code>a</code> [-125, 125] <code>b</code> [-125, 125] <p>* Space is not bound to the range and is only used as a reference to define percentage inputs/outputs in relation to the Display P3 color space.</p> <p></p> <p>The sRGB gamut represented within the RLAB color space.</p> <p>The RLAB color-appearance space was developed by Fairchild and Berns for cross-media color reproduction applications in which images are reproduced with differing white points, luminance levels, and/or surrounds.</p> <p>Learn more.</p>"},{"location":"colors/rlab/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>l</code> <code>lightness</code> <code>a</code> <code>b</code>"},{"location":"colors/rlab/#inputoutput","title":"Input/Output","text":"<p>The RLAB space is not currently supported in the CSS spec, the parsed input and string output formats use the <code>color()</code> function format using the custom name <code>--rlab</code>:</p> <pre><code>color(--rlab l a b / a)  // Color function\n</code></pre> <p>The string representation of the color object and the default string output use the <code>color(--rlab l a b / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"rlab\", [51.012, 79.742, 57.26])\ncolor(--rlab 51.012 79.742 57.26 / 1)\n&gt;&gt;&gt; Color(\"rlab\", [72.793, 25.151, 74.11]).to_string()\ncolor(--rlab 72.793 25.151 74.11)\n</code></pre> Color(\"rlab\", [51.012, 79.742, 57.26]) Color(\"rlab\", [72.793, 25.151, 74.11]).to_string() Edit Share Run Cancel"},{"location":"colors/rlab/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.rlab import RLAB\n\nclass Color(Base): ...\n\nColor.register(RLAB())\n</code></pre>"},{"location":"colors/srgb/","title":"sRGB","text":"<p>The sRGB color space is registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>srgb</code></p> <p>White Point: D65</p> <p>Coordinates:</p> Name Range* <code>r</code> [0, 1] <code>g</code> [0, 1] <code>b</code> [0, 1] <p>* Range denotes in gamut colors, but the color space supports an extended range beyond the gamut.</p> <p></p> <p>CIE 1931 xy Chromaticity \u2013 sRGB Chromaticities</p> <p>The sRGB space is a standard RGB (red, green, blue) color space that HP and Microsoft created cooperatively in 1996 to use on monitors, printers, and the Web. sRGB stands for \"Standard RGB\". It is the most widely used color space and is supported by most operating systems, software programs, monitors, and printers.</p> <p>Learn about sRGB</p>"},{"location":"colors/srgb/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>r</code> <code>red</code> <code>g</code> <code>green</code> <code>b</code> <code>blue</code>"},{"location":"colors/srgb/#inputoutput","title":"Input/Output","text":"<p>Parsed input and string output formats support all valid CSS forms:</p> <pre><code>black                  // Color name\n#RRGGBBAA              // Hex\nrgb(r g b / a)         // RGB function\nrgb(r, g, b)           // Legacy RGB Function\nrgba(r, g, b, a)       // Legacy RGBA function\ncolor(srgb r g b / a)  // Color function\n</code></pre> <p>When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used:</p> <p><pre><code>Color(\"srgb\", [0, 0, 0], 1)\n</code></pre> The string representation of the color object will always default to the <code>color(srgb r g b / a)</code> form, but the default string output will be the <code>rgb(r g b / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color('red').to_string()\nrgb(255 0 0)\n&gt;&gt;&gt; Color('orange').to_string(comma=True)\nrgb(255, 165, 0)\n&gt;&gt;&gt; Color('yellow').to_string(percent=True)\nrgb(100% 100% 0%)\n&gt;&gt;&gt; Color('green').to_string(names=True)\ngreen\n&gt;&gt;&gt; Color('blue').to_string(hex=True)\n#0000ff\n&gt;&gt;&gt; Color('indigo').to_string(color=True)\ncolor(srgb 0.29412 0 0.5098)\n</code></pre> Color('red').to_string() Color('orange').to_string(comma=True) Color('yellow').to_string(percent=True) Color('green').to_string(names=True) Color('blue').to_string(hex=True) Color('indigo').to_string(color=True) Edit Share Run Cancel"},{"location":"colors/srgb/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.srgb.css import sRGB\n\nclass Color(Base): ...\n\nColor.register(sRGB())\n</code></pre>"},{"location":"colors/srgb_linear/","title":"Linear sRGB","text":"<p>The Linear sRGB color space is registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>srgb-linear</code></p> <p>White Point: D65</p> <p>Coordinates:</p> Name Range* <code>r</code> [0, 1] <code>g</code> [0, 1] <code>b</code> [0, 1] <p>* Range denotes in gamut colors, but the color space supports an extended range beyond the gamut.</p> <p></p> <p>CIE 1931 xy Chromaticity \u2013 sRGB Chromaticities</p> <p>The sRGB Linear space is the same as sRGB except that the transfer function is linear-light (there is no gamma-encoding).</p> <p>Learn about sRGB</p>"},{"location":"colors/srgb_linear/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>r</code> <code>red</code> <code>g</code> <code>green</code> <code>b</code> <code>blue</code>"},{"location":"colors/srgb_linear/#inputsoutput","title":"Inputs/Output","text":"<p>Parsed input and string output formats support all valid CSS forms:</p> <pre><code>color(srgb-linear r g b / a)  // Color function\n</code></pre> <p>When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used:</p> <pre><code>Color(\"srgb-linear\", [0, 0, 0], 1)\n</code></pre> <p>The string representation of the color object and the default string output will be in the <code>color(srgb-linear r g b / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"srgb\", [1, 0, 0])\ncolor(srgb 1 0 0 / 1)\n&gt;&gt;&gt; Color(\"srgb\", [1, 0.37626, 0]).to_string()\nrgb(255 95.946 0)\n</code></pre> Color(\"srgb\", [1, 0, 0]) Color(\"srgb\", [1, 0.37626, 0]).to_string() Edit Share Run Cancel"},{"location":"colors/srgb_linear/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.srgb_linear import sRGBLinear\n\nclass Color(Base): ...\n\nColor.register(sRGB())\n</code></pre>"},{"location":"colors/xyy/","title":"xyY","text":"<p>The xyY color space is not registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>xyy</code></p> <p>White Point: D65</p> <p>Coordinates:</p> Name Range* <code>x</code> [0, 1] <code>y</code> [0, 1] <code>Y</code> [0, 1] <p>* Space is not bound to the range and is used to define percentage inputs/outputs.</p> <p></p> <p>The sRGB gamut represented within the xyY color space.</p> <p>A derivative of the CIE 1931 XYZ space, the CIE xyY color space, is often used as a way to graphically present the chromaticity of colors.</p> <p>Learn more.</p>"},{"location":"colors/xyy/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>x</code> <code>y</code> <code>Y</code>"},{"location":"colors/xyy/#inputoutput","title":"Input/Output","text":"<p>The xyY space is not currently supported in the CSS spec, the parsed input and string output formats use the <code>color()</code> function format using the custom name <code>--xyy</code>:</p> <pre><code>color(--xyy x y Y / a)  // Color function\n</code></pre> <p>The string representation of the color object and the default string output use the <code>color(--xyy x y Y / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"xyy\", [0.64, 0.33, 0.21264])\ncolor(--xyy 0.64 0.33 0.21264 / 1)\n&gt;&gt;&gt; Color(\"xyy\", [0.50047, 0.4408, 0.48173]).to_string()\ncolor(--xyy 0.50047 0.4408 0.48173)\n</code></pre> Color(\"xyy\", [0.64, 0.33, 0.21264]) Color(\"xyy\", [0.50047, 0.4408, 0.48173]).to_string() Edit Share Run Cancel"},{"location":"colors/xyy/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.xyy import xyY\n\nclass Color(Base): ...\n\nColor.register(xyY())\n</code></pre>"},{"location":"colors/xyz_d50/","title":"XYZ D50","text":"<p>The XYZ D50 color space is registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>xyz-d50</code></p> <p>White Point: D50</p> <p>Coordinates:</p> Name Range* <code>x</code> [0, 1] <code>y</code> [0, 1] <code>z</code> [0, 1] <p>* Space is not bound to the range and is only used as a reference to define percentage inputs/outputs.</p> <p></p> <p>The sRGB gamut represented within the XYZ D50 color space.</p> <p>XYZ D50 is the same as XYZ D65 except it uses a D50 white point.</p> <p>Learn about XYZ</p>"},{"location":"colors/xyz_d50/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>x</code> <code>y</code> <code>z</code>"},{"location":"colors/xyz_d50/#inputoutput","title":"Input/Output","text":"<p>Parsed input and string output formats support all valid CSS forms:</p> <pre><code>color(xyz-d50 x y z / a)  // Color function\n</code></pre> <p>When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used:</p> <pre><code>Color(\"xyz-d50\", [0, 0, 0], 1)\n</code></pre> <p>The string representation of the color object and the default string output will be in the <code>color(xyz x y z / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"xyz-d50\", [0.43607, 0.22249, 0.01392])\ncolor(xyz-d50 0.43607 0.22249 0.01392 / 1)\n&gt;&gt;&gt; Color(\"xyz-d50\", [0.58098, 0.49223, 0.05045]).to_string()\ncolor(xyz-d50 0.58098 0.49223 0.05045)\n</code></pre> Color(\"xyz-d50\", [0.43607, 0.22249, 0.01392]) Color(\"xyz-d50\", [0.58098, 0.49223, 0.05045]).to_string() Edit Share Run Cancel"},{"location":"colors/xyz_d50/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.xyz_d50 import XYZD50\n\nclass Color(Base): ...\n\nColor.register(XYZD50())\n</code></pre>"},{"location":"colors/xyz_d65/","title":"XYZ D65","text":"<p>The XYZ D65 color space is registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>xyz-d65</code></p> <p>White Point: D65</p> <p>Coordinates:</p> Name Range* <code>x</code> [0, 1] <code>y</code> [0, 1] <code>z</code> [0, 1] <p>* Space is not bound to the range and is only used as a reference to define percentage inputs/outputs.</p> <p></p> <p>The sRGB gamut represented within the XYZ D65 color space.</p> <p>The CIE 1931 RGB color space and CIE 1931 XYZ color space were created by the International Commission on Illumination (CIE) in 1931. They resulted from a series of experiments done in the late 1920s by William David Wright using ten observers and John Guild using seven observers. The experimental results were combined into the specification of the CIE RGB color space, from which the CIE XYZ color space was derived. The CIE 1931 color spaces are the first defined quantitative links between distributions of wavelengths in the electromagnetic visible spectrum, and physiologically perceived colors in human color vision.</p> <p>Learn about XYZ</p>"},{"location":"colors/xyz_d65/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>x</code> <code>y</code> <code>z</code>"},{"location":"colors/xyz_d65/#inputoutput","title":"Input/Output","text":"<p>Parsed input and string output formats use the <code>color()</code> format with either <code>xyz-d65</code> or <code>xyz</code> as the identifier with the latter being an alias of the former.</p> <pre><code>color(xyz x y z / a)      // Color function\ncolor(xyz-d65 x y z / a)  // Color function alternate name\n</code></pre> <p>When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used:</p> <pre><code>Color(\"xyz-d65\", [0, 0, 0], 1)\n</code></pre> <p>The string representation of the color object and the default string output will be in the  <code>color(xyz-d65 x y z / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"xyz-d65\", [0.41239, 0.21264, 0.01933])\ncolor(xyz-d65 0.41239 0.21264 0.01933 / 1)\n&gt;&gt;&gt; Color(\"xyz-d65\", [0.54694, 0.48173, 0.06418]).to_string()\ncolor(xyz-d65 0.54694 0.48173 0.06418)\n</code></pre> Color(\"xyz-d65\", [0.41239, 0.21264, 0.01933]) Color(\"xyz-d65\", [0.54694, 0.48173, 0.06418]).to_string() Edit Share Run Cancel"},{"location":"colors/xyz_d65/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.xyz_d65 import XYZD65\n\nclass Color(Base): ...\n\nColor.register(XYZD65())\n</code></pre>"},{"location":"plugins/","title":"ColorAide Plugins","text":"<p>ColorAide implements extendable portions of the <code>Color</code> object as plugins. This makes adding things such as new \u2206E methods or even new color spaces quite easy. Currently, ColorAide implements the following areas as plugins:</p> <ul> <li>\u2206E methods</li> <li>Fit/Gamut mapping</li> <li>Chromatic adaptation</li> <li>Filters</li> <li>Contrast</li> <li>Color spaces</li> <li>Interpolation</li> </ul> <p>While these documents will touch on each plugin, looking at the source code will provide a better view on how plugins are actually used as all functionality for all of these categories are implemented as plugins in ColorAide.</p>"},{"location":"plugins/cat/","title":"Chromatic Adaptation","text":""},{"location":"plugins/cat/#description","title":"Description","text":"<p>CAT plugins chromatically adapt a given XYZ coordinate from its current reference white point to a new desired white point. This is useful during conversion when one color space is converted to another color space that uses a difference reference white.</p>"},{"location":"plugins/cat/#plugin-class","title":"Plugin Class","text":"<p>Plugins are are created by subclassing <code>coloraide.cat.CAT</code>.</p> <pre><code>class CAT(Plugin, metaclass=ABCMeta):\n\"\"\"Chromatic adaptation.\"\"\"\n\n    NAME = \"\"\n\n    @abstractmethod\n    def adapt(self, w1: Tuple[float, float], w2: Tuple[float, float], xyz: VectorLike) -&gt; Vector:\n\"\"\"Adapt a given XYZ color using the provided white points.\"\"\"\n</code></pre> <p>Once registered, the plugin can then be used via <code>chromatic_adaptation</code> by passing its <code>NAME</code> via the the <code>method</code> along two white points (as XYZ values): <code>w1</code> as the current white point and <code>w2</code> as the target white point.</p> <p>It should be noted that <code>chromatic_adaptation</code> is not usually directly used by the user, so a more likely approach is to override the <code>DELTA_E</code> parameter of a subclassed <code>Color</code> object to specify the plugin as the default for chromatic adaptation.</p>"},{"location":"plugins/cat/#von-kries-cat","title":"Von Kries CAT","text":"<p>Currently, ColorAide only ships with Von Kries based adaptation methods. If it is desired to create a Von Kries based plugin, it is recommended to subclass the <code>VonKries</code> class which is based on <code>CAT</code>. When subclassing a <code>VonKries</code> based CAT, the <code>NAME</code> and a <code>MATRIX</code> must be provided. The general calculations related to the source and target white point, will automatically be calculated and an appropriate matrix and inverted matrix will be returned to perform the adaptation without any additional logic.</p> <pre><code>class Bradford(VonKries):\n\"\"\"\n    Bradford CAT.\n\n    http://brucelindbloom.com/Eqn_ChromAdapt.html\n    https://hrcak.srce.hr/file/95370\n    \"\"\"\n\n    NAME = \"bradford\"\n\n    MATRIX = [\n        [0.8951000, 0.2664000, -0.1614000],\n        [-0.7502000, 1.7135000, 0.0367000],\n        [0.0389000, -0.0685000, 1.0296000]\n    ]\n</code></pre>"},{"location":"plugins/contrast/","title":"Contrast","text":""},{"location":"plugins/contrast/#description","title":"Description","text":"<p>Contrast returns a numerical value that is meant to determine how much visual contrast exists between two colors. While the current default is agnostic to ordering of the colors, some algorithms can be sensitive to order.</p>"},{"location":"plugins/contrast/#plugin-class","title":"Plugin Class","text":"<pre><code>class ColorContrast(Plugin, metaclass=ABCMeta):\n\"\"\"Color contrast plugin class.\"\"\"\n\n    NAME = ''\n\n    @abstractmethod\n    def contrast(self, color1: 'Color', color2: 'Color', **kwargs: Any) -&gt; float:\n\"\"\"Get the contrast of the two provided colors.\"\"\"\n</code></pre> <p>Once registered, the plugin can then be used via <code>contrast</code> by passing its <code>NAME</code> via the <code>method</code> parameter along with a secondary color (<code>color2</code>) representing the background color. The calling color (<code>color1</code>) will be considered the text color. Any additional key word arguments can be specified to override default behavior. The \"contrast\" will be returned as a float.</p> <pre><code>color1.contrast(color2, method=NAME, **kwargs)\n</code></pre> <p>If you'd like the user to be able to set specific defaults, you can define an <code>__init__</code> method and manage defaults accordingly. Defaults can be passed in when instantiating a new plugin.</p> <pre><code>Color.register(Plugin(**kwargs))\n</code></pre>"},{"location":"plugins/delta_e/","title":"Delta E","text":""},{"location":"plugins/delta_e/#description","title":"Description","text":"<p>\u2206E plugins allow for getting color differences with different methods. ColorAide provides a number of methods by default which are documented under Color Distance and Delta E. All of the default \u2206E methods are provided as plugins, and users can create their own as well.</p>"},{"location":"plugins/delta_e/#plugin-class","title":"Plugin Class","text":"<p>\u2206E plugins are subclassed from <code>coloraide.distance.DeltaE</code>.</p> <pre><code>class DeltaE(Plugin, metaclass=ABCMeta):\n\"\"\"Delta E plugin class.\"\"\"\n\n    NAME = ''\n\n    @abstractmethod\n    def distance(self, color: 'Color', sample: 'Color', **kwargs: Any) -&gt; float:\n\"\"\"Get distance between color and sample.\"\"\"\n</code></pre> <p>Once registered, the plugin can then be used via <code>delta_e</code> by passing its <code>NAME</code> via the <code>method</code> parameter along with any additional key word arguments to override default behavior. The return will be a float indicating the distance.</p> <pre><code>color.delta_e(sample, method=NAME, **kwargs)\n</code></pre> <p>If you'd like the user to be able to set specific defaults, you can define an <code>__init__</code> method and manage defaults accordingly. Defaults can be passed in when instantiating a new plugin.</p> <pre><code>Color.register(Plugin(**kwargs))\n</code></pre>"},{"location":"plugins/filter/","title":"Filters","text":""},{"location":"plugins/filter/#description","title":"Description","text":"<p>Filter plugins allow you to apply a filter to a given color, altering its appearance.</p>"},{"location":"plugins/filter/#plugin-class","title":"Plugin Class","text":"<pre><code>class Filter(Plugin, metaclass=ABCMeta):\n\"\"\"Filter plugin.\"\"\"\n\n    NAME = \"\"\n    DEFAULT_SPACE = 'srgb-linear'\n    ALLOWED_SPACES = ('srgb-linear', 'srgb')\n\n    @abstractmethod\n    def filter(self, color: 'Color', amount: Optional[float], **kwargs: Any) -&gt; None:\n\"\"\"Filter the given color.\"\"\"\n</code></pre> <p>Once registered, the plugin can then be used via <code>filter</code> by passing its <code>NAME</code> via the <code>method</code> parameter along with the <code>amount</code> specifying to what magnitude the filter is applied. Any additional key word arguments also be specified to allow for overriding default behaviors. The current <code>color</code> will then be altered by the filter.</p> <p><code>DEFAULT_SPACE</code> describes the default color space under which the filter is applied, while <code>ALLOWED_SPACES</code> defines optional, allowed spaces that can be specified. Color space conversion is handled before passing the color to the plugin.</p> <pre><code>color.filter(NAME, amount, **kwargs)\n</code></pre> <p>If you'd like the user to be able to set specific defaults, you can define an <code>__init__</code> method and manage defaults accordingly. Defaults can be passed in when instantiating a new plugin.</p> <pre><code>Color.register(Plugin(**kwargs))\n</code></pre>"},{"location":"plugins/fit/","title":"Fit/Gamut Mapping","text":""},{"location":"plugins/fit/#description","title":"Description","text":"<p>Fit plugins (or gamut mapping plugins) allow for mapping an out of gamut color to be within the current color space's gamut. All default gamut mapping methods provided by ColorAide are provided via plugins.</p>"},{"location":"plugins/fit/#plugin-class","title":"Plugin Class","text":"<p>Plugins are are created by subclassing <code>coloraide.gamut.Fit</code>.</p> <pre><code>class Fit(Plugin, metaclass=ABCMeta):\n\"\"\"Fit plugin class.\"\"\"\n\"\"\"Fit plugin class.\"\"\"\n\n    NAME = ''\n\n    @abstractmethod\n    def fit(self, color: 'Color', **kwargs) -&gt; None:\n\"\"\"Get coordinates of the new gamut mapped color.\"\"\"\n</code></pre> <p>Once registered, the plugin can then be used via <code>fit</code> (and in some places like <code>convert</code>) by passing its <code>NAME</code> via the <code>method</code> parameter along with any additional key word arguments to override default behavior. The current <code>color</code> will be gamut mapped accordingly.</p> <pre><code>color.fit(method=NAME, **kwargs)\n</code></pre> <p>If you'd like the user to be able to set specific defaults, you can define an <code>__init__</code> method and manage defaults accordingly. Defaults can be passed in when instantiating a new plugin.</p> <pre><code>Color.register(Plugin(**kwargs))\n</code></pre> <p>Reserved Name</p> <p><code>clip</code> is a special, reserved name and the associated plugin cannot be overridden. Another clip plugin can be written, but it cannot override the original.</p>"},{"location":"plugins/interpolate/","title":"Interpolation","text":""},{"location":"plugins/interpolate/#description","title":"Description","text":"<p>Interpolation plugins allow for interpolation between one or more colors. All interpolation in ColorAide is provided via plugins.</p>"},{"location":"plugins/interpolate/#plugin-class","title":"Plugin Class","text":"<p>Plugins are are created by subclassing <code>coloraide.interpolate.Interpolate</code>.</p> <pre><code>class Interpolate(Plugin, metaclass=ABCMeta):\n\"\"\"Interpolation plugin.\"\"\"\n\n    NAME = \"\"\n\n    @abstractmethod\n    def interpolator(\n        self,\n        coordinates: List[Vector],\n        channel_names: Sequence[str],\n        create: Type['Color'],\n        easings: List[Optional[Callable[..., float]]],\n        stops: Dict[int, float],\n        space: str,\n        out_space: str,\n        progress: Optional[Union[Mapping[str, Callable[..., float]], Callable[..., float]]],\n        premultiplied: bool,\n        extrapolate: bool = False,\n        domain: Optional[List[float]] = None,\n        **kwargs: Any\n    ) -&gt; Interpolator:\n\"\"\"Get the interpolator object.\"\"\"\n</code></pre> <p>Once registered, the plugin can then be used via <code>interpolate</code>, <code>steps</code>, or <code>mix</code> by passing its <code>NAME</code> via the <code>method</code> parameter along with any additional key word arguments to override default behavior. An <code>Interpolator</code> object will be returned which allows for interpolating between the given list of <code>colors</code>.</p> <pre><code>color.interpolate(colors, method=NAME)\n</code></pre> <p>In general, the <code>Interpolate</code> plugin is mainly a wrapper to ensure the interpolation setup uses an appropriate <code>Interpolator</code> object which does the actual work. An interpolation plugin should derive their <code>Interpolator</code> class from <code>coloraide.interpolate.Interpolator</code>. While we won't show all the methods of the class, we will show the one function that must be defined.</p> <pre><code>class Interpolator(metaclass=ABCMeta):\n\"\"\"Interpolator.\"\"\"\n\n    def setup(self) --&gt; None:\n\"\"\"Setup.\"\"\"\n\n    @abstractmethod\n    def interpolate(\n        self,\n        point: float,\n        index: int,\n    ) -&gt; Vector:\n\"\"\"Interpolate.\"\"\"\n</code></pre> <p><code>Interpolator.interpolate</code> expects an <code>index</code> (1 - n) indicating which pair of color stops a given <code>point</code> refers to. It is possible that <code>point</code> could exceed the normal range, in which case <code>index</code> will still refer to to either the minimum or maximum color stop pair, whichever the point exceeds.</p> <p><code>point</code> is usually a value between 0 - 1, where 0 would be the color stop to the left, and 1 would be the color stop to the right. If <code>point</code> exceeds the range of 0 and 1, it can be assumed that the request is on the far left or far right of all color stops, and could be beyond the absolute range of the entire color interpolation chain.</p> <p>By default, extrapolation is disabled between all colors in an interpolation chain, and any <code>point</code> that exceeds the range of 0 - 1, after easing functions are applied, will be clamped. If <code>extrapolate</code> is set to <code>$!py True</code>, the points will not be clamped between any colors, in which case, it is an easing functions responsibility to ensure a value between 0 or 1 if extreme values are not desired.</p> <p>Additionally, an optional <code>Interpolator.setup</code> method is provided to allow for any additional setup required. Premultiplication is usually done in <code>setup</code> ahead of time. Resolution of undefined values can be recalculated here as well as it is usually needed so that premultiplication can be done on coordinates that contain undefined values. With that said, such calculations can also be deferred and handled on the fly if desired.</p> <p>Check out the source code to see some example plugins.</p>"},{"location":"plugins/space/","title":"Color Space","text":""},{"location":"plugins/space/#description","title":"Description","text":"<p>All color spaces supported by ColorAide are specified via color space plugins. These <code>Space</code> objects specify color channel properties, gamut bounds, input matching/parsing logic, string output logic, conversion to and from a specified base color, etc.</p> <p>Color space plugins are a little more complex compared to Delta E, Fit, and other plugins.</p>"},{"location":"plugins/space/#plugin-class","title":"Plugin Class","text":"<p>In general, a color space plugin is created by subclassing from <code>coloraide.spaces.Space</code>. When defining a color space, there are a couple things that must be defined. Using XYZ as an example, we will go over them.</p> <pre><code>from coloraide import cat\nfrom coloraide.channels import Channel\n\n\nclass XYZD65(Space):\n\"\"\"XYZ D65 class.\"\"\"\n\n    # A base color though which a color is converted through.\n    # XYZ is our absolute base, so it doesn't have a real base,\n    # but something like HSL might have a base color of `srgb`.\n    BASE = \"xyz-d65\"\n\n    # The name of the color space.\n    NAME = \"xyz-d65\"\n\n    # One or more accepted identifiers that are allowed for the `color(space ...)` format.\n    # For this this specific color space, both `color(xyz x y z / a)` and `color(xyz-d65 x y z / a)` are accepted.\n    # As `xyz` is listed first, `xyz` is the default used when printing in this format.\n    SERIALIZE = (\"xyz-d65\", \"xyz\")\n\n    # Specify channel attributes, bounds, etc. of the non-alpha color channels.\n    # Each channel is defined via a `Channel` object\n    #\n    #```\n    #class Channel(str):\n    #    \"\"\"Channel.\"\"\"\n    #\n    #    def __new__(\n    #        cls,\n    #        name: str,\n    #        low: float,\n    #        high: float,\n    #        bound: bool = False,\n    #        flags: int = 0,\n    #        limit: Tuple[Optional[float], Optional[float]] = (None, None)\n    #    ) -&gt; 'Channel':\n    #```\n    #\n    # - `name`: The name of the channel.\n    # - `low`: Lower limit of the channel, for unbound channels, the value will be arbitrary.\n    # - `high`: Upper limit of the channel, for unbound channels, the value will be arbitrary.\n    # - `bound`: Whether the channel enforces the gamut range.\n    # - `limit`: Optional upper and lower limit. Used to define a hard limit for the channel that is clamped\n    #            when the channel is set. This differs from gamut boundaries which can be exceeded until gamut\n    #            mapping occurs. For instance, `chroma` often enforces no values below zero as these values\n    #            do not naturally occur, not even with normal out of gamut colors. So, we could clamp the lower\n    #            bound: `(0, None)`.\n    # - `flags`: Flags used to provide additional context for the channel.\n    #\n    # The following flags are supported:\n    # - FLG_ANGLE: denotes that channel is a angle or degree value.\n    # - FLG_PERCENT: denotes the value is considered a percent input. This is usually used in named CSS functions\n    #                like `hsl()` which require string inputs for saturation and lightness to always be in a\n    #                percentage format. The CSS `color()` function ignores this flags as no channels are always\n    #                required to be percentages. Percentage range will be determined by `high` and `low`.\n    # - FLG_OPT_PERCENT: denotes the value can optionally be considered as a percent.\n    #                    This is also only used for CSS string input and output. CSS `oklab`, `lab()`, `oklch`,\n    #                    `lch()`, and `srgb()` allow for channels to be provided as percentages or normal\n    #                    numbers in certain cases. This tells the parser and serializer which channels allow this.\n    #                    Percentage range will be determined by `high` and `low`.\n    # - FLG_MIRROR_PERCENT: The channel, when importing or exporting to a percent should mirror the percentage\n    #                       for negative values. This is used mainly in Lab and Lab like spaces which have `a`\n    #                       `b` channels that allow for both negative and positive values. If set, `high` and `low`\n    #                       should fulfill `abs(low) == high`.\n    CHANNELS = (\n        Channel(\"x\", 0.0, 1.0),\n        Channel(\"y\", 0.0, 1.0),\n        Channel(\"z\", 0.0, 1.0)\n    )\n\n    # A dictionary containing a mapping of aliases to `name` attribute of `CHANNELS` found above.\n    CHANNEL_ALIASES = {}\n\n    # If you'd like this color space to parse as and export a `color(space ...)` format.\n    # If set to `False` the space will not recognize the color format as an input.\n    # This only affects input matching. To override output of the color format, you will also\n    # need to override the `to_string` method.\n    COLOR_FORMAT = True\n\n    # Specify the white point that the color space uses\n    # White point should be a `tuple` containing the x and y chromaticity points.\n    # Some basic ones are provided in the `cat` module for both 2 degree and 10 degree observer.\n    WHITE = cat.WHITES['2deg']['D65']\n\n    # If `GAMUT_CHECK` is set to a color space name, the provided color space will be used to verify the an \"in gamut\"\n    # check in addition to the current color space's channel ranges. This is often used with color spaces such as:\n    # HSL, HSV, and HWB where `GAMUT_CHECK` will be set to `srgb`.\n    #\n    # Gamut checking:\n    #   The specified color space will be checked first followed by the original. Assuming the parent color space fits,\n    #   the original should fit as well, but there are some cases when a parent color space that is slightly out of\n    #   gamut, when evaluated with a threshold, may appear to be in gamut enough, but when checking the original color\n    #   space, the values can be greatly out of specification (looking at you HSL).\n    GAMUT_CHECK = None\n\n    # When set to `True`, this denotes that the color space has the ability to represent out of gamut in colors in an\n    # extended range. When interpolation is done, if colors are interpolated in a smaller gamut than the colors being\n    # interpolated, and that color is \"bound\" to a gamut, the colors will usually be gamut mapped, but if the\n    # interpolation space happens to support extended ranges, then the colors will not be gamut mapped even if their\n    # gamut is larger than the target interpolation space.\n    EXTENDED_RANGE = False\n    # What is the color space's dynamic range\n    DYNAMIC_RANGE = 'sdr'\n\n    ############################\n    # To and from conversion functions that transform the color to and from the `BASE` color.\n    ############################\n    def to_base(self, coords: Vector) -&gt; Vector:\n\"\"\"\n        To XYZ (no change).\n\n        Any needed chromatic adaptation is handled in the parent Color object.\n        \"\"\"\n\n        return coords\n\n    def from_base(self, coords: Vector) -&gt; Vector:\n\"\"\"\n        From XYZ (no change).\n\n        Any needed chromatic adaptation is handled in the parent Color object.\n        \"\"\"\n\n        return coords\n</code></pre> <p>Once registered, colors can be created using the <code>NAME</code> via normal instantiation methods or conversions:</p> <pre><code>Color(NAME, [...])\nColor(red).convert(NAME)\n</code></pre> <p>By default, assuming <code>COLOR_FORMAT</code> is <code>True</code>, color strings will be parsed in the following format, where <code>SERIALIZE</code> is one one of the IDs specified via the <code>SERIALIZE</code> plugin property.</p> <pre><code>Color('color(SERIALIZE ...)')\n</code></pre>"},{"location":"plugins/space/#plugin-defaults","title":"Plugin Defaults","text":"<p>It is important to note that color space plugins are often not isolated. They are convert to from some <code>BASE</code> color and may be a <code>BASE</code> color for some other color space. Essentially, color spaces are chained together via the <code>BASE</code> property to ensure proper conversion to and from the color space. Because of this, it is not advisable to have any configurable defaults that would fundamentally change how the color coordinates are calculated, as such a change could affect not only the targeted color space, but other color spaces up and down the color conversion change.</p> <p>If configuration of a color space's fundamental calculations of coordinates is desired, it is recommended that the given <code>Space</code> plugin gets subclassed and provided a new <code>NAME</code>, along with <code>SERIALIZE</code> IDs that do not conflict with other spaces. Such changes would include changing a white point, changing viewing conditions, and even changing the algorithm for color space conversion.</p> <p>Defaults can be provided and configured via an <code>__init__</code> method, but it is strongly recommended that only superficial things are controlled by such options, like controlling recognized input/output string formats.</p> <p>Additionally, if provided an <code>__init__</code>, it is required that <code>super().__init__()</code> also gets called.</p>"},{"location":"plugins/space/#chromatic-adaptation","title":"Chromatic Adaptation","text":"<p>Chromatic adaptation is usually applied to a color when it is passing from one XYZ color space to another XYZ color space that has a different white point. In ColorAide, any time XYZ D65 is either the target or origin color, and the other color space has a different white point, the XYZ coordinates, will either be adapted to XYZ D65 or XYZ (new white point) respectively. This all happens without The <code>Space</code> plugin needing to do anything additional.</p> <p>White points are specified via the <code>WHITE</code> property, and should contain a tuple of <code>xy</code> coordinates of the white point.</p>"},{"location":"plugins/space/#color-normalization","title":"Color Normalization","text":"<p>In addition to the aforementioned methods, some color spaces, such as cylindrical spaces, have some additional logic that determines when a <code>hue</code> is undefined. During conversion, undefined channels are initially thrown away, but a color may be returned with undefined hues if it is a cylindrical color space and the the color is achromatic, or in some cases, very close to achromatic.</p> <p>The <code>Space.normalize</code> function is not used during conversion, but provides logic for specifically normalizing an exiting color when <code>Color.normalize</code> is called. Logic should generally match whatever occurs during conversion.</p> <p>Usually, for rectangular spaces, <code>normalize</code> simply eliminates undefined channels. For cylindrical spaces, it will also set the hue to \"undefined\" if the color meets the criteria of the color space. This may be when chroma is zero, or maybe even when very close to zero. This can vary from color space to color space.</p> <p><code>normalize</code> can be specified as an function of the <code>Space</code> plugin.</p> <pre><code>    def normalize(self, coords: Vector) -&gt; Vector:\n\"\"\"Normalize color.\"\"\"\n\n        coords = alg.no_nans(coords)\n        if coords[1] == 0 or coords[2] in (0, 1):\n            coords[0] = alg.NaN\n\n        return coords\n</code></pre>"},{"location":"plugins/space/#mix-ins","title":"Mix-ins","text":"<p>If the color is a cylindrical space, Lab-ish space, or LCh-ish space, you can additionally add in the respective mix-in class: <code>Cylindrical</code>, <code>Labish</code>, or <code>LChish</code>. It should be noted that <code>LChish</code> is subclassed from <code>Cylindrical</code>.</p> CylindricalLabishLChish <pre><code>class Cylindrical:\n\"\"\"Cylindrical space.\"\"\"\n\n    def hue_name(self) -&gt; str:\n\"\"\"Hue channel name.\"\"\"\n\n        return \"h\"\n\n    def hue_index(self) -&gt; int:  # pragma: no cover\n\"\"\"Get hue index.\"\"\"\n\n        return cast('Space', self).get_channel_index(self.hue_name())\n</code></pre> <pre><code>class Labish:\n\"\"\"Lab-ish color spaces.\"\"\"\n\n    def labish_names(self) -&gt; Tuple[str, ...]:\n\"\"\"Return Lab-ish names in the order L a b.\"\"\"\n\n        return cast('Space', self).channels[:-1]\n\n    def labish_indexes(self) -&gt; List[int]:  # pragma: no cover\n\"\"\"Return the index of the Lab-ish channels.\"\"\"\n\n        return [cast('Space', self).get_channel_index(name) for name in self.labish_names()]\n</code></pre> <pre><code>class LChish(Cylindrical):\n\"\"\"LCh-ish color spaces.\"\"\"\n\n    def lchish_names(self) -&gt; Tuple[str, ...]:  # pragma: no cover\n\"\"\"Return LCh-ish names in the order L c h.\"\"\"\n\n        return cast('Space', self).channels[:-1]\n\n    def lchish_indexes(self) -&gt; List[int]:  # pragma: no cover\n\"\"\"Return the index of the Lab-ish channels.\"\"\"\n\n        return [cast('Space', self).get_channel_index(name) for name in self.lchish_names()]\n</code></pre> <p>Mix-in classes are mainly available so that a color space can be inspected to see if it falls into a specific generic color space type in order to allow for some generic handling of the color. For instance, you may not care specifically what color space you are dealing with, but you may want to extract the hue from all cylindrical spaces, or grab the lightness (or lightness equivalent) from all Lab-ish color spaces.</p> <p>The mix-in classes provide methods mainly to extract expected channels on color spaces that may use different names for similar channels or to determine the index of a specific channel type. Occasionally, these methods may need to be overridden for a color space.</p> <p>Below, we can see that both <code>jzazbz</code> and <code>ictcp</code> identify as Lab-ish spaces. If we just care about accessing the equivalent of Lab lightness on these spaces, we can simply can access them with the following logic.</p> <pre><code>&gt;&gt;&gt; from coloraide.spaces import Labish\n&gt;&gt;&gt; srgb = Color('red')\n&gt;&gt;&gt; jzazbz = srgb.convert('jzazbz')\n&gt;&gt;&gt; ictcp = srgb.convert('ictcp')\n&gt;&gt;&gt; for c in (srgb, jzazbz, ictcp):\n...     if isinstance(c._space, Labish):\n...         print('color: ', c)\n...         l = c._space.labish_names()[0]\n...         print('channel: ', l)\n...         print('value: ', c.get(l))\n... \ncolor:  color(--jzazbz 0.13438 0.11789 0.11188 / 1)\nchannel:  jz\nvalue:  0.13438473104350318\ncolor:  color(--ictcp 0.42785 -0.11574 0.2788 / 1)\nchannel:  i\nvalue:  0.4278524836087273\n</code></pre> from coloraide.spaces import Labish srgb = Color('red') jzazbz = srgb.convert('jzazbz') ictcp = srgb.convert('ictcp')  for c in (srgb, jzazbz, ictcp):     if isinstance(c._space, Labish):         print('color: ', c)         l = c._space.labish_names()[0]         print('channel: ', l)         print('value: ', c.get(l)) Edit Share Run Cancel <p>It should be noted that just because a color space identifies in a specific, generic category, it doesn't mean it is precisely that thing. For instance, the color space CIELab is clearly a Lab-ish space, or more precisely, it is a Lab color space. Oklab, DIN99o, and others are very much Lab spaces as well. ICtCp, on the other hand, is very Lab like as its <code>Ct</code> and <code>Cp</code> channels control redness/greenness and blueness/yellowness, but the <code>I</code> channel represents intensity, not lightness which is similar but not precisely the same thing.</p>"},{"location":"plugins/space/#adding-new-inputoutput-formats","title":"Adding New Input/Output Formats","text":"<p>One common thing that may be desired is altering an existing color space to accept and output a specialized format. While using hex color codes or <code>rgb()</code> formats are fairly common, there are many places were other forms are used to represent colors. It may be beneficial for a user working with colors in some more obscure form to repurpose a color space to handle different input/output formats.</p> <p>The base of every color space is defined to accept and output the <code>color(space ...)</code> format. As this is a common input form across all color spaces, it is handled generically for all spaces in one action for performance reasons. Iterating each color space to perform the same match with a different color spaces name is obviously slower. A color can opt out of this input format by simply setting <code>COLOR_FORMAT</code> to <code>False</code>. This only disables input parsing. In order to disable this format during serialization the color space's <code>#py3 to_string()</code> method would need to be overridden.</p> <p>New, per color space matching logic can be achieved by simply by overriding the <code>match()</code> method. If it is desired to also accept the <code>color(space ...)</code> format, just keep the <code>COLOR_FORMAT</code> flag enabled; otherwise, disable it.</p> <p>As an example, let's consider the default sRGB space. We wanted to add additional CSS formats in addition to the <code>color(space ...)</code> format. While we won't go into the specific parsing logic, the general top-level logic can be seen below.</p> <p>We simply override the <code>match()</code> method and call into our CSS parser. The parser will handle the appropriate syntax for our color spaces. It is not configured to process the <code>color(space ...)</code> format as that is already handled more efficiently when with <code>COLOR_FORMAT</code> enabled. Also, notice that <code>match()</code> is expected to return two things: a tuple containing the color channel coordinates and the alpha value, and the end position (<code>([r, g, b], a), end</code>). If the match fails, it simply returns <code>None</code>.</p> <pre><code>from coloraide.spaces import srgb as base\nfrom coloraide.css import parse\n\n\nclass sRGB(base.sRGB):\n\"\"\"sRGB class.\"\"\"\n\n    # This color class should opt into the generic `color(space ...)` input format.\n    # This is `True` by default, but shown for demonstration purposes.\n    COLOR_FORMAT: True\n\n    # If the color format above is not found, continue with our custom match to handle all other formats.\n    def match(\n        self,\n        string: str,\n        start: int = 0,\n        fullmatch: bool = True\n    ) -&gt; Optional[Tuple[Tuple[Vector, float], int]]:\n\"\"\"Match a CSS color string.\"\"\"\n\n        return parse.parse_css(self, string, start, fullmatch)\n</code></pre> <p>Additionally, we control the output formats by overriding the <code>to_string()</code> function. We ensure that it accepts all the parameters we need, in our case we accept the common parameters and later check for our special inputs in <code>kwargs</code>.</p> <pre><code>    def to_string(\n        self,\n        parent: 'Color',\n        *,\n        alpha: Optional[bool] = None,\n        precision: Optional[int] = None,\n        fit: Union[bool, str] = True,\n        none: bool = False,\n        color: bool = False,\n        hex: bool = False,\n        names: bool = False,\n        comma: bool = False,\n        upper: bool = False,\n        percent: bool = False,\n        compress: bool = False,\n        **kwargs: Any\n    ) -&gt; str:\n\"\"\"Convert to CSS.\"\"\"\n\n        return serialize.serialize_css(\n            parent,\n            func='rgb',\n            alpha=alpha,\n            precision=precision,\n            fit=fit,\n            none=none,\n            color=color,\n            hexa=hex,\n            name=names,\n            legacy=comma,\n            upper=upper,\n            percent=percent,\n            compress=compress,\n            scale=255\n        )\n</code></pre> <p>As all ColorAide color spaces are defined as plugins, there should be ample examples to help someone start writing a new color space.</p>"}]}