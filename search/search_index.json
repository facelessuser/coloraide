{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Currently a Prerelease While ColorAide is very usable and out of the alpha stage, it is currently in a prerelease state. This simply means the API could still be in flux to some degree. ColorAide is still technically waiting for some issues related to CSS color syntax and behavior to be decided by the CSS Working Group. What is ColorAide? ColorAide is a color library for Python with the intent of providing an easy to use interface to work with colors. >>> from coloraide import Color >>> Color ( 'lch(75% 50 0)' ) . steps ( 'lch(75% 50 300)' , steps = 8 , space = 'lch' , hue = 'longer' ) [color(--lch 75 50 0 / 1), color(--lch 75 50 42.857 / 1), color(--lch 75 50 85.714 / 1), color(--lch 75 50 128.57 / 1), color(--lch 75 50 171.43 / 1), color(--lch 75 50 214.29 / 1), color(--lch 75 50 257.14 / 1), color(--lch 75 50 300 / 1)] from coloraide import Color Color('lch(75% 50 0)').steps('lch(75% 50 300)', steps=8, space='lch', hue='longer') Edit Share Run Cancel ColorAide is a continually evolving project, but was created with a number of specific goals in mind: Be generally easy to pick up for the average user. Support modern CSS color spaces and syntax as well as a number of popular non-CSS color spaces. Provide a plugin API to extend color spaces and more. Provide a number of useful utilities such as interpolation, color distancing, blending, gamut mapping, etc. Allow users to configure defaults to their liking. There are many color libraries out there, and ColorAide is not meant to be the one library to replace all other color libraries. In the Python community, there are a number of great libraries. Two libraries that stand out are Colour Science and Colorio , both of which are fantastic libraries, but are definitely more geared towards scientific endeavors. They provide a wealth of various spaces, illuminants, access to complex color space visualizers, and numerous esoteric tools. If you want to learn more about colors, these are great libraries to play with, but can be a little more cumbersome to use for the average user. While ColorAide could certainly be used to analyze colors, it does not aim to provide scientific tools and mainly focuses on making color usage easy and accessible in projects using colors. Installation ColorAide can be installed via Python's pip : $ pip install coloraide","title":"Introduction"},{"location":"#introduction","text":"Currently a Prerelease While ColorAide is very usable and out of the alpha stage, it is currently in a prerelease state. This simply means the API could still be in flux to some degree. ColorAide is still technically waiting for some issues related to CSS color syntax and behavior to be decided by the CSS Working Group.","title":"Introduction"},{"location":"#what-is-coloraide","text":"ColorAide is a color library for Python with the intent of providing an easy to use interface to work with colors. >>> from coloraide import Color >>> Color ( 'lch(75% 50 0)' ) . steps ( 'lch(75% 50 300)' , steps = 8 , space = 'lch' , hue = 'longer' ) [color(--lch 75 50 0 / 1), color(--lch 75 50 42.857 / 1), color(--lch 75 50 85.714 / 1), color(--lch 75 50 128.57 / 1), color(--lch 75 50 171.43 / 1), color(--lch 75 50 214.29 / 1), color(--lch 75 50 257.14 / 1), color(--lch 75 50 300 / 1)] from coloraide import Color Color('lch(75% 50 0)').steps('lch(75% 50 300)', steps=8, space='lch', hue='longer') Edit Share Run Cancel ColorAide is a continually evolving project, but was created with a number of specific goals in mind: Be generally easy to pick up for the average user. Support modern CSS color spaces and syntax as well as a number of popular non-CSS color spaces. Provide a plugin API to extend color spaces and more. Provide a number of useful utilities such as interpolation, color distancing, blending, gamut mapping, etc. Allow users to configure defaults to their liking. There are many color libraries out there, and ColorAide is not meant to be the one library to replace all other color libraries. In the Python community, there are a number of great libraries. Two libraries that stand out are Colour Science and Colorio , both of which are fantastic libraries, but are definitely more geared towards scientific endeavors. They provide a wealth of various spaces, illuminants, access to complex color space visualizers, and numerous esoteric tools. If you want to learn more about colors, these are great libraries to play with, but can be a little more cumbersome to use for the average user. While ColorAide could certainly be used to analyze colors, it does not aim to provide scientific tools and mainly focuses on making color usage easy and accessible in projects using colors.","title":"What is ColorAide?"},{"location":"#installation","text":"ColorAide can be installed via Python's pip : $ pip install coloraide","title":"Installation"},{"location":"cat/","text":"Chromatic Adaptation Chromatic adaptation is the human visual system's ability to adjust to changes in illumination in order to preserve the appearance of object colors. It is responsible for the stable appearance of object colors despite the wide variation of light which might be reflected from an object and observed by our eyes. A chromatic adaptation transform ( CAT ) emulates this important aspect of color perception in color appearance models. In short, colors look different under different lighting, and CATs are used to predict what a color should look like from one lighting source to another. Illuminants Viewing a color in daylight will look different than viewing it by candle light. Color spaces usually define a reference illuminant that clarifies the assumed lighting for the given space. For instance, sRGB is a color space defined with an illuminant of D65 (light in the shade - no direct sunlight - at noon). On the other hand, the ProPhoto RGB space uses a D50 illuminant (direct sunlight at noon). When translating a color from one illuminant to another, it is often desirable to represent that color under the new illuminant such that it appears to the eye the same as it did under the original illuminant. CATs are used to predict what the new color under the new illuminant should be in order to fulfill these requirements. For a quick example, we can demonstrate the basic principle when translating a color in the XYZ color space from a D50 illuminant to a D65 illuminant. Below, we can see that the colors look pretty much the same, even though they are now described under different illuminants. >>> d50 = Color ( 'color(xyz-d50 0.11627 0.07261 0.23256 / 1)' ) >>> d65 = d50 . convert ( 'xyz-d65' ) >>> d50 , d65 (color(xyz-d50 0.11627 0.07261 0.23256 / 1), color(xyz-d65 0.12413 0.07493 0.30933 / 1)) d50 = Color('color(xyz-d50 0.11627 0.07261 0.23256 / 1)') d65 = d50.convert('xyz-d65') d50, d65 Edit Share Run Cancel These transforms are usually designed for the XYZ color space as it operates in linear light making it the ideal place to apply the transform. Any color that must go through a CAT to account for differences in illuminants must pass through the XYZ color space. More specifically, ColorAide requires the color to pass through XYZ D65 space as that will trigger the chromatic adaptation. For instance, if a color space such as ProPhoto is being translated to sRGB, ProPhoto will first be transformed to XYZ D50, then XYZ D65 which will trigger the chromatic adaptation, next to Linear sRGB, and lastly sRGB. So, we can actually do this manually and compare the results to what we did above. In order to do this, we need to provide the specified \"white point\" for the source color and the \"white point\" for the destination color along with the XYZ coordinates we wish to transform. ColorAide uses the Bradford CAT by default, so we will specify that CAT for consistency. >>> from coloraide import cat >>> Color ( 'color(xyz-d50 0.11627 0.07261 0.23256 / 1)' ) . convert ( 'xyz-d65' ) . coords () [0.1241272855013134, 0.07493061731402745, 0.3093325898995686] >>> cat . chromatic_adaptation ( cat . WHITES [ '2deg' ][ \"D50\" ], cat . WHITES [ '2deg' ][ \"D65\" ], [ 0.11627 , 0.07261 , 0.23256 ], 'bradford' ) [0.1241272855013134, 0.07493061731402745, 0.3093325898995686] from coloraide import cat Color('color(xyz-d50 0.11627 0.07261 0.23256 / 1)').convert('xyz-d65').coords() cat.chromatic_adaptation(cat.WHITES['2deg'][\"D50\"], cat.WHITES['2deg'][\"D65\"], [0.11627, 0.07261, 0.23256], 'bradford') Edit Share Run Cancel ColorAide, currently defines the following illuminants for both 2\u02da observer and 10\u02da observer, but most people are probably only concerned with D65 and D50 (2\u02da degree observer) which are the only the illuminants used in the default color spaces provided by ColorAide. Illuminants A B C D50 D55 D65 D75 E F2 F7 F11 Supported CATs There are various CATs , all varying in complexity and accuracy. We will not go through all of them and instead will leave that up to the user to research as needed. Suffice it to say, the Bradford CAT is currently the industry standard (in most cases), but there are a variety of options available, and research continues to try and improve upon CATs of the past to come up with better CATs for the future. Currently, ColorAide mainly supports von Kries type CATs (named after an early 20 th century color scientist), or CATs that are similar to and/or are built upon the original von Kries CAT . We also do not currently support every known von Kries CAT out there, but a good number are available. In the future, support may be expanded. CAT bradford von-kries xyz-scaling sharp cat02 cat16 cmccat97 cmccat2000 Changing the Default CAT Changing the default CAT is easy and follows the same pattern as the rest of the available class overrides . Simply derive a new Color () class from the original and override the CHROMATIC_ADAPTATION property with the name of the desired CAT . Afterwards, all color transforms will use the specified CAT . >>> class Custom ( Color ): ... CHROMATIC_ADAPTATION = 'cat02' ... >>> d50 = Custom ( 'color(xyz-d50 0.11627 0.07261 0.23256 / 1)' ) >>> d65 = d50 . convert ( 'xyz-d65' ) >>> d50 , d65 (color(xyz-d50 0.11627 0.07261 0.23256 / 1), color(xyz-d65 0.12476 0.07614 0.30581 / 1)) class Custom(Color): CHROMATIC_ADAPTATION = 'cat02' d50 = Custom('color(xyz-d50 0.11627 0.07261 0.23256 / 1)') d65 = d50.convert('xyz-d65') d50, d65 Edit Share Run Cancel","title":"Chromatic Adaptation"},{"location":"cat/#chromatic-adaptation","text":"Chromatic adaptation is the human visual system's ability to adjust to changes in illumination in order to preserve the appearance of object colors. It is responsible for the stable appearance of object colors despite the wide variation of light which might be reflected from an object and observed by our eyes. A chromatic adaptation transform ( CAT ) emulates this important aspect of color perception in color appearance models. In short, colors look different under different lighting, and CATs are used to predict what a color should look like from one lighting source to another.","title":"Chromatic Adaptation"},{"location":"cat/#illuminants","text":"Viewing a color in daylight will look different than viewing it by candle light. Color spaces usually define a reference illuminant that clarifies the assumed lighting for the given space. For instance, sRGB is a color space defined with an illuminant of D65 (light in the shade - no direct sunlight - at noon). On the other hand, the ProPhoto RGB space uses a D50 illuminant (direct sunlight at noon). When translating a color from one illuminant to another, it is often desirable to represent that color under the new illuminant such that it appears to the eye the same as it did under the original illuminant. CATs are used to predict what the new color under the new illuminant should be in order to fulfill these requirements. For a quick example, we can demonstrate the basic principle when translating a color in the XYZ color space from a D50 illuminant to a D65 illuminant. Below, we can see that the colors look pretty much the same, even though they are now described under different illuminants. >>> d50 = Color ( 'color(xyz-d50 0.11627 0.07261 0.23256 / 1)' ) >>> d65 = d50 . convert ( 'xyz-d65' ) >>> d50 , d65 (color(xyz-d50 0.11627 0.07261 0.23256 / 1), color(xyz-d65 0.12413 0.07493 0.30933 / 1)) d50 = Color('color(xyz-d50 0.11627 0.07261 0.23256 / 1)') d65 = d50.convert('xyz-d65') d50, d65 Edit Share Run Cancel These transforms are usually designed for the XYZ color space as it operates in linear light making it the ideal place to apply the transform. Any color that must go through a CAT to account for differences in illuminants must pass through the XYZ color space. More specifically, ColorAide requires the color to pass through XYZ D65 space as that will trigger the chromatic adaptation. For instance, if a color space such as ProPhoto is being translated to sRGB, ProPhoto will first be transformed to XYZ D50, then XYZ D65 which will trigger the chromatic adaptation, next to Linear sRGB, and lastly sRGB. So, we can actually do this manually and compare the results to what we did above. In order to do this, we need to provide the specified \"white point\" for the source color and the \"white point\" for the destination color along with the XYZ coordinates we wish to transform. ColorAide uses the Bradford CAT by default, so we will specify that CAT for consistency. >>> from coloraide import cat >>> Color ( 'color(xyz-d50 0.11627 0.07261 0.23256 / 1)' ) . convert ( 'xyz-d65' ) . coords () [0.1241272855013134, 0.07493061731402745, 0.3093325898995686] >>> cat . chromatic_adaptation ( cat . WHITES [ '2deg' ][ \"D50\" ], cat . WHITES [ '2deg' ][ \"D65\" ], [ 0.11627 , 0.07261 , 0.23256 ], 'bradford' ) [0.1241272855013134, 0.07493061731402745, 0.3093325898995686] from coloraide import cat Color('color(xyz-d50 0.11627 0.07261 0.23256 / 1)').convert('xyz-d65').coords() cat.chromatic_adaptation(cat.WHITES['2deg'][\"D50\"], cat.WHITES['2deg'][\"D65\"], [0.11627, 0.07261, 0.23256], 'bradford') Edit Share Run Cancel ColorAide, currently defines the following illuminants for both 2\u02da observer and 10\u02da observer, but most people are probably only concerned with D65 and D50 (2\u02da degree observer) which are the only the illuminants used in the default color spaces provided by ColorAide. Illuminants A B C D50 D55 D65 D75 E F2 F7 F11","title":"Illuminants"},{"location":"cat/#supported-cats","text":"There are various CATs , all varying in complexity and accuracy. We will not go through all of them and instead will leave that up to the user to research as needed. Suffice it to say, the Bradford CAT is currently the industry standard (in most cases), but there are a variety of options available, and research continues to try and improve upon CATs of the past to come up with better CATs for the future. Currently, ColorAide mainly supports von Kries type CATs (named after an early 20 th century color scientist), or CATs that are similar to and/or are built upon the original von Kries CAT . We also do not currently support every known von Kries CAT out there, but a good number are available. In the future, support may be expanded. CAT bradford von-kries xyz-scaling sharp cat02 cat16 cmccat97 cmccat2000","title":"Supported CATs"},{"location":"cat/#changing-the-default-cat","text":"Changing the default CAT is easy and follows the same pattern as the rest of the available class overrides . Simply derive a new Color () class from the original and override the CHROMATIC_ADAPTATION property with the name of the desired CAT . Afterwards, all color transforms will use the specified CAT . >>> class Custom ( Color ): ... CHROMATIC_ADAPTATION = 'cat02' ... >>> d50 = Custom ( 'color(xyz-d50 0.11627 0.07261 0.23256 / 1)' ) >>> d65 = d50 . convert ( 'xyz-d65' ) >>> d50 , d65 (color(xyz-d50 0.11627 0.07261 0.23256 / 1), color(xyz-d65 0.12476 0.07614 0.30581 / 1)) class Custom(Color): CHROMATIC_ADAPTATION = 'cat02' d50 = Custom('color(xyz-d50 0.11627 0.07261 0.23256 / 1)') d65 = d50.convert('xyz-d65') d50, d65 Edit Share Run Cancel","title":"Changing the Default CAT"},{"location":"color/","text":"The Color Object The Color object is where all the magic of ColorAide happens. In order to manipulate, interpolate, or perform any action on a color, we must first create one. There are a number of ways to instantiate new colors. Here we will cover basic creating, cloning, and updating of the Color class object and a few other class specific topics. Creating Colors The Color object contains all the logic to create and manipulate colors. It can be imported from coloraide . from coloraide import Color Afterwards, colors can be created using various, valid CSS syntax. Syntax includes legacy formats as defined in CSS Level 3, but also contains CSS Level 4! >>> Color ( \"red\" ) color(srgb 1 0 0 / 1) >>> Color ( \"#00ff00\" ) color(srgb 0 1 0 / 1) >>> Color ( \"rgb(0 0 255 / 1)\" ) color(srgb 0 0 1 / 1) Color(\"red\") Color(\"#00ff00\") Color(\"rgb(0 0 255 / 1)\") Edit Share Run Cancel Warning: CSS Level 4 Though CSS Level 4 is supported, the CSS spec is not finalized and there could be some churn in relation to the syntax as browsers begin to implement the spec, there may be changes. ColorAide, not only supports colors in the CSS spec, but also some other additional color spaces as well. To bridge the gap with syntax, ColorAide allows all colors, whether in the CSS spec or not, to be recognized using the CSS color function ( color ( space coord ... / alpha ) ). Even if the color is in the CSS spec and is not currently specified to use the color () function, we still allow it. Essentially, we've adopted the color () function as the universal way in which to serialize colors. If the CSS spec does not formally recognize a color in this form, the color identifier will use the two dashes as a prefix ( --color-id ). Check the documentation of the given color space to discover the appropriate CSS identifier name as the CSS identifier may not always match the color space name as specified in ColorAide. >>> Color ( 'color(--hsl 130 40 % 75% / 0.5)' ) color(--hsl 130 0.4 0.75 / 0.5) Color('color(--hsl 130 40% 75% / 0.5)') Edit Share Run Cancel While CSS input is useful, we can also insert raw data points directly. When doing things this way, we must be mindful of the actual accepted input range. For instance, RGB colors are not specified in ranges from 0 - 255, but from 0 - 1. >>> Color ( \"srgb\" , [ 0.5 , 0 , 1 ], 0.3 ) color(srgb 0.5 0 1 / 0.3) Color(\"srgb\", [0.5, 0, 1], 0.3) Edit Share Run Cancel Colors can also be exported to and receive input from simple dictionaries. These can be useful when serializing to JSON or various other reasons. The space key and all relevant color channels must be specified when constructing a color object from a dictionary, alpha is the only optional channel and will be assumed as 1 if omitted. Default channel names must currently be used (no aliases). >>> d = Color ( 'red' ) . to_dict () >>> print ( d ) {'space': 'srgb', 'r': 1.0, 'g': 0.0, 'b': 0.0, 'alpha': 1.0} >>> Color ( d ) color(srgb 1 0 0 / 1) d = Color('red').to_dict() print(d) Color(d) Edit Share Run Cancel If another color instance is passed as the input, a new color will be created, essentially cloning the passed object. >>> c1 = Color ( 'red' ) >>> c2 = Color ( c1 ) >>> c1 , c2 (color(srgb 1 0 0 / 1), color(srgb 1 0 0 / 1)) c1 = Color('red') c2 = Color(c1) c1, c2 Edit Share Run Cancel You can also use the new method to generate new colors from already instantiated color objects. >>> color1 = Color ( \"red\" ) >>> color1 color(srgb 1 0 0 / 1) >>> color1 . new ( \"blue\" ) color(srgb 0 0 1 / 1) color1 = Color(\"red\") color1 color1.new(\"blue\") Edit Share Run Cancel If desired, all creation methods can be have a color space filter list passed in. The filter list will prevent an input which specifies a color space found in our list to not be accepted. Use a filter will constrain inputs to supported color spaces not found in the list. >>> try : ... Color ( \"red\" , filters = [ \"hsl\" ]) ... except ValueError : ... print ( 'Not a valid color' ) ... Not a valid color >>> Color ( \"hsl(130 30 % 75% )\" , filters = [ \"hsl\" ]) color(--hsl 130 0.3 0.75 / 1) try: Color(\"red\", filters=[\"hsl\"]) except ValueError: print('Not a valid color') Color(\"hsl(130 30% 75%)\", filters=[\"hsl\"]) Edit Share Run Cancel Cloning The clone method is an easy way to duplicate the current color object. Here we clone the green object, giving us two. >>> c1 = Color ( \"green\" ) >>> c1 color(srgb 0 0.50196 0 / 1) >>> c1 . clone () color(srgb 0 0.50196 0 / 1) c1 = Color(\"green\") c1 c1.clone() Edit Share Run Cancel Updating A color can be \"updated\" using another color input. When an update occurs, the current color space is updated from the data of the second color, but the color space does not change. Using update is the equivalent of converting the second color to the color space of the first and then updating all the coordinates (including alpha). The input parameters are identical to the new method, so we can use a color object, a color string, or even raw data points. Here we update the color red to the color blue : >>> Color ( \"red\" ) color(srgb 1 0 0 / 1) >>> Color ( \"red\" ) . update ( Color ( \"blue\" )) color(srgb 0 0 1 / 1) Color(\"red\") Color(\"red\").update(Color(\"blue\")) Edit Share Run Cancel Here we update the sRGB red with the color lch ( 80 % 50 130 ) . >>> Color ( \"red\" ) . update ( \"lch(80% 50 130)\" ) color(srgb 0.60392 0.8398 0.48396 / 1) Color(\"red\").update(\"lch(80% 50 130)\") Edit Share Run Cancel Mutating \"Mutating\" is similar to updating except that it will update the color and the color space from another color. The input parameters are identical to the new method, so we can use a color object, a color string, or even raw data points. In this example, the red color object literally becomes the specified CIELCH color of lch ( 80 % 50 130 ) . >>> Color ( \"red\" ) . mutate ( \"lch(80% 50 130)\" ) color(--lch 80 50 130 / 1) Color(\"red\").mutate(\"lch(80% 50 130)\") Edit Share Run Cancel Converting Colors can be converted to other color spaces as needed. Converting will always return a new color unless the in_place parameter is set to True , in which case, the current color will be mutated to the new converted color and a reference to itself is returned. For instance, if we had a color yellow , and we needed to work with it in another color space, such as CIELAB, we could simply call the convert method with the desired color space. >>> Color ( 'yellow' ) . convert ( \"lab\" ) color(--lab 97.607 -15.75 93.394 / 1) Color('yellow').convert(\"lab\") Edit Share Run Cancel Color Matching As previously mentioned, the Color () object can parse CSS style string inputs. The string matching logic is exposed via the match method. We can simply pass match a string, and, if the string is a valid color, a ColorMatch object will be returned. The ColorMatch object has a simple structure that contains the matched color as a Color object, and the start and end points it was located at. >>> Color . match ( \"red\" ) ColorMatch(color=color(srgb 1 0 0 / 1), start=0, end=3) Color.match(\"red\") Edit Share Run Cancel By default it matches at the start of the buffer and returns a color if it finds one. If desired, we can do a fullmatch which requires the entire buffer to match a color. >>> Color . match ( \"red and yellow\" ) ColorMatch(color=color(srgb 1 0 0 / 1), start=0, end=3) >>> Color . match ( \"red and yellow\" , fullmatch = True ) Color.match(\"red and yellow\") Color.match(\"red and yellow\", fullmatch=True) Edit Share Run Cancel We can also adjust the start position of the search. In this case, by adjusting the start position to 8 characters later, we will match yellow instead of red . >>> Color . match ( \"red and yellow\" , start = 8 ) ColorMatch(color=color(srgb 1 1 0 / 1), start=8, end=14) Color.match(\"red and yellow\", start=8) Edit Share Run Cancel Filtering unwanted color spaces is also available via the filter parameter, and is typically how creation methods avoid parsing unwanted color spaces. >>> Color . match ( \"red and yellow\" , filters = [ \"hsl\" ]) >>> Color . match ( \"hsl(130 30 % 75% )\" , filters = [ \"hsl\" ]) ColorMatch(color=color(--hsl 130 0.3 0.75 / 1), start=0, end=16) Color.match(\"red and yellow\", filters=[\"hsl\"]) Color.match(\"hsl(130 30% 75%)\", filters=[\"hsl\"]) Edit Share Run Cancel A method to find all colors in a buffer is not currently provided as looping through all the color spaces and matching all potential colors on every character is not really efficient. Additionally, some buffers may require additional context that is not available to the match function. If such behavior is desired, it is recommended to apply some additional logic to sniff out areas with high likelihood of having a color. In the following example, we construct a regular expression to find places within the buffer that potentially have a valid color. As the buffer is an HTML document we also want to incorporate some context to avoid matching HTML entities or color names that are part of a CSS variable. Once we've crafted our regular expression, we can search the buffer to find locations in the buffer that are likely to be colors. Then we can run Color.match() on those positions within the buffer to see if we find a valid color! >>> import re >>> from coloraide import Color >>> RE_COLOR_START = re . compile ( r \"(?i)(?:\\b(?<![-#&$])(?:color\\((?!\\s*-)|(?:hsla?|lch|lab|hwb|rgba?)\\()|\\b(?<![-#&$])[\\w]{3,}(?![(-])\\b|(?<![&])#)\" ) >>> text = \"\"\" ... <html> ... <head> ... <style> ... body { ... background-color: red; ... color: yellow; ... } ... </style> ... </head> ... <body> ... <p>This is a test <span style=\"background-color: #000088; color: lch(75% 50 50)\">test</span></p> ... </body> ... </html> ... \"\"\" >>> colors = [] >>> for m in RE_COLOR_START . finditer ( text ): ... start = m . start () ... mcolor = Color . match ( text , start = start ) ... if mcolor is not None : ... colors . append ( mcolor . color ) ... >>> [ x . to_string () for x in colors ] ['rgb(255 0 0)', 'rgb(255 255 0)', 'rgb(0 0 136)', 'lch(75% 50 50)'] import re from coloraide import Color RE_COLOR_START = re.compile(r\"(?i)(?:\\b(?<![-#&$])(?:color\\((?!\\s*-)|(?:hsla?|lch|lab|hwb|rgba?)\\()|\\b(?<![-#&$])[\\w]{3,}(?![(-])\\b|(?<![&])#)\") text = \"\"\" <html> <head> <style> body { background-color: red; color: yellow; } </style> </head> <body> <p>This is a test <span style=\"background-color: #000088; color: lch(75% 50 50)\">test</span></p> </body> </html> \"\"\" colors = [] for m in RE_COLOR_START.finditer(text): start = m.start() mcolor = Color.match(text, start=start) if mcolor is not None: colors.append(mcolor.color) [x.to_string() for x in colors] Edit Share Run Cancel Custom Color Classes In general, it is always recommended to subclass the Color object when setting up custom preferences or adding or removing plugins. This prevents modifying the base class which may affect other libraries relying on the module. When Color is subclassed, it is safe to then update global overrides or register and deregister plugins without the worry of affecting the base class. Override Default Settings ColorAide has a number of preferences that can be altered in the Color class. Most of these options can be configured on demand when calling into a function that uses theme, but it may be useful to setup a new defaults so that the Color object behaves how you prefer. >>> class Color2 ( Color ): ... PRECISION = 3 ... >>> Color ( 'rgb(128.12345 0 128.12345)' ) . to_string () rgb(128.12 0 128.12) >>> Color2 ( 'rgb(128.12345 0 128.12345)' ) . to_string () rgb(128 0 128) class Color2(Color): PRECISION = 3 Color('rgb(128.12345 0 128.12345)').to_string() Color2('rgb(128.12345 0 128.12345)').to_string() Edit Share Run Cancel Properties Defaults Description FIT \"lch-chroma\" The default gamut mapping method used by the Color object. INTERPOLATE \"oklab\" The default color space used for interpolation. DELTA_E \"76\" The default \u2206E algorithm used. This applies to when delta_e() is called without specifying a method or when using color distancing to separate color when using the interpolation method called steps . PRECISION 5 The default precision for string outputs. CHROMATIC_ADAPTATION \"bradford\" Chromatic adaptation method used when converting between two color spaces with different white points. See Chromatic Adaptation for more information. Plugins Currently, only color spaces, delta E methods, and gamut mapping methods are exposed as plugins. Some potential, useful cases: register a new color spaces not supported directly in ColorAide, test out a new \u2206E algorithm, experiment with a potentially better gamut mapping method, tweak an existing color space to accept and output color strings in a new format, create a variant of a color space that uses a different white point than is currently supported, etc. If you wanted a more lightweight Color object, you could deregister color spaces you don't need. Though, keep in mind that some color spaces are essential, like XYZ D65 which is used in many color conversions. Removing some colors could also break functionality of certain features that are reliant on a specific color space, such as CIELAB which is used for \u2206E * 2000 color distancing or CIELCH which is used in the the LCH Chroma gamut mapping, but both could also be deregistered to avoid issues. While we will not go into creating plugins here, we will go over how to register new plugins and deregister existing plugins. To learn more about creating plugins, checkout the plugin documentation . Registration is performed by the register method. It can take a single plugin or a list of plugins. Based on the plugin's type, The Color object will determine how to properly register the plugin. If the plugin attempts to overwrite a plugin already registered with the same name (as dictated by the plugin) the operation will fail. If overwrite is set to True , the overwrite will not fail and the new plugin will be registered with the specified name in place of the existing plugin. Here is an example creating a custom XYZ color space using the D55 white point. >>> from coloraide.cat import WHITES >>> from coloraide.spaces.xyz_d65 import XYZD65 >>> class XYZD55 ( XYZD65 ): ... BASE = \"xyz-d65\" ... NAME = \"xyz-d55\" ... SERIALIZE = ( \"xyz-d55\" ,) ... WHITE = WHITES [ '2deg' ][ 'D55' ] ... >>> class Custom ( Color ): ... ... >>> Custom . register ( XYZD55 ) >>> Custom ( 'red' ) . convert ( 'xyz-d55' ) color(xyz-d55 0.42644 0.21852 0.01591 / 1) from coloraide.cat import WHITES from coloraide.spaces.xyz_d65 import XYZD65 class XYZD55(XYZD65): BASE = \"xyz-d65\" NAME = \"xyz-d55\" SERIALIZE = (\"xyz-d55\",) WHITE = WHITES['2deg']['D55'] class Custom(Color): ... Custom.register(XYZD55) Custom('red').convert('xyz-d55') Edit Share Run Cancel If a deregistration was desired, the deregister method can be used. It takes a string that describes the plugin to deregister: category:name . Valid categories are space , delta-e , and fit . If the given plugin is not found, an error will be thrown, but if this notification is found to be unnecessary, silent can be enabled and the there will be no error thrown. >>> class Custom ( Color ): ... ... >>> Custom . deregister ( 'space:jzazbz' ) >>> try : ... Custom ( 'red' ) . convert ( 'jzazbz' ) ... except ValueError : ... print ( 'Could not convert to Jzazbz as it is no longer registered' ) ... Could not convert to Jzazbz as it is no longer registered class Custom(Color): ... Custom.deregister('space:jzazbz') try: Custom('red').convert('jzazbz') except ValueError: print('Could not convert to Jzazbz as it is no longer registered') Edit Share Run Cancel Use of * with deregister will remove all plugins. Use of category:* will remove all plugins of that category.","title":"The Color Object"},{"location":"color/#the-color-object","text":"The Color object is where all the magic of ColorAide happens. In order to manipulate, interpolate, or perform any action on a color, we must first create one. There are a number of ways to instantiate new colors. Here we will cover basic creating, cloning, and updating of the Color class object and a few other class specific topics.","title":"The Color Object"},{"location":"color/#creating-colors","text":"The Color object contains all the logic to create and manipulate colors. It can be imported from coloraide . from coloraide import Color Afterwards, colors can be created using various, valid CSS syntax. Syntax includes legacy formats as defined in CSS Level 3, but also contains CSS Level 4! >>> Color ( \"red\" ) color(srgb 1 0 0 / 1) >>> Color ( \"#00ff00\" ) color(srgb 0 1 0 / 1) >>> Color ( \"rgb(0 0 255 / 1)\" ) color(srgb 0 0 1 / 1) Color(\"red\") Color(\"#00ff00\") Color(\"rgb(0 0 255 / 1)\") Edit Share Run Cancel Warning: CSS Level 4 Though CSS Level 4 is supported, the CSS spec is not finalized and there could be some churn in relation to the syntax as browsers begin to implement the spec, there may be changes. ColorAide, not only supports colors in the CSS spec, but also some other additional color spaces as well. To bridge the gap with syntax, ColorAide allows all colors, whether in the CSS spec or not, to be recognized using the CSS color function ( color ( space coord ... / alpha ) ). Even if the color is in the CSS spec and is not currently specified to use the color () function, we still allow it. Essentially, we've adopted the color () function as the universal way in which to serialize colors. If the CSS spec does not formally recognize a color in this form, the color identifier will use the two dashes as a prefix ( --color-id ). Check the documentation of the given color space to discover the appropriate CSS identifier name as the CSS identifier may not always match the color space name as specified in ColorAide. >>> Color ( 'color(--hsl 130 40 % 75% / 0.5)' ) color(--hsl 130 0.4 0.75 / 0.5) Color('color(--hsl 130 40% 75% / 0.5)') Edit Share Run Cancel While CSS input is useful, we can also insert raw data points directly. When doing things this way, we must be mindful of the actual accepted input range. For instance, RGB colors are not specified in ranges from 0 - 255, but from 0 - 1. >>> Color ( \"srgb\" , [ 0.5 , 0 , 1 ], 0.3 ) color(srgb 0.5 0 1 / 0.3) Color(\"srgb\", [0.5, 0, 1], 0.3) Edit Share Run Cancel Colors can also be exported to and receive input from simple dictionaries. These can be useful when serializing to JSON or various other reasons. The space key and all relevant color channels must be specified when constructing a color object from a dictionary, alpha is the only optional channel and will be assumed as 1 if omitted. Default channel names must currently be used (no aliases). >>> d = Color ( 'red' ) . to_dict () >>> print ( d ) {'space': 'srgb', 'r': 1.0, 'g': 0.0, 'b': 0.0, 'alpha': 1.0} >>> Color ( d ) color(srgb 1 0 0 / 1) d = Color('red').to_dict() print(d) Color(d) Edit Share Run Cancel If another color instance is passed as the input, a new color will be created, essentially cloning the passed object. >>> c1 = Color ( 'red' ) >>> c2 = Color ( c1 ) >>> c1 , c2 (color(srgb 1 0 0 / 1), color(srgb 1 0 0 / 1)) c1 = Color('red') c2 = Color(c1) c1, c2 Edit Share Run Cancel You can also use the new method to generate new colors from already instantiated color objects. >>> color1 = Color ( \"red\" ) >>> color1 color(srgb 1 0 0 / 1) >>> color1 . new ( \"blue\" ) color(srgb 0 0 1 / 1) color1 = Color(\"red\") color1 color1.new(\"blue\") Edit Share Run Cancel If desired, all creation methods can be have a color space filter list passed in. The filter list will prevent an input which specifies a color space found in our list to not be accepted. Use a filter will constrain inputs to supported color spaces not found in the list. >>> try : ... Color ( \"red\" , filters = [ \"hsl\" ]) ... except ValueError : ... print ( 'Not a valid color' ) ... Not a valid color >>> Color ( \"hsl(130 30 % 75% )\" , filters = [ \"hsl\" ]) color(--hsl 130 0.3 0.75 / 1) try: Color(\"red\", filters=[\"hsl\"]) except ValueError: print('Not a valid color') Color(\"hsl(130 30% 75%)\", filters=[\"hsl\"]) Edit Share Run Cancel","title":"Creating Colors"},{"location":"color/#cloning","text":"The clone method is an easy way to duplicate the current color object. Here we clone the green object, giving us two. >>> c1 = Color ( \"green\" ) >>> c1 color(srgb 0 0.50196 0 / 1) >>> c1 . clone () color(srgb 0 0.50196 0 / 1) c1 = Color(\"green\") c1 c1.clone() Edit Share Run Cancel","title":"Cloning"},{"location":"color/#updating","text":"A color can be \"updated\" using another color input. When an update occurs, the current color space is updated from the data of the second color, but the color space does not change. Using update is the equivalent of converting the second color to the color space of the first and then updating all the coordinates (including alpha). The input parameters are identical to the new method, so we can use a color object, a color string, or even raw data points. Here we update the color red to the color blue : >>> Color ( \"red\" ) color(srgb 1 0 0 / 1) >>> Color ( \"red\" ) . update ( Color ( \"blue\" )) color(srgb 0 0 1 / 1) Color(\"red\") Color(\"red\").update(Color(\"blue\")) Edit Share Run Cancel Here we update the sRGB red with the color lch ( 80 % 50 130 ) . >>> Color ( \"red\" ) . update ( \"lch(80% 50 130)\" ) color(srgb 0.60392 0.8398 0.48396 / 1) Color(\"red\").update(\"lch(80% 50 130)\") Edit Share Run Cancel","title":"Updating"},{"location":"color/#mutating","text":"\"Mutating\" is similar to updating except that it will update the color and the color space from another color. The input parameters are identical to the new method, so we can use a color object, a color string, or even raw data points. In this example, the red color object literally becomes the specified CIELCH color of lch ( 80 % 50 130 ) . >>> Color ( \"red\" ) . mutate ( \"lch(80% 50 130)\" ) color(--lch 80 50 130 / 1) Color(\"red\").mutate(\"lch(80% 50 130)\") Edit Share Run Cancel","title":"Mutating"},{"location":"color/#converting","text":"Colors can be converted to other color spaces as needed. Converting will always return a new color unless the in_place parameter is set to True , in which case, the current color will be mutated to the new converted color and a reference to itself is returned. For instance, if we had a color yellow , and we needed to work with it in another color space, such as CIELAB, we could simply call the convert method with the desired color space. >>> Color ( 'yellow' ) . convert ( \"lab\" ) color(--lab 97.607 -15.75 93.394 / 1) Color('yellow').convert(\"lab\") Edit Share Run Cancel","title":"Converting"},{"location":"color/#color-matching","text":"As previously mentioned, the Color () object can parse CSS style string inputs. The string matching logic is exposed via the match method. We can simply pass match a string, and, if the string is a valid color, a ColorMatch object will be returned. The ColorMatch object has a simple structure that contains the matched color as a Color object, and the start and end points it was located at. >>> Color . match ( \"red\" ) ColorMatch(color=color(srgb 1 0 0 / 1), start=0, end=3) Color.match(\"red\") Edit Share Run Cancel By default it matches at the start of the buffer and returns a color if it finds one. If desired, we can do a fullmatch which requires the entire buffer to match a color. >>> Color . match ( \"red and yellow\" ) ColorMatch(color=color(srgb 1 0 0 / 1), start=0, end=3) >>> Color . match ( \"red and yellow\" , fullmatch = True ) Color.match(\"red and yellow\") Color.match(\"red and yellow\", fullmatch=True) Edit Share Run Cancel We can also adjust the start position of the search. In this case, by adjusting the start position to 8 characters later, we will match yellow instead of red . >>> Color . match ( \"red and yellow\" , start = 8 ) ColorMatch(color=color(srgb 1 1 0 / 1), start=8, end=14) Color.match(\"red and yellow\", start=8) Edit Share Run Cancel Filtering unwanted color spaces is also available via the filter parameter, and is typically how creation methods avoid parsing unwanted color spaces. >>> Color . match ( \"red and yellow\" , filters = [ \"hsl\" ]) >>> Color . match ( \"hsl(130 30 % 75% )\" , filters = [ \"hsl\" ]) ColorMatch(color=color(--hsl 130 0.3 0.75 / 1), start=0, end=16) Color.match(\"red and yellow\", filters=[\"hsl\"]) Color.match(\"hsl(130 30% 75%)\", filters=[\"hsl\"]) Edit Share Run Cancel A method to find all colors in a buffer is not currently provided as looping through all the color spaces and matching all potential colors on every character is not really efficient. Additionally, some buffers may require additional context that is not available to the match function. If such behavior is desired, it is recommended to apply some additional logic to sniff out areas with high likelihood of having a color. In the following example, we construct a regular expression to find places within the buffer that potentially have a valid color. As the buffer is an HTML document we also want to incorporate some context to avoid matching HTML entities or color names that are part of a CSS variable. Once we've crafted our regular expression, we can search the buffer to find locations in the buffer that are likely to be colors. Then we can run Color.match() on those positions within the buffer to see if we find a valid color! >>> import re >>> from coloraide import Color >>> RE_COLOR_START = re . compile ( r \"(?i)(?:\\b(?<![-#&$])(?:color\\((?!\\s*-)|(?:hsla?|lch|lab|hwb|rgba?)\\()|\\b(?<![-#&$])[\\w]{3,}(?![(-])\\b|(?<![&])#)\" ) >>> text = \"\"\" ... <html> ... <head> ... <style> ... body { ... background-color: red; ... color: yellow; ... } ... </style> ... </head> ... <body> ... <p>This is a test <span style=\"background-color: #000088; color: lch(75% 50 50)\">test</span></p> ... </body> ... </html> ... \"\"\" >>> colors = [] >>> for m in RE_COLOR_START . finditer ( text ): ... start = m . start () ... mcolor = Color . match ( text , start = start ) ... if mcolor is not None : ... colors . append ( mcolor . color ) ... >>> [ x . to_string () for x in colors ] ['rgb(255 0 0)', 'rgb(255 255 0)', 'rgb(0 0 136)', 'lch(75% 50 50)'] import re from coloraide import Color RE_COLOR_START = re.compile(r\"(?i)(?:\\b(?<![-#&$])(?:color\\((?!\\s*-)|(?:hsla?|lch|lab|hwb|rgba?)\\()|\\b(?<![-#&$])[\\w]{3,}(?![(-])\\b|(?<![&])#)\") text = \"\"\" <html> <head> <style> body { background-color: red; color: yellow; } </style> </head> <body> <p>This is a test <span style=\"background-color: #000088; color: lch(75% 50 50)\">test</span></p> </body> </html> \"\"\" colors = [] for m in RE_COLOR_START.finditer(text): start = m.start() mcolor = Color.match(text, start=start) if mcolor is not None: colors.append(mcolor.color) [x.to_string() for x in colors] Edit Share Run Cancel","title":"Color Matching"},{"location":"color/#custom-color-classes","text":"In general, it is always recommended to subclass the Color object when setting up custom preferences or adding or removing plugins. This prevents modifying the base class which may affect other libraries relying on the module. When Color is subclassed, it is safe to then update global overrides or register and deregister plugins without the worry of affecting the base class.","title":"Custom Color Classes"},{"location":"color/#override-default-settings","text":"ColorAide has a number of preferences that can be altered in the Color class. Most of these options can be configured on demand when calling into a function that uses theme, but it may be useful to setup a new defaults so that the Color object behaves how you prefer. >>> class Color2 ( Color ): ... PRECISION = 3 ... >>> Color ( 'rgb(128.12345 0 128.12345)' ) . to_string () rgb(128.12 0 128.12) >>> Color2 ( 'rgb(128.12345 0 128.12345)' ) . to_string () rgb(128 0 128) class Color2(Color): PRECISION = 3 Color('rgb(128.12345 0 128.12345)').to_string() Color2('rgb(128.12345 0 128.12345)').to_string() Edit Share Run Cancel Properties Defaults Description FIT \"lch-chroma\" The default gamut mapping method used by the Color object. INTERPOLATE \"oklab\" The default color space used for interpolation. DELTA_E \"76\" The default \u2206E algorithm used. This applies to when delta_e() is called without specifying a method or when using color distancing to separate color when using the interpolation method called steps . PRECISION 5 The default precision for string outputs. CHROMATIC_ADAPTATION \"bradford\" Chromatic adaptation method used when converting between two color spaces with different white points. See Chromatic Adaptation for more information.","title":"Override Default Settings"},{"location":"color/#plugins","text":"Currently, only color spaces, delta E methods, and gamut mapping methods are exposed as plugins. Some potential, useful cases: register a new color spaces not supported directly in ColorAide, test out a new \u2206E algorithm, experiment with a potentially better gamut mapping method, tweak an existing color space to accept and output color strings in a new format, create a variant of a color space that uses a different white point than is currently supported, etc. If you wanted a more lightweight Color object, you could deregister color spaces you don't need. Though, keep in mind that some color spaces are essential, like XYZ D65 which is used in many color conversions. Removing some colors could also break functionality of certain features that are reliant on a specific color space, such as CIELAB which is used for \u2206E * 2000 color distancing or CIELCH which is used in the the LCH Chroma gamut mapping, but both could also be deregistered to avoid issues. While we will not go into creating plugins here, we will go over how to register new plugins and deregister existing plugins. To learn more about creating plugins, checkout the plugin documentation . Registration is performed by the register method. It can take a single plugin or a list of plugins. Based on the plugin's type, The Color object will determine how to properly register the plugin. If the plugin attempts to overwrite a plugin already registered with the same name (as dictated by the plugin) the operation will fail. If overwrite is set to True , the overwrite will not fail and the new plugin will be registered with the specified name in place of the existing plugin. Here is an example creating a custom XYZ color space using the D55 white point. >>> from coloraide.cat import WHITES >>> from coloraide.spaces.xyz_d65 import XYZD65 >>> class XYZD55 ( XYZD65 ): ... BASE = \"xyz-d65\" ... NAME = \"xyz-d55\" ... SERIALIZE = ( \"xyz-d55\" ,) ... WHITE = WHITES [ '2deg' ][ 'D55' ] ... >>> class Custom ( Color ): ... ... >>> Custom . register ( XYZD55 ) >>> Custom ( 'red' ) . convert ( 'xyz-d55' ) color(xyz-d55 0.42644 0.21852 0.01591 / 1) from coloraide.cat import WHITES from coloraide.spaces.xyz_d65 import XYZD65 class XYZD55(XYZD65): BASE = \"xyz-d65\" NAME = \"xyz-d55\" SERIALIZE = (\"xyz-d55\",) WHITE = WHITES['2deg']['D55'] class Custom(Color): ... Custom.register(XYZD55) Custom('red').convert('xyz-d55') Edit Share Run Cancel If a deregistration was desired, the deregister method can be used. It takes a string that describes the plugin to deregister: category:name . Valid categories are space , delta-e , and fit . If the given plugin is not found, an error will be thrown, but if this notification is found to be unnecessary, silent can be enabled and the there will be no error thrown. >>> class Custom ( Color ): ... ... >>> Custom . deregister ( 'space:jzazbz' ) >>> try : ... Custom ( 'red' ) . convert ( 'jzazbz' ) ... except ValueError : ... print ( 'Could not convert to Jzazbz as it is no longer registered' ) ... Could not convert to Jzazbz as it is no longer registered class Custom(Color): ... Custom.deregister('space:jzazbz') try: Custom('red').convert('jzazbz') except ValueError: print('Could not convert to Jzazbz as it is no longer registered') Edit Share Run Cancel Use of * with deregister will remove all plugins. Use of category:* will remove all plugins of that category.","title":"Plugins"},{"location":"compositing/","text":"Compositing and Blending Alpha compositing and blending are tied together under the umbrella of compositing. Each is just an aspect of the overall compositing of colors. Blend is run first, followed by alpha compositing. ColorAide implements both alpha compositing and blending as described in the Compositing and Blending Level 1 specification. Alpha composting is based on Porter Duff compositing . By default, the compose method uses the normal blend mode and the source-over Porter Duff operator. Blending Blending is the aspect of compositing that calculates the mixing of colors where the source element and backdrop overlap. Conceptually, the colors in the source element (top layer) are blended in place with the backdrop (bottom layer). There are various blend modes, the most common is the normal blend mode which is the default blending mode for browsers. The normal blend mode simply returns the top layer's color when one is overlaid onto another. But there are many blend modes that could be used, all of which yield different results. If we were to apply a multiply blend mode, we would get something very different: When composing, the blend mode can be controlled separately in ColorAide. Here, we again use the multiply example and replicate it in ColorAide. Display P3 sRGB >>> c1 = Color ( '#07c7ed' ) >>> c2 = Color ( '#fc3d99' ) >>> c1 , c2 (color(srgb 0.02745 0.78039 0.92941 / 1), color(srgb 0.98824 0.23922 0.6 / 1)) >>> c1 . compose ( c2 , blend = 'multiply' , space = \"display-p3\" ) color(srgb 0.33867 0.23261 0.55966 / 1) c1 = Color('#07c7ed') c2 = Color('#fc3d99') c1, c2 c1.compose(c2, blend='multiply', space=\"display-p3\") Edit Share Run Cancel >>> c1 = Color ( '#07c7ed' ) >>> c2 = Color ( '#fc3d99' ) >>> c1 , c2 (color(srgb 0.02745 0.78039 0.92941 / 1), color(srgb 0.98824 0.23922 0.6 / 1)) >>> c1 . compose ( c2 , blend = 'multiply' , space = \"srgb\" ) color(srgb 0.02713 0.18668 0.55765 / 1) c1 = Color('#07c7ed') c2 = Color('#fc3d99') c1, c2 c1.compose(c2, blend='multiply', space=\"srgb\") Edit Share Run Cancel Display Differences As some browsers apply compositing based on the display's current color space, we've provided examples in both sRGB and Display P3 so that the examples can be compared on different displays. Which of the above matches your browser? ColorAide allows you to blend multiple colors quite easily as well. Simply send in a list, and the colors will be blended from right to left with the right most color being on the bottom of the stack, and the base color being on the very top. Display P3 sRGB >>> c1 = Color ( '#07c7ed' ) >>> c2 = Color ( '#fc3d99' ) >>> c3 = Color ( '#f5d311' ) >>> c1 , c2 , c3 (color(srgb 0.02745 0.78039 0.92941 / 1), color(srgb 0.98824 0.23922 0.6 / 1), color(srgb 0.96078 0.82745 0.06667 / 1)) >>> c1 . compose ([ c2 , c3 ], blend = 'multiply' , space = \"display-p3\" ) color(srgb 0.32151 0.19137 0.14794 / 1) c1 = Color('#07c7ed') c2 = Color('#fc3d99') c3 = Color('#f5d311') c1, c2, c3 c1.compose([c2, c3], blend='multiply', space=\"display-p3\") Edit Share Run Cancel >>> c1 = Color ( '#07c7ed' ) >>> c2 = Color ( '#fc3d99' ) >>> c3 = Color ( '#f5d311' ) >>> c1 , c2 , c3 (color(srgb 0.02745 0.78039 0.92941 / 1), color(srgb 0.98824 0.23922 0.6 / 1), color(srgb 0.96078 0.82745 0.06667 / 1)) >>> c1 . compose ([ c2 , c3 ], blend = 'multiply' , space = \"srgb\" ) color(srgb 0.02606 0.15447 0.03718 / 1) c1 = Color('#07c7ed') c2 = Color('#fc3d99') c3 = Color('#f5d311') c1, c2, c3 c1.compose([c2, c3], blend='multiply', space=\"srgb\") Edit Share Run Cancel Lastly, if for any reason, it is desired to compose with blending disabled (e.g. just run alpha compositing), then you can simply set blend to False . multiply is just one of many blend modes that are offered in ColorAide, check out Blend Modes to learn about other blend modes. Alpha Compositing Alpha compositing or alpha blending is the process of combining one image with a background to create the appearance of partial or full transparency. When dealing with layers, there are many possible ways to handle them: Porter Duff compositing covers all possible configurations of layers. Many of these configurations can be useful for all sorts of operations, such as masking. While this library supports all of them , the most commonly used one is source-over which is used to implement simple alpha compositing to simulate semi-transparent layers on top of each other. Given two colors, ColorAide can replicate this behavior and determine the resultant color by applying compositing. We will use the demonstration above and replicate the result in the example below. Below we set the source color to rgb ( 7 199 237 / 0 . 5 ) and the backdrop color to # fc3d99 and run it through the compose method. It should be noted that the default blend mode of normal is used in conjunction by default. Display P3 sRGB >>> c1 = Color ( '#07c7ed' ) . set ( 'alpha' , 0.5 ) >>> c2 = Color ( '#fc3d99' ) >>> c1 , c2 (color(srgb 0.02745 0.78039 0.92941 / 0.5), color(srgb 0.98824 0.23922 0.6 / 1)) >>> c1 . compose ( c2 , space = \"display-p3\" ) color(srgb 0.65142 0.53412 0.76833 / 1) c1 = Color('#07c7ed').set('alpha', 0.5) c2 = Color('#fc3d99') c1, c2 c1.compose(c2, space=\"display-p3\") Edit Share Run Cancel >>> c1 = Color ( '#07c7ed' ) . set ( 'alpha' , 0.5 ) >>> c2 = Color ( '#fc3d99' ) >>> c1 , c2 (color(srgb 0.02745 0.78039 0.92941 / 0.5), color(srgb 0.98824 0.23922 0.6 / 1)) >>> c1 . compose ( c2 , space = \"srgb\" ) color(srgb 0.50784 0.5098 0.76471 / 1) c1 = Color('#07c7ed').set('alpha', 0.5) c2 = Color('#fc3d99') c1, c2 c1.compose(c2, space=\"srgb\") Edit Share Run Cancel Display Differences As some browsers apply compositing based on the display's current color space, we've provided examples in both sRGB and Display P3 so that the examples can be compared on different displays. Which of the above matches your browser? While the average user will be content with the default alpha compositing, Porter Duff offers many other configurations. If desired, we can change the Porter Duff operator used and apply different composite logic. For instance, in this case we can get the resultant of the backdrop over the source color by setting the operator to destination-over . As the backdrop is fully opaque, we just get the backdrop color unaltered. Display P3 sRGB >>> c1 = Color ( '#07c7ed' ) . set ( 'alpha' , 0.5 ) >>> c2 = Color ( '#fc3d99' ) >>> c1 , c2 (color(srgb 0.02745 0.78039 0.92941 / 0.5), color(srgb 0.98824 0.23922 0.6 / 1)) >>> c1 . compose ( c2 , operator = 'destination-over' , space = \"display-p3\" ) color(srgb 0.98824 0.23922 0.6 / 1) c1 = Color('#07c7ed').set('alpha', 0.5) c2 = Color('#fc3d99') c1, c2 c1.compose(c2, operator='destination-over', space=\"display-p3\") Edit Share Run Cancel >>> c1 = Color ( '#07c7ed' ) . set ( 'alpha' , 0.5 ) >>> c2 = Color ( '#fc3d99' ) >>> c1 , c2 (color(srgb 0.02745 0.78039 0.92941 / 0.5), color(srgb 0.98824 0.23922 0.6 / 1)) >>> c1 . compose ( c2 , operator = 'destination-over' , space = \"srgb\" ) color(srgb 0.98824 0.23922 0.6 / 1) c1 = Color('#07c7ed').set('alpha', 0.5) c2 = Color('#fc3d99') c1, c2 c1.compose(c2, operator='destination-over', space=\"srgb\") Edit Share Run Cancel You can also apply alpha compositing to multiple layers at once. Simply send in a list, and the colors will be composed from right to left with the right most color being on the bottom of the stack and the base color being on the very top. Here we are using the normal blend mode and 50% transparency on all the circles with an opaque white background. We will calculate the center color where all three layers overlap. Display P3 sRGB >>> c1 = Color ( '#07c7ed' ) . set ( 'alpha' , 0.5 ) >>> c2 = Color ( '#fc3d99' ) . set ( 'alpha' , 0.5 ) >>> c3 = Color ( '#f5d311' ) . set ( 'alpha' , 0.5 ) >>> bg = Color ( 'white' ) >>> c1 , c2 , c3 , bg (color(srgb 0.02745 0.78039 0.92941 / 0.5), color(srgb 0.98824 0.23922 0.6 / 0.5), color(srgb 0.96078 0.82745 0.06667 / 0.5), color(srgb 1 1 1 / 1)) >>> c1 . compose ([ c2 , c3 , bg ], blend = 'normal' , space = \"display-p3\" ) color(srgb 0.63703 0.69225 0.77313 / 1) c1 = Color('#07c7ed').set('alpha', 0.5) c2 = Color('#fc3d99').set('alpha', 0.5) c3 = Color('#f5d311').set('alpha', 0.5) bg = Color('white') c1, c2, c3, bg c1.compose([c2, c3, bg], blend='normal', space=\"display-p3\") Edit Share Run Cancel >>> c1 = Color ( '#07c7ed' ) . set ( 'alpha' , 0.5 ) >>> c2 = Color ( '#fc3d99' ) . set ( 'alpha' , 0.5 ) >>> c3 = Color ( '#f5d311' ) . set ( 'alpha' , 0.5 ) >>> bg = Color ( 'white' ) >>> c1 , c2 , c3 , bg (color(srgb 0.02745 0.78039 0.92941 / 0.5), color(srgb 0.98824 0.23922 0.6 / 0.5), color(srgb 0.96078 0.82745 0.06667 / 0.5), color(srgb 1 1 1 / 1)) >>> c1 . compose ([ c2 , c3 , bg ], blend = 'normal' , space = \"srgb\" ) color(srgb 0.50588 0.67843 0.74804 / 1) c1 = Color('#07c7ed').set('alpha', 0.5) c2 = Color('#fc3d99').set('alpha', 0.5) c3 = Color('#f5d311').set('alpha', 0.5) bg = Color('white') c1, c2, c3, bg c1.compose([c2, c3, bg], blend='normal', space=\"srgb\") Edit Share Run Cancel Lastly, if for any reason, it is desired to run compose with alpha compositing disabled (e.g. just run blending), then you can simply set operator to False . Check out Compositing Operators to learn about the many variations that are supported. Complex Compositing We've covered alpha compositing and blending and have demonstrated their use with simple two color examples and multi-layered examples, but what about different blend modes mixed with alpha compositing? In this example, we will consider three circles, each with a unique color: # 07c7ed , # fc3d99 , and # f5d311 . We apply 50% transparency to all the circles and place them on a white background. We then perform a multiply blend on all the circles but isolate them so the multiply blend does not apply to the background. The circles are all represented with CSS. We will now try and replicate the colors with ColorAide. So in the code below, we work our way from the bottom of the stack to the top. Since the background is isolated from the multiply blending, in each region, we start by performing a normal blend on the bottom circle against the background. We then apply multiply blending on each color that is stacked on top. We've provided both the P3 and sRGB outputs to make it easy to compare in case your browser blends in one instead of the other. Display P3 sRGB >>> c1 = Color ( '#07c7ed' ) . set ( 'alpha' , 0.5 ) >>> c2 = Color ( '#fc3d99' ) . set ( 'alpha' , 0.5 ) >>> c3 = Color ( '#f5d311' ) . set ( 'alpha' , 0.5 ) >>> cw2 = c2 . compose ( 'white' , blend = 'normal' , space = 'display-p3' ) >>> cw3 = c3 . compose ( 'white' , blend = 'normal' , space = 'display-p3' ) >>> r1 = c2 . compose ( cw3 , blend = 'multiply' , space = 'display-p3' ) >>> r2 = c1 . compose ( cw2 , blend = 'multiply' , space = 'display-p3' ) >>> r3 = c1 . compose ( cw3 , blend = 'multiply' , space = 'display-p3' ) >>> r1 , r2 , r3 (color(srgb 0.98122 0.58007 0.49257 / 1), color(srgb 0.66117 0.57542 0.77558 / 1), color(srgb 0.61489 0.8159 0.59659 / 1)) >>> c1 . compose ([ c2 , cw3 ], blend = 'multiply' , space = 'display-p3' ) color(srgb 0.64659 0.52543 0.48429 / 1) c1 = Color('#07c7ed').set('alpha', 0.5) c2 = Color('#fc3d99').set('alpha', 0.5) c3 = Color('#f5d311').set('alpha', 0.5) cw2 = c2.compose('white', blend='normal', space='display-p3') cw3 = c3.compose('white', blend='normal', space='display-p3') r1 = c2.compose(cw3, blend='multiply', space='display-p3') r2 = c1.compose(cw2, blend='multiply', space='display-p3') r3 = c1.compose(cw3, blend='multiply', space='display-p3') r1, r2, r3 c1.compose([c2, cw3], blend='multiply', space='display-p3') Edit Share Run Cancel >>> c1 = Color ( '#07c7ed' ) . set ( 'alpha' , 0.5 ) >>> c2 = Color ( '#fc3d99' ) . set ( 'alpha' , 0.5 ) >>> c3 = Color ( '#f5d311' ) . set ( 'alpha' , 0.5 ) >>> cw2 = c2 . compose ( 'white' , blend = 'normal' , space = 'srgb' ) >>> cw3 = c3 . compose ( 'white' , blend = 'normal' , space = 'srgb' ) >>> r1 = c2 . compose ( cw3 , blend = 'multiply' , space = 'srgb' ) >>> r2 = c1 . compose ( cw2 , blend = 'multiply' , space = 'srgb' ) >>> r3 = c1 . compose ( cw3 , blend = 'multiply' , space = 'srgb' ) >>> r1 , r2 , r3 (color(srgb 0.97463 0.56615 0.42667 / 1), color(srgb 0.5107 0.55157 0.77176 / 1), color(srgb 0.50365 0.81339 0.51451 / 1)) >>> c1 . compose ([ c2 , cw3 ], blend = 'multiply' , space = 'srgb' ) color(srgb 0.50069 0.50399 0.41161 / 1) c1 = Color('#07c7ed').set('alpha', 0.5) c2 = Color('#fc3d99').set('alpha', 0.5) c3 = Color('#f5d311').set('alpha', 0.5) cw2 = c2.compose('white', blend='normal', space='srgb') cw3 = c3.compose('white', blend='normal', space='srgb') r1 = c2.compose(cw3, blend='multiply', space='srgb') r2 = c1.compose(cw2, blend='multiply', space='srgb') r3 = c1.compose(cw3, blend='multiply', space='srgb') r1, r2, r3 c1.compose([c2, cw3], blend='multiply', space='srgb') Edit Share Run Cancel Results may vary depending on the browser, but we can see (ignoring rounding differences) that the colors match up. This was performed on Chrome in macOS using a display that uses display-p3 . Blend Modes Normal The blending formula simply selects the source color. Specified as 'normal' . Multiply The source color is multiplied by the destination color and replaces the destination. The resultant color is always at least as dark as either the source or destination color. Multiplying any color with black results in black. Multiplying any color with white preserves the original color. Specified as 'multiply' . Screen Multiplies the complements of the backdrop and source color values, then complements the result. The result color is always at least as light as either of the two constituent colors. Screening any color with white produces white; screening with black leaves the original color unchanged. The effect is similar to projecting multiple photographic slides simultaneously onto a single screen. Specified as 'screen' . Overlay Multiplies or screens the colors, depending on the backdrop color value. Source colors overlay the backdrop while preserving its highlights and shadows. The backdrop color is not replaced but is mixed with the source color to reflect the lightness or darkness of the backdrop. Specified as 'overlay' . Darken Selects the darker of the backdrop and source colors. The backdrop is replaced with the source where the source is darker; otherwise, it is left unchanged. Specified as 'darken' . Lighten Selects the lighter of the backdrop and source colors. The backdrop is replaced with the source where the source is lighter; otherwise, it is left unchanged. Specified as 'lighten' . Color Dodge Brightens the backdrop color to reflect the source color. Painting with black produces no changes. Specified as 'color-dodge' . Color Burn Darkens the backdrop color to reflect the source color. Painting with white produces no change. Specified as 'color-burn' . Hard Light Multiplies or screens the colors, depending on the source color value. The effect is similar to shining a harsh spotlight on the backdrop. Specified as 'hard-light' . Soft Light Darkens or lightens the colors, depending on the source color value. The effect is similar to shining a diffused spotlight on the backdrop. Specified as 'soft-light' . Difference Subtracts the darker of the two constituent colors from the lighter color. Painting with white inverts the backdrop color; painting with black produces no change. Specified as 'difference' . Exclusion Produces an effect similar to that of the Difference mode but lower in contrast. Painting with white inverts the backdrop color; painting with black produces no change. Specified as 'exclusion' . Hue Creates a color with the hue of the source color and the saturation and luminosity of the backdrop color. Specified as 'hue' . Saturation Creates a color with the saturation of the source color and the hue and luminosity of the backdrop color. Painting with this mode in an area of the backdrop that is a pure gray (no saturation) produces no change. Specified as 'saturation' . Luminosity Creates a color with the luminosity of the source color and the hue and saturation of the backdrop color. This produces an inverse effect to that of the Color mode. This mode is the one you can use to create monochrome \"tinted\" image effects like the ones you can see in different website headers. Specified as 'luminosity' . Color Creates a color with the hue and saturation of the source color and the luminosity of the backdrop color. This preserves the gray levels of the backdrop and is useful for coloring monochrome images or tinting color images. Specified as 'color' . Compositing Operators Clear No regions are enabled. Specified as 'clear' . Copy Only the source will be present. Specified as 'copy' . Destination Only the destination will be present. Specified as 'destination' . Source Over Source is placed over the destination. Specified as 'source-over' . Destination Over Destination is placed over the source. Specified as 'destination-over' . Source In The source that overlaps the destination, replaces the destination. Specified as 'source-in' . Destination In Destination which overlaps the source, replaces the source. Specified as 'destination-in' . Source Out Source is placed, where it falls outside of the destination. Specified as 'source-out' . Destination Out Destination is placed, where it falls outside of the source. Specified as 'destination-out' . Source Atop Source which overlaps the destination, replaces the destination. Destination is placed elsewhere. Specified as 'source-atop' . Destination Atop Destination which overlaps the source replaces the source. Source is placed elsewhere. Specified as 'destination-atop' . XOR Destination which overlaps the source replaces the source. Source is placed elsewhere. Specified as 'xor' . Lighter Display the sum of the source image and destination image. Specified as 'lighter' . img { background: white; } .circle { display: block; width: 80px; height: 80px; border-radius: 50%; position: absolute; transition: all 0.5s ease; z-index: 10; } .isolate label { position: absolute; bottom: 0; width: 100%; text-align: center; } .circle-1 { background: #f5d311; } .dual .circle-1 { background: #fc3d99; } .isolate:not(.dual):hover .circle-1 { transform: translateX(-10px) translateY(-7.5px); } .isolate.dual:hover .circle-1 { transform: translateX(-10px); } .circle-2 { background: #fc3d99; left: 40px; } .dual .circle-2 { background: #07c7ed; } .isolate:not(.dual):hover .circle-2 { transform: translateX(10px) translateY(-7.5px); } .isolate.dual:hover .circle-2 { transform: translateX(20px); } .circle-3 { background: #07c7ed; left: 20px; top: 40px; } .isolate:not(.dual):hover .circle-3 { transform: translateY(7.5px); } .isolate { display: block; height: 120px; width: 120px; isolation: isolate; position: relative; margin: 0 10px; } .isolate.dual { height: 80px; } div.blend-wrap { display: flex; min-height: calc(120px + 0.8em); width: 100%; } div.blend-wrap > :not(.blend-content) { order: 0; } div.blend-wrap .isolate { margin-top: 0.8em; } div.blend-wrap > .blend-content { order: 1; } .blend-normal .circle { mix-blend-mode: normal; } .blend-multiply .circle { mix-blend-mode: multiply; } .blend-screen .circle { mix-blend-mode: screen; } .blend-overlay .circle { mix-blend-mode: overlay; } .blend-color-burn .circle { mix-blend-mode: color-burn; } .blend-color-dodge .circle { mix-blend-mode: color-dodge; } .blend-exclusion .circle { mix-blend-mode: exclusion; } .blend-difference .circle { mix-blend-mode: difference; } .blend-darken .circle { mix-blend-mode: darken; } .blend-lighten .circle { mix-blend-mode: lighten; } .blend-soft-light .circle { mix-blend-mode: soft-light; } .blend-hard-light .circle { mix-blend-mode: hard-light; } .blend-hue .circle { mix-blend-mode: hue; } .blend-saturation .circle { mix-blend-mode: saturation; } .blend-luminosity .circle { mix-blend-mode: luminosity; } .blend-color .circle { mix-blend-mode: color; }","title":"Compositing and Blending"},{"location":"compositing/#compositing-and-blending","text":"Alpha compositing and blending are tied together under the umbrella of compositing. Each is just an aspect of the overall compositing of colors. Blend is run first, followed by alpha compositing. ColorAide implements both alpha compositing and blending as described in the Compositing and Blending Level 1 specification. Alpha composting is based on Porter Duff compositing . By default, the compose method uses the normal blend mode and the source-over Porter Duff operator.","title":"Compositing and Blending"},{"location":"compositing/#blending","text":"Blending is the aspect of compositing that calculates the mixing of colors where the source element and backdrop overlap. Conceptually, the colors in the source element (top layer) are blended in place with the backdrop (bottom layer). There are various blend modes, the most common is the normal blend mode which is the default blending mode for browsers. The normal blend mode simply returns the top layer's color when one is overlaid onto another. But there are many blend modes that could be used, all of which yield different results. If we were to apply a multiply blend mode, we would get something very different: When composing, the blend mode can be controlled separately in ColorAide. Here, we again use the multiply example and replicate it in ColorAide. Display P3 sRGB >>> c1 = Color ( '#07c7ed' ) >>> c2 = Color ( '#fc3d99' ) >>> c1 , c2 (color(srgb 0.02745 0.78039 0.92941 / 1), color(srgb 0.98824 0.23922 0.6 / 1)) >>> c1 . compose ( c2 , blend = 'multiply' , space = \"display-p3\" ) color(srgb 0.33867 0.23261 0.55966 / 1) c1 = Color('#07c7ed') c2 = Color('#fc3d99') c1, c2 c1.compose(c2, blend='multiply', space=\"display-p3\") Edit Share Run Cancel >>> c1 = Color ( '#07c7ed' ) >>> c2 = Color ( '#fc3d99' ) >>> c1 , c2 (color(srgb 0.02745 0.78039 0.92941 / 1), color(srgb 0.98824 0.23922 0.6 / 1)) >>> c1 . compose ( c2 , blend = 'multiply' , space = \"srgb\" ) color(srgb 0.02713 0.18668 0.55765 / 1) c1 = Color('#07c7ed') c2 = Color('#fc3d99') c1, c2 c1.compose(c2, blend='multiply', space=\"srgb\") Edit Share Run Cancel Display Differences As some browsers apply compositing based on the display's current color space, we've provided examples in both sRGB and Display P3 so that the examples can be compared on different displays. Which of the above matches your browser? ColorAide allows you to blend multiple colors quite easily as well. Simply send in a list, and the colors will be blended from right to left with the right most color being on the bottom of the stack, and the base color being on the very top. Display P3 sRGB >>> c1 = Color ( '#07c7ed' ) >>> c2 = Color ( '#fc3d99' ) >>> c3 = Color ( '#f5d311' ) >>> c1 , c2 , c3 (color(srgb 0.02745 0.78039 0.92941 / 1), color(srgb 0.98824 0.23922 0.6 / 1), color(srgb 0.96078 0.82745 0.06667 / 1)) >>> c1 . compose ([ c2 , c3 ], blend = 'multiply' , space = \"display-p3\" ) color(srgb 0.32151 0.19137 0.14794 / 1) c1 = Color('#07c7ed') c2 = Color('#fc3d99') c3 = Color('#f5d311') c1, c2, c3 c1.compose([c2, c3], blend='multiply', space=\"display-p3\") Edit Share Run Cancel >>> c1 = Color ( '#07c7ed' ) >>> c2 = Color ( '#fc3d99' ) >>> c3 = Color ( '#f5d311' ) >>> c1 , c2 , c3 (color(srgb 0.02745 0.78039 0.92941 / 1), color(srgb 0.98824 0.23922 0.6 / 1), color(srgb 0.96078 0.82745 0.06667 / 1)) >>> c1 . compose ([ c2 , c3 ], blend = 'multiply' , space = \"srgb\" ) color(srgb 0.02606 0.15447 0.03718 / 1) c1 = Color('#07c7ed') c2 = Color('#fc3d99') c3 = Color('#f5d311') c1, c2, c3 c1.compose([c2, c3], blend='multiply', space=\"srgb\") Edit Share Run Cancel Lastly, if for any reason, it is desired to compose with blending disabled (e.g. just run alpha compositing), then you can simply set blend to False . multiply is just one of many blend modes that are offered in ColorAide, check out Blend Modes to learn about other blend modes.","title":"Blending"},{"location":"compositing/#alpha-compositing","text":"Alpha compositing or alpha blending is the process of combining one image with a background to create the appearance of partial or full transparency. When dealing with layers, there are many possible ways to handle them: Porter Duff compositing covers all possible configurations of layers. Many of these configurations can be useful for all sorts of operations, such as masking. While this library supports all of them , the most commonly used one is source-over which is used to implement simple alpha compositing to simulate semi-transparent layers on top of each other. Given two colors, ColorAide can replicate this behavior and determine the resultant color by applying compositing. We will use the demonstration above and replicate the result in the example below. Below we set the source color to rgb ( 7 199 237 / 0 . 5 ) and the backdrop color to # fc3d99 and run it through the compose method. It should be noted that the default blend mode of normal is used in conjunction by default. Display P3 sRGB >>> c1 = Color ( '#07c7ed' ) . set ( 'alpha' , 0.5 ) >>> c2 = Color ( '#fc3d99' ) >>> c1 , c2 (color(srgb 0.02745 0.78039 0.92941 / 0.5), color(srgb 0.98824 0.23922 0.6 / 1)) >>> c1 . compose ( c2 , space = \"display-p3\" ) color(srgb 0.65142 0.53412 0.76833 / 1) c1 = Color('#07c7ed').set('alpha', 0.5) c2 = Color('#fc3d99') c1, c2 c1.compose(c2, space=\"display-p3\") Edit Share Run Cancel >>> c1 = Color ( '#07c7ed' ) . set ( 'alpha' , 0.5 ) >>> c2 = Color ( '#fc3d99' ) >>> c1 , c2 (color(srgb 0.02745 0.78039 0.92941 / 0.5), color(srgb 0.98824 0.23922 0.6 / 1)) >>> c1 . compose ( c2 , space = \"srgb\" ) color(srgb 0.50784 0.5098 0.76471 / 1) c1 = Color('#07c7ed').set('alpha', 0.5) c2 = Color('#fc3d99') c1, c2 c1.compose(c2, space=\"srgb\") Edit Share Run Cancel Display Differences As some browsers apply compositing based on the display's current color space, we've provided examples in both sRGB and Display P3 so that the examples can be compared on different displays. Which of the above matches your browser? While the average user will be content with the default alpha compositing, Porter Duff offers many other configurations. If desired, we can change the Porter Duff operator used and apply different composite logic. For instance, in this case we can get the resultant of the backdrop over the source color by setting the operator to destination-over . As the backdrop is fully opaque, we just get the backdrop color unaltered. Display P3 sRGB >>> c1 = Color ( '#07c7ed' ) . set ( 'alpha' , 0.5 ) >>> c2 = Color ( '#fc3d99' ) >>> c1 , c2 (color(srgb 0.02745 0.78039 0.92941 / 0.5), color(srgb 0.98824 0.23922 0.6 / 1)) >>> c1 . compose ( c2 , operator = 'destination-over' , space = \"display-p3\" ) color(srgb 0.98824 0.23922 0.6 / 1) c1 = Color('#07c7ed').set('alpha', 0.5) c2 = Color('#fc3d99') c1, c2 c1.compose(c2, operator='destination-over', space=\"display-p3\") Edit Share Run Cancel >>> c1 = Color ( '#07c7ed' ) . set ( 'alpha' , 0.5 ) >>> c2 = Color ( '#fc3d99' ) >>> c1 , c2 (color(srgb 0.02745 0.78039 0.92941 / 0.5), color(srgb 0.98824 0.23922 0.6 / 1)) >>> c1 . compose ( c2 , operator = 'destination-over' , space = \"srgb\" ) color(srgb 0.98824 0.23922 0.6 / 1) c1 = Color('#07c7ed').set('alpha', 0.5) c2 = Color('#fc3d99') c1, c2 c1.compose(c2, operator='destination-over', space=\"srgb\") Edit Share Run Cancel You can also apply alpha compositing to multiple layers at once. Simply send in a list, and the colors will be composed from right to left with the right most color being on the bottom of the stack and the base color being on the very top. Here we are using the normal blend mode and 50% transparency on all the circles with an opaque white background. We will calculate the center color where all three layers overlap. Display P3 sRGB >>> c1 = Color ( '#07c7ed' ) . set ( 'alpha' , 0.5 ) >>> c2 = Color ( '#fc3d99' ) . set ( 'alpha' , 0.5 ) >>> c3 = Color ( '#f5d311' ) . set ( 'alpha' , 0.5 ) >>> bg = Color ( 'white' ) >>> c1 , c2 , c3 , bg (color(srgb 0.02745 0.78039 0.92941 / 0.5), color(srgb 0.98824 0.23922 0.6 / 0.5), color(srgb 0.96078 0.82745 0.06667 / 0.5), color(srgb 1 1 1 / 1)) >>> c1 . compose ([ c2 , c3 , bg ], blend = 'normal' , space = \"display-p3\" ) color(srgb 0.63703 0.69225 0.77313 / 1) c1 = Color('#07c7ed').set('alpha', 0.5) c2 = Color('#fc3d99').set('alpha', 0.5) c3 = Color('#f5d311').set('alpha', 0.5) bg = Color('white') c1, c2, c3, bg c1.compose([c2, c3, bg], blend='normal', space=\"display-p3\") Edit Share Run Cancel >>> c1 = Color ( '#07c7ed' ) . set ( 'alpha' , 0.5 ) >>> c2 = Color ( '#fc3d99' ) . set ( 'alpha' , 0.5 ) >>> c3 = Color ( '#f5d311' ) . set ( 'alpha' , 0.5 ) >>> bg = Color ( 'white' ) >>> c1 , c2 , c3 , bg (color(srgb 0.02745 0.78039 0.92941 / 0.5), color(srgb 0.98824 0.23922 0.6 / 0.5), color(srgb 0.96078 0.82745 0.06667 / 0.5), color(srgb 1 1 1 / 1)) >>> c1 . compose ([ c2 , c3 , bg ], blend = 'normal' , space = \"srgb\" ) color(srgb 0.50588 0.67843 0.74804 / 1) c1 = Color('#07c7ed').set('alpha', 0.5) c2 = Color('#fc3d99').set('alpha', 0.5) c3 = Color('#f5d311').set('alpha', 0.5) bg = Color('white') c1, c2, c3, bg c1.compose([c2, c3, bg], blend='normal', space=\"srgb\") Edit Share Run Cancel Lastly, if for any reason, it is desired to run compose with alpha compositing disabled (e.g. just run blending), then you can simply set operator to False . Check out Compositing Operators to learn about the many variations that are supported.","title":"Alpha Compositing"},{"location":"compositing/#complex-compositing","text":"We've covered alpha compositing and blending and have demonstrated their use with simple two color examples and multi-layered examples, but what about different blend modes mixed with alpha compositing? In this example, we will consider three circles, each with a unique color: # 07c7ed , # fc3d99 , and # f5d311 . We apply 50% transparency to all the circles and place them on a white background. We then perform a multiply blend on all the circles but isolate them so the multiply blend does not apply to the background. The circles are all represented with CSS. We will now try and replicate the colors with ColorAide. So in the code below, we work our way from the bottom of the stack to the top. Since the background is isolated from the multiply blending, in each region, we start by performing a normal blend on the bottom circle against the background. We then apply multiply blending on each color that is stacked on top. We've provided both the P3 and sRGB outputs to make it easy to compare in case your browser blends in one instead of the other. Display P3 sRGB >>> c1 = Color ( '#07c7ed' ) . set ( 'alpha' , 0.5 ) >>> c2 = Color ( '#fc3d99' ) . set ( 'alpha' , 0.5 ) >>> c3 = Color ( '#f5d311' ) . set ( 'alpha' , 0.5 ) >>> cw2 = c2 . compose ( 'white' , blend = 'normal' , space = 'display-p3' ) >>> cw3 = c3 . compose ( 'white' , blend = 'normal' , space = 'display-p3' ) >>> r1 = c2 . compose ( cw3 , blend = 'multiply' , space = 'display-p3' ) >>> r2 = c1 . compose ( cw2 , blend = 'multiply' , space = 'display-p3' ) >>> r3 = c1 . compose ( cw3 , blend = 'multiply' , space = 'display-p3' ) >>> r1 , r2 , r3 (color(srgb 0.98122 0.58007 0.49257 / 1), color(srgb 0.66117 0.57542 0.77558 / 1), color(srgb 0.61489 0.8159 0.59659 / 1)) >>> c1 . compose ([ c2 , cw3 ], blend = 'multiply' , space = 'display-p3' ) color(srgb 0.64659 0.52543 0.48429 / 1) c1 = Color('#07c7ed').set('alpha', 0.5) c2 = Color('#fc3d99').set('alpha', 0.5) c3 = Color('#f5d311').set('alpha', 0.5) cw2 = c2.compose('white', blend='normal', space='display-p3') cw3 = c3.compose('white', blend='normal', space='display-p3') r1 = c2.compose(cw3, blend='multiply', space='display-p3') r2 = c1.compose(cw2, blend='multiply', space='display-p3') r3 = c1.compose(cw3, blend='multiply', space='display-p3') r1, r2, r3 c1.compose([c2, cw3], blend='multiply', space='display-p3') Edit Share Run Cancel >>> c1 = Color ( '#07c7ed' ) . set ( 'alpha' , 0.5 ) >>> c2 = Color ( '#fc3d99' ) . set ( 'alpha' , 0.5 ) >>> c3 = Color ( '#f5d311' ) . set ( 'alpha' , 0.5 ) >>> cw2 = c2 . compose ( 'white' , blend = 'normal' , space = 'srgb' ) >>> cw3 = c3 . compose ( 'white' , blend = 'normal' , space = 'srgb' ) >>> r1 = c2 . compose ( cw3 , blend = 'multiply' , space = 'srgb' ) >>> r2 = c1 . compose ( cw2 , blend = 'multiply' , space = 'srgb' ) >>> r3 = c1 . compose ( cw3 , blend = 'multiply' , space = 'srgb' ) >>> r1 , r2 , r3 (color(srgb 0.97463 0.56615 0.42667 / 1), color(srgb 0.5107 0.55157 0.77176 / 1), color(srgb 0.50365 0.81339 0.51451 / 1)) >>> c1 . compose ([ c2 , cw3 ], blend = 'multiply' , space = 'srgb' ) color(srgb 0.50069 0.50399 0.41161 / 1) c1 = Color('#07c7ed').set('alpha', 0.5) c2 = Color('#fc3d99').set('alpha', 0.5) c3 = Color('#f5d311').set('alpha', 0.5) cw2 = c2.compose('white', blend='normal', space='srgb') cw3 = c3.compose('white', blend='normal', space='srgb') r1 = c2.compose(cw3, blend='multiply', space='srgb') r2 = c1.compose(cw2, blend='multiply', space='srgb') r3 = c1.compose(cw3, blend='multiply', space='srgb') r1, r2, r3 c1.compose([c2, cw3], blend='multiply', space='srgb') Edit Share Run Cancel Results may vary depending on the browser, but we can see (ignoring rounding differences) that the colors match up. This was performed on Chrome in macOS using a display that uses display-p3 .","title":"Complex Compositing"},{"location":"compositing/#blend-modes","text":"","title":"Blend Modes"},{"location":"compositing/#normal","text":"The blending formula simply selects the source color. Specified as 'normal' .","title":"Normal"},{"location":"compositing/#multiply","text":"The source color is multiplied by the destination color and replaces the destination. The resultant color is always at least as dark as either the source or destination color. Multiplying any color with black results in black. Multiplying any color with white preserves the original color. Specified as 'multiply' .","title":"Multiply"},{"location":"compositing/#screen","text":"Multiplies the complements of the backdrop and source color values, then complements the result. The result color is always at least as light as either of the two constituent colors. Screening any color with white produces white; screening with black leaves the original color unchanged. The effect is similar to projecting multiple photographic slides simultaneously onto a single screen. Specified as 'screen' .","title":"Screen"},{"location":"compositing/#overlay","text":"Multiplies or screens the colors, depending on the backdrop color value. Source colors overlay the backdrop while preserving its highlights and shadows. The backdrop color is not replaced but is mixed with the source color to reflect the lightness or darkness of the backdrop. Specified as 'overlay' .","title":"Overlay"},{"location":"compositing/#darken","text":"Selects the darker of the backdrop and source colors. The backdrop is replaced with the source where the source is darker; otherwise, it is left unchanged. Specified as 'darken' .","title":"Darken"},{"location":"compositing/#lighten","text":"Selects the lighter of the backdrop and source colors. The backdrop is replaced with the source where the source is lighter; otherwise, it is left unchanged. Specified as 'lighten' .","title":"Lighten"},{"location":"compositing/#color-dodge","text":"Brightens the backdrop color to reflect the source color. Painting with black produces no changes. Specified as 'color-dodge' .","title":"Color Dodge"},{"location":"compositing/#color-burn","text":"Darkens the backdrop color to reflect the source color. Painting with white produces no change. Specified as 'color-burn' .","title":"Color Burn"},{"location":"compositing/#hard-light","text":"Multiplies or screens the colors, depending on the source color value. The effect is similar to shining a harsh spotlight on the backdrop. Specified as 'hard-light' .","title":"Hard Light"},{"location":"compositing/#soft-light","text":"Darkens or lightens the colors, depending on the source color value. The effect is similar to shining a diffused spotlight on the backdrop. Specified as 'soft-light' .","title":"Soft Light"},{"location":"compositing/#difference","text":"Subtracts the darker of the two constituent colors from the lighter color. Painting with white inverts the backdrop color; painting with black produces no change. Specified as 'difference' .","title":"Difference"},{"location":"compositing/#exclusion","text":"Produces an effect similar to that of the Difference mode but lower in contrast. Painting with white inverts the backdrop color; painting with black produces no change. Specified as 'exclusion' .","title":"Exclusion"},{"location":"compositing/#hue","text":"Creates a color with the hue of the source color and the saturation and luminosity of the backdrop color. Specified as 'hue' .","title":"Hue"},{"location":"compositing/#saturation","text":"Creates a color with the saturation of the source color and the hue and luminosity of the backdrop color. Painting with this mode in an area of the backdrop that is a pure gray (no saturation) produces no change. Specified as 'saturation' .","title":"Saturation"},{"location":"compositing/#luminosity","text":"Creates a color with the luminosity of the source color and the hue and saturation of the backdrop color. This produces an inverse effect to that of the Color mode. This mode is the one you can use to create monochrome \"tinted\" image effects like the ones you can see in different website headers. Specified as 'luminosity' .","title":"Luminosity"},{"location":"compositing/#color","text":"Creates a color with the hue and saturation of the source color and the luminosity of the backdrop color. This preserves the gray levels of the backdrop and is useful for coloring monochrome images or tinting color images. Specified as 'color' .","title":"Color"},{"location":"compositing/#compositing-operators","text":"","title":"Compositing Operators"},{"location":"compositing/#clear","text":"No regions are enabled. Specified as 'clear' .","title":"Clear"},{"location":"compositing/#copy","text":"Only the source will be present. Specified as 'copy' .","title":"Copy"},{"location":"compositing/#destination","text":"Only the destination will be present. Specified as 'destination' .","title":"Destination"},{"location":"compositing/#source-over","text":"Source is placed over the destination. Specified as 'source-over' .","title":"Source Over"},{"location":"compositing/#destination-over","text":"Destination is placed over the source. Specified as 'destination-over' .","title":"Destination Over"},{"location":"compositing/#source-in","text":"The source that overlaps the destination, replaces the destination. Specified as 'source-in' .","title":"Source In"},{"location":"compositing/#destination-in","text":"Destination which overlaps the source, replaces the source. Specified as 'destination-in' .","title":"Destination In"},{"location":"compositing/#source-out","text":"Source is placed, where it falls outside of the destination. Specified as 'source-out' .","title":"Source Out"},{"location":"compositing/#destination-out","text":"Destination is placed, where it falls outside of the source. Specified as 'destination-out' .","title":"Destination Out"},{"location":"compositing/#source-atop","text":"Source which overlaps the destination, replaces the destination. Destination is placed elsewhere. Specified as 'source-atop' .","title":"Source Atop"},{"location":"compositing/#destination-atop","text":"Destination which overlaps the source replaces the source. Source is placed elsewhere. Specified as 'destination-atop' .","title":"Destination Atop"},{"location":"compositing/#xor","text":"Destination which overlaps the source replaces the source. Source is placed elsewhere. Specified as 'xor' .","title":"XOR"},{"location":"compositing/#lighter","text":"Display the sum of the source image and destination image. Specified as 'lighter' . img { background: white; } .circle { display: block; width: 80px; height: 80px; border-radius: 50%; position: absolute; transition: all 0.5s ease; z-index: 10; } .isolate label { position: absolute; bottom: 0; width: 100%; text-align: center; } .circle-1 { background: #f5d311; } .dual .circle-1 { background: #fc3d99; } .isolate:not(.dual):hover .circle-1 { transform: translateX(-10px) translateY(-7.5px); } .isolate.dual:hover .circle-1 { transform: translateX(-10px); } .circle-2 { background: #fc3d99; left: 40px; } .dual .circle-2 { background: #07c7ed; } .isolate:not(.dual):hover .circle-2 { transform: translateX(10px) translateY(-7.5px); } .isolate.dual:hover .circle-2 { transform: translateX(20px); } .circle-3 { background: #07c7ed; left: 20px; top: 40px; } .isolate:not(.dual):hover .circle-3 { transform: translateY(7.5px); } .isolate { display: block; height: 120px; width: 120px; isolation: isolate; position: relative; margin: 0 10px; } .isolate.dual { height: 80px; } div.blend-wrap { display: flex; min-height: calc(120px + 0.8em); width: 100%; } div.blend-wrap > :not(.blend-content) { order: 0; } div.blend-wrap .isolate { margin-top: 0.8em; } div.blend-wrap > .blend-content { order: 1; } .blend-normal .circle { mix-blend-mode: normal; } .blend-multiply .circle { mix-blend-mode: multiply; } .blend-screen .circle { mix-blend-mode: screen; } .blend-overlay .circle { mix-blend-mode: overlay; } .blend-color-burn .circle { mix-blend-mode: color-burn; } .blend-color-dodge .circle { mix-blend-mode: color-dodge; } .blend-exclusion .circle { mix-blend-mode: exclusion; } .blend-difference .circle { mix-blend-mode: difference; } .blend-darken .circle { mix-blend-mode: darken; } .blend-lighten .circle { mix-blend-mode: lighten; } .blend-soft-light .circle { mix-blend-mode: soft-light; } .blend-hard-light .circle { mix-blend-mode: hard-light; } .blend-hue .circle { mix-blend-mode: hue; } .blend-saturation .circle { mix-blend-mode: saturation; } .blend-luminosity .circle { mix-blend-mode: luminosity; } .blend-color .circle { mix-blend-mode: color; }","title":"Lighter"},{"location":"contrast/","text":"Contrast ColorAide provides a number of utilities related to luminance and contrast, or better put, contrast as defined by Web Content Accessibility Guidelines ( WCAG ) 2.0 specification . Relative Luminance In the CIE XYZ and xyY color spaces, the Y parameter is linear to changes in the volume of light. Specifically this refers to the amount of reflected light where 1.0 is assumed to be a perfect reflector in relation to the reference white. The WCAG in the 2.0 specification provides the following formula to acquire the relative luminance from an sRGB color. What is not explicitly said, but is happening, is the formula removes the gamut correction from each of the color channels and then calculates the luminance. What we end up with is actually the Y channel of the XYZ color space with a D65 white point. >>> r , g , b = Color ( 'purple' ) . coords () >>> r = r / 12.92 if r <= 0.03928 else (( r + 0.055 ) / 1.055 ) ** 2.4 >>> g = g / 12.92 if g <= 0.03928 else (( g + 0.055 ) / 1.055 ) ** 2.4 >>> b = b / 12.92 if b <= 0.03928 else (( b + 0.055 ) / 1.055 ) ** 2.4 >>> l = ( 0.2126 * r + 0.7152 * g + 0.0722 * b ) >>> print ( l ) 0.06147707043243851 >>> Color ( 'purple' ) . convert ( 'xyz-d65' ) . y 0.06148383144929487 r, g, b = Color('purple').coords() r = r / 12.92 if r <= 0.03928 else ((r + 0.055) / 1.055) ** 2.4 g = g / 12.92 if g <= 0.03928 else ((g + 0.055) / 1.055) ** 2.4 b = b / 12.92 if b <= 0.03928 else ((b + 0.055) / 1.055) ** 2.4 l = (0.2126 * r + 0.7152 * g + 0.0722 * b) print(l) Color('purple').convert('xyz-d65').y Edit Share Run Cancel For convenience, the luminance method exposes access to this value to make it quick and easy query the relative luminance, or Y parameter from XYZ D65, for a given color. >>> Color ( \"black\" ) . luminance () 0.0 >>> Color ( \"white\" ) . luminance () 1.0 >>> Color ( \"blue\" ) . luminance () 0.07219231536073371 Color(\"black\").luminance() Color(\"white\").luminance() Color(\"blue\").luminance() Edit Share Run Cancel Contrast Ratio WCAG 2.0 spec specifies the contrast ratio using the equation below. # Where `l1` is the lighter luminance and `l2` the darker contrast_ratio = ( l1 + 0.05 ) / ( l2 + 0.05 ) To get the this contrast ratio between two colors, simply pass in the second color: >>> Color ( \"blue\" ) . contrast ( \"red\" ) 2.149390533243867 Color(\"blue\").contrast(\"red\") Edit Share Run Cancel","title":"Contrast"},{"location":"contrast/#contrast","text":"ColorAide provides a number of utilities related to luminance and contrast, or better put, contrast as defined by Web Content Accessibility Guidelines ( WCAG ) 2.0 specification .","title":"Contrast"},{"location":"contrast/#relative-luminance","text":"In the CIE XYZ and xyY color spaces, the Y parameter is linear to changes in the volume of light. Specifically this refers to the amount of reflected light where 1.0 is assumed to be a perfect reflector in relation to the reference white. The WCAG in the 2.0 specification provides the following formula to acquire the relative luminance from an sRGB color. What is not explicitly said, but is happening, is the formula removes the gamut correction from each of the color channels and then calculates the luminance. What we end up with is actually the Y channel of the XYZ color space with a D65 white point. >>> r , g , b = Color ( 'purple' ) . coords () >>> r = r / 12.92 if r <= 0.03928 else (( r + 0.055 ) / 1.055 ) ** 2.4 >>> g = g / 12.92 if g <= 0.03928 else (( g + 0.055 ) / 1.055 ) ** 2.4 >>> b = b / 12.92 if b <= 0.03928 else (( b + 0.055 ) / 1.055 ) ** 2.4 >>> l = ( 0.2126 * r + 0.7152 * g + 0.0722 * b ) >>> print ( l ) 0.06147707043243851 >>> Color ( 'purple' ) . convert ( 'xyz-d65' ) . y 0.06148383144929487 r, g, b = Color('purple').coords() r = r / 12.92 if r <= 0.03928 else ((r + 0.055) / 1.055) ** 2.4 g = g / 12.92 if g <= 0.03928 else ((g + 0.055) / 1.055) ** 2.4 b = b / 12.92 if b <= 0.03928 else ((b + 0.055) / 1.055) ** 2.4 l = (0.2126 * r + 0.7152 * g + 0.0722 * b) print(l) Color('purple').convert('xyz-d65').y Edit Share Run Cancel For convenience, the luminance method exposes access to this value to make it quick and easy query the relative luminance, or Y parameter from XYZ D65, for a given color. >>> Color ( \"black\" ) . luminance () 0.0 >>> Color ( \"white\" ) . luminance () 1.0 >>> Color ( \"blue\" ) . luminance () 0.07219231536073371 Color(\"black\").luminance() Color(\"white\").luminance() Color(\"blue\").luminance() Edit Share Run Cancel","title":"Relative Luminance"},{"location":"contrast/#contrast-ratio","text":"WCAG 2.0 spec specifies the contrast ratio using the equation below. # Where `l1` is the lighter luminance and `l2` the darker contrast_ratio = ( l1 + 0.05 ) / ( l2 + 0.05 ) To get the this contrast ratio between two colors, simply pass in the second color: >>> Color ( \"blue\" ) . contrast ( \"red\" ) 2.149390533243867 Color(\"blue\").contrast(\"red\") Edit Share Run Cancel","title":"Contrast Ratio"},{"location":"distance/","text":"Color Distance and Delta E The difference or distance between two colors allows for a quantified analysis of how far apart two colors are from one another. This metric is of particular interest in the field of color science, but it has practical applications in color libraries working with colors. Usually, color distance is applied to near perceptual uniform color spaces in order to obtain a metric regarding a color's visual, perceptual distance from another color. This can be useful in gamut mapping or even determining that colors are close enough or far enough away from each other. Color Distance ColorAide provides a simple euclidean color distance function. By default, it evaluates the distance in the CIELAB color space, but it can be configured to evaluate in any color space, such as Oklab, etc. It may be less useful in some color spaces compared to others. Some spaces may not be well suited, such as cylindrical spaces. Some spaces might not be as very perceptually uniform as others requiring more complex algorithms. >>> Color ( \"red\" ) . distance ( \"blue\" , space = \"srgb\" ) 1.4142135623730951 >>> Color ( \"red\" ) . distance ( \"blue\" , space = \"lab\" ) 184.0190486209969 Color(\"red\").distance(\"blue\", space=\"srgb\") Color(\"red\").distance(\"blue\", space=\"lab\") Edit Share Run Cancel Delta E The delta_e function gives access to various \u2206E implementations, which are just different algorithms to calculate distance. Some are simply Euclidean distance withing a certain color space, some are far more complex. If no method is specified, the default implementation is \u2206E * ab (CIE76) which uses a simple Euclidean distancing algorithm on the CIELAB color space. It is fast, but not as accurate as later iterations of the algorithm as CIELAB is not actually as perceptually uniform as it was thought when CIELAB was originally developed. >>> Color ( \"red\" ) . delta_e ( \"blue\" ) 184.0190486209969 Color(\"red\").delta_e(\"blue\") Edit Share Run Cancel When method is set, the specified \u2206E algorithm will be used instead. For instance, below we use \u2206E 00 which is a more complex algorithm that accounts for the CIELAB's weakness in perceptually uniformity. It does come at the cost of being a little slower. >>> Color ( \"red\" ) . delta_e ( \"blue\" , method = \"2000\" ) 55.79977339019777 Color(\"red\").delta_e(\"blue\", method=\"2000\") Edit Share Run Cancel Below are all the supported \u2206E methods. Follow relevant links to read the specs and find out more about a given \u2206E method. Delta E Name Parameters \u2206E * ab (CIE76) 76 \u2206E * cmc (CMC l:c (1984)) cmc l=2, c=1 \u2206E * 94 (CIE94) 94 kl=1, k1=0.045, k2=0.015 \u2206E * 00 (CIEDE2000) 2000 kl=1, kc=1, kh=1 \u2206E itp (ICtCp) itp scalar=720 \u2206E z (Jzazbz) jz \u2206E 99o (DIN99o) 99o \u2206E HyAB (HyAB) hyab space=\"lab\" \u2206E ok ok scalar=1 \u2206E methods are also accessible via methods delta_e_<name> , where <name> is a name from the above table. >>> Color ( \"red\" ) . delta_e_jz ( \"blue\" ) 0.3396038842016558 >>> Color ( \"red\" ) . delta_e_hyab ( \"blue\" ) 207.07305826980567 Color(\"red\").delta_e_jz(\"blue\") Color(\"red\").delta_e_hyab(\"blue\") Edit Share Run Cancel Finding Closest Color ColorAide implements a simple way to find the closest color, given a list of colors, to another color. The method is called closest and takes a list of colors that are to be compared to the calling color object. The first color with the smallest distance between the calling color object and itself will be considered the nearest/closest color. Consider the following example. Here we provide a list of colors to compare against red . After comparing all the colors, the closest ends up being maroon . >>> Color ( 'red' ) . closest ([ 'pink' , 'yellow' , 'green' , 'blue' , 'purple' , 'maroon' ]) color(srgb 0.50196 0 0 / 1) Color('red').closest(['pink', 'yellow', 'green', 'blue', 'purple', 'maroon']) Edit Share Run Cancel","title":"Color Distance and Delta E"},{"location":"distance/#color-distance-and-delta-e","text":"The difference or distance between two colors allows for a quantified analysis of how far apart two colors are from one another. This metric is of particular interest in the field of color science, but it has practical applications in color libraries working with colors. Usually, color distance is applied to near perceptual uniform color spaces in order to obtain a metric regarding a color's visual, perceptual distance from another color. This can be useful in gamut mapping or even determining that colors are close enough or far enough away from each other.","title":"Color Distance and Delta E"},{"location":"distance/#color-distance","text":"ColorAide provides a simple euclidean color distance function. By default, it evaluates the distance in the CIELAB color space, but it can be configured to evaluate in any color space, such as Oklab, etc. It may be less useful in some color spaces compared to others. Some spaces may not be well suited, such as cylindrical spaces. Some spaces might not be as very perceptually uniform as others requiring more complex algorithms. >>> Color ( \"red\" ) . distance ( \"blue\" , space = \"srgb\" ) 1.4142135623730951 >>> Color ( \"red\" ) . distance ( \"blue\" , space = \"lab\" ) 184.0190486209969 Color(\"red\").distance(\"blue\", space=\"srgb\") Color(\"red\").distance(\"blue\", space=\"lab\") Edit Share Run Cancel","title":"Color Distance"},{"location":"distance/#delta-e","text":"The delta_e function gives access to various \u2206E implementations, which are just different algorithms to calculate distance. Some are simply Euclidean distance withing a certain color space, some are far more complex. If no method is specified, the default implementation is \u2206E * ab (CIE76) which uses a simple Euclidean distancing algorithm on the CIELAB color space. It is fast, but not as accurate as later iterations of the algorithm as CIELAB is not actually as perceptually uniform as it was thought when CIELAB was originally developed. >>> Color ( \"red\" ) . delta_e ( \"blue\" ) 184.0190486209969 Color(\"red\").delta_e(\"blue\") Edit Share Run Cancel When method is set, the specified \u2206E algorithm will be used instead. For instance, below we use \u2206E 00 which is a more complex algorithm that accounts for the CIELAB's weakness in perceptually uniformity. It does come at the cost of being a little slower. >>> Color ( \"red\" ) . delta_e ( \"blue\" , method = \"2000\" ) 55.79977339019777 Color(\"red\").delta_e(\"blue\", method=\"2000\") Edit Share Run Cancel Below are all the supported \u2206E methods. Follow relevant links to read the specs and find out more about a given \u2206E method. Delta E Name Parameters \u2206E * ab (CIE76) 76 \u2206E * cmc (CMC l:c (1984)) cmc l=2, c=1 \u2206E * 94 (CIE94) 94 kl=1, k1=0.045, k2=0.015 \u2206E * 00 (CIEDE2000) 2000 kl=1, kc=1, kh=1 \u2206E itp (ICtCp) itp scalar=720 \u2206E z (Jzazbz) jz \u2206E 99o (DIN99o) 99o \u2206E HyAB (HyAB) hyab space=\"lab\" \u2206E ok ok scalar=1 \u2206E methods are also accessible via methods delta_e_<name> , where <name> is a name from the above table. >>> Color ( \"red\" ) . delta_e_jz ( \"blue\" ) 0.3396038842016558 >>> Color ( \"red\" ) . delta_e_hyab ( \"blue\" ) 207.07305826980567 Color(\"red\").delta_e_jz(\"blue\") Color(\"red\").delta_e_hyab(\"blue\") Edit Share Run Cancel","title":"Delta E"},{"location":"distance/#finding-closest-color","text":"ColorAide implements a simple way to find the closest color, given a list of colors, to another color. The method is called closest and takes a list of colors that are to be compared to the calling color object. The first color with the smallest distance between the calling color object and itself will be considered the nearest/closest color. Consider the following example. Here we provide a list of colors to compare against red . After comparing all the colors, the closest ends up being maroon . >>> Color ( 'red' ) . closest ([ 'pink' , 'yellow' , 'green' , 'blue' , 'purple' , 'maroon' ]) color(srgb 0.50196 0 0 / 1) Color('red').closest(['pink', 'yellow', 'green', 'blue', 'purple', 'maroon']) Edit Share Run Cancel","title":"Finding Closest Color"},{"location":"gamut/","text":"Gamut Mapping Many color spaces are designed in such a way that they can only represent colors accurately within a specific range. This range in which a color can accurately be represented is known as the color gamut. While some color spaces are theoretically unbounded, there are many that are designed with distinct ranges. The sRGB and Display P3 color spaces are both RGB color spaces, but they actually can represent a different amount of colors. Display P3 has a wider gamut and allows for greener greens and redder reds, etc. In the image below, we show four different RGB color spaces, each with varying different gamut sizes. Display P3 contains all the colors in sRGB and extends it even further. Rec. 2020, another RGB color space, is even wider. ProPhoto is so wide that it contains colors that the human eye can't even see. In order to visually represent a color from a wider gamut color space, such as Display P3, in a more narrow color space, such as sRGB, a suitable color within the more narrow color space must must be selected and be shown in its place. This selecting of a suitable replacement is called gamut mapping. ColorAide defines a couple methods to help identify when a color is outside the gamut bounds of a color space and to help find a suitable, alternative color that is within the gamut. Checking Gamut When dealing with colors, it can be important to know whether a color is within its own gamut. The in_gamut function allows for comparing the current color's specified values against the color space's gamut. Let's assume we have a color rgb ( 30 % 105 % 0 % ) . The color is out of gamut due to the green channel exceeding the channel's limit of 100 % . When we execute in_gamut , we can see that the color is not in its own gamut. >>> Color ( \"rgb(30 % 105% 0%)\" ) . in_gamut () False Color(\"rgb(30% 105% 0%)\").in_gamut() Edit Share Run Cancel On the other hand, some color spaces do not have a limit. CIELAB is one such color space. Sometimes limits will be placed on the color space channels for practicality, but theoretically, there are no bounds. When we check a CIELAB color, we will find that it is always considered in gamut. >>> Color ( \"lab(200% -20 40 / 1)\" ) . in_gamut () True Color(\"lab(200% -20 40 / 1)\").in_gamut() Edit Share Run Cancel While checking CIELAB's own gamut isn't very useful, we can test it against a different color space's gamut. By simply passing in the name of a different color space, the current color will be converted to the provided space and then will run in_gamut on the new color. You could do this manually, but using in_gamut in this manner can be very convenient. In the example below, we can see that the CIELAB color of lab ( 200 % - 20 40 / 1 ) is outside the narrow gamut of sRGB. >>> Color ( \"lab(200% -20 40 / 1)\" ) . in_gamut ( 'srgb' ) False Color(\"lab(200% -20 40 / 1)\").in_gamut('srgb') Edit Share Run Cancel Tolerance Generally, ColorAide does not round off values in order to guarantee the best possible values for round tripping, but due to limitations of floating-point arithmetic and precision of conversion algorithms, there can be edge cases where colors don't round trip perfectly. By default, in_gamut allows for a tolerance of 0.000075 to account for such cases where a color is \"close enough\". If desired, this \"tolerance\" can be adjusted. Let's consider CIELAB with a D65 white point. The sRGB round trip through CIELAB D65 for white does not perfectly convert back to the original color. This is due to the perils of floating point arithmetic. >>> Color ( 'color(srgb 1 1 1)' ) . convert ( 'lab-d65' ) . coords () [100.0, 0.0, 0.0] >>> Color ( 'color(srgb 1 1 1)' ) . convert ( 'lab-d65' ) . convert ( 'srgb' ) . coords () [1.0000000000000002, 0.9999999999999999, 0.9999999999999997] Color('color(srgb 1 1 1)').convert('lab-d65').coords() Color('color(srgb 1 1 1)').convert('lab-d65').convert('srgb').coords() Edit Share Run Cancel We can see that when using a tolerance of zero, and gamut checking in sRGB, that the color is considered out of gamut. This makes sense as the round trip through CIELAB D65 and back is so very close, but ever so slightly off. Depending on what you are doing, this may not be an issue up until you are ready to finalize the color, so sometimes it may be desirable to have some tolerance, and other times not. >>> Color ( 'color(srgb 1 1 1)' ) . convert ( 'lab-d65' ) . convert ( 'srgb' ) . coords () [1.0000000000000002, 0.9999999999999999, 0.9999999999999997] >>> Color ( 'color(srgb 1 1 1)' ) . convert ( 'lab-d65' ) . convert ( 'srgb' ) . in_gamut () True >>> Color ( 'color(srgb 1 1 1)' ) . convert ( 'lab-d65' ) . convert ( 'srgb' ) . in_gamut ( tolerance = 0 ) False Color('color(srgb 1 1 1)').convert('lab-d65').convert('srgb').coords() Color('color(srgb 1 1 1)').convert('lab-d65').convert('srgb').in_gamut() Color('color(srgb 1 1 1)').convert('lab-d65').convert('srgb').in_gamut(tolerance=0) Edit Share Run Cancel On the topic of tolerance, lets consider some color models that do not handle out of gamut colors very well. There are some color models that are alternate representations of an existing color space. For instance, the cylindrical spaces HSL, HSV, and HWB are just different color models for the sRGB color space. They are are essentially the sRGB color space, just with cylindrical coordinates that isolate certain attributes of the color space: saturation, whiteness, blackness, etc. So their gamut is exactly the same as the sRGB space, because they are the sRGB color space. So it stands to reason that simply using the sRGB gamut check for them should be sufficient, and if we are using strict tolerance, this would be true. >>> Color ( 'rgb(255 255 255)' ) . in_gamut ( 'srgb' , tolerance = 0 ) True >>> Color ( 'hsl(0 0 % 100% )' ) . in_gamut ( 'srgb' , tolerance = 0 ) True >>> Color ( 'color(--hsv 0 0 % 100% )' ) . in_gamut ( 'srgb' , tolerance = 0 ) True >>> Color ( 'rgb(255.05 255 255)' ) . in_gamut ( 'srgb' , tolerance = 0 ) False >>> Color ( 'hsl(0 0 % 100.05% )' ) . in_gamut ( 'srgb' , tolerance = 0 ) False >>> Color ( 'color(--hsv 0 0 % 100.05% )' ) . in_gamut ( 'srgb' , tolerance = 0 ) False Color('rgb(255 255 255)').in_gamut('srgb', tolerance=0) Color('hsl(0 0% 100%)').in_gamut('srgb', tolerance=0) Color('color(--hsv 0 0% 100%)').in_gamut('srgb', tolerance=0) Color('rgb(255.05 255 255)').in_gamut('srgb', tolerance=0) Color('hsl(0 0% 100.05%)').in_gamut('srgb', tolerance=0) Color('color(--hsv 0 0% 100.05%)').in_gamut('srgb', tolerance=0) Edit Share Run Cancel But when we are not using a strict threshold, and we check one of these models only using the sRGB gamut, there are some cases where these cylindrical colors can exhibit coordinates wildly outside of the model's range but still very close to the sRGB gamut. In this example, we have an sRGB color that is extremely close to being in gamut, but when we convert it to HSL, we can see wildly large saturation. >>> hsl = Color ( 'color(srgb 0.9999999999994 1.0000000000002 0.9999999999997)' ) . convert ( 'hsl' ) >>> hsl . to_string ( fit = False ) hsl(142.5 200.06% 100%) >>> hsl . in_gamut ( 'srgb' ) True hsl = Color('color(srgb 0.9999999999994 1.0000000000002 0.9999999999997)').convert('hsl') hsl.to_string(fit=False) hsl.in_gamut('srgb') Edit Share Run Cancel This happens because these cylindrical color models do not represent colors out of gamut in a very sane way. They are simply not designed to extend past the color gamut. So even a slightly out of gamut sRGB color can translate to a value way outside the cylindrical color model's boundaries. For this reason, gamut checks in the HSL, HSV, or HWB models apply tolerance checks on the color's coordinates in the sRGB color space and the respective cylindrical model ensuring we have coordinates that are close to the color's actual gamut and reasonably close to the cylindrical model's constraints as well. So, when using HSL as the gamut check, we can see that it ensures the color is not only very close to the sRGB gamut, but that it is also very close the color model's constraints. >>> hsl = Color ( 'color(srgb 0.9999999999994 1.0000000000002 0.9999999999997)' ) . convert ( 'hsl' ) >>> hsl color(--hsl 142.5 2.0006 1 / 1) >>> hsl . in_gamut ( 'hsl' ) False hsl = Color('color(srgb 0.9999999999994 1.0000000000002 0.9999999999997)').convert('hsl') hsl hsl.in_gamut('hsl') Edit Share Run Cancel If the Cartesian check is the only desired check, and the strange cylindrical values that are returned are not a problem, srgb can always be specified. tolerance = 0 can also be used to constrain the check to values exactly in the gamut. When a color is precisely in gamut, HSL has a very tight conversion to and from sRGB. A color that is in gamut, will remain in gamut throughout the conversion, forwards and backwards. Okhsl and Okhsv, on the other hand, are color models have a looser conversion algorithm. While the constrains mimic the traditional HSL and HSV boundaries, the edges of those boundaries do not always convert precisely back into the sRGB gamut. Okhsl and Okhsv are color models that more approximate the sRGB gamut, and seem to expect some clipping and/or rounding when going back to sRGB. Adjusting the tolerance for these color models may be sufficient until you are ready to finalize the color by clipping the color to remove the noise. >>> okhsv = Color ( 'color(--okhsv 20 100 % 75% / 1)' ) >>> okhsv . in_gamut () False >>> okhsv . convert ( 'srgb' ) color(srgb 0.74239 -0.00034 0.18686 / 1) >>> okhsv . in_gamut ( tolerance = 0.0005 ) True okhsv = Color('color(--okhsv 20 100% 75% / 1)') okhsv.in_gamut() okhsv.convert('srgb') okhsv.in_gamut(tolerance=0.0005) Edit Share Run Cancel Mapping Colors Gamut mapping is the process of taking a color that is out of gamut and adjusting it such that it fits within the gamut. Gamut mapping in general is performed via the fit () method. Doing this will cause the default gamut mapping to be used. If desired, a user can also specify any currently registered gamut mapping method via the method parameter. >>> Color ( 'rgb(270 30 120)' ) . fit () color(srgb 1 0.18694 0.47465 / 1) >>> Color ( 'rgb(270 30 120)' ) . fit ( method = 'clip' ) color(srgb 1 0.11765 0.47059 / 1) Color('rgb(270 30 120)').fit() Color('rgb(270 30 120)').fit(method='clip') Edit Share Run Cancel Gamut mapping can also be used to fit colors in other gamuts, for instance, fitting a Display P3 color into an sRGB gamut. >>> c1 = Color ( 'color(display-p3 1 1 0)' ) >>> c1 . in_gamut ( 'srgb' ) False >>> c1 . fit ( 'srgb' , in_place = True ) color(display-p3 0.99903 0.9947 0.32928 / 1) >>> c1 . in_gamut () True c1 = Color('color(display-p3 1 1 0)') c1.in_gamut('srgb') c1.fit('srgb', in_place=True) c1.in_gamut() Edit Share Run Cancel Caveats when Mapping in Other Spaces When fitting in another color space, results may vary depending on what color space you are in and what color space you are using to fit the color. We went into great depths when discussing gamut checking about how transform functions from one color space to another are not always exact. We also gave quite a number of examples showing cases in which some color spaces were more sensitive to slight deviations outside their gamut than others. This is mainly mentioned as fitting in one color space and round tripping back may not give exact results: >>> Color ( \"color(--lch-d65 100 50 75)\" ) . convert ( 'srgb' ) . fit () . coords () [1.0, 1.0, 1.0] >>> Color ( \"color(--lch-d65 100 50 75)\" ) . fit ( 'srgb' ) . convert ( 'srgb' ) . coords () [1.0000000000000002, 0.9999999999999999, 0.9999999999999997] Color(\"color(--lch-d65 100 50 75)\").convert('srgb').fit().coords() Color(\"color(--lch-d65 100 50 75)\").fit('srgb').convert('srgb').coords() Edit Share Run Cancel While the above case is well within the threshold, depending on what you are doing, and what spaces you are working in, it may make sense to fully convert to a space and work directly in that space opposed to the indirect fitting of a color in a different color space. Clipping is not the default gamut mapping method, and generally not recommended to be used as such, but that doesn't mean it isn't useful. Clipping is still very important and can be used to trim channel noise after certain mathematical operations or even used in other gamut mapping algorithms if used carefully. For this reason, clip also has its own dedicated method for quick access: clip () . It can also be applied directly to the current color space or can be applied on the gamuts of other color spaces just like fit () . >>> Color ( 'rgb(270 30 120)' ) . clip () color(srgb 1 0.11765 0.47059 / 1) >>> Color ( 'color(display-p3 1 1 0)' ) . clip ( 'srgb' ) color(display-p3 1 1 0.3309 / 1) Color('rgb(270 30 120)').clip() Color('color(display-p3 1 1 0)').clip('srgb') Edit Share Run Cancel There are actually many different ways to gamut map a color. Some are computationally expensive, some are quite simple, and many do really good in some cases and not so well in others. There is probably no perfect gamut mapping method, but some are better than others. ColorAide currently only offers a couple simple methods to gamut map. Method Description clip Simple, naive clipping. lch-chroma Uses a combination of chroma reduction and MINDE in the CIELCH color space to bring a color into gamut. This is the default method used. oklch-chroma Like lch-chroma , but uses the Oklch color space instead. Currently experimental and is meant to be similar to css-color-4 , but provides better results at the cost of being a little slower. css-color-4 This is the algorithm as currently specified by the CSS Color Level 4 specification . It is like oklch-chroma , but it is faster at the cost of providing slightly inferior results. CSS Level 4 Gamut Mapping The CSS CSS Color Level 4 specification currently recommends using Oklch as the gamut mapping color space and uses an algorithm very similar to what we use. But Oklch is a very new color space to be used in the field of gamut mapping. While CIELCH is not perfect, its weakness are known. Oklch may have quirks of its own, so usage is considered experimental and not used by default. We currently provide css-color-4 for CSS purists, but the spec could change as it is still not really finalized. Additionally, some issues with it have been discovered which is why we currently offer both oklch-chroma and css-color-4 . css-color-4 seems to suffer from an issue that can cause color banding when doing interpolations. The way it kicks out of the binary search when reducing chroma can lead to a worse case scenario were two adjacent, gamut mapped colors can exaggerate their maximum color distance. This creates noticeable banding at some points. While maybe some eyes may struggle to see the difference, others may notice some color banding. Below we illustrate the problem. The CSS algorithm is used on top and our adjusted variant is used on the bottom. >>> class ColorCss ( Color ): ... FIT = 'css-color-4' ... >>> class ColorOk ( Color ): ... FIT = 'oklch-chroma' ... >>> ColorCss ( \"lch(85% 80 310)\" ) . interpolate ( \"lch(85% 100 85)\" , space = 'oklch' ) <coloraide.interpolate.InterpolateSingle object at 0x1033d0eb0> >>> ColorOk ( \"lch(85% 80 310)\" ) . interpolate ( \"lch(85% 100 85)\" , space = 'oklch' ) <coloraide.interpolate.InterpolateSingle object at 0x1033e4160> class ColorCss(Color): FIT = 'css-color-4' class ColorOk(Color): FIT = 'oklch-chroma' ColorCss(\"lch(85% 80 310)\").interpolate(\"lch(85% 100 85)\", space='oklch') ColorOk(\"lch(85% 80 310)\").interpolate(\"lch(85% 100 85)\", space='oklch') Edit Share Run Cancel Why Not Just Clip? In current web browsers, clipping is the default way in which out of gamut colors have been handled. It is fast, and has generally been fine as most browsers have been constrained to using sRGB. But as modern browsers begin to adopt more wide gamut monitors such as Display P3, and CSS grows to support an assortment of wide and ultra wide color spaces, representing the best intent of an out of gamut color becomes more important. ColorAide uses a default gamut mapping algorithm that performs gamut mapping in the CIELCH color space using chroma reduction coupled with minimum \u2206E ( MINDE ). This approach is meant to preserve enough of the important attributes of the out of gamut color as is possible, mostly preserving both lightness and hue, hue being the attribute that people are most sensitive to. MINDE is used to abandon chroma reduction and clip the color when the color is very close to being in gamut. MINDE also allows us to catch cases where the geometry of the color space's gamut is such that we may slip by higher chroma options resulting in undesirable, aggressive chroma reduction. Below we have an example of using chroma reduction with MINDE . It can be noted that chroma is reduced until we are very close to being in gamut. The MINDE helps us catch the peak of the yellow shape as, otherwise, we would have continued reducing chroma until we were at a very chroma reduced, pale yellow. One might see some cases of clipping and think it does a fine job and question why any of this complexity is necessary. In order to demonstrate the differences in gamut mapping vs clipping, see the example below. We start with the color color ( display-p3 1 1 0 ) and interpolate with it in the CIELCH color space reducing just the lightness. This will leave both chroma and hue intact. The Interactive playground below automatically gamut maps the color previews to sRGB, but we'll control the method being used by providing two different Color objects: one that uses lch-chroma (the default) for gamut mapping, and one that uses clip . Notice how clipping, the bottom color set, clips these dark colors and makes them reddish. This is a very undesirable outcome. >>> class ColorClip ( Color ): ... FIT = 'clip' ... >>> yellow = Color ( 'color(display-p3 1 1 0)' ) >>> lightness_mask = Color ( 'lch(0% none none)' ) >>> yellow . steps ( lightness_mask , steps = 10 , space = 'lch' ) [color(display-p3 1 1 0 / 1), color(display-p3 0.86965 0.87865 -0.1393 / 1), color(display-p3 0.74183 0.76037 -0.16139 / 1), color(display-p3 0.61856 0.64535 -0.17688 / 1), color(display-p3 0.50161 0.53384 -0.19747 / 1), color(display-p3 0.39311 0.42617 -0.22085 / 1), color(display-p3 0.29717 0.32269 -0.24546 / 1), color(display-p3 0.22186 0.22377 -0.27027 / 1), color(display-p3 0.17897 0.12968 -0.29464 / 1), color(display-p3 0.13001 0.03358 -0.31816 / 1)] >>> ColorRow () <docs.src.py.notebook.ColorRow object at 0x1033d08e0> >>> yellow = ColorClip ( 'color(display-p3 1 1 0)' ) >>> lightness_mask = Color ( 'lch(0% none none)' ) >>> yellow . steps ( lightness_mask , steps = 10 , space = 'lch' ) [color(display-p3 1 1 0 / 1), color(display-p3 0.86965 0.87865 -0.1393 / 1), color(display-p3 0.74183 0.76037 -0.16139 / 1), color(display-p3 0.61856 0.64535 -0.17688 / 1), color(display-p3 0.50161 0.53384 -0.19747 / 1), color(display-p3 0.39311 0.42617 -0.22085 / 1), color(display-p3 0.29717 0.32269 -0.24546 / 1), color(display-p3 0.22186 0.22377 -0.27027 / 1), color(display-p3 0.17897 0.12968 -0.29464 / 1), color(display-p3 0.13001 0.03358 -0.31816 / 1)] class ColorClip(Color): FIT = 'clip' # Gamut mapping in Lch yellow = Color('color(display-p3 1 1 0)') lightness_mask = Color('lch(0% none none)') yellow.steps(lightness_mask, steps=10, space='lch') # Force a new row for next example ColorRow() # Clipping yellow = ColorClip('color(display-p3 1 1 0)') lightness_mask = Color('lch(0% none none)') yellow.steps(lightness_mask, steps=10, space='lch') Edit Share Run Cancel There are times when clipping is simply preferred. It is fast, and if you are just trimming noise off channels, it is very useful, but if the idea is to present an in gamut color that tries to preserve as much of the intent of the original color as possible, other methods may be desired. There are no doubt better gamut methods available than ColorAide offers, and more may be added in the future, but ColorAide can also be extended using 3 rd party plugins as well.","title":"Gamut Mapping"},{"location":"gamut/#gamut-mapping","text":"Many color spaces are designed in such a way that they can only represent colors accurately within a specific range. This range in which a color can accurately be represented is known as the color gamut. While some color spaces are theoretically unbounded, there are many that are designed with distinct ranges. The sRGB and Display P3 color spaces are both RGB color spaces, but they actually can represent a different amount of colors. Display P3 has a wider gamut and allows for greener greens and redder reds, etc. In the image below, we show four different RGB color spaces, each with varying different gamut sizes. Display P3 contains all the colors in sRGB and extends it even further. Rec. 2020, another RGB color space, is even wider. ProPhoto is so wide that it contains colors that the human eye can't even see. In order to visually represent a color from a wider gamut color space, such as Display P3, in a more narrow color space, such as sRGB, a suitable color within the more narrow color space must must be selected and be shown in its place. This selecting of a suitable replacement is called gamut mapping. ColorAide defines a couple methods to help identify when a color is outside the gamut bounds of a color space and to help find a suitable, alternative color that is within the gamut.","title":"Gamut Mapping"},{"location":"gamut/#checking-gamut","text":"When dealing with colors, it can be important to know whether a color is within its own gamut. The in_gamut function allows for comparing the current color's specified values against the color space's gamut. Let's assume we have a color rgb ( 30 % 105 % 0 % ) . The color is out of gamut due to the green channel exceeding the channel's limit of 100 % . When we execute in_gamut , we can see that the color is not in its own gamut. >>> Color ( \"rgb(30 % 105% 0%)\" ) . in_gamut () False Color(\"rgb(30% 105% 0%)\").in_gamut() Edit Share Run Cancel On the other hand, some color spaces do not have a limit. CIELAB is one such color space. Sometimes limits will be placed on the color space channels for practicality, but theoretically, there are no bounds. When we check a CIELAB color, we will find that it is always considered in gamut. >>> Color ( \"lab(200% -20 40 / 1)\" ) . in_gamut () True Color(\"lab(200% -20 40 / 1)\").in_gamut() Edit Share Run Cancel While checking CIELAB's own gamut isn't very useful, we can test it against a different color space's gamut. By simply passing in the name of a different color space, the current color will be converted to the provided space and then will run in_gamut on the new color. You could do this manually, but using in_gamut in this manner can be very convenient. In the example below, we can see that the CIELAB color of lab ( 200 % - 20 40 / 1 ) is outside the narrow gamut of sRGB. >>> Color ( \"lab(200% -20 40 / 1)\" ) . in_gamut ( 'srgb' ) False Color(\"lab(200% -20 40 / 1)\").in_gamut('srgb') Edit Share Run Cancel","title":"Checking Gamut"},{"location":"gamut/#tolerance","text":"Generally, ColorAide does not round off values in order to guarantee the best possible values for round tripping, but due to limitations of floating-point arithmetic and precision of conversion algorithms, there can be edge cases where colors don't round trip perfectly. By default, in_gamut allows for a tolerance of 0.000075 to account for such cases where a color is \"close enough\". If desired, this \"tolerance\" can be adjusted. Let's consider CIELAB with a D65 white point. The sRGB round trip through CIELAB D65 for white does not perfectly convert back to the original color. This is due to the perils of floating point arithmetic. >>> Color ( 'color(srgb 1 1 1)' ) . convert ( 'lab-d65' ) . coords () [100.0, 0.0, 0.0] >>> Color ( 'color(srgb 1 1 1)' ) . convert ( 'lab-d65' ) . convert ( 'srgb' ) . coords () [1.0000000000000002, 0.9999999999999999, 0.9999999999999997] Color('color(srgb 1 1 1)').convert('lab-d65').coords() Color('color(srgb 1 1 1)').convert('lab-d65').convert('srgb').coords() Edit Share Run Cancel We can see that when using a tolerance of zero, and gamut checking in sRGB, that the color is considered out of gamut. This makes sense as the round trip through CIELAB D65 and back is so very close, but ever so slightly off. Depending on what you are doing, this may not be an issue up until you are ready to finalize the color, so sometimes it may be desirable to have some tolerance, and other times not. >>> Color ( 'color(srgb 1 1 1)' ) . convert ( 'lab-d65' ) . convert ( 'srgb' ) . coords () [1.0000000000000002, 0.9999999999999999, 0.9999999999999997] >>> Color ( 'color(srgb 1 1 1)' ) . convert ( 'lab-d65' ) . convert ( 'srgb' ) . in_gamut () True >>> Color ( 'color(srgb 1 1 1)' ) . convert ( 'lab-d65' ) . convert ( 'srgb' ) . in_gamut ( tolerance = 0 ) False Color('color(srgb 1 1 1)').convert('lab-d65').convert('srgb').coords() Color('color(srgb 1 1 1)').convert('lab-d65').convert('srgb').in_gamut() Color('color(srgb 1 1 1)').convert('lab-d65').convert('srgb').in_gamut(tolerance=0) Edit Share Run Cancel On the topic of tolerance, lets consider some color models that do not handle out of gamut colors very well. There are some color models that are alternate representations of an existing color space. For instance, the cylindrical spaces HSL, HSV, and HWB are just different color models for the sRGB color space. They are are essentially the sRGB color space, just with cylindrical coordinates that isolate certain attributes of the color space: saturation, whiteness, blackness, etc. So their gamut is exactly the same as the sRGB space, because they are the sRGB color space. So it stands to reason that simply using the sRGB gamut check for them should be sufficient, and if we are using strict tolerance, this would be true. >>> Color ( 'rgb(255 255 255)' ) . in_gamut ( 'srgb' , tolerance = 0 ) True >>> Color ( 'hsl(0 0 % 100% )' ) . in_gamut ( 'srgb' , tolerance = 0 ) True >>> Color ( 'color(--hsv 0 0 % 100% )' ) . in_gamut ( 'srgb' , tolerance = 0 ) True >>> Color ( 'rgb(255.05 255 255)' ) . in_gamut ( 'srgb' , tolerance = 0 ) False >>> Color ( 'hsl(0 0 % 100.05% )' ) . in_gamut ( 'srgb' , tolerance = 0 ) False >>> Color ( 'color(--hsv 0 0 % 100.05% )' ) . in_gamut ( 'srgb' , tolerance = 0 ) False Color('rgb(255 255 255)').in_gamut('srgb', tolerance=0) Color('hsl(0 0% 100%)').in_gamut('srgb', tolerance=0) Color('color(--hsv 0 0% 100%)').in_gamut('srgb', tolerance=0) Color('rgb(255.05 255 255)').in_gamut('srgb', tolerance=0) Color('hsl(0 0% 100.05%)').in_gamut('srgb', tolerance=0) Color('color(--hsv 0 0% 100.05%)').in_gamut('srgb', tolerance=0) Edit Share Run Cancel But when we are not using a strict threshold, and we check one of these models only using the sRGB gamut, there are some cases where these cylindrical colors can exhibit coordinates wildly outside of the model's range but still very close to the sRGB gamut. In this example, we have an sRGB color that is extremely close to being in gamut, but when we convert it to HSL, we can see wildly large saturation. >>> hsl = Color ( 'color(srgb 0.9999999999994 1.0000000000002 0.9999999999997)' ) . convert ( 'hsl' ) >>> hsl . to_string ( fit = False ) hsl(142.5 200.06% 100%) >>> hsl . in_gamut ( 'srgb' ) True hsl = Color('color(srgb 0.9999999999994 1.0000000000002 0.9999999999997)').convert('hsl') hsl.to_string(fit=False) hsl.in_gamut('srgb') Edit Share Run Cancel This happens because these cylindrical color models do not represent colors out of gamut in a very sane way. They are simply not designed to extend past the color gamut. So even a slightly out of gamut sRGB color can translate to a value way outside the cylindrical color model's boundaries. For this reason, gamut checks in the HSL, HSV, or HWB models apply tolerance checks on the color's coordinates in the sRGB color space and the respective cylindrical model ensuring we have coordinates that are close to the color's actual gamut and reasonably close to the cylindrical model's constraints as well. So, when using HSL as the gamut check, we can see that it ensures the color is not only very close to the sRGB gamut, but that it is also very close the color model's constraints. >>> hsl = Color ( 'color(srgb 0.9999999999994 1.0000000000002 0.9999999999997)' ) . convert ( 'hsl' ) >>> hsl color(--hsl 142.5 2.0006 1 / 1) >>> hsl . in_gamut ( 'hsl' ) False hsl = Color('color(srgb 0.9999999999994 1.0000000000002 0.9999999999997)').convert('hsl') hsl hsl.in_gamut('hsl') Edit Share Run Cancel If the Cartesian check is the only desired check, and the strange cylindrical values that are returned are not a problem, srgb can always be specified. tolerance = 0 can also be used to constrain the check to values exactly in the gamut. When a color is precisely in gamut, HSL has a very tight conversion to and from sRGB. A color that is in gamut, will remain in gamut throughout the conversion, forwards and backwards. Okhsl and Okhsv, on the other hand, are color models have a looser conversion algorithm. While the constrains mimic the traditional HSL and HSV boundaries, the edges of those boundaries do not always convert precisely back into the sRGB gamut. Okhsl and Okhsv are color models that more approximate the sRGB gamut, and seem to expect some clipping and/or rounding when going back to sRGB. Adjusting the tolerance for these color models may be sufficient until you are ready to finalize the color by clipping the color to remove the noise. >>> okhsv = Color ( 'color(--okhsv 20 100 % 75% / 1)' ) >>> okhsv . in_gamut () False >>> okhsv . convert ( 'srgb' ) color(srgb 0.74239 -0.00034 0.18686 / 1) >>> okhsv . in_gamut ( tolerance = 0.0005 ) True okhsv = Color('color(--okhsv 20 100% 75% / 1)') okhsv.in_gamut() okhsv.convert('srgb') okhsv.in_gamut(tolerance=0.0005) Edit Share Run Cancel","title":"Tolerance"},{"location":"gamut/#mapping-colors","text":"Gamut mapping is the process of taking a color that is out of gamut and adjusting it such that it fits within the gamut. Gamut mapping in general is performed via the fit () method. Doing this will cause the default gamut mapping to be used. If desired, a user can also specify any currently registered gamut mapping method via the method parameter. >>> Color ( 'rgb(270 30 120)' ) . fit () color(srgb 1 0.18694 0.47465 / 1) >>> Color ( 'rgb(270 30 120)' ) . fit ( method = 'clip' ) color(srgb 1 0.11765 0.47059 / 1) Color('rgb(270 30 120)').fit() Color('rgb(270 30 120)').fit(method='clip') Edit Share Run Cancel Gamut mapping can also be used to fit colors in other gamuts, for instance, fitting a Display P3 color into an sRGB gamut. >>> c1 = Color ( 'color(display-p3 1 1 0)' ) >>> c1 . in_gamut ( 'srgb' ) False >>> c1 . fit ( 'srgb' , in_place = True ) color(display-p3 0.99903 0.9947 0.32928 / 1) >>> c1 . in_gamut () True c1 = Color('color(display-p3 1 1 0)') c1.in_gamut('srgb') c1.fit('srgb', in_place=True) c1.in_gamut() Edit Share Run Cancel Caveats when Mapping in Other Spaces When fitting in another color space, results may vary depending on what color space you are in and what color space you are using to fit the color. We went into great depths when discussing gamut checking about how transform functions from one color space to another are not always exact. We also gave quite a number of examples showing cases in which some color spaces were more sensitive to slight deviations outside their gamut than others. This is mainly mentioned as fitting in one color space and round tripping back may not give exact results: >>> Color ( \"color(--lch-d65 100 50 75)\" ) . convert ( 'srgb' ) . fit () . coords () [1.0, 1.0, 1.0] >>> Color ( \"color(--lch-d65 100 50 75)\" ) . fit ( 'srgb' ) . convert ( 'srgb' ) . coords () [1.0000000000000002, 0.9999999999999999, 0.9999999999999997] Color(\"color(--lch-d65 100 50 75)\").convert('srgb').fit().coords() Color(\"color(--lch-d65 100 50 75)\").fit('srgb').convert('srgb').coords() Edit Share Run Cancel While the above case is well within the threshold, depending on what you are doing, and what spaces you are working in, it may make sense to fully convert to a space and work directly in that space opposed to the indirect fitting of a color in a different color space. Clipping is not the default gamut mapping method, and generally not recommended to be used as such, but that doesn't mean it isn't useful. Clipping is still very important and can be used to trim channel noise after certain mathematical operations or even used in other gamut mapping algorithms if used carefully. For this reason, clip also has its own dedicated method for quick access: clip () . It can also be applied directly to the current color space or can be applied on the gamuts of other color spaces just like fit () . >>> Color ( 'rgb(270 30 120)' ) . clip () color(srgb 1 0.11765 0.47059 / 1) >>> Color ( 'color(display-p3 1 1 0)' ) . clip ( 'srgb' ) color(display-p3 1 1 0.3309 / 1) Color('rgb(270 30 120)').clip() Color('color(display-p3 1 1 0)').clip('srgb') Edit Share Run Cancel There are actually many different ways to gamut map a color. Some are computationally expensive, some are quite simple, and many do really good in some cases and not so well in others. There is probably no perfect gamut mapping method, but some are better than others. ColorAide currently only offers a couple simple methods to gamut map. Method Description clip Simple, naive clipping. lch-chroma Uses a combination of chroma reduction and MINDE in the CIELCH color space to bring a color into gamut. This is the default method used. oklch-chroma Like lch-chroma , but uses the Oklch color space instead. Currently experimental and is meant to be similar to css-color-4 , but provides better results at the cost of being a little slower. css-color-4 This is the algorithm as currently specified by the CSS Color Level 4 specification . It is like oklch-chroma , but it is faster at the cost of providing slightly inferior results. CSS Level 4 Gamut Mapping The CSS CSS Color Level 4 specification currently recommends using Oklch as the gamut mapping color space and uses an algorithm very similar to what we use. But Oklch is a very new color space to be used in the field of gamut mapping. While CIELCH is not perfect, its weakness are known. Oklch may have quirks of its own, so usage is considered experimental and not used by default. We currently provide css-color-4 for CSS purists, but the spec could change as it is still not really finalized. Additionally, some issues with it have been discovered which is why we currently offer both oklch-chroma and css-color-4 . css-color-4 seems to suffer from an issue that can cause color banding when doing interpolations. The way it kicks out of the binary search when reducing chroma can lead to a worse case scenario were two adjacent, gamut mapped colors can exaggerate their maximum color distance. This creates noticeable banding at some points. While maybe some eyes may struggle to see the difference, others may notice some color banding. Below we illustrate the problem. The CSS algorithm is used on top and our adjusted variant is used on the bottom. >>> class ColorCss ( Color ): ... FIT = 'css-color-4' ... >>> class ColorOk ( Color ): ... FIT = 'oklch-chroma' ... >>> ColorCss ( \"lch(85% 80 310)\" ) . interpolate ( \"lch(85% 100 85)\" , space = 'oklch' ) <coloraide.interpolate.InterpolateSingle object at 0x1033d0eb0> >>> ColorOk ( \"lch(85% 80 310)\" ) . interpolate ( \"lch(85% 100 85)\" , space = 'oklch' ) <coloraide.interpolate.InterpolateSingle object at 0x1033e4160> class ColorCss(Color): FIT = 'css-color-4' class ColorOk(Color): FIT = 'oklch-chroma' ColorCss(\"lch(85% 80 310)\").interpolate(\"lch(85% 100 85)\", space='oklch') ColorOk(\"lch(85% 80 310)\").interpolate(\"lch(85% 100 85)\", space='oklch') Edit Share Run Cancel","title":"Mapping Colors"},{"location":"gamut/#why-not-just-clip","text":"In current web browsers, clipping is the default way in which out of gamut colors have been handled. It is fast, and has generally been fine as most browsers have been constrained to using sRGB. But as modern browsers begin to adopt more wide gamut monitors such as Display P3, and CSS grows to support an assortment of wide and ultra wide color spaces, representing the best intent of an out of gamut color becomes more important. ColorAide uses a default gamut mapping algorithm that performs gamut mapping in the CIELCH color space using chroma reduction coupled with minimum \u2206E ( MINDE ). This approach is meant to preserve enough of the important attributes of the out of gamut color as is possible, mostly preserving both lightness and hue, hue being the attribute that people are most sensitive to. MINDE is used to abandon chroma reduction and clip the color when the color is very close to being in gamut. MINDE also allows us to catch cases where the geometry of the color space's gamut is such that we may slip by higher chroma options resulting in undesirable, aggressive chroma reduction. Below we have an example of using chroma reduction with MINDE . It can be noted that chroma is reduced until we are very close to being in gamut. The MINDE helps us catch the peak of the yellow shape as, otherwise, we would have continued reducing chroma until we were at a very chroma reduced, pale yellow. One might see some cases of clipping and think it does a fine job and question why any of this complexity is necessary. In order to demonstrate the differences in gamut mapping vs clipping, see the example below. We start with the color color ( display-p3 1 1 0 ) and interpolate with it in the CIELCH color space reducing just the lightness. This will leave both chroma and hue intact. The Interactive playground below automatically gamut maps the color previews to sRGB, but we'll control the method being used by providing two different Color objects: one that uses lch-chroma (the default) for gamut mapping, and one that uses clip . Notice how clipping, the bottom color set, clips these dark colors and makes them reddish. This is a very undesirable outcome. >>> class ColorClip ( Color ): ... FIT = 'clip' ... >>> yellow = Color ( 'color(display-p3 1 1 0)' ) >>> lightness_mask = Color ( 'lch(0% none none)' ) >>> yellow . steps ( lightness_mask , steps = 10 , space = 'lch' ) [color(display-p3 1 1 0 / 1), color(display-p3 0.86965 0.87865 -0.1393 / 1), color(display-p3 0.74183 0.76037 -0.16139 / 1), color(display-p3 0.61856 0.64535 -0.17688 / 1), color(display-p3 0.50161 0.53384 -0.19747 / 1), color(display-p3 0.39311 0.42617 -0.22085 / 1), color(display-p3 0.29717 0.32269 -0.24546 / 1), color(display-p3 0.22186 0.22377 -0.27027 / 1), color(display-p3 0.17897 0.12968 -0.29464 / 1), color(display-p3 0.13001 0.03358 -0.31816 / 1)] >>> ColorRow () <docs.src.py.notebook.ColorRow object at 0x1033d08e0> >>> yellow = ColorClip ( 'color(display-p3 1 1 0)' ) >>> lightness_mask = Color ( 'lch(0% none none)' ) >>> yellow . steps ( lightness_mask , steps = 10 , space = 'lch' ) [color(display-p3 1 1 0 / 1), color(display-p3 0.86965 0.87865 -0.1393 / 1), color(display-p3 0.74183 0.76037 -0.16139 / 1), color(display-p3 0.61856 0.64535 -0.17688 / 1), color(display-p3 0.50161 0.53384 -0.19747 / 1), color(display-p3 0.39311 0.42617 -0.22085 / 1), color(display-p3 0.29717 0.32269 -0.24546 / 1), color(display-p3 0.22186 0.22377 -0.27027 / 1), color(display-p3 0.17897 0.12968 -0.29464 / 1), color(display-p3 0.13001 0.03358 -0.31816 / 1)] class ColorClip(Color): FIT = 'clip' # Gamut mapping in Lch yellow = Color('color(display-p3 1 1 0)') lightness_mask = Color('lch(0% none none)') yellow.steps(lightness_mask, steps=10, space='lch') # Force a new row for next example ColorRow() # Clipping yellow = ColorClip('color(display-p3 1 1 0)') lightness_mask = Color('lch(0% none none)') yellow.steps(lightness_mask, steps=10, space='lch') Edit Share Run Cancel There are times when clipping is simply preferred. It is fast, and if you are just trimming noise off channels, it is very useful, but if the idea is to present an in gamut color that tries to preserve as much of the intent of the original color as possible, other methods may be desired. There are no doubt better gamut methods available than ColorAide offers, and more may be added in the future, but ColorAide can also be extended using 3 rd party plugins as well.","title":"Why Not Just Clip?"},{"location":"interpolation/","text":"Color Interpolation Interpolation is a type of estimation that finds new data points based on the range of a discrete set of known data points. When used in the context of color, it is finding one or more colors that reside between any two given colors. One of the most common, and easiest ways to interpolate data between two points is to use linear interpolation. An easy way of thinking about this concept is to imagine drawing a straight line that connects two colors within a color space. We could then navigate up and down that line and return colors at different points to simulate mixing colors at various percentages or return the whole range and create a gradient. To further illustrate this point, the example below shows a slice of the Oklab color space at a lightness of 70%. On this 2D plane, we select two colors: oklab ( 70 % 0 . 2 - 0 . 1 ) and oklab ( 70 % 0 0 . 1 ) . We then connect these two colors with a line. We can then select any point on the line to simulate the mixing of these colors. 0% would yield the first color, 100% would yield the second color, and 50% would yield a new color: oklab ( 70 % 0 . 1 0 ) . Using this simple method as a foundation, ColorAide provides a number of useful utilities to mix colors. Interpolating The interpolate method allows a user to create a linear interpolation function using two or more colors. A returned interpolation function accepts an input between 0 - 1 and will cause a new color between the specified colors to be returned. If a an input value exceeds the range, a color will be returned that is extrapolated on the imaginary line that continues beyond the specified colors which may be surprising. By default, colors are interpolated in the perceptually uniform Oklab color space, though any supported color space can be used instead. This also applies to all methods that use interpolation, such as steps , mix , etc. As an example, below we create an interpolation between rebeccapurple and lch ( 85 % 100 85 ) . We then step through values of 0.1 , 0.2 , 0.3 , etc. This returns colors at various positions on the line that connects the two colors, 0 returning rebeccapurple and 1 returning lch ( 85 % 100 85 ) . >>> i = Color ( \"rebeccapurple\" ) . interpolate ( \"lch(85% 100 85)\" , space = 'lch' ) >>> [ i ( x / 10 ) . to_string () for x in range ( 10 )] ['rgb(102 51 153)', 'rgb(142.02 45.341 154.32)', 'rgb(178.57 36.395 149.51)', 'rgb(211.1 28.455 139.17)', 'rgb(238.6 32.963 124.25)', 'rgb(255 53.081 105.76)', 'rgb(255 91.583 90.14)', 'rgb(255 124.14 78.179)', 'rgb(255 152.99 68.933)', 'rgb(255 178.36 45.889)'] i = Color(\"rebeccapurple\").interpolate(\"lch(85% 100 85)\", space='lch') [i(x/10).to_string() for x in range(10)] Edit Share Run Cancel If we create enough steps, we can create a gradient. >>> Color ( \"rebeccapurple\" ) . interpolate ( ... \"lch(85% 100 85)\" , ... space = 'lch' ... ) <coloraide.interpolate.InterpolateSingle object at 0x1033d0970> Color(\"rebeccapurple\").interpolate( \"lch(85% 100 85)\", space='lch' ) Edit Share Run Cancel Interpolating in Constrained Gamuts Some color spaces, like sRGB, have a limited gamut, but have extended ranges that allow them to represent out of gamut colors in a sane way. Other models, like HSL, HSV, and HWB have the same limited gamut, but have no sane way to represent out of gamut colors. If colors are requested to be interpolated and are too big to be interpolated in the requested color space and cannot properly be represented in that space or model, the colors will be gamut mapped before interpolation. Interpolation can also be done across multiple colors. The function, just like when interpolating between two colors, takes a range of 0 - 1, only this range now applies to the range that spans all the colors, not just two. As it may be impossible to draw a straight line that passes through a series of colors, piecewise interpolation is used at anytime there is more than one color. As this type of interpolation will be cover more later, suffice it to say that this method breaks up the interpolation into individual segments/pieces consisting of only two of the colors in the series and applies linear interpolation to these segments/pieces individually. >>> Color ( 'black' ) . interpolate ([ 'red' , 'white' ]) <coloraide.interpolate.InterpolatePiecewise object at 0x1033d3430> Color('black').interpolate(['red', 'white']) Edit Share Run Cancel Hue Interpolation In interpolation, hues are handled special allowing us to control the way in which hues are evaluated. By default, the shortest angle between two hues is interpolated between, but the hue allows us to redefine this behavior in a number of different ways: shorter , longer , increasing , decreasing , and specified . Below, we can see how the interpolation varies using shorter vs longer (interpolate between the largest angle). >>> i = Color ( \"lch(52% 58.1 22.7)\" ) . interpolate ( ... Color ( \"lch(56% 49.1 257.1)\" ) . mask ( \"hue\" , invert = True ), ... space = \"lch\" ... ) >>> i ( 0.2477 ) . to_string () lch(52% 58.1 351.59) >>> i = Color ( \"lch(52% 58.1 22.7)\" ) . interpolate ( ... Color ( \"lch(56% 49.1 257.1)\" ) . mask ( \"hue\" , invert = True ), ... space = \"lch\" , ... hue = \"longer\" ... ) >>> i ( 0.2477 ) . to_string () lch(52% 58.1 80.761) i = Color(\"lch(52% 58.1 22.7)\").interpolate( Color(\"lch(56% 49.1 257.1)\").mask(\"hue\", invert=True), space=\"lch\" ) i(0.2477).to_string() i = Color(\"lch(52% 58.1 22.7)\").interpolate( Color(\"lch(56% 49.1 257.1)\").mask(\"hue\", invert=True), space=\"lch\", hue=\"longer\" ) i(0.2477).to_string() Edit Share Run Cancel To help visualize the different hue methods, consider the following evaluation between rebeccapurple and lch ( 85 % 85 805 ) . Below we will demonstrate each of the different hue evaluations. To learn more, check out the CSS level 4 specification which describes each one. shorter longer increasing decreasing specified >>> Color ( \"rebeccapurple\" ) . interpolate ( ... \"lch(85% 100 805)\" , ... space = 'lch' , ... hue = \"shorter\" ... ) <coloraide.interpolate.InterpolateSingle object at 0x1033b17b0> Color(\"rebeccapurple\").interpolate( \"lch(85% 100 805)\", space='lch', hue=\"shorter\" ) Edit Share Run Cancel >>> Color ( \"rebeccapurple\" ) . interpolate ( ... \"lch(85% 100 805)\" , ... space = 'lch' , ... hue = \"longer\" ... ) <coloraide.interpolate.InterpolateSingle object at 0x1033b2050> Color(\"rebeccapurple\").interpolate( \"lch(85% 100 805)\", space='lch', hue=\"longer\" ) Edit Share Run Cancel >>> Color ( \"rebeccapurple\" ) . interpolate ( ... \"lch(85% 100 805)\" , ... space = 'lch' , ... hue = \"increasing\" ... ) <coloraide.interpolate.InterpolateSingle object at 0x102f5e1d0> Color(\"rebeccapurple\").interpolate( \"lch(85% 100 805)\", space='lch', hue=\"increasing\" ) Edit Share Run Cancel >>> Color ( \"rebeccapurple\" ) . interpolate ( ... \"lch(85% 100 805)\" , ... space = 'lch' , ... hue = \"decreasing\" ... ) <coloraide.interpolate.InterpolateSingle object at 0x102fc5b70> Color(\"rebeccapurple\").interpolate( \"lch(85% 100 805)\", space='lch', hue=\"decreasing\" ) Edit Share Run Cancel >>> Color ( \"rebeccapurple\" ) . interpolate ( ... \"lch(85% 100 805)\" , ... space = 'lch' , ... hue = \"specified\" ... ) <coloraide.interpolate.InterpolateSingle object at 0x102fc5360> Color(\"rebeccapurple\").interpolate( \"lch(85% 100 805)\", space='lch', hue=\"specified\" ) Edit Share Run Cancel Masking If desired, we can mask off specific channels that we do not wish to interpolate. Masking works by cloning the color and setting the specified channels as undefined (internally set to NaN ). When interpolating, if one color's channel has a NaN , the other color's channel will be used as the result, keeping that channel at a constant value. If both colors have a NaN for the same channel, then NaN will be returned. Magic Behind NaN There are times when NaN values can happen naturally, such as with achromatic colors with hues. To learn more, check out Undefined Handling/ NaN Handling . In the following example, we have a base color of lch ( 52 % 58 . 1 22 . 7 ) which we then interpolate with lch ( 56 % 49 . 1 257 . 1 ) . We then mask off the second color's channels except for hue . Applying this logic, we will end up with a range of colors that maintains the same lightness and chroma as the first color, but with different hues. We can see as we step through the colors that only the hue is interpolated. >>> i = Color ( \"lch(52% 58.1 22.7)\" ) . interpolate ( ... Color ( \"lch(56% 49.1 257.1)\" ) . mask ([ 'lightness' , 'chroma' , 'alpha' ]), ... space = \"lch\" ... ) >>> [ i ( x / 10 ) . to_string () for x in range ( 10 )] ['lch(52% 58.1 22.7)', 'lch(52% 58.1 10.14)', 'lch(52% 58.1 357.58)', 'lch(52% 58.1 345.02)', 'lch(52% 58.1 332.46)', 'lch(52% 58.1 319.9)', 'lch(52% 58.1 307.34)', 'lch(52% 58.1 294.78)', 'lch(52% 58.1 282.22)', 'lch(52% 58.1 269.66)'] i = Color(\"lch(52% 58.1 22.7)\").interpolate( Color(\"lch(56% 49.1 257.1)\").mask(['lightness', 'chroma', 'alpha']), space=\"lch\" ) [i(x/10).to_string() for x in range(10)] Edit Share Run Cancel You can also create inverted masks. An inverted mask will mask all except the specified channel. >>> i = Color ( \"lch(52% 58.1 22.7)\" ) . interpolate ( ... Color ( \"lch(56% 49.1 257.1)\" ) . mask ( 'hue' , invert = True ), ... space = \"lch\" ... ) >>> [ i ( x / 10 ) . to_string () for x in range ( 10 )] ['lch(52% 58.1 22.7)', 'lch(52% 58.1 10.14)', 'lch(52% 58.1 357.58)', 'lch(52% 58.1 345.02)', 'lch(52% 58.1 332.46)', 'lch(52% 58.1 319.9)', 'lch(52% 58.1 307.34)', 'lch(52% 58.1 294.78)', 'lch(52% 58.1 282.22)', 'lch(52% 58.1 269.66)'] i = Color(\"lch(52% 58.1 22.7)\").interpolate( Color(\"lch(56% 49.1 257.1)\").mask('hue', invert=True), space=\"lch\" ) [i(x/10).to_string() for x in range(10)] Edit Share Run Cancel Magic Behind Masking Masking actually clones the color, setting the specified channels to undefined values. To learn more about masking and undefined values, check out Undefined Handling . Using Easing Functions Linear interpolation is not only linear in terms of the straightness of the imaginary line connecting two colors, but also in regards to the rate we travel along that line to return colors. Normally, if we were to request an interpolation point at 0.5 , we'd get a color exactly in the middle between the two colors. With an easing function we can actually control the rate at which we travel the interpolation line, compressing the rate at the start or end of the line, elongating the rate in the middle, or compress the rate periodically. The possibilities are endless. Sometimes, it is easier to visualize what something means than to just have it explained. Here we apply an easing function by setting progress . Here we change the rate of progress along the line using different easing functions. >>> import math >>> Color ( \"green\" ) . interpolate ( ... \"blue\" , ... progress = lambda t : t ** 3 ... ) <coloraide.interpolate.InterpolateSingle object at 0x1033e53f0> >>> Color ( \"green\" ) . interpolate ( ... \"blue\" , ... progress = lambda t : 8 * t ** 4 if t < 0.5 else 1 - (( - 2 * t + 2 ) ** 4 ) / 2 ... ) <coloraide.interpolate.InterpolateSingle object at 0x103637250> >>> Color ( \"green\" ) . interpolate ( ... \"blue\" , ... progress = lambda t : math . sin (( t * math . pi ) / 2 ) ... ) <coloraide.interpolate.InterpolateSingle object at 0x103657d00> import math Color(\"green\").interpolate( \"blue\", progress=lambda t: t ** 3 ) Color(\"green\").interpolate( \"blue\", progress=lambda t: 8 * t ** 4 if t < 0.5 else 1 - ((-2 * t + 2) ** 4) / 2 ) Color(\"green\").interpolate( \"blue\", progress=lambda t: math.sin((t * math.pi) / 2) ) Edit Share Run Cancel ColorAide even lets you apply easing functions to specific channels. This can be done to one or more channels at a time. Below, we apply t ** 3 to alpha while allowing all other channels to interpolate normally. >>> Color ( \"lch(50% 50 0)\" ) . interpolate ( ... \"lch(90% 50 20 / 0)\" , ... progress = { ... 'alpha' : lambda t : t ** 3 ... } ... ) <coloraide.interpolate.InterpolateSingle object at 0x1032c1480> Color(\"lch(50% 50 0)\").interpolate( \"lch(90% 50 20 / 0)\", progress={ 'alpha': lambda t: t ** 3 } ) Edit Share Run Cancel We can also set all the channels to a function via all and then override specific channels. >>> Color ( \"lch(50% 50 0)\" ) . interpolate ( ... \"lch(90% 50 20 / 0)\" , ... progress = { ... 'all' : lambda t : 1 - t , ... 'alpha' : lambda t : t ** 3 ... } ... ) <coloraide.interpolate.InterpolateSingle object at 0x1032c2170> Color(\"lch(50% 50 0)\").interpolate( \"lch(90% 50 20 / 0)\", progress={ 'all': lambda t: 1 - t, 'alpha': lambda t: t ** 3 } ) Edit Share Run Cancel Mixing Interpolation Options Any options not consumed by mix will be passed to the underlying interpolation function. This includes options like hue , progress , etc. The mix function is built on top of the interpolate function and provides a simple, intuitive interface for mixing two colors. Simply pass in a color to mix with the base color, and you'll get an equal mix of the two. >>> Color ( \"red\" ) . mix ( Color ( \"blue\" )) color(srgb 0.55044 0.32562 0.6365 / 1) Color(\"red\").mix(Color(\"blue\")) Edit Share Run Cancel By default, colors are mixed at 50%, but the percentage can be controlled. Here we mix the color blue into the color red at 20%. With blue at 20% and red at 80%, this gives us a more reddish color. >>> Color ( \"red\" ) . mix ( Color ( \"blue\" ), 0.2 ) color(srgb 0.82084 0.26522 0.37806 / 1) Color(\"red\").mix(Color(\"blue\"), 0.2) Edit Share Run Cancel As with all interpolation based functions, if needed, a different color space can be specified with the space parameter. Notice below that this creates a different color. The results of mixing in a different color space may be more desirable as color mixing may be more natural. >>> Color ( \"red\" ) . mix ( Color ( \"blue\" ), space = \"hsl\" ) color(srgb 1 0 1 / 1) Color(\"red\").mix(Color(\"blue\"), space=\"hsl\") Edit Share Run Cancel Mix can also accept a string and will create the color for us which is great if we don't need to work with the second color afterwards. >>> Color ( \"red\" ) . mix ( \"blue\" , 0.2 ) color(srgb 0.82084 0.26522 0.37806 / 1) Color(\"red\").mix(\"blue\", 0.2) Edit Share Run Cancel Mixing will always return a new color unless in_place is set True . Steps Interpolation Options Any options not consumed by mix will be passed to the underlying interpolation function. This includes options like hue , progress , etc. The steps method provides an intuitive interface to create lists of discrete colors. Like mixing, it is also built on interpolate . Just provide two colors, and specify how many steps are wanted. >>> Color ( \"red\" ) . steps ( \"blue\" , steps = 10 ) [color(srgb 1 0 0 / 1), color(srgb 0.90045 0.20791 0.27521 / 1), color(srgb 0.80092 0.27537 0.40045 / 1), color(srgb 0.70118 0.31007 0.50198 / 1), color(srgb 0.60092 0.32459 0.59316 / 1), color(srgb 0.49961 0.32272 0.67882 / 1), color(srgb 0.39631 0.30469 0.76127 / 1), color(srgb 0.28903 0.26729 0.84181 / 1), color(srgb 0.17188 0.19896 0.92122 / 1), color(srgb 0 0 1 / 1)] Color(\"red\").steps(\"blue\", steps=10) Edit Share Run Cancel If desired, multiple colors can be provided, and steps will be returned for all the interpolated segments. When interpolating multiple colors, piecewise interpolation is used (which is covered in more detail later). >>> Color ( \"red\" ) . steps ([ \"orange\" , \"yellow\" , \"green\" ], steps = 10 ) [color(srgb 1 0 0 / 1), color(srgb 1.01 0.34365 0.0003 / 1), color(srgb 1.0105 0.50766 0.00032 / 1), color(srgb 1 0.64706 0 / 1), color(srgb 1.009 0.76646 0.00013 / 1), color(srgb 1.0093 0.88367 0.00014 / 1), color(srgb 1 1 0 / 1), color(srgb 0.71561 0.83059 0.00014 / 1), color(srgb 0.42921 0.66463 0.00011 / 1), color(srgb 0 0.50196 0 / 1)] Color(\"red\").steps([\"orange\", \"yellow\", \"green\"], steps=10) Edit Share Run Cancel Steps can also be configured to return colors based on a maximum Delta E distance. This means you can ensure the distance between all colors is no greater than a certain value. In this example, we specify the color color ( display-p3 0 1 0 ) and interpolate steps between red . The result gives us an array of colors, where the distance between any two colors should be no greater than the Delta E result of 10. >>> Color ( \"display-p3\" , [ 0 , 1 , 0 ]) . steps ( ... \"red\" , ... space = \"lch\" , ... out_space = \"srgb\" , ... max_delta_e = 10 ... ) [color(srgb -0.5116 1.0183 -0.31067 / 1), color(srgb -0.46346 1.0029 -0.32404 / 1), color(srgb -0.40809 0.98732 -0.33344 / 1), color(srgb -0.34139 0.97149 -0.33975 / 1), color(srgb -0.25333 0.95542 -0.34363 / 1), color(srgb -0.09291 0.9391 -0.34554 / 1), color(srgb 0.20395 0.92252 -0.34587 / 1), color(srgb 0.30881 0.90567 -0.3449 / 1), color(srgb 0.38262 0.88855 -0.34288 / 1), color(srgb 0.44216 0.87114 -0.34031 / 1), color(srgb 0.49308 0.85343 -0.33745 / 1), color(srgb 0.53801 0.83543 -0.33432 / 1), color(srgb 0.57843 0.81711 -0.3309 / 1), color(srgb 0.61529 0.79848 -0.3272 / 1), color(srgb 0.6492 0.77953 -0.3232 / 1), color(srgb 0.6806 0.76025 -0.3189 / 1), color(srgb 0.7098 0.74064 -0.3143 / 1), color(srgb 0.73704 0.72068 -0.30938 / 1), color(srgb 0.76251 0.70037 -0.30415 / 1), color(srgb 0.78634 0.6797 -0.2986 / 1), color(srgb 0.80865 0.65865 -0.29271 / 1), color(srgb 0.82951 0.63722 -0.28647 / 1), color(srgb 0.84901 0.61539 -0.27988 / 1), color(srgb 0.86719 0.59316 -0.27292 / 1), color(srgb 0.8841 0.57048 -0.26557 / 1), color(srgb 0.89978 0.54736 -0.25782 / 1), color(srgb 0.91427 0.52375 -0.24963 / 1), color(srgb 0.92758 0.49962 -0.241 / 1), color(srgb 0.93973 0.47493 -0.23187 / 1), color(srgb 0.95075 0.44961 -0.2222 / 1), color(srgb 0.96064 0.4236 -0.21195 / 1), color(srgb 0.96942 0.39678 -0.20105 / 1), color(srgb 0.97711 0.36904 -0.1894 / 1), color(srgb 0.98371 0.34016 -0.17689 / 1), color(srgb 0.98924 0.30989 -0.16335 / 1), color(srgb 0.99369 0.27779 -0.14854 / 1), color(srgb 0.99709 0.24321 -0.13211 / 1), color(srgb 0.99942 0.20495 -0.11292 / 1), color(srgb 1.0007 0.1606 -0.08857 / 1), color(srgb 1.0009 0.1035 -0.05395 / 1), color(srgb 1 0 0 / 1)] Color(\"display-p3\", [0, 1, 0]).steps( \"red\", space=\"lch\", out_space=\"srgb\", max_delta_e=10 ) Edit Share Run Cancel max_steps can be used to limit the results of max_delta_e in case result balloons to an unexpected size. Obviously, this affects the Delta E between the colors inversely. It should be noted that steps are injected equally between every color when satisfying a max Delta E limit in order to avoid shifting the midpoint. In some cases, in order to satisfy both the max_delta_e and the max_steps requirement, the number of steps may even be clipped such that they are less than the max_steps limit. max_steps is set to 1000 by default, but can be set to None if no limit is desired. >>> Color ( \"display-p3\" , [ 0 , 1 , 0 ]) . steps ( ... \"red\" , ... space = \"lch\" , ... out_space = \"srgb\" , ... max_delta_e = 10 , ... max_steps = 10 ... ) [color(srgb -0.5116 1.0183 -0.31067 / 1), color(srgb -0.19966 0.9482 -0.34469 / 1), color(srgb 0.43603 0.87309 -0.34061 / 1), color(srgb 0.6269 0.7922 -0.3259 / 1), color(srgb 0.757 0.70491 -0.30534 / 1), color(srgb 0.85316 0.61049 -0.27836 / 1), color(srgb 0.92327 0.50772 -0.24393 / 1), color(srgb 0.97033 0.39375 -0.19979 / 1), color(srgb 0.99571 0.25894 -0.13964 / 1), color(srgb 1 0 0 / 1)] Color(\"display-p3\", [0, 1, 0]).steps( \"red\", space=\"lch\", out_space=\"srgb\", max_delta_e=10, max_steps=10 ) Edit Share Run Cancel When specifying a max_delta_e , steps will function as a minimum required steps and will push the delta even smaller if the required steps is greater than the calculated steps via the maximum Delta E limit. >>> Color ( \"display-p3\" , [ 0 , 1 , 0 ]) . steps ( ... \"red\" , ... space = \"lch\" , ... out_space = \"srgb\" , ... max_delta_e = 10 , ... steps = 50 ... ) [color(srgb -0.5116 1.0183 -0.31067 / 1), color(srgb -0.47276 1.0057 -0.32192 / 1), color(srgb -0.42946 0.99307 -0.33039 / 1), color(srgb -0.37992 0.98024 -0.33661 / 1), color(srgb -0.32082 0.96725 -0.341 / 1), color(srgb -0.24447 0.9541 -0.34385 / 1), color(srgb -0.1198 0.94078 -0.34542 / 1), color(srgb 0.15996 0.92729 -0.34592 / 1), color(srgb 0.26558 0.91362 -0.3455 / 1), color(srgb 0.33665 0.89976 -0.34431 / 1), color(srgb 0.3931 0.88572 -0.34248 / 1), color(srgb 0.44104 0.8715 -0.34036 / 1), color(srgb 0.48324 0.85707 -0.33806 / 1), color(srgb 0.52118 0.84244 -0.33557 / 1), color(srgb 0.55582 0.82761 -0.33289 / 1), color(srgb 0.58776 0.81258 -0.33002 / 1), color(srgb 0.61745 0.79733 -0.32696 / 1), color(srgb 0.64519 0.78187 -0.32371 / 1), color(srgb 0.67123 0.76619 -0.32025 / 1), color(srgb 0.69575 0.75029 -0.31659 / 1), color(srgb 0.7189 0.73416 -0.31273 / 1), color(srgb 0.74079 0.7178 -0.30866 / 1), color(srgb 0.76151 0.7012 -0.30437 / 1), color(srgb 0.78113 0.68437 -0.29987 / 1), color(srgb 0.79972 0.66729 -0.29515 / 1), color(srgb 0.81733 0.64995 -0.2902 / 1), color(srgb 0.834 0.63236 -0.28502 / 1), color(srgb 0.84977 0.6145 -0.2796 / 1), color(srgb 0.86467 0.59636 -0.27393 / 1), color(srgb 0.87872 0.57794 -0.26801 / 1), color(srgb 0.89194 0.55922 -0.26182 / 1), color(srgb 0.90434 0.54018 -0.25536 / 1), color(srgb 0.91596 0.52082 -0.2486 / 1), color(srgb 0.92679 0.50111 -0.24154 / 1), color(srgb 0.93686 0.48103 -0.23415 / 1), color(srgb 0.94616 0.46054 -0.22641 / 1), color(srgb 0.95471 0.43961 -0.2183 / 1), color(srgb 0.96252 0.41819 -0.20979 / 1), color(srgb 0.96959 0.39623 -0.20082 / 1), color(srgb 0.97593 0.37364 -0.19136 / 1), color(srgb 0.98155 0.35032 -0.18134 / 1), color(srgb 0.98644 0.32615 -0.17067 / 1), color(srgb 0.99062 0.30093 -0.15926 / 1), color(srgb 0.99409 0.27439 -0.14694 / 1), color(srgb 0.99685 0.24615 -0.13353 / 1), color(srgb 0.99891 0.21556 -0.11841 / 1), color(srgb 1.0002 0.18152 -0.10034 / 1), color(srgb 1.0009 0.14177 -0.07755 / 1), color(srgb 1.0008 0.09013 -0.04535 / 1), color(srgb 1 0 0 / 1)] Color(\"display-p3\", [0, 1, 0]).steps( \"red\", space=\"lch\", out_space=\"srgb\", max_delta_e=10, steps=50 ) Edit Share Run Cancel steps uses the color class's default \u2206E method to calculate max \u2206E, the current default \u2206E being \u2206E * ab . While using something like \u2206E * 00 is far more accurate, it is a much more expensive operation. If desired, the class's default \u2206E can be changed via subclassing the color object and and changing DELTA_E class variable or by manually specifying the method via the delta_e parameter. \u2206E * ab . \u2206E * 00 >>> Color ( \"display-p3\" , [ 0 , 1 , 0 ]) . steps ( ... \"red\" , ... space = \"lch\" , ... out_space = \"srgb\" , ... max_delta_e = 10 , ... delta_e = \"76\" ... ) [color(srgb -0.5116 1.0183 -0.31067 / 1), color(srgb -0.46346 1.0029 -0.32404 / 1), color(srgb -0.40809 0.98732 -0.33344 / 1), color(srgb -0.34139 0.97149 -0.33975 / 1), color(srgb -0.25333 0.95542 -0.34363 / 1), color(srgb -0.09291 0.9391 -0.34554 / 1), color(srgb 0.20395 0.92252 -0.34587 / 1), color(srgb 0.30881 0.90567 -0.3449 / 1), color(srgb 0.38262 0.88855 -0.34288 / 1), color(srgb 0.44216 0.87114 -0.34031 / 1), color(srgb 0.49308 0.85343 -0.33745 / 1), color(srgb 0.53801 0.83543 -0.33432 / 1), color(srgb 0.57843 0.81711 -0.3309 / 1), color(srgb 0.61529 0.79848 -0.3272 / 1), color(srgb 0.6492 0.77953 -0.3232 / 1), color(srgb 0.6806 0.76025 -0.3189 / 1), color(srgb 0.7098 0.74064 -0.3143 / 1), color(srgb 0.73704 0.72068 -0.30938 / 1), color(srgb 0.76251 0.70037 -0.30415 / 1), color(srgb 0.78634 0.6797 -0.2986 / 1), color(srgb 0.80865 0.65865 -0.29271 / 1), color(srgb 0.82951 0.63722 -0.28647 / 1), color(srgb 0.84901 0.61539 -0.27988 / 1), color(srgb 0.86719 0.59316 -0.27292 / 1), color(srgb 0.8841 0.57048 -0.26557 / 1), color(srgb 0.89978 0.54736 -0.25782 / 1), color(srgb 0.91427 0.52375 -0.24963 / 1), color(srgb 0.92758 0.49962 -0.241 / 1), color(srgb 0.93973 0.47493 -0.23187 / 1), color(srgb 0.95075 0.44961 -0.2222 / 1), color(srgb 0.96064 0.4236 -0.21195 / 1), color(srgb 0.96942 0.39678 -0.20105 / 1), color(srgb 0.97711 0.36904 -0.1894 / 1), color(srgb 0.98371 0.34016 -0.17689 / 1), color(srgb 0.98924 0.30989 -0.16335 / 1), color(srgb 0.99369 0.27779 -0.14854 / 1), color(srgb 0.99709 0.24321 -0.13211 / 1), color(srgb 0.99942 0.20495 -0.11292 / 1), color(srgb 1.0007 0.1606 -0.08857 / 1), color(srgb 1.0009 0.1035 -0.05395 / 1), color(srgb 1 0 0 / 1)] Color(\"display-p3\", [0, 1, 0]).steps( \"red\", space=\"lch\", out_space=\"srgb\", max_delta_e=10, delta_e=\"76\" ) Edit Share Run Cancel >>> Color ( \"display-p3\" , [ 0 , 1 , 0 ]) . steps ( ... \"red\" , ... space = \"lch\" , ... out_space = \"srgb\" , ... max_delta_e = 10 , ... delta_e = \"2000\" ... ) [color(srgb -0.5116 1.0183 -0.31067 / 1), color(srgb -0.39445 0.98382 -0.33508 / 1), color(srgb -0.19966 0.9482 -0.34469 / 1), color(srgb 0.27893 0.91132 -0.34535 / 1), color(srgb 0.43603 0.87309 -0.34061 / 1), color(srgb 0.5427 0.83341 -0.33396 / 1), color(srgb 0.6269 0.7922 -0.3259 / 1), color(srgb 0.69708 0.7494 -0.31638 / 1), color(srgb 0.757 0.70491 -0.30534 / 1), color(srgb 0.80865 0.65865 -0.29271 / 1), color(srgb 0.85316 0.61049 -0.27836 / 1), color(srgb 0.89122 0.56026 -0.26217 / 1), color(srgb 0.92327 0.50772 -0.24393 / 1), color(srgb 0.94958 0.45246 -0.22331 / 1), color(srgb 0.97033 0.39375 -0.19979 / 1), color(srgb 0.98567 0.33024 -0.1725 / 1), color(srgb 0.99571 0.25894 -0.13964 / 1), color(srgb 1.0005 0.17119 -0.0946 / 1), color(srgb 1 0 0 / 1)] Color(\"display-p3\", [0, 1, 0]).steps( \"red\", space=\"lch\", out_space=\"srgb\", max_delta_e=10, delta_e=\"2000\" ) Edit Share Run Cancel Piecewise Interpolation The interploate and steps methods allow for piecewise interpolation across multiple color ranges. Anytime, multiple colors are provided via a list, the piecewise logic will be applied to the various segments. >>> Color ( 'red' ) . interpolate ([ 'white' , 'black' , 'blue' ]) <coloraide.interpolate.InterpolatePiecewise object at 0x1032c1480> Color('red').interpolate(['white', 'black', 'blue']) Edit Share Run Cancel When interpolating between two colors, we showed that you can control the transition by setting easing functions to the progress parameter or control hue interpolation with the hue parameter. For piecewise interpolation, when progress , hue , or premultiplied are set via the function parameters, that will be the defaults used between all the provided colors, but you can also setup specific interpolation configurations between any two colors by using the Piecewise object. For instance, in the example below, we can apply an easing between just the white and black colors. Notice that we wrap black in a Piecewise object so that the easing function is applied to black and the color immediately before it ( white ). >>> Color ( 'red' ) . interpolate ([ 'white' , Piecewise ( 'black' , progress = lambda t : t * ( 2 - t )), 'blue' ]) <coloraide.interpolate.InterpolatePiecewise object at 0x1033fe770> Color('red').interpolate(['white', Piecewise('black', progress=lambda t: t * (2 - t)), 'blue']) Edit Share Run Cancel Additionally, you can set color stops using the Piecewise object's stop parameter. This will ensure that the given color is interpolated at 100% at that percentage of the total interpolation. In the example below, we specify that in the entire gradient that at 75% the color will be green . >>> Color ( 'orange' ) . interpolate ([ Piecewise ( 'green' , 0.75 ), 'blue' ]) <coloraide.interpolate.InterpolatePiecewise object at 0x1033d1450> Color('orange').interpolate([Piecewise('green', 0.75), 'blue']) Edit Share Run Cancel As the base color cannot be wrapped in a Piecewise object, the steps and interpolation method provide a stop parameter that specifically sets a stop for the base color. In the example below, we specify that the base color's stop will be at 75%, but since the base is always the first color, what it really means is that the color will remain as the base color until 75% and then begin the transition to the next color. In this case, the gradient remains orange until it reaches 75% and then transitions to green completing the full transition at 100%. >>> Color ( 'orange' ) . interpolate ( 'green' , stop = 0.75 ) <coloraide.interpolate.InterpolatePiecewise object at 0x103242200> Color('orange').interpolate('green', stop=0.75) Edit Share Run Cancel And when we put it all together: >>> Color ( 'red' ) . interpolate ([ Piecewise ( 'white' , 0.6 ), Piecewise ( 'black' , 0.8 ), 'blue' ], stop = 0.4 ) <coloraide.interpolate.InterpolatePiecewise object at 0x10329d030> Color('red').interpolate([Piecewise('white', 0.6), Piecewise('black', 0.8), 'blue'], stop=0.4) Edit Share Run Cancel As previously mentioned, this can also be applied to steps as well. >>> Color ( 'red' ) . steps ([ Piecewise ( 'white' , 0.6 ), Piecewise ( 'black' , 0.8 ), 'blue' ], stop = 0.4 , steps = 15 ) [color(srgb 1 0 0 / 1), color(srgb 1 0 0 / 1), color(srgb 1 0 0 / 1), color(srgb 1 0 0 / 1), color(srgb 1 0 0 / 1), color(srgb 1 0 0 / 1), color(srgb 1.0212 0.30668 0.24221 / 1), color(srgb 1.0468 0.63142 0.56947 / 1), color(srgb 1.0254 0.89766 0.87595 / 1), color(srgb 0.72543 0.72543 0.72543 / 1), color(srgb 0.31083 0.31083 0.31083 / 1), color(srgb 0.00471 0.00471 0.00471 / 1), color(srgb 0 0 0.16538 / 1), color(srgb 0 0 0.55229 / 1), color(srgb 0 0 1 / 1)] Color('red').steps([Piecewise('white', 0.6), Piecewise('black', 0.8), 'blue'], stop=0.4, steps=15) Edit Share Run Cancel Undefined/ NaN Handling Color spaces that have hue coordinates often have rules about when the hue is considered relevant. For instance, in the HSL color space, if saturation is zero, the hue is essentially powerless. This is because the color is \"without color\" or achromatic; therefore, the hue can have no affect on the actual color. ColorAide will generally respect the values a user provides, so if an achromatic HSL color is given a hue of 270 degrees, ColorAide will accept it, but the hue will not affect the color in any meaningful way. During conversions, such context is lost, and if an achromatic color is converted to the color space like HSL, the resultant color will have a hue that is noted as undefined. This is simply because there is no good hue for achromatic colors as they play no part in the color. All hues actually incorrect as achromatic colors have no real hue. Instead, colors will be returned with a value that represents that the hue is missing or undefined, or maybe better worded, could not be defined. Many libraries, like d3-color , chroma.js , and color.js , represent null hues with NaN (not a number). This is usually done to make color interpolation easier. Some, like d3-color, are a bit more liberal with NaN and will target special cases that are above and beyond the normal rules to help ensure good interpolation. For instance, they not only mark hue undefined on HSL colors when saturation is zero, but they'll mark saturation as NaN when lightness indicates \"black\" or \"white\". ColorAide also uses NaN , or in Python float ( 'nan' ) , to represent undefined channels. In certain situations, when a hue is deemed undefined, the hue value will be set to coloraide.NaN , which is just a constant containing float ( 'nan' ) . When interpolating, if one color's channel has a NaN , the other color's channel will be used as the result. If both colors have a NaN for the same channel, then NaN will be returned. Notice that in this example, because white's saturation is zero, the hue is undefined. Because the hue is undefined, when the color is mixed with a second color ( green ), the hue of the second color is used. >>> color = Color ( 'white' ) . convert ( 'hsl' ) >>> color . coords () [nan, 0.0, 1.0] >>> color2 = Color ( 'green' ) . convert ( 'hsl' ) >>> color2 . coords () [120.0, 1.0, 0.25098039215686274] >>> color . mix ( color2 , space = \"hsl\" ) color(--hsl 120 0.5 0.62549 / 1) color = Color('white').convert('hsl') color.coords() color2 = Color('green').convert('hsl') color2.coords() color.mix(color2, space=\"hsl\") Edit Share Run Cancel But if we manually set the hue to 0 instead of NaN , we can see that the mixing goes quite differently. >>> color = Color ( 'white' ) . convert ( 'hsl' ) . set ( 'hue' , 0 ) >>> color . coords () [0.0, 0.0, 1.0] >>> color2 = Color ( 'green' ) . convert ( 'hsl' ) >>> color2 . coords () [120.0, 1.0, 0.25098039215686274] >>> color . mix ( color2 , space = \"hsl\" ) color(--hsl 60 0.5 0.62549 / 1) color = Color('white').convert('hsl').set('hue', 0) color.coords() color2 = Color('green').convert('hsl') color2.coords() color.mix(color2, space=\"hsl\") Edit Share Run Cancel Technically, any channel can be set to NaN . And there are various ways to do this. The Color Manipulation documentation goes into the details of how these Nan values naturally occur and the various ways a user and manipulate them.","title":"Color Interpolation"},{"location":"interpolation/#color-interpolation","text":"Interpolation is a type of estimation that finds new data points based on the range of a discrete set of known data points. When used in the context of color, it is finding one or more colors that reside between any two given colors. One of the most common, and easiest ways to interpolate data between two points is to use linear interpolation. An easy way of thinking about this concept is to imagine drawing a straight line that connects two colors within a color space. We could then navigate up and down that line and return colors at different points to simulate mixing colors at various percentages or return the whole range and create a gradient. To further illustrate this point, the example below shows a slice of the Oklab color space at a lightness of 70%. On this 2D plane, we select two colors: oklab ( 70 % 0 . 2 - 0 . 1 ) and oklab ( 70 % 0 0 . 1 ) . We then connect these two colors with a line. We can then select any point on the line to simulate the mixing of these colors. 0% would yield the first color, 100% would yield the second color, and 50% would yield a new color: oklab ( 70 % 0 . 1 0 ) . Using this simple method as a foundation, ColorAide provides a number of useful utilities to mix colors.","title":"Color Interpolation"},{"location":"interpolation/#interpolating","text":"The interpolate method allows a user to create a linear interpolation function using two or more colors. A returned interpolation function accepts an input between 0 - 1 and will cause a new color between the specified colors to be returned. If a an input value exceeds the range, a color will be returned that is extrapolated on the imaginary line that continues beyond the specified colors which may be surprising. By default, colors are interpolated in the perceptually uniform Oklab color space, though any supported color space can be used instead. This also applies to all methods that use interpolation, such as steps , mix , etc. As an example, below we create an interpolation between rebeccapurple and lch ( 85 % 100 85 ) . We then step through values of 0.1 , 0.2 , 0.3 , etc. This returns colors at various positions on the line that connects the two colors, 0 returning rebeccapurple and 1 returning lch ( 85 % 100 85 ) . >>> i = Color ( \"rebeccapurple\" ) . interpolate ( \"lch(85% 100 85)\" , space = 'lch' ) >>> [ i ( x / 10 ) . to_string () for x in range ( 10 )] ['rgb(102 51 153)', 'rgb(142.02 45.341 154.32)', 'rgb(178.57 36.395 149.51)', 'rgb(211.1 28.455 139.17)', 'rgb(238.6 32.963 124.25)', 'rgb(255 53.081 105.76)', 'rgb(255 91.583 90.14)', 'rgb(255 124.14 78.179)', 'rgb(255 152.99 68.933)', 'rgb(255 178.36 45.889)'] i = Color(\"rebeccapurple\").interpolate(\"lch(85% 100 85)\", space='lch') [i(x/10).to_string() for x in range(10)] Edit Share Run Cancel If we create enough steps, we can create a gradient. >>> Color ( \"rebeccapurple\" ) . interpolate ( ... \"lch(85% 100 85)\" , ... space = 'lch' ... ) <coloraide.interpolate.InterpolateSingle object at 0x1033d0970> Color(\"rebeccapurple\").interpolate( \"lch(85% 100 85)\", space='lch' ) Edit Share Run Cancel Interpolating in Constrained Gamuts Some color spaces, like sRGB, have a limited gamut, but have extended ranges that allow them to represent out of gamut colors in a sane way. Other models, like HSL, HSV, and HWB have the same limited gamut, but have no sane way to represent out of gamut colors. If colors are requested to be interpolated and are too big to be interpolated in the requested color space and cannot properly be represented in that space or model, the colors will be gamut mapped before interpolation. Interpolation can also be done across multiple colors. The function, just like when interpolating between two colors, takes a range of 0 - 1, only this range now applies to the range that spans all the colors, not just two. As it may be impossible to draw a straight line that passes through a series of colors, piecewise interpolation is used at anytime there is more than one color. As this type of interpolation will be cover more later, suffice it to say that this method breaks up the interpolation into individual segments/pieces consisting of only two of the colors in the series and applies linear interpolation to these segments/pieces individually. >>> Color ( 'black' ) . interpolate ([ 'red' , 'white' ]) <coloraide.interpolate.InterpolatePiecewise object at 0x1033d3430> Color('black').interpolate(['red', 'white']) Edit Share Run Cancel","title":"Interpolating"},{"location":"interpolation/#hue-interpolation","text":"In interpolation, hues are handled special allowing us to control the way in which hues are evaluated. By default, the shortest angle between two hues is interpolated between, but the hue allows us to redefine this behavior in a number of different ways: shorter , longer , increasing , decreasing , and specified . Below, we can see how the interpolation varies using shorter vs longer (interpolate between the largest angle). >>> i = Color ( \"lch(52% 58.1 22.7)\" ) . interpolate ( ... Color ( \"lch(56% 49.1 257.1)\" ) . mask ( \"hue\" , invert = True ), ... space = \"lch\" ... ) >>> i ( 0.2477 ) . to_string () lch(52% 58.1 351.59) >>> i = Color ( \"lch(52% 58.1 22.7)\" ) . interpolate ( ... Color ( \"lch(56% 49.1 257.1)\" ) . mask ( \"hue\" , invert = True ), ... space = \"lch\" , ... hue = \"longer\" ... ) >>> i ( 0.2477 ) . to_string () lch(52% 58.1 80.761) i = Color(\"lch(52% 58.1 22.7)\").interpolate( Color(\"lch(56% 49.1 257.1)\").mask(\"hue\", invert=True), space=\"lch\" ) i(0.2477).to_string() i = Color(\"lch(52% 58.1 22.7)\").interpolate( Color(\"lch(56% 49.1 257.1)\").mask(\"hue\", invert=True), space=\"lch\", hue=\"longer\" ) i(0.2477).to_string() Edit Share Run Cancel To help visualize the different hue methods, consider the following evaluation between rebeccapurple and lch ( 85 % 85 805 ) . Below we will demonstrate each of the different hue evaluations. To learn more, check out the CSS level 4 specification which describes each one. shorter longer increasing decreasing specified >>> Color ( \"rebeccapurple\" ) . interpolate ( ... \"lch(85% 100 805)\" , ... space = 'lch' , ... hue = \"shorter\" ... ) <coloraide.interpolate.InterpolateSingle object at 0x1033b17b0> Color(\"rebeccapurple\").interpolate( \"lch(85% 100 805)\", space='lch', hue=\"shorter\" ) Edit Share Run Cancel >>> Color ( \"rebeccapurple\" ) . interpolate ( ... \"lch(85% 100 805)\" , ... space = 'lch' , ... hue = \"longer\" ... ) <coloraide.interpolate.InterpolateSingle object at 0x1033b2050> Color(\"rebeccapurple\").interpolate( \"lch(85% 100 805)\", space='lch', hue=\"longer\" ) Edit Share Run Cancel >>> Color ( \"rebeccapurple\" ) . interpolate ( ... \"lch(85% 100 805)\" , ... space = 'lch' , ... hue = \"increasing\" ... ) <coloraide.interpolate.InterpolateSingle object at 0x102f5e1d0> Color(\"rebeccapurple\").interpolate( \"lch(85% 100 805)\", space='lch', hue=\"increasing\" ) Edit Share Run Cancel >>> Color ( \"rebeccapurple\" ) . interpolate ( ... \"lch(85% 100 805)\" , ... space = 'lch' , ... hue = \"decreasing\" ... ) <coloraide.interpolate.InterpolateSingle object at 0x102fc5b70> Color(\"rebeccapurple\").interpolate( \"lch(85% 100 805)\", space='lch', hue=\"decreasing\" ) Edit Share Run Cancel >>> Color ( \"rebeccapurple\" ) . interpolate ( ... \"lch(85% 100 805)\" , ... space = 'lch' , ... hue = \"specified\" ... ) <coloraide.interpolate.InterpolateSingle object at 0x102fc5360> Color(\"rebeccapurple\").interpolate( \"lch(85% 100 805)\", space='lch', hue=\"specified\" ) Edit Share Run Cancel","title":"Hue Interpolation"},{"location":"interpolation/#masking","text":"If desired, we can mask off specific channels that we do not wish to interpolate. Masking works by cloning the color and setting the specified channels as undefined (internally set to NaN ). When interpolating, if one color's channel has a NaN , the other color's channel will be used as the result, keeping that channel at a constant value. If both colors have a NaN for the same channel, then NaN will be returned. Magic Behind NaN There are times when NaN values can happen naturally, such as with achromatic colors with hues. To learn more, check out Undefined Handling/ NaN Handling . In the following example, we have a base color of lch ( 52 % 58 . 1 22 . 7 ) which we then interpolate with lch ( 56 % 49 . 1 257 . 1 ) . We then mask off the second color's channels except for hue . Applying this logic, we will end up with a range of colors that maintains the same lightness and chroma as the first color, but with different hues. We can see as we step through the colors that only the hue is interpolated. >>> i = Color ( \"lch(52% 58.1 22.7)\" ) . interpolate ( ... Color ( \"lch(56% 49.1 257.1)\" ) . mask ([ 'lightness' , 'chroma' , 'alpha' ]), ... space = \"lch\" ... ) >>> [ i ( x / 10 ) . to_string () for x in range ( 10 )] ['lch(52% 58.1 22.7)', 'lch(52% 58.1 10.14)', 'lch(52% 58.1 357.58)', 'lch(52% 58.1 345.02)', 'lch(52% 58.1 332.46)', 'lch(52% 58.1 319.9)', 'lch(52% 58.1 307.34)', 'lch(52% 58.1 294.78)', 'lch(52% 58.1 282.22)', 'lch(52% 58.1 269.66)'] i = Color(\"lch(52% 58.1 22.7)\").interpolate( Color(\"lch(56% 49.1 257.1)\").mask(['lightness', 'chroma', 'alpha']), space=\"lch\" ) [i(x/10).to_string() for x in range(10)] Edit Share Run Cancel You can also create inverted masks. An inverted mask will mask all except the specified channel. >>> i = Color ( \"lch(52% 58.1 22.7)\" ) . interpolate ( ... Color ( \"lch(56% 49.1 257.1)\" ) . mask ( 'hue' , invert = True ), ... space = \"lch\" ... ) >>> [ i ( x / 10 ) . to_string () for x in range ( 10 )] ['lch(52% 58.1 22.7)', 'lch(52% 58.1 10.14)', 'lch(52% 58.1 357.58)', 'lch(52% 58.1 345.02)', 'lch(52% 58.1 332.46)', 'lch(52% 58.1 319.9)', 'lch(52% 58.1 307.34)', 'lch(52% 58.1 294.78)', 'lch(52% 58.1 282.22)', 'lch(52% 58.1 269.66)'] i = Color(\"lch(52% 58.1 22.7)\").interpolate( Color(\"lch(56% 49.1 257.1)\").mask('hue', invert=True), space=\"lch\" ) [i(x/10).to_string() for x in range(10)] Edit Share Run Cancel Magic Behind Masking Masking actually clones the color, setting the specified channels to undefined values. To learn more about masking and undefined values, check out Undefined Handling .","title":"Masking"},{"location":"interpolation/#using-easing-functions","text":"Linear interpolation is not only linear in terms of the straightness of the imaginary line connecting two colors, but also in regards to the rate we travel along that line to return colors. Normally, if we were to request an interpolation point at 0.5 , we'd get a color exactly in the middle between the two colors. With an easing function we can actually control the rate at which we travel the interpolation line, compressing the rate at the start or end of the line, elongating the rate in the middle, or compress the rate periodically. The possibilities are endless. Sometimes, it is easier to visualize what something means than to just have it explained. Here we apply an easing function by setting progress . Here we change the rate of progress along the line using different easing functions. >>> import math >>> Color ( \"green\" ) . interpolate ( ... \"blue\" , ... progress = lambda t : t ** 3 ... ) <coloraide.interpolate.InterpolateSingle object at 0x1033e53f0> >>> Color ( \"green\" ) . interpolate ( ... \"blue\" , ... progress = lambda t : 8 * t ** 4 if t < 0.5 else 1 - (( - 2 * t + 2 ) ** 4 ) / 2 ... ) <coloraide.interpolate.InterpolateSingle object at 0x103637250> >>> Color ( \"green\" ) . interpolate ( ... \"blue\" , ... progress = lambda t : math . sin (( t * math . pi ) / 2 ) ... ) <coloraide.interpolate.InterpolateSingle object at 0x103657d00> import math Color(\"green\").interpolate( \"blue\", progress=lambda t: t ** 3 ) Color(\"green\").interpolate( \"blue\", progress=lambda t: 8 * t ** 4 if t < 0.5 else 1 - ((-2 * t + 2) ** 4) / 2 ) Color(\"green\").interpolate( \"blue\", progress=lambda t: math.sin((t * math.pi) / 2) ) Edit Share Run Cancel ColorAide even lets you apply easing functions to specific channels. This can be done to one or more channels at a time. Below, we apply t ** 3 to alpha while allowing all other channels to interpolate normally. >>> Color ( \"lch(50% 50 0)\" ) . interpolate ( ... \"lch(90% 50 20 / 0)\" , ... progress = { ... 'alpha' : lambda t : t ** 3 ... } ... ) <coloraide.interpolate.InterpolateSingle object at 0x1032c1480> Color(\"lch(50% 50 0)\").interpolate( \"lch(90% 50 20 / 0)\", progress={ 'alpha': lambda t: t ** 3 } ) Edit Share Run Cancel We can also set all the channels to a function via all and then override specific channels. >>> Color ( \"lch(50% 50 0)\" ) . interpolate ( ... \"lch(90% 50 20 / 0)\" , ... progress = { ... 'all' : lambda t : 1 - t , ... 'alpha' : lambda t : t ** 3 ... } ... ) <coloraide.interpolate.InterpolateSingle object at 0x1032c2170> Color(\"lch(50% 50 0)\").interpolate( \"lch(90% 50 20 / 0)\", progress={ 'all': lambda t: 1 - t, 'alpha': lambda t: t ** 3 } ) Edit Share Run Cancel","title":"Using Easing Functions"},{"location":"interpolation/#mixing","text":"Interpolation Options Any options not consumed by mix will be passed to the underlying interpolation function. This includes options like hue , progress , etc. The mix function is built on top of the interpolate function and provides a simple, intuitive interface for mixing two colors. Simply pass in a color to mix with the base color, and you'll get an equal mix of the two. >>> Color ( \"red\" ) . mix ( Color ( \"blue\" )) color(srgb 0.55044 0.32562 0.6365 / 1) Color(\"red\").mix(Color(\"blue\")) Edit Share Run Cancel By default, colors are mixed at 50%, but the percentage can be controlled. Here we mix the color blue into the color red at 20%. With blue at 20% and red at 80%, this gives us a more reddish color. >>> Color ( \"red\" ) . mix ( Color ( \"blue\" ), 0.2 ) color(srgb 0.82084 0.26522 0.37806 / 1) Color(\"red\").mix(Color(\"blue\"), 0.2) Edit Share Run Cancel As with all interpolation based functions, if needed, a different color space can be specified with the space parameter. Notice below that this creates a different color. The results of mixing in a different color space may be more desirable as color mixing may be more natural. >>> Color ( \"red\" ) . mix ( Color ( \"blue\" ), space = \"hsl\" ) color(srgb 1 0 1 / 1) Color(\"red\").mix(Color(\"blue\"), space=\"hsl\") Edit Share Run Cancel Mix can also accept a string and will create the color for us which is great if we don't need to work with the second color afterwards. >>> Color ( \"red\" ) . mix ( \"blue\" , 0.2 ) color(srgb 0.82084 0.26522 0.37806 / 1) Color(\"red\").mix(\"blue\", 0.2) Edit Share Run Cancel Mixing will always return a new color unless in_place is set True .","title":"Mixing"},{"location":"interpolation/#steps","text":"Interpolation Options Any options not consumed by mix will be passed to the underlying interpolation function. This includes options like hue , progress , etc. The steps method provides an intuitive interface to create lists of discrete colors. Like mixing, it is also built on interpolate . Just provide two colors, and specify how many steps are wanted. >>> Color ( \"red\" ) . steps ( \"blue\" , steps = 10 ) [color(srgb 1 0 0 / 1), color(srgb 0.90045 0.20791 0.27521 / 1), color(srgb 0.80092 0.27537 0.40045 / 1), color(srgb 0.70118 0.31007 0.50198 / 1), color(srgb 0.60092 0.32459 0.59316 / 1), color(srgb 0.49961 0.32272 0.67882 / 1), color(srgb 0.39631 0.30469 0.76127 / 1), color(srgb 0.28903 0.26729 0.84181 / 1), color(srgb 0.17188 0.19896 0.92122 / 1), color(srgb 0 0 1 / 1)] Color(\"red\").steps(\"blue\", steps=10) Edit Share Run Cancel If desired, multiple colors can be provided, and steps will be returned for all the interpolated segments. When interpolating multiple colors, piecewise interpolation is used (which is covered in more detail later). >>> Color ( \"red\" ) . steps ([ \"orange\" , \"yellow\" , \"green\" ], steps = 10 ) [color(srgb 1 0 0 / 1), color(srgb 1.01 0.34365 0.0003 / 1), color(srgb 1.0105 0.50766 0.00032 / 1), color(srgb 1 0.64706 0 / 1), color(srgb 1.009 0.76646 0.00013 / 1), color(srgb 1.0093 0.88367 0.00014 / 1), color(srgb 1 1 0 / 1), color(srgb 0.71561 0.83059 0.00014 / 1), color(srgb 0.42921 0.66463 0.00011 / 1), color(srgb 0 0.50196 0 / 1)] Color(\"red\").steps([\"orange\", \"yellow\", \"green\"], steps=10) Edit Share Run Cancel Steps can also be configured to return colors based on a maximum Delta E distance. This means you can ensure the distance between all colors is no greater than a certain value. In this example, we specify the color color ( display-p3 0 1 0 ) and interpolate steps between red . The result gives us an array of colors, where the distance between any two colors should be no greater than the Delta E result of 10. >>> Color ( \"display-p3\" , [ 0 , 1 , 0 ]) . steps ( ... \"red\" , ... space = \"lch\" , ... out_space = \"srgb\" , ... max_delta_e = 10 ... ) [color(srgb -0.5116 1.0183 -0.31067 / 1), color(srgb -0.46346 1.0029 -0.32404 / 1), color(srgb -0.40809 0.98732 -0.33344 / 1), color(srgb -0.34139 0.97149 -0.33975 / 1), color(srgb -0.25333 0.95542 -0.34363 / 1), color(srgb -0.09291 0.9391 -0.34554 / 1), color(srgb 0.20395 0.92252 -0.34587 / 1), color(srgb 0.30881 0.90567 -0.3449 / 1), color(srgb 0.38262 0.88855 -0.34288 / 1), color(srgb 0.44216 0.87114 -0.34031 / 1), color(srgb 0.49308 0.85343 -0.33745 / 1), color(srgb 0.53801 0.83543 -0.33432 / 1), color(srgb 0.57843 0.81711 -0.3309 / 1), color(srgb 0.61529 0.79848 -0.3272 / 1), color(srgb 0.6492 0.77953 -0.3232 / 1), color(srgb 0.6806 0.76025 -0.3189 / 1), color(srgb 0.7098 0.74064 -0.3143 / 1), color(srgb 0.73704 0.72068 -0.30938 / 1), color(srgb 0.76251 0.70037 -0.30415 / 1), color(srgb 0.78634 0.6797 -0.2986 / 1), color(srgb 0.80865 0.65865 -0.29271 / 1), color(srgb 0.82951 0.63722 -0.28647 / 1), color(srgb 0.84901 0.61539 -0.27988 / 1), color(srgb 0.86719 0.59316 -0.27292 / 1), color(srgb 0.8841 0.57048 -0.26557 / 1), color(srgb 0.89978 0.54736 -0.25782 / 1), color(srgb 0.91427 0.52375 -0.24963 / 1), color(srgb 0.92758 0.49962 -0.241 / 1), color(srgb 0.93973 0.47493 -0.23187 / 1), color(srgb 0.95075 0.44961 -0.2222 / 1), color(srgb 0.96064 0.4236 -0.21195 / 1), color(srgb 0.96942 0.39678 -0.20105 / 1), color(srgb 0.97711 0.36904 -0.1894 / 1), color(srgb 0.98371 0.34016 -0.17689 / 1), color(srgb 0.98924 0.30989 -0.16335 / 1), color(srgb 0.99369 0.27779 -0.14854 / 1), color(srgb 0.99709 0.24321 -0.13211 / 1), color(srgb 0.99942 0.20495 -0.11292 / 1), color(srgb 1.0007 0.1606 -0.08857 / 1), color(srgb 1.0009 0.1035 -0.05395 / 1), color(srgb 1 0 0 / 1)] Color(\"display-p3\", [0, 1, 0]).steps( \"red\", space=\"lch\", out_space=\"srgb\", max_delta_e=10 ) Edit Share Run Cancel max_steps can be used to limit the results of max_delta_e in case result balloons to an unexpected size. Obviously, this affects the Delta E between the colors inversely. It should be noted that steps are injected equally between every color when satisfying a max Delta E limit in order to avoid shifting the midpoint. In some cases, in order to satisfy both the max_delta_e and the max_steps requirement, the number of steps may even be clipped such that they are less than the max_steps limit. max_steps is set to 1000 by default, but can be set to None if no limit is desired. >>> Color ( \"display-p3\" , [ 0 , 1 , 0 ]) . steps ( ... \"red\" , ... space = \"lch\" , ... out_space = \"srgb\" , ... max_delta_e = 10 , ... max_steps = 10 ... ) [color(srgb -0.5116 1.0183 -0.31067 / 1), color(srgb -0.19966 0.9482 -0.34469 / 1), color(srgb 0.43603 0.87309 -0.34061 / 1), color(srgb 0.6269 0.7922 -0.3259 / 1), color(srgb 0.757 0.70491 -0.30534 / 1), color(srgb 0.85316 0.61049 -0.27836 / 1), color(srgb 0.92327 0.50772 -0.24393 / 1), color(srgb 0.97033 0.39375 -0.19979 / 1), color(srgb 0.99571 0.25894 -0.13964 / 1), color(srgb 1 0 0 / 1)] Color(\"display-p3\", [0, 1, 0]).steps( \"red\", space=\"lch\", out_space=\"srgb\", max_delta_e=10, max_steps=10 ) Edit Share Run Cancel When specifying a max_delta_e , steps will function as a minimum required steps and will push the delta even smaller if the required steps is greater than the calculated steps via the maximum Delta E limit. >>> Color ( \"display-p3\" , [ 0 , 1 , 0 ]) . steps ( ... \"red\" , ... space = \"lch\" , ... out_space = \"srgb\" , ... max_delta_e = 10 , ... steps = 50 ... ) [color(srgb -0.5116 1.0183 -0.31067 / 1), color(srgb -0.47276 1.0057 -0.32192 / 1), color(srgb -0.42946 0.99307 -0.33039 / 1), color(srgb -0.37992 0.98024 -0.33661 / 1), color(srgb -0.32082 0.96725 -0.341 / 1), color(srgb -0.24447 0.9541 -0.34385 / 1), color(srgb -0.1198 0.94078 -0.34542 / 1), color(srgb 0.15996 0.92729 -0.34592 / 1), color(srgb 0.26558 0.91362 -0.3455 / 1), color(srgb 0.33665 0.89976 -0.34431 / 1), color(srgb 0.3931 0.88572 -0.34248 / 1), color(srgb 0.44104 0.8715 -0.34036 / 1), color(srgb 0.48324 0.85707 -0.33806 / 1), color(srgb 0.52118 0.84244 -0.33557 / 1), color(srgb 0.55582 0.82761 -0.33289 / 1), color(srgb 0.58776 0.81258 -0.33002 / 1), color(srgb 0.61745 0.79733 -0.32696 / 1), color(srgb 0.64519 0.78187 -0.32371 / 1), color(srgb 0.67123 0.76619 -0.32025 / 1), color(srgb 0.69575 0.75029 -0.31659 / 1), color(srgb 0.7189 0.73416 -0.31273 / 1), color(srgb 0.74079 0.7178 -0.30866 / 1), color(srgb 0.76151 0.7012 -0.30437 / 1), color(srgb 0.78113 0.68437 -0.29987 / 1), color(srgb 0.79972 0.66729 -0.29515 / 1), color(srgb 0.81733 0.64995 -0.2902 / 1), color(srgb 0.834 0.63236 -0.28502 / 1), color(srgb 0.84977 0.6145 -0.2796 / 1), color(srgb 0.86467 0.59636 -0.27393 / 1), color(srgb 0.87872 0.57794 -0.26801 / 1), color(srgb 0.89194 0.55922 -0.26182 / 1), color(srgb 0.90434 0.54018 -0.25536 / 1), color(srgb 0.91596 0.52082 -0.2486 / 1), color(srgb 0.92679 0.50111 -0.24154 / 1), color(srgb 0.93686 0.48103 -0.23415 / 1), color(srgb 0.94616 0.46054 -0.22641 / 1), color(srgb 0.95471 0.43961 -0.2183 / 1), color(srgb 0.96252 0.41819 -0.20979 / 1), color(srgb 0.96959 0.39623 -0.20082 / 1), color(srgb 0.97593 0.37364 -0.19136 / 1), color(srgb 0.98155 0.35032 -0.18134 / 1), color(srgb 0.98644 0.32615 -0.17067 / 1), color(srgb 0.99062 0.30093 -0.15926 / 1), color(srgb 0.99409 0.27439 -0.14694 / 1), color(srgb 0.99685 0.24615 -0.13353 / 1), color(srgb 0.99891 0.21556 -0.11841 / 1), color(srgb 1.0002 0.18152 -0.10034 / 1), color(srgb 1.0009 0.14177 -0.07755 / 1), color(srgb 1.0008 0.09013 -0.04535 / 1), color(srgb 1 0 0 / 1)] Color(\"display-p3\", [0, 1, 0]).steps( \"red\", space=\"lch\", out_space=\"srgb\", max_delta_e=10, steps=50 ) Edit Share Run Cancel steps uses the color class's default \u2206E method to calculate max \u2206E, the current default \u2206E being \u2206E * ab . While using something like \u2206E * 00 is far more accurate, it is a much more expensive operation. If desired, the class's default \u2206E can be changed via subclassing the color object and and changing DELTA_E class variable or by manually specifying the method via the delta_e parameter. \u2206E * ab . \u2206E * 00 >>> Color ( \"display-p3\" , [ 0 , 1 , 0 ]) . steps ( ... \"red\" , ... space = \"lch\" , ... out_space = \"srgb\" , ... max_delta_e = 10 , ... delta_e = \"76\" ... ) [color(srgb -0.5116 1.0183 -0.31067 / 1), color(srgb -0.46346 1.0029 -0.32404 / 1), color(srgb -0.40809 0.98732 -0.33344 / 1), color(srgb -0.34139 0.97149 -0.33975 / 1), color(srgb -0.25333 0.95542 -0.34363 / 1), color(srgb -0.09291 0.9391 -0.34554 / 1), color(srgb 0.20395 0.92252 -0.34587 / 1), color(srgb 0.30881 0.90567 -0.3449 / 1), color(srgb 0.38262 0.88855 -0.34288 / 1), color(srgb 0.44216 0.87114 -0.34031 / 1), color(srgb 0.49308 0.85343 -0.33745 / 1), color(srgb 0.53801 0.83543 -0.33432 / 1), color(srgb 0.57843 0.81711 -0.3309 / 1), color(srgb 0.61529 0.79848 -0.3272 / 1), color(srgb 0.6492 0.77953 -0.3232 / 1), color(srgb 0.6806 0.76025 -0.3189 / 1), color(srgb 0.7098 0.74064 -0.3143 / 1), color(srgb 0.73704 0.72068 -0.30938 / 1), color(srgb 0.76251 0.70037 -0.30415 / 1), color(srgb 0.78634 0.6797 -0.2986 / 1), color(srgb 0.80865 0.65865 -0.29271 / 1), color(srgb 0.82951 0.63722 -0.28647 / 1), color(srgb 0.84901 0.61539 -0.27988 / 1), color(srgb 0.86719 0.59316 -0.27292 / 1), color(srgb 0.8841 0.57048 -0.26557 / 1), color(srgb 0.89978 0.54736 -0.25782 / 1), color(srgb 0.91427 0.52375 -0.24963 / 1), color(srgb 0.92758 0.49962 -0.241 / 1), color(srgb 0.93973 0.47493 -0.23187 / 1), color(srgb 0.95075 0.44961 -0.2222 / 1), color(srgb 0.96064 0.4236 -0.21195 / 1), color(srgb 0.96942 0.39678 -0.20105 / 1), color(srgb 0.97711 0.36904 -0.1894 / 1), color(srgb 0.98371 0.34016 -0.17689 / 1), color(srgb 0.98924 0.30989 -0.16335 / 1), color(srgb 0.99369 0.27779 -0.14854 / 1), color(srgb 0.99709 0.24321 -0.13211 / 1), color(srgb 0.99942 0.20495 -0.11292 / 1), color(srgb 1.0007 0.1606 -0.08857 / 1), color(srgb 1.0009 0.1035 -0.05395 / 1), color(srgb 1 0 0 / 1)] Color(\"display-p3\", [0, 1, 0]).steps( \"red\", space=\"lch\", out_space=\"srgb\", max_delta_e=10, delta_e=\"76\" ) Edit Share Run Cancel >>> Color ( \"display-p3\" , [ 0 , 1 , 0 ]) . steps ( ... \"red\" , ... space = \"lch\" , ... out_space = \"srgb\" , ... max_delta_e = 10 , ... delta_e = \"2000\" ... ) [color(srgb -0.5116 1.0183 -0.31067 / 1), color(srgb -0.39445 0.98382 -0.33508 / 1), color(srgb -0.19966 0.9482 -0.34469 / 1), color(srgb 0.27893 0.91132 -0.34535 / 1), color(srgb 0.43603 0.87309 -0.34061 / 1), color(srgb 0.5427 0.83341 -0.33396 / 1), color(srgb 0.6269 0.7922 -0.3259 / 1), color(srgb 0.69708 0.7494 -0.31638 / 1), color(srgb 0.757 0.70491 -0.30534 / 1), color(srgb 0.80865 0.65865 -0.29271 / 1), color(srgb 0.85316 0.61049 -0.27836 / 1), color(srgb 0.89122 0.56026 -0.26217 / 1), color(srgb 0.92327 0.50772 -0.24393 / 1), color(srgb 0.94958 0.45246 -0.22331 / 1), color(srgb 0.97033 0.39375 -0.19979 / 1), color(srgb 0.98567 0.33024 -0.1725 / 1), color(srgb 0.99571 0.25894 -0.13964 / 1), color(srgb 1.0005 0.17119 -0.0946 / 1), color(srgb 1 0 0 / 1)] Color(\"display-p3\", [0, 1, 0]).steps( \"red\", space=\"lch\", out_space=\"srgb\", max_delta_e=10, delta_e=\"2000\" ) Edit Share Run Cancel","title":"Steps"},{"location":"interpolation/#piecewise-interpolation","text":"The interploate and steps methods allow for piecewise interpolation across multiple color ranges. Anytime, multiple colors are provided via a list, the piecewise logic will be applied to the various segments. >>> Color ( 'red' ) . interpolate ([ 'white' , 'black' , 'blue' ]) <coloraide.interpolate.InterpolatePiecewise object at 0x1032c1480> Color('red').interpolate(['white', 'black', 'blue']) Edit Share Run Cancel When interpolating between two colors, we showed that you can control the transition by setting easing functions to the progress parameter or control hue interpolation with the hue parameter. For piecewise interpolation, when progress , hue , or premultiplied are set via the function parameters, that will be the defaults used between all the provided colors, but you can also setup specific interpolation configurations between any two colors by using the Piecewise object. For instance, in the example below, we can apply an easing between just the white and black colors. Notice that we wrap black in a Piecewise object so that the easing function is applied to black and the color immediately before it ( white ). >>> Color ( 'red' ) . interpolate ([ 'white' , Piecewise ( 'black' , progress = lambda t : t * ( 2 - t )), 'blue' ]) <coloraide.interpolate.InterpolatePiecewise object at 0x1033fe770> Color('red').interpolate(['white', Piecewise('black', progress=lambda t: t * (2 - t)), 'blue']) Edit Share Run Cancel Additionally, you can set color stops using the Piecewise object's stop parameter. This will ensure that the given color is interpolated at 100% at that percentage of the total interpolation. In the example below, we specify that in the entire gradient that at 75% the color will be green . >>> Color ( 'orange' ) . interpolate ([ Piecewise ( 'green' , 0.75 ), 'blue' ]) <coloraide.interpolate.InterpolatePiecewise object at 0x1033d1450> Color('orange').interpolate([Piecewise('green', 0.75), 'blue']) Edit Share Run Cancel As the base color cannot be wrapped in a Piecewise object, the steps and interpolation method provide a stop parameter that specifically sets a stop for the base color. In the example below, we specify that the base color's stop will be at 75%, but since the base is always the first color, what it really means is that the color will remain as the base color until 75% and then begin the transition to the next color. In this case, the gradient remains orange until it reaches 75% and then transitions to green completing the full transition at 100%. >>> Color ( 'orange' ) . interpolate ( 'green' , stop = 0.75 ) <coloraide.interpolate.InterpolatePiecewise object at 0x103242200> Color('orange').interpolate('green', stop=0.75) Edit Share Run Cancel And when we put it all together: >>> Color ( 'red' ) . interpolate ([ Piecewise ( 'white' , 0.6 ), Piecewise ( 'black' , 0.8 ), 'blue' ], stop = 0.4 ) <coloraide.interpolate.InterpolatePiecewise object at 0x10329d030> Color('red').interpolate([Piecewise('white', 0.6), Piecewise('black', 0.8), 'blue'], stop=0.4) Edit Share Run Cancel As previously mentioned, this can also be applied to steps as well. >>> Color ( 'red' ) . steps ([ Piecewise ( 'white' , 0.6 ), Piecewise ( 'black' , 0.8 ), 'blue' ], stop = 0.4 , steps = 15 ) [color(srgb 1 0 0 / 1), color(srgb 1 0 0 / 1), color(srgb 1 0 0 / 1), color(srgb 1 0 0 / 1), color(srgb 1 0 0 / 1), color(srgb 1 0 0 / 1), color(srgb 1.0212 0.30668 0.24221 / 1), color(srgb 1.0468 0.63142 0.56947 / 1), color(srgb 1.0254 0.89766 0.87595 / 1), color(srgb 0.72543 0.72543 0.72543 / 1), color(srgb 0.31083 0.31083 0.31083 / 1), color(srgb 0.00471 0.00471 0.00471 / 1), color(srgb 0 0 0.16538 / 1), color(srgb 0 0 0.55229 / 1), color(srgb 0 0 1 / 1)] Color('red').steps([Piecewise('white', 0.6), Piecewise('black', 0.8), 'blue'], stop=0.4, steps=15) Edit Share Run Cancel","title":"Piecewise Interpolation"},{"location":"interpolation/#null-handling","text":"Color spaces that have hue coordinates often have rules about when the hue is considered relevant. For instance, in the HSL color space, if saturation is zero, the hue is essentially powerless. This is because the color is \"without color\" or achromatic; therefore, the hue can have no affect on the actual color. ColorAide will generally respect the values a user provides, so if an achromatic HSL color is given a hue of 270 degrees, ColorAide will accept it, but the hue will not affect the color in any meaningful way. During conversions, such context is lost, and if an achromatic color is converted to the color space like HSL, the resultant color will have a hue that is noted as undefined. This is simply because there is no good hue for achromatic colors as they play no part in the color. All hues actually incorrect as achromatic colors have no real hue. Instead, colors will be returned with a value that represents that the hue is missing or undefined, or maybe better worded, could not be defined. Many libraries, like d3-color , chroma.js , and color.js , represent null hues with NaN (not a number). This is usually done to make color interpolation easier. Some, like d3-color, are a bit more liberal with NaN and will target special cases that are above and beyond the normal rules to help ensure good interpolation. For instance, they not only mark hue undefined on HSL colors when saturation is zero, but they'll mark saturation as NaN when lightness indicates \"black\" or \"white\". ColorAide also uses NaN , or in Python float ( 'nan' ) , to represent undefined channels. In certain situations, when a hue is deemed undefined, the hue value will be set to coloraide.NaN , which is just a constant containing float ( 'nan' ) . When interpolating, if one color's channel has a NaN , the other color's channel will be used as the result. If both colors have a NaN for the same channel, then NaN will be returned. Notice that in this example, because white's saturation is zero, the hue is undefined. Because the hue is undefined, when the color is mixed with a second color ( green ), the hue of the second color is used. >>> color = Color ( 'white' ) . convert ( 'hsl' ) >>> color . coords () [nan, 0.0, 1.0] >>> color2 = Color ( 'green' ) . convert ( 'hsl' ) >>> color2 . coords () [120.0, 1.0, 0.25098039215686274] >>> color . mix ( color2 , space = \"hsl\" ) color(--hsl 120 0.5 0.62549 / 1) color = Color('white').convert('hsl') color.coords() color2 = Color('green').convert('hsl') color2.coords() color.mix(color2, space=\"hsl\") Edit Share Run Cancel But if we manually set the hue to 0 instead of NaN , we can see that the mixing goes quite differently. >>> color = Color ( 'white' ) . convert ( 'hsl' ) . set ( 'hue' , 0 ) >>> color . coords () [0.0, 0.0, 1.0] >>> color2 = Color ( 'green' ) . convert ( 'hsl' ) >>> color2 . coords () [120.0, 1.0, 0.25098039215686274] >>> color . mix ( color2 , space = \"hsl\" ) color(--hsl 60 0.5 0.62549 / 1) color = Color('white').convert('hsl').set('hue', 0) color.coords() color2 = Color('green').convert('hsl') color2.coords() color.mix(color2, space=\"hsl\") Edit Share Run Cancel Technically, any channel can be set to NaN . And there are various ways to do this. The Color Manipulation documentation goes into the details of how these Nan values naturally occur and the various ways a user and manipulate them.","title":"Undefined/NaN Handling"},{"location":"manipulation/","text":"Manipulating Colors Once a Color object is created, you have access to all the color channels. Color channels can be read individually or extracted all at once. Getting and setting color channels is flexible and easy, allowing for intuitive access. Reading Coordinates There are various ways to read the current values of color coordinates. Channel properties can be read directly: >>> color = Color ( \"orange\" ) >>> color . red 1.0 color = Color(\"orange\") color.red Edit Share Run Cancel Channel values can also be read by using the get method and providing the name of desired channel. >>> color = Color ( \"orange\" ) >>> color . get ( \"green\" ) 0.6470588235294118 color = Color(\"orange\") color.get(\"green\") Edit Share Run Cancel Additionally, we can also access values of the current color in terms of other color space properties. Simply specify the color space and the color property. >>> color = Color ( \"orange\" ) >>> color . get ( \"lch.chroma\" ) 83.76900622509224 color = Color(\"orange\") color.get(\"lch.chroma\") Edit Share Run Cancel All coordinates can be read simultaneously by using the coords function. The alpha channel is excluded from coords and must be retrieved separately. >>> color = Color ( \"orange\" ) >>> color . coords () [1.0, 0.6470588235294118, 0.0] >>> color . alpha 1.0 color = Color(\"orange\") color.coords() color.alpha Edit Share Run Cancel Modifying Coordinates Channel properties can be modified directly by using the named property. Here we modify red by adjusting its green property and get an orange hued color. >>> color = Color ( \"red\" ) >>> color . green = 0.5 >>> color . to_string () rgb(255 127.5 0) color = Color(\"red\") color.green = 0.5 color.to_string() Edit Share Run Cancel When doing so, keep in mind, the internal coordinates are being adjusted, so their scale and range is dictated by the given color space in which they relate to. sRGB, for example, specifies its color channels in the range of [0, 1], though it should allow extended ranges if required. Much like reading with the get method, values can be modified with the set method. As these methods return a reference to the current class, multiple set operations can be chained together. Chaining multiple set operations together, we can transform white to rgb ( 0 127 . 5 255 ) . >>> Color ( \"white\" ) . set ( \"red\" , 0 ) . set ( \"green\" , 0.5 ) color(srgb 0 0.5 1 / 1) Color(\"white\").set(\"red\", 0).set(\"green\", 0.5) Edit Share Run Cancel Functions can also be used to modify a channel property. This allows us to do more complex set operations. Here we do a relative adjustment of the green channel and transform the color pink to rgb ( 255 249 . 6 203 ) . >>> Color ( \"pink\" ) . set ( 'green' , lambda g : g * 1.3 ) color(srgb 1 0.97882 0.79608 / 1) Color(\"pink\").set('green', lambda g: g * 1.3) Edit Share Run Cancel Modifying Coordinates in Other Spaces Channels in other color spaces can also be modified with the set function. Here we alter the color blue by editing the hue channel in the CIELCH color space and get rgb (- 63 . 911 91 . 016 - 63 . 173 ) . Keep in mind that the colors are being converted to the specified space under the hood, set, and then converted back, so if you have multiple operations to apply in a given color space, it may be more efficient to convert to that space, apply the set operations directly, and then convert back. >>> Color ( \"blue\" ) . set ( 'lch.hue' , 130 ) color(srgb -0.25063 0.35692 -0.24774 / 1) Color(\"blue\").set('lch.hue', 130) Edit Share Run Cancel When setting a color in another color space, the final value is subject to any rounding errors that may occur in the round trip to and from the specified color space. Also, depending on the transform functions of the spaces involved, and whether the original color is on the edge of its own gamut, this can lead to a color going slightly out of gamut, and if one of the spaces involved in the conversion doesn't handle out of gamut colors with sensible values, you may get something unexpected back. Consider the following example comparing the modification of an HSL color in HWB vs Oklab. >>> Color ( 'hsl(0 0 % 50% )' ) . set ( 'hwb.blackness' , 0 ) . set ( 'hwb.whiteness' , 100 ) color(--hsl none 0 1 / 1) >>> Color ( 'hsl(0 0 % 50% )' ) . set ( 'oklab.lightness' , 1 ) color(--hsl 223.91 -1.3211 1 / 1) >>> Color ( 'hsl(0 0 % 50% )' ) . set ( 'oklab.lightness' , 1 ) . convert ( 'srgb' ) . coords () [0.9999999929041132, 1.0000000085633445, 1.0000000512914544] Color('hsl(0 0% 50%)').set('hwb.blackness', 0).set('hwb.whiteness', 100) Color('hsl(0 0% 50%)').set('oklab.lightness', 1) Color('hsl(0 0% 50%)').set('oklab.lightness', 1).convert('srgb').coords() Edit Share Run Cancel The above example cleanly converts between HSL and HWB as the conversion between these two is much more precise, but the Oklab example is not quite as precise and returns a color with a saturation that is way out of bounds. This is partly because the Oklab max whiteness isn't exactly 1 , but more like ~0.999... , The HSL model doesn't really represent out of gamut colors in a logical way and, in this case, creates a color with a negative saturation. It looks worse than it really is as when we convert it to sRGB, we see it is barely off. None of this is a bug, it is just the nature of the algorithms we are using to convert, the precision of the floats, and the slight rounding errors that occur when using floating-point arithmetic , etc. Undefined Values Colors in general can sometimes have undefined channels. This can actually happen in a number of ways. Channels can naturally be undefined under certain situations as defined by the color space. For instance, spaces with hues will have powerless hues when the color is achromatic. This can occur if saturation or chroma is zero, or when a color has no lightness, etc. Normally, if a hue is defined manually defined on an achromatic color they are considered defined even if the defined value is powerless, but during the conversion process, the algorithm won't know what to assign as a hue. For instance, if saturation is zero, one could argue the hue should be 0 , but that is actually a red hue, and achromatic colors have no hue. In the end, no hue is actually satisfactory, so an undefined hue is applied. >>> color = Color ( 'white' ) . convert ( 'hsl' ) >>> color . coords () [nan, 0.0, 1.0] color = Color('white').convert('hsl') color.coords() Edit Share Run Cancel When specifying raw data, and an insufficient amount of channel data is provided, the missing channels will be assumed as undefined, the exception is the alpha channel which is assumed to be 1 unless explicitly defined or explicitly set as undefined. >>> Color ( 'srgb' , [ 1 ]) . coords () [1.0, nan, nan] >>> Color ( 'srgb' , [ 1 , 0 , 0 ], NaN ) . alpha nan Color('srgb', [1]).coords() Color('srgb', [1, 0, 0], NaN).alpha Edit Share Run Cancel Undefined values can also occur when a user specifies a channel with the none keyword. This can also be done in raw color data by directly passing float ( 'nan' ) \u2013 the provided NaN constant is essentially an alias for float ( 'nan' ) . One may question why such a thing would ever be desired, but this can be quite useful when interpolating as undefined channels will not be interpolated. It can be thought of as a way to mask off channels. Checkout the Interpolation section in the documentation to learn more. >>> from coloraide import NaN >>> color = Color ( \"srgb\" , [ 0.3 , NaN , 0.4 ]) >>> color . coords () [0.3, nan, 0.4] >>> color = Color ( 'rgb(30% none 40%)' ) >>> color . coords () [0.3, nan, 0.4] from coloraide import NaN color = Color(\"srgb\", [0.3, NaN, 0.4]) color.coords() color = Color('rgb(30% none 40%)') color.coords() Edit Share Run Cancel Lastly, a user can use the mask method which is a quick way to set one or multiple channels as undefined. Additionally, it returns a clone leaving the original untouched by default. >>> Color ( 'white' ) . coords () [1.0, 1.0, 1.0] >>> Color ( 'white' ) . mask ([ 'red' , 'green' ]) . coords () [nan, nan, 1.0] Color('white').coords() Color('white').mask(['red', 'green']).coords() Edit Share Run Cancel The alpha channel can also be masked: >>> Color ( 'white' ) . mask ( 'alpha' ) . alpha nan Color('white').mask('alpha').alpha Edit Share Run Cancel You can also do inverse masks, or masks that apply to every channel not specified. >>> c = Color ( 'white' ) . mask ( 'blue' , invert = True ) >>> c . coords () [nan, nan, 1.0] >>> c . alpha nan c = Color('white').mask('blue', invert=True) c.coords() c.alpha Edit Share Run Cancel Checking for Undefined Values As previously mentioned, a color channel can be undefined for a number of reasons. And in cases such as interpolation, undefined values can even be useful. On the other hand, sometimes an undefined value may need to be handled special. Undefined values are represented as the float value NaN . And since NaN values are not numbers \u2013 hence the name \"not a number\" \u2013 they don't quite work the same as normal numbers. They don't contribute to math operations like add, multiply, and divide. Any math operation performed with a NaN will simply yield NaN . NaN values are essentially infectious. At first glance, the behavior of NaN values can seem confusing, but it is actually pretty intuitive. If we define a color with an undefined channel, and try to add to that value, what should we get? In reality, if the value is undefined, how could we possibly add to it? The only sane answer is to return NaN again. >>> color = Color ( 'color(srgb 1 none 1)' ) >>> color . g + 0.5 nan color = Color('color(srgb 1 none 1)') color.g + 0.5 Edit Share Run Cancel Because a NaN may cause surprising results, it can be useful to check if a hue (or any channel) is NaN before applying certain operations where NaN may be undesirable, especially if the color potentially came from an unknown source.To make checking for NaN s easy, the convenience function is_nan has been made available. You can simply give is_nan the property you wish to check, and it will return either return True or False . >>> Color ( 'hsl(none 0 % 100% )' ) . is_nan ( 'hue' ) True Color('hsl(none 0% 100%)').is_nan('hue') Edit Share Run Cancel This is equivalent to using the math library and comparing the value directly: >>> import math >>> math . isnan ( Color ( 'hsl(none 0 % 100% )' ) . hue ) True import math math.isnan(Color('hsl(none 0% 100%)').hue) Edit Share Run Cancel","title":"Manipulating Colors"},{"location":"manipulation/#manipulating-colors","text":"Once a Color object is created, you have access to all the color channels. Color channels can be read individually or extracted all at once. Getting and setting color channels is flexible and easy, allowing for intuitive access.","title":"Manipulating Colors"},{"location":"manipulation/#reading-coordinates","text":"There are various ways to read the current values of color coordinates. Channel properties can be read directly: >>> color = Color ( \"orange\" ) >>> color . red 1.0 color = Color(\"orange\") color.red Edit Share Run Cancel Channel values can also be read by using the get method and providing the name of desired channel. >>> color = Color ( \"orange\" ) >>> color . get ( \"green\" ) 0.6470588235294118 color = Color(\"orange\") color.get(\"green\") Edit Share Run Cancel Additionally, we can also access values of the current color in terms of other color space properties. Simply specify the color space and the color property. >>> color = Color ( \"orange\" ) >>> color . get ( \"lch.chroma\" ) 83.76900622509224 color = Color(\"orange\") color.get(\"lch.chroma\") Edit Share Run Cancel All coordinates can be read simultaneously by using the coords function. The alpha channel is excluded from coords and must be retrieved separately. >>> color = Color ( \"orange\" ) >>> color . coords () [1.0, 0.6470588235294118, 0.0] >>> color . alpha 1.0 color = Color(\"orange\") color.coords() color.alpha Edit Share Run Cancel","title":"Reading Coordinates"},{"location":"manipulation/#modifying-coordinates","text":"Channel properties can be modified directly by using the named property. Here we modify red by adjusting its green property and get an orange hued color. >>> color = Color ( \"red\" ) >>> color . green = 0.5 >>> color . to_string () rgb(255 127.5 0) color = Color(\"red\") color.green = 0.5 color.to_string() Edit Share Run Cancel When doing so, keep in mind, the internal coordinates are being adjusted, so their scale and range is dictated by the given color space in which they relate to. sRGB, for example, specifies its color channels in the range of [0, 1], though it should allow extended ranges if required. Much like reading with the get method, values can be modified with the set method. As these methods return a reference to the current class, multiple set operations can be chained together. Chaining multiple set operations together, we can transform white to rgb ( 0 127 . 5 255 ) . >>> Color ( \"white\" ) . set ( \"red\" , 0 ) . set ( \"green\" , 0.5 ) color(srgb 0 0.5 1 / 1) Color(\"white\").set(\"red\", 0).set(\"green\", 0.5) Edit Share Run Cancel Functions can also be used to modify a channel property. This allows us to do more complex set operations. Here we do a relative adjustment of the green channel and transform the color pink to rgb ( 255 249 . 6 203 ) . >>> Color ( \"pink\" ) . set ( 'green' , lambda g : g * 1.3 ) color(srgb 1 0.97882 0.79608 / 1) Color(\"pink\").set('green', lambda g: g * 1.3) Edit Share Run Cancel","title":"Modifying Coordinates"},{"location":"manipulation/#modifying-coordinates-in-other-spaces","text":"Channels in other color spaces can also be modified with the set function. Here we alter the color blue by editing the hue channel in the CIELCH color space and get rgb (- 63 . 911 91 . 016 - 63 . 173 ) . Keep in mind that the colors are being converted to the specified space under the hood, set, and then converted back, so if you have multiple operations to apply in a given color space, it may be more efficient to convert to that space, apply the set operations directly, and then convert back. >>> Color ( \"blue\" ) . set ( 'lch.hue' , 130 ) color(srgb -0.25063 0.35692 -0.24774 / 1) Color(\"blue\").set('lch.hue', 130) Edit Share Run Cancel When setting a color in another color space, the final value is subject to any rounding errors that may occur in the round trip to and from the specified color space. Also, depending on the transform functions of the spaces involved, and whether the original color is on the edge of its own gamut, this can lead to a color going slightly out of gamut, and if one of the spaces involved in the conversion doesn't handle out of gamut colors with sensible values, you may get something unexpected back. Consider the following example comparing the modification of an HSL color in HWB vs Oklab. >>> Color ( 'hsl(0 0 % 50% )' ) . set ( 'hwb.blackness' , 0 ) . set ( 'hwb.whiteness' , 100 ) color(--hsl none 0 1 / 1) >>> Color ( 'hsl(0 0 % 50% )' ) . set ( 'oklab.lightness' , 1 ) color(--hsl 223.91 -1.3211 1 / 1) >>> Color ( 'hsl(0 0 % 50% )' ) . set ( 'oklab.lightness' , 1 ) . convert ( 'srgb' ) . coords () [0.9999999929041132, 1.0000000085633445, 1.0000000512914544] Color('hsl(0 0% 50%)').set('hwb.blackness', 0).set('hwb.whiteness', 100) Color('hsl(0 0% 50%)').set('oklab.lightness', 1) Color('hsl(0 0% 50%)').set('oklab.lightness', 1).convert('srgb').coords() Edit Share Run Cancel The above example cleanly converts between HSL and HWB as the conversion between these two is much more precise, but the Oklab example is not quite as precise and returns a color with a saturation that is way out of bounds. This is partly because the Oklab max whiteness isn't exactly 1 , but more like ~0.999... , The HSL model doesn't really represent out of gamut colors in a logical way and, in this case, creates a color with a negative saturation. It looks worse than it really is as when we convert it to sRGB, we see it is barely off. None of this is a bug, it is just the nature of the algorithms we are using to convert, the precision of the floats, and the slight rounding errors that occur when using floating-point arithmetic , etc.","title":"Modifying Coordinates in Other Spaces"},{"location":"manipulation/#undefined-values","text":"Colors in general can sometimes have undefined channels. This can actually happen in a number of ways. Channels can naturally be undefined under certain situations as defined by the color space. For instance, spaces with hues will have powerless hues when the color is achromatic. This can occur if saturation or chroma is zero, or when a color has no lightness, etc. Normally, if a hue is defined manually defined on an achromatic color they are considered defined even if the defined value is powerless, but during the conversion process, the algorithm won't know what to assign as a hue. For instance, if saturation is zero, one could argue the hue should be 0 , but that is actually a red hue, and achromatic colors have no hue. In the end, no hue is actually satisfactory, so an undefined hue is applied. >>> color = Color ( 'white' ) . convert ( 'hsl' ) >>> color . coords () [nan, 0.0, 1.0] color = Color('white').convert('hsl') color.coords() Edit Share Run Cancel When specifying raw data, and an insufficient amount of channel data is provided, the missing channels will be assumed as undefined, the exception is the alpha channel which is assumed to be 1 unless explicitly defined or explicitly set as undefined. >>> Color ( 'srgb' , [ 1 ]) . coords () [1.0, nan, nan] >>> Color ( 'srgb' , [ 1 , 0 , 0 ], NaN ) . alpha nan Color('srgb', [1]).coords() Color('srgb', [1, 0, 0], NaN).alpha Edit Share Run Cancel Undefined values can also occur when a user specifies a channel with the none keyword. This can also be done in raw color data by directly passing float ( 'nan' ) \u2013 the provided NaN constant is essentially an alias for float ( 'nan' ) . One may question why such a thing would ever be desired, but this can be quite useful when interpolating as undefined channels will not be interpolated. It can be thought of as a way to mask off channels. Checkout the Interpolation section in the documentation to learn more. >>> from coloraide import NaN >>> color = Color ( \"srgb\" , [ 0.3 , NaN , 0.4 ]) >>> color . coords () [0.3, nan, 0.4] >>> color = Color ( 'rgb(30% none 40%)' ) >>> color . coords () [0.3, nan, 0.4] from coloraide import NaN color = Color(\"srgb\", [0.3, NaN, 0.4]) color.coords() color = Color('rgb(30% none 40%)') color.coords() Edit Share Run Cancel Lastly, a user can use the mask method which is a quick way to set one or multiple channels as undefined. Additionally, it returns a clone leaving the original untouched by default. >>> Color ( 'white' ) . coords () [1.0, 1.0, 1.0] >>> Color ( 'white' ) . mask ([ 'red' , 'green' ]) . coords () [nan, nan, 1.0] Color('white').coords() Color('white').mask(['red', 'green']).coords() Edit Share Run Cancel The alpha channel can also be masked: >>> Color ( 'white' ) . mask ( 'alpha' ) . alpha nan Color('white').mask('alpha').alpha Edit Share Run Cancel You can also do inverse masks, or masks that apply to every channel not specified. >>> c = Color ( 'white' ) . mask ( 'blue' , invert = True ) >>> c . coords () [nan, nan, 1.0] >>> c . alpha nan c = Color('white').mask('blue', invert=True) c.coords() c.alpha Edit Share Run Cancel","title":"Undefined Values"},{"location":"manipulation/#checking-for-undefined-values","text":"As previously mentioned, a color channel can be undefined for a number of reasons. And in cases such as interpolation, undefined values can even be useful. On the other hand, sometimes an undefined value may need to be handled special. Undefined values are represented as the float value NaN . And since NaN values are not numbers \u2013 hence the name \"not a number\" \u2013 they don't quite work the same as normal numbers. They don't contribute to math operations like add, multiply, and divide. Any math operation performed with a NaN will simply yield NaN . NaN values are essentially infectious. At first glance, the behavior of NaN values can seem confusing, but it is actually pretty intuitive. If we define a color with an undefined channel, and try to add to that value, what should we get? In reality, if the value is undefined, how could we possibly add to it? The only sane answer is to return NaN again. >>> color = Color ( 'color(srgb 1 none 1)' ) >>> color . g + 0.5 nan color = Color('color(srgb 1 none 1)') color.g + 0.5 Edit Share Run Cancel Because a NaN may cause surprising results, it can be useful to check if a hue (or any channel) is NaN before applying certain operations where NaN may be undesirable, especially if the color potentially came from an unknown source.To make checking for NaN s easy, the convenience function is_nan has been made available. You can simply give is_nan the property you wish to check, and it will return either return True or False . >>> Color ( 'hsl(none 0 % 100% )' ) . is_nan ( 'hue' ) True Color('hsl(none 0% 100%)').is_nan('hue') Edit Share Run Cancel This is equivalent to using the math library and comparing the value directly: >>> import math >>> math . isnan ( Color ( 'hsl(none 0 % 100% )' ) . hue ) True import math math.isnan(Color('hsl(none 0% 100%)').hue) Edit Share Run Cancel","title":"Checking for Undefined Values"},{"location":"playground/","text":"Notebook Submit Cancel","title":"Playground"},{"location":"strings/","text":"String Output ColorAide supports serializing colors in the same formats that it accepts as inputs. This includes all CSS formats for the associated color spaces, and if a color space is not supported in CSS, the color ( space ... ) format. ColorAide exposes various options to allow users to serialize in the form they most prefer. Convert to Strings Colors can be serialized to strings by using the to_string method. The color class will convert the current color into one of the many of CSS formats supported for the given color space. >>> Color ( \"srgb\" , [ 0.5 , 0 , 1 ], 0.3 ) . to_string () rgb(127.5 0 255 / 0.3) Color(\"srgb\", [0.5, 0, 1], 0.3).to_string() Edit Share Run Cancel There are a number of options that are common among all color spaces, but there are also some color space specific options. We will only cover the color spaces shipped with ColorAide. It is possible to write a color space plugin that uses very different options. Common Options All color spaces support the following parameters. Alpha alpha is set to None by default and controls whether the alpha channel is shown in the serialized output. When in the default state, alpha will only be shown if the alpha channel has a value less than 100%, but if set to True , alpha will always be shown. Setting to False will cause alpha to be ignored in the output. Precision precision controls the precision of the output values. The name is a little misleading as it will actually adjust the precision and scale of the values. The default is 5. In some cases, like the sRGB hex output, precision may not really come into play as hex values are rounded to the nearest whole number. >>> Color ( \"rgb(30.3456 % 75% 100%)\" ) . to_string ( precision = 5 , percent = True ) rgb(30.346% 75% 100%) >>> Color ( \"rgb(30.3456 % 75% 100%)\" ) . to_string ( precision = 4 , percent = True ) rgb(30.35% 75% 100%) >>> Color ( \"rgb(30.3456 % 75% 100%)\" ) . to_string ( precision = 3 , percent = True ) rgb(30.3% 75% 100%) >>> Color ( \"rgb(30.3456 % 75% 100%)\" ) . to_string ( precision = 2 , percent = True ) rgb(30% 75% 100%) >>> Color ( \"rgb(30.3456 % 75% 100%)\" ) . to_string ( precision = 1 , percent = True ) rgb(30% 80% 100%) Color(\"rgb(30.3456% 75% 100%)\").to_string(precision=5, percent=True) Color(\"rgb(30.3456% 75% 100%)\").to_string(precision=4, percent=True) Color(\"rgb(30.3456% 75% 100%)\").to_string(precision=3, percent=True) Color(\"rgb(30.3456% 75% 100%)\").to_string(precision=2, percent=True) Color(\"rgb(30.3456% 75% 100%)\").to_string(precision=1, percent=True) Edit Share Run Cancel Providing a precision of 0 will simply enable simple rounding to the nearest whole number. >>> Color ( \"rgb(30.3456 % 75% 100%)\" ) . to_string ( precision = 0 , percent = True ) rgb(30% 75% 100%) Color(\"rgb(30.3456% 75% 100%)\").to_string(precision=0, percent=True) Edit Share Run Cancel Providing a precision of -1 is a special input that will give the highest precision that can be given. Not particularly helpful except to look at the raw decimal number. >>> Color ( \"rgb(30.3456 % 75% 100%)\" ) . to_string ( precision =- 1 , percent = True ) rgb(30.345600000000001017497197608463466167449951171875% 75% 100%) Color(\"rgb(30.3456% 75% 100%)\").to_string(precision=-1, percent=True) Edit Share Run Cancel One note though, format of the value matters. Here we output in the range of 0 - 255. We can see that a precision of 1 , in this case, can throw the color out of gamut. So remember to use a sufficient precision for what you are doing and the values you are working in. >>> Color ( \"rgb(30.3456 % 75% 100%)\" ) . to_string ( precision = 1 ) rgb(80 200 300) Color(\"rgb(30.3456% 75% 100%)\").to_string(precision=1) Edit Share Run Cancel Fit fit is set to True by default and controls whether colors are fit to their gamut or not. Some color spaces are technically unbounded, so no fitting may occur in those color spaces. Additionally, some color formats, like sRGB hex, are always fitted (regardless of this setting) as they must fit into the gamut or they cannot be translated. >>> Color ( \"rgb(30 % 105% 0%)\" ) . to_string () rgb(108.59 255 62.011) >>> Color ( \"rgb(30 % 105% 0%)\" ) . to_string ( fit = False ) rgb(76.5 267.75 0) Color(\"rgb(30% 105% 0%)\").to_string() Color(\"rgb(30% 105% 0%)\").to_string(fit=False) Edit Share Run Cancel Additionally, we can choose a different fitting method by passing fit the name of the method we would like. >>> Color ( \"rgb(30 % 105% 0%)\" ) . to_string () rgb(108.59 255 62.011) >>> Color ( \"rgb(30 % 105% 0%)\" ) . to_string ( fit = 'clip' ) rgb(76.5 255 0) Color(\"rgb(30% 105% 0%)\").to_string() Color(\"rgb(30% 105% 0%)\").to_string(fit='clip') Edit Share Run Cancel Color color , for some color spaces, is the default output, but for others this format can be explicitly requested by setting color to True . If set to True , this will take priority over other format options. >>> Color ( \"rebeccapurple\" ) . to_string ( color = True ) color(srgb 0.4 0.2 0.6) Color(\"rebeccapurple\").to_string(color=True) Edit Share Run Cancel None Colors that have undefined channels are internally represented with NaN . On output, these can be displayed as none per the most recent CSS spec. These are very new, so most browsers do not support them. This is disabled by default until a time when this behavior is common enough. NaN values will not survive fitting unless a color channel is naturally undefined. An example would be a hue when the color has saturation or chroma set to zero. >>> Color ( 'hsl(none 0 % 30% )' ) . to_string ( none = True ) hsl(none 0% 30%) Color('hsl(none 0% 30%)').to_string(none=True) Edit Share Run Cancel The one exception is that legacy rgb() , rgba() , hsl() , and hsla() forms (comma separated) do not support none per the CSS spec. Format Specific Options These options may occur in various color spaces depending on the CSS output format. Comma In CSS, there are a few color spaces that allow a comma format: srgb and hsl . ColorAide allows these to be read in and to be output in their legacy comma format. These are the only formats that ship with comma support. If we want commas, we can force the comma syntax by setting comma to True . This can alter some color space output in other subtle ways. As the comma format is the old legacy approach, when sRGB has commas enabled, it will use rgba instead of rgb . If using the non-comma syntax, rgb is always used, even when the color has transparency. >>> Color ( \"rgb(30 75 100 / 20%)\" ) . to_string ( comma = True ) rgba(30, 75, 100, 0.2) Color(\"rgb(30 75 100 / 20%)\").to_string(comma=True) Edit Share Run Cancel sRGB Specific Options These options are currently specific to the sRGB color space. Hex sRGB can output colors to a hex format which is unique compared to HSL and others. Simply enable hex . >>> Color ( \"rebeccapurple\" ) . to_string ( hex = True ) #663399 Color(\"rebeccapurple\").to_string(hex=True) Edit Share Run Cancel Upper You can force hex to output in uppercase. >>> Color ( \"red\" ) . to_string ( hex = True ) #ff0000 >>> Color ( \"red\" ) . to_string ( hex = True , upper = True ) #FF0000 Color(\"red\").to_string(hex=True) Color(\"red\").to_string(hex=True, upper=True) Edit Share Run Cancel Compress When converting to the hex color format, a color can be compressed in certain cases. Enabling compress will compress a hex color if possible. >>> Color ( \"#11223388\" ) . to_string ( hex = True ) #11223388 >>> Color ( \"#11223388\" ) . to_string ( hex = True , compress = True ) #1238 Color(\"#11223388\").to_string(hex=True) Color(\"#11223388\").to_string(hex=True, compress=True) Edit Share Run Cancel Percent sRGB also can output colors in an optional percent format. This will output the channels in the range of [0%,100%] instead of using the range [0,255]. >>> Color ( \"rebeccapurple\" ) . to_string ( percent = True ) rgb(40% 20% 60%) Color(\"rebeccapurple\").to_string(percent=True) Edit Share Run Cancel Names sRGB can also output color names. If a color evaluates to a hex code which also evaluates to a color name in the internal CSS color name mapping, then a color name will be returned. If the color does not match a color name, it will fallback to whatever the other options dictate. >>> Color ( \"#663399\" ) . to_string ( names = True ) rebeccapurple Color(\"#663399\").to_string(names=True) Edit Share Run Cancel","title":"String Output"},{"location":"strings/#string-output","text":"ColorAide supports serializing colors in the same formats that it accepts as inputs. This includes all CSS formats for the associated color spaces, and if a color space is not supported in CSS, the color ( space ... ) format. ColorAide exposes various options to allow users to serialize in the form they most prefer.","title":"String Output"},{"location":"strings/#convert-to-strings","text":"Colors can be serialized to strings by using the to_string method. The color class will convert the current color into one of the many of CSS formats supported for the given color space. >>> Color ( \"srgb\" , [ 0.5 , 0 , 1 ], 0.3 ) . to_string () rgb(127.5 0 255 / 0.3) Color(\"srgb\", [0.5, 0, 1], 0.3).to_string() Edit Share Run Cancel There are a number of options that are common among all color spaces, but there are also some color space specific options. We will only cover the color spaces shipped with ColorAide. It is possible to write a color space plugin that uses very different options.","title":"Convert to Strings"},{"location":"strings/#common-options","text":"All color spaces support the following parameters.","title":"Common Options"},{"location":"strings/#alpha","text":"alpha is set to None by default and controls whether the alpha channel is shown in the serialized output. When in the default state, alpha will only be shown if the alpha channel has a value less than 100%, but if set to True , alpha will always be shown. Setting to False will cause alpha to be ignored in the output.","title":"Alpha"},{"location":"strings/#precision","text":"precision controls the precision of the output values. The name is a little misleading as it will actually adjust the precision and scale of the values. The default is 5. In some cases, like the sRGB hex output, precision may not really come into play as hex values are rounded to the nearest whole number. >>> Color ( \"rgb(30.3456 % 75% 100%)\" ) . to_string ( precision = 5 , percent = True ) rgb(30.346% 75% 100%) >>> Color ( \"rgb(30.3456 % 75% 100%)\" ) . to_string ( precision = 4 , percent = True ) rgb(30.35% 75% 100%) >>> Color ( \"rgb(30.3456 % 75% 100%)\" ) . to_string ( precision = 3 , percent = True ) rgb(30.3% 75% 100%) >>> Color ( \"rgb(30.3456 % 75% 100%)\" ) . to_string ( precision = 2 , percent = True ) rgb(30% 75% 100%) >>> Color ( \"rgb(30.3456 % 75% 100%)\" ) . to_string ( precision = 1 , percent = True ) rgb(30% 80% 100%) Color(\"rgb(30.3456% 75% 100%)\").to_string(precision=5, percent=True) Color(\"rgb(30.3456% 75% 100%)\").to_string(precision=4, percent=True) Color(\"rgb(30.3456% 75% 100%)\").to_string(precision=3, percent=True) Color(\"rgb(30.3456% 75% 100%)\").to_string(precision=2, percent=True) Color(\"rgb(30.3456% 75% 100%)\").to_string(precision=1, percent=True) Edit Share Run Cancel Providing a precision of 0 will simply enable simple rounding to the nearest whole number. >>> Color ( \"rgb(30.3456 % 75% 100%)\" ) . to_string ( precision = 0 , percent = True ) rgb(30% 75% 100%) Color(\"rgb(30.3456% 75% 100%)\").to_string(precision=0, percent=True) Edit Share Run Cancel Providing a precision of -1 is a special input that will give the highest precision that can be given. Not particularly helpful except to look at the raw decimal number. >>> Color ( \"rgb(30.3456 % 75% 100%)\" ) . to_string ( precision =- 1 , percent = True ) rgb(30.345600000000001017497197608463466167449951171875% 75% 100%) Color(\"rgb(30.3456% 75% 100%)\").to_string(precision=-1, percent=True) Edit Share Run Cancel One note though, format of the value matters. Here we output in the range of 0 - 255. We can see that a precision of 1 , in this case, can throw the color out of gamut. So remember to use a sufficient precision for what you are doing and the values you are working in. >>> Color ( \"rgb(30.3456 % 75% 100%)\" ) . to_string ( precision = 1 ) rgb(80 200 300) Color(\"rgb(30.3456% 75% 100%)\").to_string(precision=1) Edit Share Run Cancel","title":"Precision"},{"location":"strings/#fit","text":"fit is set to True by default and controls whether colors are fit to their gamut or not. Some color spaces are technically unbounded, so no fitting may occur in those color spaces. Additionally, some color formats, like sRGB hex, are always fitted (regardless of this setting) as they must fit into the gamut or they cannot be translated. >>> Color ( \"rgb(30 % 105% 0%)\" ) . to_string () rgb(108.59 255 62.011) >>> Color ( \"rgb(30 % 105% 0%)\" ) . to_string ( fit = False ) rgb(76.5 267.75 0) Color(\"rgb(30% 105% 0%)\").to_string() Color(\"rgb(30% 105% 0%)\").to_string(fit=False) Edit Share Run Cancel Additionally, we can choose a different fitting method by passing fit the name of the method we would like. >>> Color ( \"rgb(30 % 105% 0%)\" ) . to_string () rgb(108.59 255 62.011) >>> Color ( \"rgb(30 % 105% 0%)\" ) . to_string ( fit = 'clip' ) rgb(76.5 255 0) Color(\"rgb(30% 105% 0%)\").to_string() Color(\"rgb(30% 105% 0%)\").to_string(fit='clip') Edit Share Run Cancel","title":"Fit"},{"location":"strings/#color","text":"color , for some color spaces, is the default output, but for others this format can be explicitly requested by setting color to True . If set to True , this will take priority over other format options. >>> Color ( \"rebeccapurple\" ) . to_string ( color = True ) color(srgb 0.4 0.2 0.6) Color(\"rebeccapurple\").to_string(color=True) Edit Share Run Cancel","title":"Color"},{"location":"strings/#none","text":"Colors that have undefined channels are internally represented with NaN . On output, these can be displayed as none per the most recent CSS spec. These are very new, so most browsers do not support them. This is disabled by default until a time when this behavior is common enough. NaN values will not survive fitting unless a color channel is naturally undefined. An example would be a hue when the color has saturation or chroma set to zero. >>> Color ( 'hsl(none 0 % 30% )' ) . to_string ( none = True ) hsl(none 0% 30%) Color('hsl(none 0% 30%)').to_string(none=True) Edit Share Run Cancel The one exception is that legacy rgb() , rgba() , hsl() , and hsla() forms (comma separated) do not support none per the CSS spec.","title":"None"},{"location":"strings/#format-specific-options","text":"These options may occur in various color spaces depending on the CSS output format.","title":"Format Specific Options"},{"location":"strings/#comma","text":"In CSS, there are a few color spaces that allow a comma format: srgb and hsl . ColorAide allows these to be read in and to be output in their legacy comma format. These are the only formats that ship with comma support. If we want commas, we can force the comma syntax by setting comma to True . This can alter some color space output in other subtle ways. As the comma format is the old legacy approach, when sRGB has commas enabled, it will use rgba instead of rgb . If using the non-comma syntax, rgb is always used, even when the color has transparency. >>> Color ( \"rgb(30 75 100 / 20%)\" ) . to_string ( comma = True ) rgba(30, 75, 100, 0.2) Color(\"rgb(30 75 100 / 20%)\").to_string(comma=True) Edit Share Run Cancel","title":"Comma"},{"location":"strings/#srgb-specific-options","text":"These options are currently specific to the sRGB color space.","title":"sRGB Specific Options"},{"location":"strings/#hex","text":"sRGB can output colors to a hex format which is unique compared to HSL and others. Simply enable hex . >>> Color ( \"rebeccapurple\" ) . to_string ( hex = True ) #663399 Color(\"rebeccapurple\").to_string(hex=True) Edit Share Run Cancel","title":"Hex"},{"location":"strings/#upper","text":"You can force hex to output in uppercase. >>> Color ( \"red\" ) . to_string ( hex = True ) #ff0000 >>> Color ( \"red\" ) . to_string ( hex = True , upper = True ) #FF0000 Color(\"red\").to_string(hex=True) Color(\"red\").to_string(hex=True, upper=True) Edit Share Run Cancel","title":"Upper"},{"location":"strings/#compress","text":"When converting to the hex color format, a color can be compressed in certain cases. Enabling compress will compress a hex color if possible. >>> Color ( \"#11223388\" ) . to_string ( hex = True ) #11223388 >>> Color ( \"#11223388\" ) . to_string ( hex = True , compress = True ) #1238 Color(\"#11223388\").to_string(hex=True) Color(\"#11223388\").to_string(hex=True, compress=True) Edit Share Run Cancel","title":"Compress"},{"location":"strings/#percent","text":"sRGB also can output colors in an optional percent format. This will output the channels in the range of [0%,100%] instead of using the range [0,255]. >>> Color ( \"rebeccapurple\" ) . to_string ( percent = True ) rgb(40% 20% 60%) Color(\"rebeccapurple\").to_string(percent=True) Edit Share Run Cancel","title":"Percent"},{"location":"strings/#names","text":"sRGB can also output color names. If a color evaluates to a hex code which also evaluates to a color name in the internal CSS color name mapping, then a color name will be returned. If the color does not match a color name, it will fallback to whatever the other options dictate. >>> Color ( \"#663399\" ) . to_string ( names = True ) rebeccapurple Color(\"#663399\").to_string(names=True) Edit Share Run Cancel","title":"Names"},{"location":"about/acknowledgments/","text":"Acknowledgments All projects gain help and inspiration from somewhere, and we wanted to document the places in which we we gathered knowledge, ideas, and help. Projects When we began writing ColorAide, we wanted a simple interface to deal with different colors. We also wanted to support CSS colors which a lot of people are familiar with. We had a number of questions about the CSS spec and stumbled on Color.js , a JavaScript library developed and maintained by the co-authors of the CSS spec. We found Color.js and its authors helped clarify a number of confusing points. Additionally, their library did end up heavily inspiring many aspects of our own API as its approach very much aligned with the direction we had already started down.","title":"Acknowledgments"},{"location":"about/acknowledgments/#acknowledgments","text":"All projects gain help and inspiration from somewhere, and we wanted to document the places in which we we gathered knowledge, ideas, and help.","title":"Acknowledgments"},{"location":"about/acknowledgments/#projects","text":"When we began writing ColorAide, we wanted a simple interface to deal with different colors. We also wanted to support CSS colors which a lot of people are familiar with. We had a number of questions about the CSS spec and stumbled on Color.js , a JavaScript library developed and maintained by the co-authors of the CSS spec. We found Color.js and its authors helped clarify a number of confusing points. Additionally, their library did end up heavily inspiring many aspects of our own API as its approach very much aligned with the direction we had already started down.","title":"Projects"},{"location":"about/changelog/","text":"Changelog 0.15.1 FIX : Fix an issue related to matching colors in a buffer at a given offset. 0.15.0 Warning No changes in the public API have changed, but type annotations have. If you were importing type annotations, you will have to update them. Also, if any undocumented math related methods were accessed (for plugins or otherwise) they've been moved to coloraide.algebra NEW : A number of performance improvements. NEW : Regenerate all matrices with our own matrix tools so that there is consistency between precision of pre-generated matrices and on-the-fly matrix generation. Reduces some noise in a few color space transforms. NEW : Changes to type annotations. Mutable<type> , where type is either Matrix , Vector , or Array , are simply known as <type> . Types previously specified as <type> , where type is either Matrix , Vector , or Array , are now known as <type>Like . The types are expected to be mutable lists, anything else is noted as \"like\". NEW : All matrix and math utilities have been moved to coloraide.algebra . FIX : Fix rare issue where precision adjustment could fail. FIX : Fix matrix divide logic when dividing a number or vector by a matrix. There are no actual usage of these cases in the code but they were fixed in case they are used in the future. 0.14.1 FIX : Fix bug related to parsing strings without full matching. 0.14.0 Note No changes should break existing color space plugins. Moved objects and references are still also available in old locations, and new functionality is implemented in such a way as to not break existing plugins, but plugins should be updated as sometime before the 1.0 release, such legacy access will be removed. NEW : Faster parsing. Instead of parsing color(space ...) each time it is evaluated for a different color space, parse it generically and then associate it with a given registered color space. If a color spaces wishes to opt out of the color(space ...) input format, the space should set COLOR_FORMAT to False . This means there is no need to call super.match() when overriding Color.match() to ensure support for the color(space ...) format as it will be handled unless COLOR_FORMAT is turned off. DEFAULT_MATCH usage should also be discontinued as it now does nothing. NEW : Other speed optimizations. NEW : All CSS parsing and serialization is now contained in a single module at coloraide.css . This simplifies the current color space classes greatly when it comes to supporting CSS specific formats. NEW : Move our white space mapping to the cat module as it makes more sense there. NEW : GamutBound , GamutUnbound , and associated flags are now contained under coloraide.gamut.bounds . NEW : normalize will also remove masked values to properly adjust the color. FIX : Compositing and blending should not \"fit\" colors before applying, it is only specified that the range should be clamped at the end of blending. FIX : Fix issue where a subclassed Color() object could not recognize the base class or other subclasses. 0.13.0 NEW : Add new closest method that takes a list of colors and returns the one that is closet to the calling color object. NEW : CSS color syntax no longer allows for forgiving channels in color() . This means that when a channel other than alpha is omitted, we will no longer treat them as undefined. Instead, the color will simply fail to parse. Raw data channels also must specify all channels. NEW : Clamp lower bounds of chroma at the channel level. NEW : coloraide.spaces.WHITES is now a 2 deep dictionary containing both 2\u02da and 10\u02da observer variants of white points. NEW : Color space plugins now specify WHITE as a tuple with the x and y chromaticity coordinates. This allows a space to specify unknown white points if desired. FIX : Fix longer hue interpolation when \u03b81 - \u03b82 = 0 . The spec is wrong in this case, and interpolation should still occur the long way around instead of keeping hue constant. FIX : Reduce redundancy in some CSS parsing patterns. FIX : Minor performance improvements. FIX : Legacy rgb() , rgba() , hsl() , and hsla() comma separated forms in CSS do not support none , only the new space separated forms do. FIX : Ensure py.typed is installed with package so that type annotations work properly. 0.12.0 NEW : Add a gamut mapping variant that matches the CSS Color Level 4 spec. FIX : Fix precision rounding issue. 0.11.0 Breaking Changes Prior to 0.11.0, if you specified a cylindrical space directly, ColorAide would normalize undefined hues the same way that the conversion algorithm did. In the below case, saturation is zero, so the hue was declared undefined. >>> Color ( 'hsl(270 0 % 50% )' ) color ( -- hsl none 0 0.5 / 1 ) We should not have been doing this, and it made some cases of interpolation a bit confusing. It is no longer done as the hues are in fact specified by the user, even if they are powerless in relation to contributing to the rendered color. When a cylindrical color is converted or if a user declares the channel as undefined with none or some other way, then the channel will be declared undefined, because in these cases, they truly are. >>> Color ( 'white' ) . convert ( 'hsl' ) color ( -- hsl none 0 1 / 1 ) >>> Color ( 'color(--hsl none 0 0.5)' ) color ( -- hsl none 0 0.5 ) If you are working directly in a cylindrical color space and ever wish to force the normalization of color hues as undefined when the color meets the usual requirements as specified by the color space's current rules, just call normalize on the color and it will apply the same logic that occurs during the conversion process. >>> Color ( 'hsl(270 0 % 50% )' ) . normalize () color ( -- hsl none 0 0.5 / 1 ) If you relied on commas in CSS forms that did not support them, this behavior is no longer allowed. It was thought that CSS may consider allowing comma formats in formats like hwb() , etc., and it was considered, but ultimately the decision was to avoid adding such support. We've updated our input and output support to reflect this. Color spaces can always be subclassed and have this support added back, if desired, but will not be shipped as the default anymore. The D65 form of Luv and LCHuv is now the only supported Luv based color spaces by default now. D50 Luv and LCHuv have been dropped and luv and lchuv now refers to the D65 version. In most places, the D65 is the most common used white space as most monitors are calibrated for this white point. The only reason CIELAB and CIELCH are D50 by default is that CSS requires it. Anyone interested in using Luv with a different white point can easily subclass the current Luv and create a new plugin color space that uses the new white point. Renamed DIN99o Lch identifier to the short name of lch99o . NEW : ColorAide now only ships with the D65 version Luv and LCHuv as D65, in most places is the expected white space. Now, the identifier luv and lchuv will refer to the D65 version of the respective color spaces. D50 variants are no longer available by default. NEW : Add the HSLuv color space. NEW : DIN99o Lch identifier was renamed from din99o-lch to lch99o . To use in CSS color() form, use --lch99o . NEW : Refactor chroma reduction/ MINDE logic to cut processing time in half. Gamut mapping results remain very similar. NEW : Be more strict with CSS inputs and outputs. hwb() , lab() , lch() , oklab() , and oklch() no longer support comma string formats. NEW : Officially drop Python 3.6 support. FIX : Do not assume user defined, powerless hues as undefined. If they are defined by the user, they should be respected, even if they have no effect on the current color. This helps to ensure interpolations acts in an unsurprising way. If a user manually specifies the channel with none , then it will be considered undefined, or if the color goes through a conversion to a space that cannot pick an appropriate hue, they will also be undefined. 0.10.0 NEW : Switch back to using CIELCH for gamut mapping ( lch-chroma ). There are still some edge cases that make oklch-chroma less desirable. FIX : Fix an issue where when attempting to generate steps some \u2206E distance apart, the maximum step range was not respected and could result in large hangs. 0.9.0 Breaking Changes Custom gamut mapping plugins no longer return coordinates and require the method to update the passed in color. NEW : Improved, faster gamut mapping algorithm. NEW : FIT plugins (gamut mapping) no longer return coordinates but should modify the color passed in. NEW : Expose default interpolation space as a class variable that can be controlled when creating a custom class via class inheritance. NEW : Colors can now directly specify the \u2206E method that is used when interpolating color steps and using max_delta_e via the new delta_e argument. If the delta_e parameter is omitted, the color object's default \u2206E method will be used. NEW : Oklab is now the default interpolation color space. NEW : Interpolation will now avoid fitting colors that are out of gamut unless the color space cannot represent out of gamut colors. Currently, all of the RGB colors ( srgb , display-p3 , etc.) all support extended ranges, but the HSL, HWB, and HSV color models for srgb (including spaces such as okhsl and okhsv ) do not support extended ranges and will still be gamut mapped. FIX : Remove some incorrect code from the gamut mapping algorithm that would shortcut the mapping to reduce chroma to zero. 0.8.0 Breaking Changes The use of xyz as the color space name has been changed in favor of xyz-d65 . This better matches the CSS specification. As we are still in a prerelease state, we have not provided any backwards compatibility. CSS color input strings in the form color ( xyz x y z ) will continue to be accepted as CSS will allow both the xyz and the xyz-d65 identifier, but output serialization will prefer the color ( xyz-d65 x y z ) form as using xyz is an alias for xyz-d65 . Again, this breaking change only affects operations where the color space \"name\" is used in the API to specify usage of a specific color space in order to create a color, convert, mutate, interpolate, etc. Color ( 'red' ) . convert ( 'xyz' ) # Bad Color ( 'red' ) . convert ( 'xyz-d65' ) # Okay Color ( 'xyz' [ 0 , 0 , 0 ]) # Bad Color ( 'xyz-d65' [ 0 , 0 , 0 ]) # Okay Color ( 'red' ) . interpolate ( 'green' , space = 'xyz' ) # Bad Color ( 'red' ) . interpolate ( 'green' , space = 'xyz-d65' ) # Okay # No changes to CSS inputs Color ( 'color(xyz 0 0 0)' ) # Okay Color ( 'color(xyz-d65 0 0 0)' ) # Okay NEW : Add the official CSS syntax oklab() and oklch() for the Oklab and Oklch color spaces respectively. NEW : Custom fit plugin's fit method now allows additional kwargs in its signature. The API will accept kwargs allowing a custom fit plugin to have configurable parameters. None of the current built-in plugins provide additional parameters, but this is provided in case it is found useful in the future. NEW : XYZ D65 space will now be known as xyz-d65 , not xyz . Per the CSS specification, we also ensure XYZ D65 color space serializes as xyz-d65 instead of the alias xyz . CSS input string format will still accept the xyz identifier as this is defined in the CSS specification as an alias for xyz-d65 , but when serializing a color to a string, the xyz-d65 will be used as the preferred form. NEW : By default, gamut mapping is done with oklch-chroma which matches the current CSS specification. If desired, the old way ( lch-chroma ) can manually be specified or set as the default by subclassing Color and setting FIT to lch-chroma . FIX : Ensure the convert method's fit parameter is typed appropriately and is documented correctly. 0.7.0 NEW : Formally expose srgb-linear as a valid color space. NEW : Distance plugins and gamut mapping plugins now use classmethod instead of staticmethod . This allows for inheritance from other classes and the overriding of plugin options included as class members. NEW : Tweak Lch chroma gamut mapping threshold. FIX : Issue where it is possible, when generating steps, to cause a shift in midpoint of colors if exceeding the maximum steps. Ensure that no stops are injected if injecting a stop between every color would exceed the max steps. 0.6.0 NEW : Update spaces such that they provide a single conversion point which simplifies color space API and centralizes all conversion logic allowing us to pull chromatic adaptation out of spaces. NEW : color() output format never uses percent when serializing, but will optionally accept percent as input. NEW : Slight refactor of color space, delta E, and gamut mapping plugins. All now specify there name via the property NAME instead of methods space() for color spaces and name() for other plugins. NEW : Restructure source structure by flattening out some directories and better organizing source files. This changes some import paths. NEW : Color spaces do not specify alpha in CHANNEL_NAMES as the alpha name cannot be changed. NEW : Color space objects do not need a constant to track number of color channels. 0.5.0 NEW : Add type annotations and refactor code to better accommodate the type annotations. Public API not really affected, but a bit of the internals have changed. FIX : Fix issue where compose , if backdrop list is empty, would not respect in_place option. 0.4.0 NEW : Officially support Python 3.10. NEW : Slightly more accurate Oklab matrix calculation. NEW : Exported dictionary form can now be used as a normal color input in functions like contrast , interpolate , etc. NEW : Color objects will accept a dictionary mapping when alpha is not specified. When this occurs, alpha is assumed to be 1 . FIX : Fix an object compare issue. 0.3.0 Breaking Changes XYZ changes below will cause breakage as xyz now refers to XYZ with D65 instead of D50. Also, CSS identifiers changed per the recent specification change. NEW : When calling dir() on Color() , ensure dynamic methods are in the list. NEW : xyz now refers to XYZ D65. CSS color () function now specifies D65 color as either color ( xyz x y z ) or color ( xyz-d65 x y z ) . XYZ D50 is now specified as color ( xyz-D50 x y z ) . NEW : Add CIELUV and CIELCH uv D65 variants. 0.2.0 NEW : Provide dedicated clip method. clip is still a specifiable method under the fit function. It is also a reserved name under fit and cannot be overridden via plugins or be removed. NEW : Add more conversion shortcuts to OK family of color spaces. FIX : Fix an issue where the shorter conversion path wasn't always taken as convert couldn't find to/from methods if the color space name had - in it. 0.1.0 First non-alpha prerelease. Notable changes from the last alpha listed below. Breaking Changes There are some breaking changes if coming from the previous alpha releases. All sRGB cylindrical spaces' non-hue data ranges are no longer scaled to 0 - 100, but use 0 - 1. Hue ranges have not changed. NEW : By accepting HSL, HSV, and HWB as non-hue channels as 0-100, we do lose a little precision, so for 1.0, we are switching to accepting and returning raw data values between 0 - 1. We've kept hue between 0 - 360 as it is easier for users to deal with hues between 0 - 360. Doing this will also match the new color spaces Okhsl and Okhsv that need to be kept at 0 - 1 to get better rounding. NEW : We do not currently restrict percentages anymore in color () functions. There is no hard rules that we need to at this time and no currently specified spaces that do this in the CSS specification. This is relaxed for now until some future time when it becomes clear we must. NEW : New okhsl and okhsv color space. NEW : All color channels now accept the none keyword to specify an undefined channel. They can also optionally output CSS strings with the keyword. NEW : Interpolation will return an undefined channel if both colors have that channel set to undefined. NEW : Provide a way to dump a color object to a simple dictionary and have the Color() object accept that dictionary to recreate the color object. NEW : Provide cat16 chromatic adaptation. NEW : Add normalize method to force channel normalization (evaluation of channels and setting undefined as appropriate). NEW : Interpolated and composited colors will normalize undefined channels when returning a color. NEW : Jzazbz now also has an alias for az and bz channels as a and b respectively. FIX : Fix an attribute \"get\" issue where attributes that were not present on the Color() object appeared to be present when using hasattr() . FIX : More accurate Oklab matrix.","title":"Changelog"},{"location":"about/changelog/#changelog","text":"","title":"Changelog"},{"location":"about/changelog/#0151","text":"FIX : Fix an issue related to matching colors in a buffer at a given offset.","title":"0.15.1"},{"location":"about/changelog/#0150","text":"Warning No changes in the public API have changed, but type annotations have. If you were importing type annotations, you will have to update them. Also, if any undocumented math related methods were accessed (for plugins or otherwise) they've been moved to coloraide.algebra NEW : A number of performance improvements. NEW : Regenerate all matrices with our own matrix tools so that there is consistency between precision of pre-generated matrices and on-the-fly matrix generation. Reduces some noise in a few color space transforms. NEW : Changes to type annotations. Mutable<type> , where type is either Matrix , Vector , or Array , are simply known as <type> . Types previously specified as <type> , where type is either Matrix , Vector , or Array , are now known as <type>Like . The types are expected to be mutable lists, anything else is noted as \"like\". NEW : All matrix and math utilities have been moved to coloraide.algebra . FIX : Fix rare issue where precision adjustment could fail. FIX : Fix matrix divide logic when dividing a number or vector by a matrix. There are no actual usage of these cases in the code but they were fixed in case they are used in the future.","title":"0.15.0"},{"location":"about/changelog/#0141","text":"FIX : Fix bug related to parsing strings without full matching.","title":"0.14.1"},{"location":"about/changelog/#0140","text":"Note No changes should break existing color space plugins. Moved objects and references are still also available in old locations, and new functionality is implemented in such a way as to not break existing plugins, but plugins should be updated as sometime before the 1.0 release, such legacy access will be removed. NEW : Faster parsing. Instead of parsing color(space ...) each time it is evaluated for a different color space, parse it generically and then associate it with a given registered color space. If a color spaces wishes to opt out of the color(space ...) input format, the space should set COLOR_FORMAT to False . This means there is no need to call super.match() when overriding Color.match() to ensure support for the color(space ...) format as it will be handled unless COLOR_FORMAT is turned off. DEFAULT_MATCH usage should also be discontinued as it now does nothing. NEW : Other speed optimizations. NEW : All CSS parsing and serialization is now contained in a single module at coloraide.css . This simplifies the current color space classes greatly when it comes to supporting CSS specific formats. NEW : Move our white space mapping to the cat module as it makes more sense there. NEW : GamutBound , GamutUnbound , and associated flags are now contained under coloraide.gamut.bounds . NEW : normalize will also remove masked values to properly adjust the color. FIX : Compositing and blending should not \"fit\" colors before applying, it is only specified that the range should be clamped at the end of blending. FIX : Fix issue where a subclassed Color() object could not recognize the base class or other subclasses.","title":"0.14.0"},{"location":"about/changelog/#0130","text":"NEW : Add new closest method that takes a list of colors and returns the one that is closet to the calling color object. NEW : CSS color syntax no longer allows for forgiving channels in color() . This means that when a channel other than alpha is omitted, we will no longer treat them as undefined. Instead, the color will simply fail to parse. Raw data channels also must specify all channels. NEW : Clamp lower bounds of chroma at the channel level. NEW : coloraide.spaces.WHITES is now a 2 deep dictionary containing both 2\u02da and 10\u02da observer variants of white points. NEW : Color space plugins now specify WHITE as a tuple with the x and y chromaticity coordinates. This allows a space to specify unknown white points if desired. FIX : Fix longer hue interpolation when \u03b81 - \u03b82 = 0 . The spec is wrong in this case, and interpolation should still occur the long way around instead of keeping hue constant. FIX : Reduce redundancy in some CSS parsing patterns. FIX : Minor performance improvements. FIX : Legacy rgb() , rgba() , hsl() , and hsla() comma separated forms in CSS do not support none , only the new space separated forms do. FIX : Ensure py.typed is installed with package so that type annotations work properly.","title":"0.13.0"},{"location":"about/changelog/#0120","text":"NEW : Add a gamut mapping variant that matches the CSS Color Level 4 spec. FIX : Fix precision rounding issue.","title":"0.12.0"},{"location":"about/changelog/#0110","text":"Breaking Changes Prior to 0.11.0, if you specified a cylindrical space directly, ColorAide would normalize undefined hues the same way that the conversion algorithm did. In the below case, saturation is zero, so the hue was declared undefined. >>> Color ( 'hsl(270 0 % 50% )' ) color ( -- hsl none 0 0.5 / 1 ) We should not have been doing this, and it made some cases of interpolation a bit confusing. It is no longer done as the hues are in fact specified by the user, even if they are powerless in relation to contributing to the rendered color. When a cylindrical color is converted or if a user declares the channel as undefined with none or some other way, then the channel will be declared undefined, because in these cases, they truly are. >>> Color ( 'white' ) . convert ( 'hsl' ) color ( -- hsl none 0 1 / 1 ) >>> Color ( 'color(--hsl none 0 0.5)' ) color ( -- hsl none 0 0.5 ) If you are working directly in a cylindrical color space and ever wish to force the normalization of color hues as undefined when the color meets the usual requirements as specified by the color space's current rules, just call normalize on the color and it will apply the same logic that occurs during the conversion process. >>> Color ( 'hsl(270 0 % 50% )' ) . normalize () color ( -- hsl none 0 0.5 / 1 ) If you relied on commas in CSS forms that did not support them, this behavior is no longer allowed. It was thought that CSS may consider allowing comma formats in formats like hwb() , etc., and it was considered, but ultimately the decision was to avoid adding such support. We've updated our input and output support to reflect this. Color spaces can always be subclassed and have this support added back, if desired, but will not be shipped as the default anymore. The D65 form of Luv and LCHuv is now the only supported Luv based color spaces by default now. D50 Luv and LCHuv have been dropped and luv and lchuv now refers to the D65 version. In most places, the D65 is the most common used white space as most monitors are calibrated for this white point. The only reason CIELAB and CIELCH are D50 by default is that CSS requires it. Anyone interested in using Luv with a different white point can easily subclass the current Luv and create a new plugin color space that uses the new white point. Renamed DIN99o Lch identifier to the short name of lch99o . NEW : ColorAide now only ships with the D65 version Luv and LCHuv as D65, in most places is the expected white space. Now, the identifier luv and lchuv will refer to the D65 version of the respective color spaces. D50 variants are no longer available by default. NEW : Add the HSLuv color space. NEW : DIN99o Lch identifier was renamed from din99o-lch to lch99o . To use in CSS color() form, use --lch99o . NEW : Refactor chroma reduction/ MINDE logic to cut processing time in half. Gamut mapping results remain very similar. NEW : Be more strict with CSS inputs and outputs. hwb() , lab() , lch() , oklab() , and oklch() no longer support comma string formats. NEW : Officially drop Python 3.6 support. FIX : Do not assume user defined, powerless hues as undefined. If they are defined by the user, they should be respected, even if they have no effect on the current color. This helps to ensure interpolations acts in an unsurprising way. If a user manually specifies the channel with none , then it will be considered undefined, or if the color goes through a conversion to a space that cannot pick an appropriate hue, they will also be undefined.","title":"0.11.0"},{"location":"about/changelog/#0100","text":"NEW : Switch back to using CIELCH for gamut mapping ( lch-chroma ). There are still some edge cases that make oklch-chroma less desirable. FIX : Fix an issue where when attempting to generate steps some \u2206E distance apart, the maximum step range was not respected and could result in large hangs.","title":"0.10.0"},{"location":"about/changelog/#090","text":"Breaking Changes Custom gamut mapping plugins no longer return coordinates and require the method to update the passed in color. NEW : Improved, faster gamut mapping algorithm. NEW : FIT plugins (gamut mapping) no longer return coordinates but should modify the color passed in. NEW : Expose default interpolation space as a class variable that can be controlled when creating a custom class via class inheritance. NEW : Colors can now directly specify the \u2206E method that is used when interpolating color steps and using max_delta_e via the new delta_e argument. If the delta_e parameter is omitted, the color object's default \u2206E method will be used. NEW : Oklab is now the default interpolation color space. NEW : Interpolation will now avoid fitting colors that are out of gamut unless the color space cannot represent out of gamut colors. Currently, all of the RGB colors ( srgb , display-p3 , etc.) all support extended ranges, but the HSL, HWB, and HSV color models for srgb (including spaces such as okhsl and okhsv ) do not support extended ranges and will still be gamut mapped. FIX : Remove some incorrect code from the gamut mapping algorithm that would shortcut the mapping to reduce chroma to zero.","title":"0.9.0"},{"location":"about/changelog/#080","text":"Breaking Changes The use of xyz as the color space name has been changed in favor of xyz-d65 . This better matches the CSS specification. As we are still in a prerelease state, we have not provided any backwards compatibility. CSS color input strings in the form color ( xyz x y z ) will continue to be accepted as CSS will allow both the xyz and the xyz-d65 identifier, but output serialization will prefer the color ( xyz-d65 x y z ) form as using xyz is an alias for xyz-d65 . Again, this breaking change only affects operations where the color space \"name\" is used in the API to specify usage of a specific color space in order to create a color, convert, mutate, interpolate, etc. Color ( 'red' ) . convert ( 'xyz' ) # Bad Color ( 'red' ) . convert ( 'xyz-d65' ) # Okay Color ( 'xyz' [ 0 , 0 , 0 ]) # Bad Color ( 'xyz-d65' [ 0 , 0 , 0 ]) # Okay Color ( 'red' ) . interpolate ( 'green' , space = 'xyz' ) # Bad Color ( 'red' ) . interpolate ( 'green' , space = 'xyz-d65' ) # Okay # No changes to CSS inputs Color ( 'color(xyz 0 0 0)' ) # Okay Color ( 'color(xyz-d65 0 0 0)' ) # Okay NEW : Add the official CSS syntax oklab() and oklch() for the Oklab and Oklch color spaces respectively. NEW : Custom fit plugin's fit method now allows additional kwargs in its signature. The API will accept kwargs allowing a custom fit plugin to have configurable parameters. None of the current built-in plugins provide additional parameters, but this is provided in case it is found useful in the future. NEW : XYZ D65 space will now be known as xyz-d65 , not xyz . Per the CSS specification, we also ensure XYZ D65 color space serializes as xyz-d65 instead of the alias xyz . CSS input string format will still accept the xyz identifier as this is defined in the CSS specification as an alias for xyz-d65 , but when serializing a color to a string, the xyz-d65 will be used as the preferred form. NEW : By default, gamut mapping is done with oklch-chroma which matches the current CSS specification. If desired, the old way ( lch-chroma ) can manually be specified or set as the default by subclassing Color and setting FIT to lch-chroma . FIX : Ensure the convert method's fit parameter is typed appropriately and is documented correctly.","title":"0.8.0"},{"location":"about/changelog/#070","text":"NEW : Formally expose srgb-linear as a valid color space. NEW : Distance plugins and gamut mapping plugins now use classmethod instead of staticmethod . This allows for inheritance from other classes and the overriding of plugin options included as class members. NEW : Tweak Lch chroma gamut mapping threshold. FIX : Issue where it is possible, when generating steps, to cause a shift in midpoint of colors if exceeding the maximum steps. Ensure that no stops are injected if injecting a stop between every color would exceed the max steps.","title":"0.7.0"},{"location":"about/changelog/#060","text":"NEW : Update spaces such that they provide a single conversion point which simplifies color space API and centralizes all conversion logic allowing us to pull chromatic adaptation out of spaces. NEW : color() output format never uses percent when serializing, but will optionally accept percent as input. NEW : Slight refactor of color space, delta E, and gamut mapping plugins. All now specify there name via the property NAME instead of methods space() for color spaces and name() for other plugins. NEW : Restructure source structure by flattening out some directories and better organizing source files. This changes some import paths. NEW : Color spaces do not specify alpha in CHANNEL_NAMES as the alpha name cannot be changed. NEW : Color space objects do not need a constant to track number of color channels.","title":"0.6.0"},{"location":"about/changelog/#050","text":"NEW : Add type annotations and refactor code to better accommodate the type annotations. Public API not really affected, but a bit of the internals have changed. FIX : Fix issue where compose , if backdrop list is empty, would not respect in_place option.","title":"0.5.0"},{"location":"about/changelog/#040","text":"NEW : Officially support Python 3.10. NEW : Slightly more accurate Oklab matrix calculation. NEW : Exported dictionary form can now be used as a normal color input in functions like contrast , interpolate , etc. NEW : Color objects will accept a dictionary mapping when alpha is not specified. When this occurs, alpha is assumed to be 1 . FIX : Fix an object compare issue.","title":"0.4.0"},{"location":"about/changelog/#030","text":"Breaking Changes XYZ changes below will cause breakage as xyz now refers to XYZ with D65 instead of D50. Also, CSS identifiers changed per the recent specification change. NEW : When calling dir() on Color() , ensure dynamic methods are in the list. NEW : xyz now refers to XYZ D65. CSS color () function now specifies D65 color as either color ( xyz x y z ) or color ( xyz-d65 x y z ) . XYZ D50 is now specified as color ( xyz-D50 x y z ) . NEW : Add CIELUV and CIELCH uv D65 variants.","title":"0.3.0"},{"location":"about/changelog/#020","text":"NEW : Provide dedicated clip method. clip is still a specifiable method under the fit function. It is also a reserved name under fit and cannot be overridden via plugins or be removed. NEW : Add more conversion shortcuts to OK family of color spaces. FIX : Fix an issue where the shorter conversion path wasn't always taken as convert couldn't find to/from methods if the color space name had - in it.","title":"0.2.0"},{"location":"about/changelog/#010","text":"First non-alpha prerelease. Notable changes from the last alpha listed below. Breaking Changes There are some breaking changes if coming from the previous alpha releases. All sRGB cylindrical spaces' non-hue data ranges are no longer scaled to 0 - 100, but use 0 - 1. Hue ranges have not changed. NEW : By accepting HSL, HSV, and HWB as non-hue channels as 0-100, we do lose a little precision, so for 1.0, we are switching to accepting and returning raw data values between 0 - 1. We've kept hue between 0 - 360 as it is easier for users to deal with hues between 0 - 360. Doing this will also match the new color spaces Okhsl and Okhsv that need to be kept at 0 - 1 to get better rounding. NEW : We do not currently restrict percentages anymore in color () functions. There is no hard rules that we need to at this time and no currently specified spaces that do this in the CSS specification. This is relaxed for now until some future time when it becomes clear we must. NEW : New okhsl and okhsv color space. NEW : All color channels now accept the none keyword to specify an undefined channel. They can also optionally output CSS strings with the keyword. NEW : Interpolation will return an undefined channel if both colors have that channel set to undefined. NEW : Provide a way to dump a color object to a simple dictionary and have the Color() object accept that dictionary to recreate the color object. NEW : Provide cat16 chromatic adaptation. NEW : Add normalize method to force channel normalization (evaluation of channels and setting undefined as appropriate). NEW : Interpolated and composited colors will normalize undefined channels when returning a color. NEW : Jzazbz now also has an alias for az and bz channels as a and b respectively. FIX : Fix an attribute \"get\" issue where attributes that were not present on the Color() object appeared to be present when using hasattr() . FIX : More accurate Oklab matrix.","title":"0.1.0"},{"location":"about/contributing/","text":"Contributing & Support There are many ways to help support this project, regardless of skills and abilities. If you enjoy this project and want to get involved, consider checking out one of the various ways below. Feel free to get creative, there may be other ways to contribute in which we have not thought of! Become a Sponsor Open source projects take time and money. Help support the project by becoming a sponsor. You can add your support at any tier you feel comfortable with. No amount is too little. We also accept one time contributions via PayPal. GitHub Sponsors PayPal Bug Reports Please read the documentation and search the issue tracker to try and find the answer to your question before posting an issue. When creating an issue on the repository, please provide as much info as possible: Version being used. Operating system. Version of Python. Errors in console. Detailed description of the problem. Examples for reproducing the error. You can post pictures, but if specific text or code is required to reproduce the issue, please provide the text in a plain text format for easy copy/paste. The more info provided, the greater the chance someone will take the time to answer, implement, or fix the issue. Be prepared to answer questions and provide additional information if required. Issues in which the creator refuses to respond to follow up questions will be marked as stale and closed. Reviewing Code Take part in reviewing pull requests and/or reviewing direct commits. Make suggestions to improve the code and discuss solutions to overcome weakness in the algorithm. Answer Questions in Issues Take time and answer questions and offer suggestions to people who've created issues in the issue tracker. Often people will have questions that you might have an answer for. Or maybe you know how to help them accomplish a specific task they are asking about. Feel free to share your experience to help others out. Pull Requests Pull requests are welcome, and a great way to help fix bugs and add new features. Documentation Improvements A ton of time has been spent not only creating and supporting this tool and related extensions, but also spent making this documentation. If you feel it is still lacking, show your appreciation for the tool and/or extensions by helping to improve the documentation.","title":"Contributing &amp; Support"},{"location":"about/contributing/#contributing--support","text":"There are many ways to help support this project, regardless of skills and abilities. If you enjoy this project and want to get involved, consider checking out one of the various ways below. Feel free to get creative, there may be other ways to contribute in which we have not thought of!","title":"Contributing &amp; Support"},{"location":"about/contributing/#become-a-sponsor","text":"Open source projects take time and money. Help support the project by becoming a sponsor. You can add your support at any tier you feel comfortable with. No amount is too little. We also accept one time contributions via PayPal. GitHub Sponsors PayPal","title":"Become a Sponsor "},{"location":"about/contributing/#bug-reports","text":"Please read the documentation and search the issue tracker to try and find the answer to your question before posting an issue. When creating an issue on the repository, please provide as much info as possible: Version being used. Operating system. Version of Python. Errors in console. Detailed description of the problem. Examples for reproducing the error. You can post pictures, but if specific text or code is required to reproduce the issue, please provide the text in a plain text format for easy copy/paste. The more info provided, the greater the chance someone will take the time to answer, implement, or fix the issue. Be prepared to answer questions and provide additional information if required. Issues in which the creator refuses to respond to follow up questions will be marked as stale and closed.","title":"Bug Reports"},{"location":"about/contributing/#reviewing-code","text":"Take part in reviewing pull requests and/or reviewing direct commits. Make suggestions to improve the code and discuss solutions to overcome weakness in the algorithm.","title":"Reviewing Code"},{"location":"about/contributing/#answer-questions-in-issues","text":"Take time and answer questions and offer suggestions to people who've created issues in the issue tracker. Often people will have questions that you might have an answer for. Or maybe you know how to help them accomplish a specific task they are asking about. Feel free to share your experience to help others out.","title":"Answer Questions in Issues"},{"location":"about/contributing/#pull-requests","text":"Pull requests are welcome, and a great way to help fix bugs and add new features.","title":"Pull Requests"},{"location":"about/contributing/#documentation-improvements","text":"A ton of time has been spent not only creating and supporting this tool and related extensions, but also spent making this documentation. If you feel it is still lacking, show your appreciation for the tool and/or extensions by helping to improve the documentation.","title":"Documentation Improvements"},{"location":"about/license/","text":"License MIT License Copyright \u00a9 2020 - 2022 Isaac Muse Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"about/license/#license","text":"MIT License Copyright \u00a9 2020 - 2022 Isaac Muse Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"api/","text":"Color API coloraide.NaN Description NaN is a convenience constant for float('nan') . Import path NaN is imported from the coloraide library: from coloraide import NaN coloraide.Piecewise class Piecewise ( namedtuple ( 'Piecewise' , [ 'color' , 'stop' , 'progress' , 'hue' , 'premultiplied' ] ) ): Description Piecewise objects are used in interpolate methods. They allow a user to control interpolation stops , progress , hue , or premultiplied options for a specific interpolation piece when doing piecewise interpolation. Import Path Piecewise is imported from coloraide library: from coloraide import Piecewise Parameters Input parameters match interpolate parameters of the same name. Only color is required and all other parameters default to None . If a parameter is None , it will be ignored by interpolate . coloraide.Color class Color : def __init__ ( self , color , data = None , alpha = util . DEF_ALPHA , * , filters = None , ** kwargs ): Description The Color class object is a wrapper around the internal color space objects. It provides an API interface to allow users to specify and manipulate colors. Import path Color is imported from the coloraide library: from coloraide import Color Parameters Parameters Defaults Description color A color string, a dictionary describing the color, or another Color class object. If given data , a string must be used and should represent the color space to use. data None data accepts a list of numbers representing the coordinates of the color. If provided, color must be a string specifying the color space. alpha 1 alpha accepts a number specifying the alpha channel. Must be used in conjunction with data or it will be ignored. filters None filters accepts a list of color spaces to allow. When None is provided (the default) all supported color spaces are accepted. Color.register @classmethod def register ( cls , plugin , overwrite = False ): Description Register a plugin(s). Parameters Parameters Defaults Description plugin A plugin object or list of plugin objects to register. overwrite False overwrite will avoid allow an already registered plugin to be overwritten if the plugin to register specifies a name that is already used for registration. Color.deregister @classmethod def deregister ( cls , plugin , silent = False ): Description Remove an already registered plugin(s). Parameters Parameters Defaults Description plugin A string or list of strings that describe the plugin to be removed. Strings should be in the format category:name where category is either space , delta-e , or fit and name is the name the plugin was registered under. * will remove all plugins and category:* will remove all within a specific category. silent False silent will avoid throwing an error if the name can not be found in the specified category. Color.match @classmethod def match ( cls , string , start = 0 , fullmatch = False , * , filters = None ): Description The match class method provides access to the color matching interface and allows a user to provide a color string and get back a ColorMatch object. ColorMatch objects contain three properties: class ColorMatch : def __init__ ( self , color , start , end ): color : the Color object. start : the starting point within the string buffer where the color was found. end : the ending point within the string buffer where the color was found. Match does not search the entire buffer, but simply matches at the location specified by start . Parameters Parameters Defaults Description string A string representing the color. start 0 Accepts an integer offset into the provided string buffer to start the match. fullmatch False A boolean which defines whether match must match to the end of the string buffer. filters None filters accepts a list of color spaces to allow. When None is provided (the default) all supported color spaces are accepted. Return Returns a ColorMatch object. Color.new def new ( self , color , data = None , alpha = util . DEF_ALPHA , * , filters = None , ** kwargs ): Description The new class method exposes the interface of creating new color objects. Using new is the same as using Color() . Parameters Parameters Defaults Description color A color string, or other Color class object. If given data , a string must be used and should represent the color space to use. data None data accepts a list of numbers representing the coordinates of the color. If provided, color must be a string specifying the color space. alpha 1 alpha accepts a number specifying the alpha channel. Must be used in conjunction with data or it will be ignored. filters None filters accepts a list of color spaces to allow. When None is provided (the default) all supported color spaces are accepted. Return Returns a Color object. Color.clone def clone ( self ): Description The clone method provides a way to create a duplicate of the current Color instance. Return Returns a Color object. Color.update def update ( self , color , data = None , alpha = util . DEF_ALPHA , * , filters = None , ** kwargs ): Description The update method provides a way to update the underlying color spaces with coordinates from any color space. The methods signature looks just like new and accepts color strings, Color objects, or raw data points specified with a color space string and coordinates. The object itself will be updated and remain in its current color space. Parameters Parameters Defaults Description color A color string, or other Color class object. If given data , a string must be used and should represent the color space to use. data None data accepts a list of numbers representing the coordinates of the color. If provided, color must be a string specifying the color space. alpha 1 alpha accepts a number specifying the alpha channel. Must be used in conjunction with data or it will be ignored. filters None filters accepts a list of color spaces to allow. When None is provided (the default) all supported color spaces are accepted. Return Returns a reference to the current Color object. Color.mutate def mutate ( self , color , data = None , alpha = util . DEF_ALPHA , * , filters = None , ** kwargs ): Description The mutate method is just like update except that it will not only update the color space, but mutate it to the provided color space. Parameters Parameters Defaults Description color A color string, or other Color class object. If given data , a string must be used and should represent the color space to use. data None data accepts a list of numbers representing the coordinates of the color. If provided, color must be a string specifying the color space. alpha 1 alpha accepts a number specifying the alpha channel. Must be used in conjunction with data or it will be ignored. filters None filters accepts a list of color spaces to allow. When None is provided (the default) all supported color spaces are accepted. Return Returns a reference to the current Color object. Color.convert def convert ( self , space , * , fit = False , in_place = False ): Description Converts a Color object from one color space to another. If the current color space matches the specified color space, the object will be cloned. Parameters Parameters Defaults Description space A string representing the desired final color space. fit False Parameter specifying whether the current color should be gamut mapped into the final, desired color space. If set to True , the color will be gamut mapped using the default gamut mapping method. If set to a string, the string will be interpreted as the name of the gamut mapping method to be used. in_place False Boolean specifying whether the convert should alter the current Color object or return a new one. Return Returns a reference to the converted Color object. If in_place is True , the return will be a reference to the current Color object. Color.space def space ( self ): Description Retrieves the current color space of the color. Return Returns a string with the name of the current color space. Color.coords def coords ( self ): Description Returns a list of the color's coordinates. This does not include the alpha channel. Alpha can be accessed via the alpha property or get and set accessors. Return Returns a list of numbers indicating the current coordinate values. Color.normalize def to_dict ( self ): Description Force normalization of a color's channels by cleaning up channels that shouldn't be undefined and setting any channels to undefined if they meet the specific color's criteria dictating such, e.g., hue is undefined in HSL when saturation is zero. Normalize modifies the current color in place. Return Returns a reference to the current Color object after normalizing the channels for undefined hues. Color.to_dict def to_dict ( self , ** kwargs ): Description Dump the color object to a simple dictionary. Return A dictionary containing the color space name, the channel name with their respective values. Color.to_string def to_string ( self , ** kwargs ): Description Method that converts the current color to an output format supported by the color space. While a number of the parameters are common, some may be specific to the color space. The usage guide covers color space specific options in more details. Parameters Common parameters: Parameters Defaults Description alpha None Boolean or None value which determines whether the output includes alpha . If None (the default) alpha will only be shown if less than 1. If True , alpha will always be shown. If False , alpha will be omitted. precision 5 Integer value that sets precision and scale. Precision and scale will match the value if greater than zero. If 0 , values will be rounded to the nearest integer. If -1 , number will be output at the highest precision. fit True A boolean that controls whether gamut mapping is performed on string creation. By default, colors will be fit to their own color space. This can be disabled by setting to False . color False A boolean that will determine if the color(space coord+ / alpha) format is used for string output. Has highest precedence. sRGB specific parameters: Parameters Defaults Description hex . False String output will be in #RRGGBBAA format. names False Boolean indicating a preference for CSS color names. When translating a color to it's closest hex form, if that hex value matches a CSS color name, that color name will be returned as the output. hex does not have to be True for this to apply. compress False If hex is True and compress is True , hex values will be compressed if possible: #RRGGBBAA \u2192 #RGBA . Space dependent parameters: Parameters Defaults Description comma False If supported by the color space and the current output format, commas will be used instead of space format: rgba(0, 0, 0, 1) \u2192 rgb(0 0 0 /1) . Return Returns a string representation of the current color. Color.luminance def luminance ( self ): Description Get the relative luminance. Relative luminance is obtained from the Y coordinate in the XYZ color space. XYZ, in this case, has a D65 white point. Return Returns an float indicating the relative luminance. Color.contrast def contrast ( self , color ): Description Get the contrast ratio based on the relative luminance between two colors. Parameters Parameters Defaults Description color A color string or Color object representing a color. Return Returns a float indicating the contrast ratio between two colors. Color.distance def distance ( self , color , * , space = util . DEF_DISTANCE_SPACE ): Description Performs a euclidean distance algorithm on two colors. Parameters Parameters Defaults Description color A color string or Color object representing a color. space \"lab\" Color space to perform distancing algorithm in. Return Returns a float indicating euclidean distance between the two colors. Color.delta_e def delta_e ( self , color , * , method = None , ** kwargs ): Description Performs a delta E distance algorithm on two colors. Default algorithm that is used is Delta E 1976 ( 76 ). Some methods have additional weighting that can be configured through method specific options which are represented by **kwargs . Available methods: Name Input Parameters \u2206E * ab (CIE76) 76 \u2206E * cmc (CMC l:c (1984)) cmc l=2, c=1 \u2206E * 94 (CIE94) 94 kl=1, k1=0.045, k2=0.015 \u2206E * 00 (CIEDE2000) 2000 kl=1, kc=1, kh=1 \u2206E itp (ICtCp) itp scalar=720 \u2206E z (Jzazbz) jz \u2206E 99o (DIN99o) 99o \u2206E HyAB (HyAB) hyab space=\"lab\" \u2206E ok ok scalar=1 Parameters Parameters Defaults Description color A color string or Color object representing a color. method None String that specifies the method to use. If None , the default will be used. **kwargs Any distancing specific parameters to pass to \u2206E method. Return Returns a float indicating the delta E distance between the two colors. color.closest def closest ( self , colors , * , method = None , ** kwargs ): Description Given a list of colors, calculates the closest color to the calling color object. Parameters Parameters Defaults Description colors A list of color strings, Color object, or dictionary representing a color. method None String that specifies the method of color distancing to use. **kwargs Any distancing specific parameters to pass to \u2206E method. Return The Color that is closest to the calling color object. In the off chance that an empty list is passed in None will be returned. color.mask def mask self , channels , invert = False , in_place = False ): Description The mask method will set any and all specified channels to NaN . If invert is set to True , mask will set any and all channels not specified to NaN . Parameters Parameters Defaults Description channel A string specifying a channel, or a list of strings specifying multiple channels. Specified channels will be masked (or the only channels not masked if invert is True ). invert False Use inverse masking logic and mask all channels that are not specified. in_place False Boolean used to determine if the current color should be modified \"in place\" or a new Color object should be returned. Return Returns a reference to the masked Color object. If in_place is True , the return will be a reference to the current Color object. Color.interpolate def interpolate ( self , color , * , stop = 0 , space = \"lab\" , progress = None , out_space = None , hue = util . DEF_HUE_ADJ , premultiplied = False ): Description The interpolate method creates a function that takes a value between 0 - 1 and interpolates a new color based on the input value. If more than one color is provided, the returned function will span the interpolations between all the provided colors with the same range of 0 - 1. Interpolation can be customized by limiting the interpolation to specific color channels, providing custom interpolation functions, and even adjusting the hue logic used. Piecewise objects can be used to specify stops or adjust the interpolation for itself and the preceding color. Hue Evaluation Description shorter Angles are adjusted so that \u03b8\u2082 - \u03b8\u2081 \u2208 [-180, 180]. longer Angles are adjusted so that \u03b8\u2082 - \u03b8\u2081 \u2208 {0, [180, 360)}. increasing Angles are adjusted so that \u03b8\u2082 - \u03b8\u2081 \u2208 [0, 360). decreasing Angles are adjusted so that \u03b8\u2082 - \u03b8\u2081 \u2208 (-360, 0] specified No fixup is performed. Angles are interpolated in the same way as every other component. Parameters Parameters Defaults Description color A color string, Color object, or Piecewise object representing a color. Also, multiple can be provided via a list. space \"lab\" Color space to interpolate in. progress None An optional function that that allows for custom logic to perform non-linear interpolation. out_space None Color space that the new color should be in. If None , the color will be in the same color space as the base color. hue \"shorter\" Define how color spaces which have hue angles are interpolated. Default evaluates between the shortest angle. premultiplied False Use premultiplied alpha when interpolating. Return Returns a function that takes a range from [0..1] . The function returns a reference to the interpolated Color object. Color.steps def steps ( self , color , * , steps = 2 , max_steps = 1000 , max_delta_e = 0 , delta_e = None , ** interpolate_args ): Description Creates an interpolate function and iterates through it with user defined step parameters to produce discrete color steps. Will attempt to provide the minimum number of steps without exceeding max_steps . If max_delta_e is provided, the distance between each stop will be cut in half until there are no colors with a distance greater than the specified max_delta_e . The default \u2206E method is used by default, but it can be changed with the delta_e parameter. If more than one color is provided, the steps will be returned from the interpolations between all the provided colors. Like interpolate , the default interpolation space is lab . Parameters Parameters Defaults Description color A color string or Color object representing a color. Also, multiple can be provided via a list. steps 2 Minimum number of steps. max_steps 1000 Maximum number of steps. max_delta_e 0 Maximum delta E distance between the color stops. A value of 0 or less will be ignored. delta_e None A string indicating which \u2206E method to use. If nothing is supplied, the class object's current default \u2206E method will be used. ** interpolate_args See interpolate Keyword arguments defined in interpolate . Return List of Color objects. Color.mix def mix ( self , color , percent = util . DEF_MIX , * , in_place = False , ** interpolate_args ): Description Interpolates between two colors returning a color that represents the mixing of the base color and the provided color mixed at the provided percent , where percent applies to how much the provided color contributes to the the final result. Parameters Parameters Defaults Description color A color string or Color object representing a color. percent 0.5 A numerical value between 0 - 1 representing the percentage at which the parameter color will be mixed. in_place False Boolean used to determine if the the current color should be modified \"in place\" or a new Color object should be returned. ** interpolate_args See interpolate Keyword arguments defined in interpolate . Return Returns a reference to the new Color object or a reference to the current Color if in_place is True . Color.average def average ( self , color , weights = None , * , space = 'lab' , out_space = None , in_place = False , hue = util . DEF_HUE_ADJ , sort_hue = False ): Description Allows the averaging of one or more colors essentially allowing a mixing of any number of colors. Each color is mixed in such a way so that each color has an equal weight. If, and only if, a color set has a color with transparency, the transparency will be averaged separately. The specified color(s) to average with the base color can be a single color, or a list of colors as specified in the parameters below. Like interpolate , the default interpolation space is lab . Parameters Parameters Defaults Description color A color string or Color object representing a color. Also, multiple can be provided via a list. weights [ 1 ] * n An array of length n (where n is number of colors that are to be averaged) that specifies the weight of the given colors. Order of the weights should match the order of the inputs where the base color is index 0. space \"lab\" Color space to interpolate in. out_space None Color space that the new color should be in. If None , the color will be in the same color space as the base color. hue \"shorter\" Define how color spaces which have hue angles are interpolated. Default evaluates between the shortest angle. in_place False Boolean used to determine if the the current color should be modified \"in place\" or a new Color object should be returned. sort_hue #py3 False Specifies whether cylindrical spaces should sort colors by hue before averaging to ensure a consistence, predictable averaging regardless of what order the colors are provided. Return Returns a reference to the new Color object or a reference to the current Color if in_place is True . Color.compose def compose ( self , backdrop , * , blend = None , operator = None , space = None , out_space = None , in_place = False ): Description Apply compositing which consists of a blend mode and a Porter Duff operator for alpha compositing. The current color is treated as the source (top layer) and the provided color as the backdrop (bottom layer). Colors will be composited in the srgb color space unless otherwise specified. Colors should generally be RGB-ish colors (sRGB, Display P3, A98 RGB, etc.). Some non-RGB-ish colors may work okay, with the defaults, but many the algorithm is really designed for RGB-ish colors. Non-RGB-ish colors are likely to provide nonsense results. Supported blend modes are: Blend Modes normal multiply darken lighten burn dodge screen overlay hard-light exclusion difference soft-light hue saturation luminosity color color hue saturation luminosity Supported Port Duff operators are: Operators clear copy destination source-over destination-over source-in destination-in source-out destination-out source-atop destination-atop xor lighter Parameters Parameters Defaults Description backdrop A background color represented with either a string or Color object. blend None A blend mode to use to use when compositing. Values should be a string specifying the name of the blend mode to use. If None , normal will be used. If False , blending will be skipped. operator None A Porter Duff operator to use for alpha compositing. Values should be a string specifying the name of the operator to use. If None , source-over will be used. If False , alpha compositing will be skipped. space None A color space to perform the overlay in. If None , the base color's space will be used. out_space None A color space to output the resultant color to. in_place False Boolean used to determine if the the current color should be modified \"in place\" or a new Color object should be returned. Return Returns a reference to the new Color object or a reference to the current Color if in_place is True . Color.clip def clip ( self , space = None , * , in_place = False ) Description Performs simple clipping on color channels that are out of gamut. Parameters Parameters Defaults Description space None The color space that the color must be mapped to. If space is None , then the current color space will be used. in_place False Boolean used to determine if the the current color should be modified \"in place\" or a new Color object should be returned. Return Returns a reference to the new Color object or a reference to the current Color if in_place is True . Color.fit def fit ( self , space = None , * , method = None , in_place = False , ** kwargs ): Description Fits color to the current or specified color gamut. By default, oklch-chroma gamut mapping is used. This is essentially an approach that holds lightness and hue constant in the Oklch color space while reducing chroma until the color is in gamut. Clipping is done at each step of the way and the color distance measured to see how close our color is to the intended color. The supported gamut mapping methods are: Name Input Clipping clip Oklch Chroma oklch-chroma LCH Chroma lch-chroma Parameters Some methods could have additional parameters to configure the behavior, these would be done through **kwargs . None of built-in gamut mapping methods currently have additional parameters. Parameters Defaults Description space None The color space that the color must be mapped to. If space is None , then the current color space will be used. method None String that specifies which gamut mapping method to use. If None , oklch-chroma will be used. in_place False Boolean used to determine if the the current color should be modified \"in place\" or a new Color object should be returned. Return Returns a reference to the new Color object or a reference to the current Color if in_place is True . Color.in_gamut def in_gamut ( self , space = None , * , tolerance = util . DEF_FIT_TOLERANCE ): Description Checks if the current color is in the current or specified gamut. Parameters Parameters Defaults Description space None The color space that the color must be fit within. If space is None , then the current color space will be used. tolerance 0.000075 Tolerance allowed when checking bounds of color. Return Returns a boolean indicating whether the color is in the specified gamut. Color.get def get ( self , name ): Description Retrieves the coordinate value from the specified channel. Channel must be a channel name in the current color space or a channel name in the specified color space using the syntax: space.channel . Parameters Parameters Defaults Description name Channel name or color space and channel name to retrieve value from. Return Returns a numerical value that is stored internally for the specified channel, or a calculated value in the case that a channel in a different color space is requested. Color.set def set ( self , name , value ): Description Sets the given value to the specified channel. If the name is provided in the form space.channel , the value will be applied to the channel of the specified color space while keeping current color space the same. The value can be a numerical value, a CSS string compatible with the specified color space, or a function that accepts a numerical channel value and returns a numerical channel value. This function returns the current colors reference so that multiple sets can be chained together. Parameters Parameters Defaults Description name Channel name or color space and channel name to retrieve value from. value A numerical value, a string value accepted by the specified color space, or a function. Return Returns a reference to the current Color object. Color.is_nan def is_nan ( self , name ): Description Retrieves the coordinate value from the specified channel and checks whether the value is NaN . Channel must be a channel name in the current color space or a channel name in the specified color space using the syntax: space.channel . Parameters Parameters Defaults Description name A string indicating what channel property to check. Return Returns a boolean indicating whether the specified color space's channel is NaN . Color.white def white ( self ): Description Retrieves the white point for the current color's color space. Return Returns a set of XYZ coordinates that align with the white point for the given color space. Color.xy def xy ( self ): Description Retrieves the CIE 1931 (x, y) chromaticity coordinates for a given color. Return Returns a tuple of CIE 1931 (x, y) chromaticity points for the given color. Color.uv def uv ( self , mode = '1976' ): Description Retrieves the UCS 1960 (u, v) chromaticity coordinates for a given color or the CIE 1976 UCS (u', v') chromaticity coordinates, the latter being the default. Parameters Parameters Defaults Description mode '1976' A string indicating what mode to use. 1976 refers to the (u', v') points as described by CIE 1976 UCS and 1960 describes the (u, v) points as documented by CIE 1960 UCS . Return Returns a tuple of (u, v) \u2013 either 1976 (u', v') or 1960 (u, v) \u2013 chromaticity points for the given color. Color Channel Properties Depending on the given color space, channel properties will be available on the color object as well. These are dynamically available depending on what the current color space is. For instance, if the color space is sRGB, the channels red , green , blue , and alpha will all be available. Color channel names are defined in Supported Colors . These properties are read and writable. When read, they will return the numerical value stored in the specified channel. When written, they can accept a numerical value or a string value using CSS syntax acceptable for that channel in that color space. For more complex setting operations, or to chain multiple set operations, please use set and get . Color Dynamic Methods Depending on what \u2206E methods are available, you can access the method, not only as Color.delta_e(value, method=\"name\") , you can can also access them directly via Color.delta_e_name(value) : >>> Color ( 'red' ) . delta_e ( 'green' , method = \"2000\" ) 70.23670072102784 >>> Color ( 'red' ) . delta_e_2000 ( 'green' ) 70.23670072102784 Color('red').delta_e('green', method=\"2000\") Color('red').delta_e_2000('green') Edit Share Run Cancel","title":"Color API"},{"location":"api/#color-api","text":"","title":"Color API"},{"location":"api/#nan","text":"Description NaN is a convenience constant for float('nan') . Import path NaN is imported from the coloraide library: from coloraide import NaN","title":"coloraide.NaN"},{"location":"api/#piecewise","text":"class Piecewise ( namedtuple ( 'Piecewise' , [ 'color' , 'stop' , 'progress' , 'hue' , 'premultiplied' ] ) ): Description Piecewise objects are used in interpolate methods. They allow a user to control interpolation stops , progress , hue , or premultiplied options for a specific interpolation piece when doing piecewise interpolation. Import Path Piecewise is imported from coloraide library: from coloraide import Piecewise Parameters Input parameters match interpolate parameters of the same name. Only color is required and all other parameters default to None . If a parameter is None , it will be ignored by interpolate .","title":"coloraide.Piecewise"},{"location":"api/#color","text":"class Color : def __init__ ( self , color , data = None , alpha = util . DEF_ALPHA , * , filters = None , ** kwargs ): Description The Color class object is a wrapper around the internal color space objects. It provides an API interface to allow users to specify and manipulate colors. Import path Color is imported from the coloraide library: from coloraide import Color Parameters Parameters Defaults Description color A color string, a dictionary describing the color, or another Color class object. If given data , a string must be used and should represent the color space to use. data None data accepts a list of numbers representing the coordinates of the color. If provided, color must be a string specifying the color space. alpha 1 alpha accepts a number specifying the alpha channel. Must be used in conjunction with data or it will be ignored. filters None filters accepts a list of color spaces to allow. When None is provided (the default) all supported color spaces are accepted.","title":"coloraide.Color"},{"location":"api/#register","text":"@classmethod def register ( cls , plugin , overwrite = False ): Description Register a plugin(s). Parameters Parameters Defaults Description plugin A plugin object or list of plugin objects to register. overwrite False overwrite will avoid allow an already registered plugin to be overwritten if the plugin to register specifies a name that is already used for registration.","title":"Color.register"},{"location":"api/#deregister","text":"@classmethod def deregister ( cls , plugin , silent = False ): Description Remove an already registered plugin(s). Parameters Parameters Defaults Description plugin A string or list of strings that describe the plugin to be removed. Strings should be in the format category:name where category is either space , delta-e , or fit and name is the name the plugin was registered under. * will remove all plugins and category:* will remove all within a specific category. silent False silent will avoid throwing an error if the name can not be found in the specified category.","title":"Color.deregister"},{"location":"api/#match","text":"@classmethod def match ( cls , string , start = 0 , fullmatch = False , * , filters = None ): Description The match class method provides access to the color matching interface and allows a user to provide a color string and get back a ColorMatch object. ColorMatch objects contain three properties: class ColorMatch : def __init__ ( self , color , start , end ): color : the Color object. start : the starting point within the string buffer where the color was found. end : the ending point within the string buffer where the color was found. Match does not search the entire buffer, but simply matches at the location specified by start . Parameters Parameters Defaults Description string A string representing the color. start 0 Accepts an integer offset into the provided string buffer to start the match. fullmatch False A boolean which defines whether match must match to the end of the string buffer. filters None filters accepts a list of color spaces to allow. When None is provided (the default) all supported color spaces are accepted. Return Returns a ColorMatch object.","title":"Color.match"},{"location":"api/#new","text":"def new ( self , color , data = None , alpha = util . DEF_ALPHA , * , filters = None , ** kwargs ): Description The new class method exposes the interface of creating new color objects. Using new is the same as using Color() . Parameters Parameters Defaults Description color A color string, or other Color class object. If given data , a string must be used and should represent the color space to use. data None data accepts a list of numbers representing the coordinates of the color. If provided, color must be a string specifying the color space. alpha 1 alpha accepts a number specifying the alpha channel. Must be used in conjunction with data or it will be ignored. filters None filters accepts a list of color spaces to allow. When None is provided (the default) all supported color spaces are accepted. Return Returns a Color object.","title":"Color.new"},{"location":"api/#clone","text":"def clone ( self ): Description The clone method provides a way to create a duplicate of the current Color instance. Return Returns a Color object.","title":"Color.clone"},{"location":"api/#update","text":"def update ( self , color , data = None , alpha = util . DEF_ALPHA , * , filters = None , ** kwargs ): Description The update method provides a way to update the underlying color spaces with coordinates from any color space. The methods signature looks just like new and accepts color strings, Color objects, or raw data points specified with a color space string and coordinates. The object itself will be updated and remain in its current color space. Parameters Parameters Defaults Description color A color string, or other Color class object. If given data , a string must be used and should represent the color space to use. data None data accepts a list of numbers representing the coordinates of the color. If provided, color must be a string specifying the color space. alpha 1 alpha accepts a number specifying the alpha channel. Must be used in conjunction with data or it will be ignored. filters None filters accepts a list of color spaces to allow. When None is provided (the default) all supported color spaces are accepted. Return Returns a reference to the current Color object.","title":"Color.update"},{"location":"api/#mutate","text":"def mutate ( self , color , data = None , alpha = util . DEF_ALPHA , * , filters = None , ** kwargs ): Description The mutate method is just like update except that it will not only update the color space, but mutate it to the provided color space. Parameters Parameters Defaults Description color A color string, or other Color class object. If given data , a string must be used and should represent the color space to use. data None data accepts a list of numbers representing the coordinates of the color. If provided, color must be a string specifying the color space. alpha 1 alpha accepts a number specifying the alpha channel. Must be used in conjunction with data or it will be ignored. filters None filters accepts a list of color spaces to allow. When None is provided (the default) all supported color spaces are accepted. Return Returns a reference to the current Color object.","title":"Color.mutate"},{"location":"api/#convert","text":"def convert ( self , space , * , fit = False , in_place = False ): Description Converts a Color object from one color space to another. If the current color space matches the specified color space, the object will be cloned. Parameters Parameters Defaults Description space A string representing the desired final color space. fit False Parameter specifying whether the current color should be gamut mapped into the final, desired color space. If set to True , the color will be gamut mapped using the default gamut mapping method. If set to a string, the string will be interpreted as the name of the gamut mapping method to be used. in_place False Boolean specifying whether the convert should alter the current Color object or return a new one. Return Returns a reference to the converted Color object. If in_place is True , the return will be a reference to the current Color object.","title":"Color.convert"},{"location":"api/#space","text":"def space ( self ): Description Retrieves the current color space of the color. Return Returns a string with the name of the current color space.","title":"Color.space"},{"location":"api/#coords","text":"def coords ( self ): Description Returns a list of the color's coordinates. This does not include the alpha channel. Alpha can be accessed via the alpha property or get and set accessors. Return Returns a list of numbers indicating the current coordinate values.","title":"Color.coords"},{"location":"api/#normalize","text":"def to_dict ( self ): Description Force normalization of a color's channels by cleaning up channels that shouldn't be undefined and setting any channels to undefined if they meet the specific color's criteria dictating such, e.g., hue is undefined in HSL when saturation is zero. Normalize modifies the current color in place. Return Returns a reference to the current Color object after normalizing the channels for undefined hues.","title":"Color.normalize"},{"location":"api/#to_dict","text":"def to_dict ( self , ** kwargs ): Description Dump the color object to a simple dictionary. Return A dictionary containing the color space name, the channel name with their respective values.","title":"Color.to_dict"},{"location":"api/#to_string","text":"def to_string ( self , ** kwargs ): Description Method that converts the current color to an output format supported by the color space. While a number of the parameters are common, some may be specific to the color space. The usage guide covers color space specific options in more details. Parameters Common parameters: Parameters Defaults Description alpha None Boolean or None value which determines whether the output includes alpha . If None (the default) alpha will only be shown if less than 1. If True , alpha will always be shown. If False , alpha will be omitted. precision 5 Integer value that sets precision and scale. Precision and scale will match the value if greater than zero. If 0 , values will be rounded to the nearest integer. If -1 , number will be output at the highest precision. fit True A boolean that controls whether gamut mapping is performed on string creation. By default, colors will be fit to their own color space. This can be disabled by setting to False . color False A boolean that will determine if the color(space coord+ / alpha) format is used for string output. Has highest precedence. sRGB specific parameters: Parameters Defaults Description hex . False String output will be in #RRGGBBAA format. names False Boolean indicating a preference for CSS color names. When translating a color to it's closest hex form, if that hex value matches a CSS color name, that color name will be returned as the output. hex does not have to be True for this to apply. compress False If hex is True and compress is True , hex values will be compressed if possible: #RRGGBBAA \u2192 #RGBA . Space dependent parameters: Parameters Defaults Description comma False If supported by the color space and the current output format, commas will be used instead of space format: rgba(0, 0, 0, 1) \u2192 rgb(0 0 0 /1) . Return Returns a string representation of the current color.","title":"Color.to_string"},{"location":"api/#luminance","text":"def luminance ( self ): Description Get the relative luminance. Relative luminance is obtained from the Y coordinate in the XYZ color space. XYZ, in this case, has a D65 white point. Return Returns an float indicating the relative luminance.","title":"Color.luminance"},{"location":"api/#colorcontrast","text":"def contrast ( self , color ): Description Get the contrast ratio based on the relative luminance between two colors. Parameters Parameters Defaults Description color A color string or Color object representing a color. Return Returns a float indicating the contrast ratio between two colors.","title":"Color.contrast"},{"location":"api/#distance","text":"def distance ( self , color , * , space = util . DEF_DISTANCE_SPACE ): Description Performs a euclidean distance algorithm on two colors. Parameters Parameters Defaults Description color A color string or Color object representing a color. space \"lab\" Color space to perform distancing algorithm in. Return Returns a float indicating euclidean distance between the two colors.","title":"Color.distance"},{"location":"api/#delta_e","text":"def delta_e ( self , color , * , method = None , ** kwargs ): Description Performs a delta E distance algorithm on two colors. Default algorithm that is used is Delta E 1976 ( 76 ). Some methods have additional weighting that can be configured through method specific options which are represented by **kwargs . Available methods: Name Input Parameters \u2206E * ab (CIE76) 76 \u2206E * cmc (CMC l:c (1984)) cmc l=2, c=1 \u2206E * 94 (CIE94) 94 kl=1, k1=0.045, k2=0.015 \u2206E * 00 (CIEDE2000) 2000 kl=1, kc=1, kh=1 \u2206E itp (ICtCp) itp scalar=720 \u2206E z (Jzazbz) jz \u2206E 99o (DIN99o) 99o \u2206E HyAB (HyAB) hyab space=\"lab\" \u2206E ok ok scalar=1 Parameters Parameters Defaults Description color A color string or Color object representing a color. method None String that specifies the method to use. If None , the default will be used. **kwargs Any distancing specific parameters to pass to \u2206E method. Return Returns a float indicating the delta E distance between the two colors.","title":"Color.delta_e"},{"location":"api/#closest","text":"def closest ( self , colors , * , method = None , ** kwargs ): Description Given a list of colors, calculates the closest color to the calling color object. Parameters Parameters Defaults Description colors A list of color strings, Color object, or dictionary representing a color. method None String that specifies the method of color distancing to use. **kwargs Any distancing specific parameters to pass to \u2206E method. Return The Color that is closest to the calling color object. In the off chance that an empty list is passed in None will be returned.","title":"color.closest"},{"location":"api/#mask","text":"def mask self , channels , invert = False , in_place = False ): Description The mask method will set any and all specified channels to NaN . If invert is set to True , mask will set any and all channels not specified to NaN . Parameters Parameters Defaults Description channel A string specifying a channel, or a list of strings specifying multiple channels. Specified channels will be masked (or the only channels not masked if invert is True ). invert False Use inverse masking logic and mask all channels that are not specified. in_place False Boolean used to determine if the current color should be modified \"in place\" or a new Color object should be returned. Return Returns a reference to the masked Color object. If in_place is True , the return will be a reference to the current Color object.","title":"color.mask"},{"location":"api/#interpolate","text":"def interpolate ( self , color , * , stop = 0 , space = \"lab\" , progress = None , out_space = None , hue = util . DEF_HUE_ADJ , premultiplied = False ): Description The interpolate method creates a function that takes a value between 0 - 1 and interpolates a new color based on the input value. If more than one color is provided, the returned function will span the interpolations between all the provided colors with the same range of 0 - 1. Interpolation can be customized by limiting the interpolation to specific color channels, providing custom interpolation functions, and even adjusting the hue logic used. Piecewise objects can be used to specify stops or adjust the interpolation for itself and the preceding color. Hue Evaluation Description shorter Angles are adjusted so that \u03b8\u2082 - \u03b8\u2081 \u2208 [-180, 180]. longer Angles are adjusted so that \u03b8\u2082 - \u03b8\u2081 \u2208 {0, [180, 360)}. increasing Angles are adjusted so that \u03b8\u2082 - \u03b8\u2081 \u2208 [0, 360). decreasing Angles are adjusted so that \u03b8\u2082 - \u03b8\u2081 \u2208 (-360, 0] specified No fixup is performed. Angles are interpolated in the same way as every other component. Parameters Parameters Defaults Description color A color string, Color object, or Piecewise object representing a color. Also, multiple can be provided via a list. space \"lab\" Color space to interpolate in. progress None An optional function that that allows for custom logic to perform non-linear interpolation. out_space None Color space that the new color should be in. If None , the color will be in the same color space as the base color. hue \"shorter\" Define how color spaces which have hue angles are interpolated. Default evaluates between the shortest angle. premultiplied False Use premultiplied alpha when interpolating. Return Returns a function that takes a range from [0..1] . The function returns a reference to the interpolated Color object.","title":"Color.interpolate"},{"location":"api/#steps","text":"def steps ( self , color , * , steps = 2 , max_steps = 1000 , max_delta_e = 0 , delta_e = None , ** interpolate_args ): Description Creates an interpolate function and iterates through it with user defined step parameters to produce discrete color steps. Will attempt to provide the minimum number of steps without exceeding max_steps . If max_delta_e is provided, the distance between each stop will be cut in half until there are no colors with a distance greater than the specified max_delta_e . The default \u2206E method is used by default, but it can be changed with the delta_e parameter. If more than one color is provided, the steps will be returned from the interpolations between all the provided colors. Like interpolate , the default interpolation space is lab . Parameters Parameters Defaults Description color A color string or Color object representing a color. Also, multiple can be provided via a list. steps 2 Minimum number of steps. max_steps 1000 Maximum number of steps. max_delta_e 0 Maximum delta E distance between the color stops. A value of 0 or less will be ignored. delta_e None A string indicating which \u2206E method to use. If nothing is supplied, the class object's current default \u2206E method will be used. ** interpolate_args See interpolate Keyword arguments defined in interpolate . Return List of Color objects.","title":"Color.steps"},{"location":"api/#mix","text":"def mix ( self , color , percent = util . DEF_MIX , * , in_place = False , ** interpolate_args ): Description Interpolates between two colors returning a color that represents the mixing of the base color and the provided color mixed at the provided percent , where percent applies to how much the provided color contributes to the the final result. Parameters Parameters Defaults Description color A color string or Color object representing a color. percent 0.5 A numerical value between 0 - 1 representing the percentage at which the parameter color will be mixed. in_place False Boolean used to determine if the the current color should be modified \"in place\" or a new Color object should be returned. ** interpolate_args See interpolate Keyword arguments defined in interpolate . Return Returns a reference to the new Color object or a reference to the current Color if in_place is True .","title":"Color.mix"},{"location":"api/#average","text":"def average ( self , color , weights = None , * , space = 'lab' , out_space = None , in_place = False , hue = util . DEF_HUE_ADJ , sort_hue = False ): Description Allows the averaging of one or more colors essentially allowing a mixing of any number of colors. Each color is mixed in such a way so that each color has an equal weight. If, and only if, a color set has a color with transparency, the transparency will be averaged separately. The specified color(s) to average with the base color can be a single color, or a list of colors as specified in the parameters below. Like interpolate , the default interpolation space is lab . Parameters Parameters Defaults Description color A color string or Color object representing a color. Also, multiple can be provided via a list. weights [ 1 ] * n An array of length n (where n is number of colors that are to be averaged) that specifies the weight of the given colors. Order of the weights should match the order of the inputs where the base color is index 0. space \"lab\" Color space to interpolate in. out_space None Color space that the new color should be in. If None , the color will be in the same color space as the base color. hue \"shorter\" Define how color spaces which have hue angles are interpolated. Default evaluates between the shortest angle. in_place False Boolean used to determine if the the current color should be modified \"in place\" or a new Color object should be returned. sort_hue #py3 False Specifies whether cylindrical spaces should sort colors by hue before averaging to ensure a consistence, predictable averaging regardless of what order the colors are provided. Return Returns a reference to the new Color object or a reference to the current Color if in_place is True .","title":"Color.average"},{"location":"api/#compose","text":"def compose ( self , backdrop , * , blend = None , operator = None , space = None , out_space = None , in_place = False ): Description Apply compositing which consists of a blend mode and a Porter Duff operator for alpha compositing. The current color is treated as the source (top layer) and the provided color as the backdrop (bottom layer). Colors will be composited in the srgb color space unless otherwise specified. Colors should generally be RGB-ish colors (sRGB, Display P3, A98 RGB, etc.). Some non-RGB-ish colors may work okay, with the defaults, but many the algorithm is really designed for RGB-ish colors. Non-RGB-ish colors are likely to provide nonsense results. Supported blend modes are: Blend Modes normal multiply darken lighten burn dodge screen overlay hard-light exclusion difference soft-light hue saturation luminosity color color hue saturation luminosity Supported Port Duff operators are: Operators clear copy destination source-over destination-over source-in destination-in source-out destination-out source-atop destination-atop xor lighter Parameters Parameters Defaults Description backdrop A background color represented with either a string or Color object. blend None A blend mode to use to use when compositing. Values should be a string specifying the name of the blend mode to use. If None , normal will be used. If False , blending will be skipped. operator None A Porter Duff operator to use for alpha compositing. Values should be a string specifying the name of the operator to use. If None , source-over will be used. If False , alpha compositing will be skipped. space None A color space to perform the overlay in. If None , the base color's space will be used. out_space None A color space to output the resultant color to. in_place False Boolean used to determine if the the current color should be modified \"in place\" or a new Color object should be returned. Return Returns a reference to the new Color object or a reference to the current Color if in_place is True .","title":"Color.compose"},{"location":"api/#clip","text":"def clip ( self , space = None , * , in_place = False ) Description Performs simple clipping on color channels that are out of gamut. Parameters Parameters Defaults Description space None The color space that the color must be mapped to. If space is None , then the current color space will be used. in_place False Boolean used to determine if the the current color should be modified \"in place\" or a new Color object should be returned. Return Returns a reference to the new Color object or a reference to the current Color if in_place is True .","title":"Color.clip"},{"location":"api/#fit","text":"def fit ( self , space = None , * , method = None , in_place = False , ** kwargs ): Description Fits color to the current or specified color gamut. By default, oklch-chroma gamut mapping is used. This is essentially an approach that holds lightness and hue constant in the Oklch color space while reducing chroma until the color is in gamut. Clipping is done at each step of the way and the color distance measured to see how close our color is to the intended color. The supported gamut mapping methods are: Name Input Clipping clip Oklch Chroma oklch-chroma LCH Chroma lch-chroma Parameters Some methods could have additional parameters to configure the behavior, these would be done through **kwargs . None of built-in gamut mapping methods currently have additional parameters. Parameters Defaults Description space None The color space that the color must be mapped to. If space is None , then the current color space will be used. method None String that specifies which gamut mapping method to use. If None , oklch-chroma will be used. in_place False Boolean used to determine if the the current color should be modified \"in place\" or a new Color object should be returned. Return Returns a reference to the new Color object or a reference to the current Color if in_place is True .","title":"Color.fit"},{"location":"api/#in_gamut","text":"def in_gamut ( self , space = None , * , tolerance = util . DEF_FIT_TOLERANCE ): Description Checks if the current color is in the current or specified gamut. Parameters Parameters Defaults Description space None The color space that the color must be fit within. If space is None , then the current color space will be used. tolerance 0.000075 Tolerance allowed when checking bounds of color. Return Returns a boolean indicating whether the color is in the specified gamut.","title":"Color.in_gamut"},{"location":"api/#get","text":"def get ( self , name ): Description Retrieves the coordinate value from the specified channel. Channel must be a channel name in the current color space or a channel name in the specified color space using the syntax: space.channel . Parameters Parameters Defaults Description name Channel name or color space and channel name to retrieve value from. Return Returns a numerical value that is stored internally for the specified channel, or a calculated value in the case that a channel in a different color space is requested.","title":"Color.get"},{"location":"api/#set","text":"def set ( self , name , value ): Description Sets the given value to the specified channel. If the name is provided in the form space.channel , the value will be applied to the channel of the specified color space while keeping current color space the same. The value can be a numerical value, a CSS string compatible with the specified color space, or a function that accepts a numerical channel value and returns a numerical channel value. This function returns the current colors reference so that multiple sets can be chained together. Parameters Parameters Defaults Description name Channel name or color space and channel name to retrieve value from. value A numerical value, a string value accepted by the specified color space, or a function. Return Returns a reference to the current Color object.","title":"Color.set"},{"location":"api/#is_nan","text":"def is_nan ( self , name ): Description Retrieves the coordinate value from the specified channel and checks whether the value is NaN . Channel must be a channel name in the current color space or a channel name in the specified color space using the syntax: space.channel . Parameters Parameters Defaults Description name A string indicating what channel property to check. Return Returns a boolean indicating whether the specified color space's channel is NaN .","title":"Color.is_nan"},{"location":"api/#white","text":"def white ( self ): Description Retrieves the white point for the current color's color space. Return Returns a set of XYZ coordinates that align with the white point for the given color space.","title":"Color.white"},{"location":"api/#xy","text":"def xy ( self ): Description Retrieves the CIE 1931 (x, y) chromaticity coordinates for a given color. Return Returns a tuple of CIE 1931 (x, y) chromaticity points for the given color.","title":"Color.xy"},{"location":"api/#xy","text":"def uv ( self , mode = '1976' ): Description Retrieves the UCS 1960 (u, v) chromaticity coordinates for a given color or the CIE 1976 UCS (u', v') chromaticity coordinates, the latter being the default. Parameters Parameters Defaults Description mode '1976' A string indicating what mode to use. 1976 refers to the (u', v') points as described by CIE 1976 UCS and 1960 describes the (u, v) points as documented by CIE 1960 UCS . Return Returns a tuple of (u, v) \u2013 either 1976 (u', v') or 1960 (u, v) \u2013 chromaticity points for the given color.","title":"Color.xy"},{"location":"api/#color-channel-properties","text":"Depending on the given color space, channel properties will be available on the color object as well. These are dynamically available depending on what the current color space is. For instance, if the color space is sRGB, the channels red , green , blue , and alpha will all be available. Color channel names are defined in Supported Colors . These properties are read and writable. When read, they will return the numerical value stored in the specified channel. When written, they can accept a numerical value or a string value using CSS syntax acceptable for that channel in that color space. For more complex setting operations, or to chain multiple set operations, please use set and get .","title":"Color Channel Properties"},{"location":"api/#color-dynamic-methods","text":"Depending on what \u2206E methods are available, you can access the method, not only as Color.delta_e(value, method=\"name\") , you can can also access them directly via Color.delta_e_name(value) : >>> Color ( 'red' ) . delta_e ( 'green' , method = \"2000\" ) 70.23670072102784 >>> Color ( 'red' ) . delta_e_2000 ( 'green' ) 70.23670072102784 Color('red').delta_e('green', method=\"2000\") Color('red').delta_e_2000('green') Edit Share Run Cancel","title":"Color Dynamic Methods"},{"location":"colors/","text":"Supported Colors ColorAide aims to support all the color spaces and models currently offered in modern CSS, such as sRGB, Display P3, CIELAB, Oklab, etc. We also try to include a number of color spaces that are not available in CSS, but are generally popular. It is doubtful that we'll ever include all available color spaces that exist, but ColorAide is extensible and allows for new color spaces and models to be added by anyone, even 3 rd parties. Currently, we also offer a separate package called ColorAide Extras that provides some more color spaces: Hunter Lab, xyY, IPT, etc. We will most likely keep less common and experimental spaces/models over there and be very selective as to what we bring over here. Possible Relocation of Some Color Spaces for 1.0.0 It is possible that before the 1.0.0 release that we may move some color spaces from ColorAide over to ColorAide Extras . Any color spaces and associated \u2206E methods not considered part of the CSS spec could could be considered for relocation. HSLuv, Jzazbz, DIN99o, CIELUV, and ICtCp are all examples of spaces that could be moved to ColorAide Extras in the future. This would provide a leaner package with the option for users to install the additional package and cherry pick the spaces of interest. RGB RGB is a color model used by a number of different color spaces. The sRGB color space is probably the one most think of when someone mentions RGB. The RGB model represents colors with three channels: red, green, and blue. Though a number of color spaces use the RGB model, how colors translate to those coordinates differs from one color space to another. Depending on the color space, the range of colors within its gamut can be quite different. sRGB Properties Name: srgb White Point: D65 Coordinates: Name Range r [0, 1] g [0, 1] b [0, 1] CIE 1931 xy Chromaticity -- sRGB Chromaticities The sRGB space is a standard RGB (red, green, blue) color space that HP and Microsoft created cooperatively in 1996 to use on monitors, printers, and the Web. SRGB stands for \"Standard RGB\". It is the most widely used color space and is supported by most operating systems, software programs, monitors, and printers. Learn about sRGB ColorAide Details Channel Aliases: Channels Aliases r red g green b blue Inputs: Parsed input and string output formats support all valid CSS forms: black // Color name # RRGGBBAA // Hex rgb ( r g b / a ) // RGB function rgb ( r , g , b ) // Legacy RGB Function rgba ( r , g , b , a ) // Legacy RGBA function color ( srgb r g b / a ) // Color function When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"srgb\" , [ 0 , 0 , 0 ], 1 ) Output: The string representation of the color object will always default to the color ( srgb r g b / a ) form, but the default string output will be the rgb ( r g b / a ) form. >>> Color ( \"srgb\" , [ 0 , 0 , 0 ], 1 ) color(srgb 0 0 0 / 1) >>> Color ( \"srgb\" , [ 0 , 0 , 0 ], 1 ) . to_string () rgb(0 0 0) Color(\"srgb\", [0, 0, 0], 1) Color(\"srgb\", [0, 0, 0], 1).to_string() Edit Share Run Cancel sRGB Linear Properties Name: srgb-linear White Point: D65 Coordinates: Name Range r [0, 1] g [0, 1] b [0, 1] CIE 1931 xy Chromaticity -- sRGB Linear Chromaticities The sRGB Linear space is the same as sRGB except that the transfer function is linear-light (there is no gamma-encoding). Learn about sRGB ColorAide Details Channel Aliases: Channels Aliases r red g green b blue Inputs: Parsed input and string output formats support all valid CSS forms: color ( srgb-linear r g b / a ) // Color function When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"srgb-linear\" , [ 0 , 0 , 0 ], 1 ) Output: The string representation of the color object and the default string output will be in the color ( srgb-linear r g b / a ) form. >>> Color ( \"srgb-linear\" , [ 0 , 0 , 0 ], 1 ) color(srgb-linear 0 0 0 / 1) >>> Color ( \"srgb-linear\" , [ 0 , 0 , 0 ], 1 ) . to_string () color(srgb-linear 0 0 0) Color(\"srgb-linear\", [0, 0, 0], 1) Color(\"srgb-linear\", [0, 0, 0], 1).to_string() Edit Share Run Cancel Display P3 Properties Name: display-p3 White Point: D65 Coordinates: Name Range r [0, 1] g [0, 1] b [0, 1] CIE 1931 xy Chromaticity -- Display P3 Chromaticities Display P3 is a combination of the DCI-P3 color gamut with the D65 white point together with the sRGB gamma curve. It originated from the DCI-P3 color gamut's implementation in digital cinema projectors, as this standard offers more vibrant greens and reds than the traditional sRGB color gamut. Learn about Display P3 ColorAide Details Channel Aliases: Channels Aliases r red g green b blue Inputs Parsed input and string output formats support all valid CSS forms: color ( display-p3 r g b / a ) // Color function When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"display-p3\" , [ 0 , 0 , 0 ], 1 ) Output The string representation of the color object and the default string output will be in the color ( display-p3 r g b / a ) form. >>> Color ( \"display-p3\" , [ 0 , 0 , 0 ], 1 ) color(display-p3 0 0 0 / 1) >>> Color ( \"display-p3\" , [ 0 , 0 , 0 ], 1 ) . to_string () color(display-p3 0 0 0) Color(\"display-p3\", [0, 0, 0], 1) Color(\"display-p3\", [0, 0, 0], 1).to_string() Edit Share Run Cancel A98 RGB Properties Name: a98-rgb White Point: D65 Coordinates: Name Range r [0, 1] g [0, 1] b [0, 1] CIE 1931 xy Chromaticity -- Adobe RGB 1998 Chromaticities The Adobe RGB (1998) color space or opRGB is a color space developed by Adobe Systems, Inc. in 1998. It was designed to encompass most of the colors achievable on CMYK color printers, but by using RGB primary colors on a device such as a computer display. The Adobe RGB (1998) color space encompasses roughly 50% of the visible colors specified by the CIELAB color space - improving upon the gamut of the sRGB color space, primarily in cyan-green hues. Learn about A98 RGB ColorAide Details Channel Aliases: Channels Aliases r red g green b blue Inputs: Parsed input and string output formats support all valid CSS forms: color ( a98-rgb r g b / a ) // Color function When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"a98-rgb\" , [ 0 , 0 , 0 ], 1 ) Output The string representation of the color object and the default string output will be in the color ( a98-rgb r g b / a ) form. >>> Color ( \"a98-rgb\" , [ 0 , 0 , 0 ], 1 ) color(a98-rgb 0 0 0 / 1) >>> Color ( \"a98-rgb\" , [ 0 , 0 , 0 ], 1 ) . to_string () color(a98-rgb 0 0 0) Color(\"a98-rgb\", [0, 0, 0], 1) Color(\"a98-rgb\", [0, 0, 0], 1).to_string() Edit Share Run Cancel REC. 2020 Properties Name: rec2020 White Point: D65 Coordinates: Name Range r [0, 1] g [0, 1] b [0, 1] CIE 1931 xy Chromaticity -- Rec. 2020 Chromaticities The Rec. 2020 color space is a very wide gamut RGB color space which is used in 4k and 8k UHDTV. ITU-R Recommendation BT.2020, more commonly known by the abbreviations Rec. 2020 or BT.2020, defines various aspects of ultra-high-definition television (UHDTV) with standard dynamic range (SDR) and wide color gamut (WCG), including picture resolutions, frame rates with progressive scan, bit depths, color primaries, RGB and luma-chroma color representations, chroma subsamplings, and an opto-electronic transfer function. Learn about REC.2020 ColorAide Details Channel Aliases: Channels Aliases r red g green b blue Inputs: Parsed input and string output formats support all valid CSS forms: color ( rec2020 r g b / a ) // Color function When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"rec2020\" , [ 0 , 0 , 0 ], 1 ) Output: The string representation of the color object and the default string output will be in the color ( rec2020 r g b / a ) form. >>> Color ( \"rec2020\" , [ 0 , 0 , 0 ], 1 ) color(rec2020 0 0 0 / 1) >>> Color ( \"rec2020\" , [ 0 , 0 , 0 ], 1 ) . to_string () color(rec2020 0 0 0) Color(\"rec2020\", [0, 0, 0], 1) Color(\"rec2020\", [0, 0, 0], 1).to_string() Edit Share Run Cancel ProPhoto Properties Name: prophoto-rgb White Point: D50 Coordinates: Name Range r [0, 1] g [0, 1] b [0, 1] CIE 1931 xy Chromaticity -- ProPhoto RGB Chromaticities The ProPhoto RGB color space, also known as ROMM RGB (Reference Output Medium Metric), is an output referred RGB color space developed by Kodak. It offers an especially large gamut designed for use with photographic output in mind. The ProPhoto RGB color space encompasses over 90% of possible surface colors in the CIE L*a*b* color space, and 100% of likely occurring real-world surface colors documented by Pointer in 1980. ColorAide Details Channel Aliases: Channels Aliases r red g green b blue Inputs: Parsed input and string output formats support all valid CSS forms: color ( prophoto-rgb r g b / a ) // Color function When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"prophoto-rgb\" , [ 0 , 0 , 0 ], 1 ) Output: The string representation of the color object and the default string output will be in the color ( prophoto-rgb r g b / a ) form. >>> Color ( \"prophoto-rgb\" , [ 0 , 0 , 0 ], 1 ) color(prophoto-rgb 0 0 0 / 1) >>> Color ( \"prophoto-rgb\" , [ 0 , 0 , 0 ], 1 ) . to_string () color(prophoto-rgb 0 0 0) Color(\"prophoto-rgb\", [0, 0, 0], 1) Color(\"prophoto-rgb\", [0, 0, 0], 1).to_string() Edit Share Run Cancel Learn about ProPhoto Cylindrical sRGB Spaces The sRGB color space has been represented in a number of cylindrical models. Each model was an attempt to either align the color with human perception or make it more intuitive to work with. The term \"cylindrical\" is used as the spaces take on the shape of a cylinder, whereas the RGB model is very much a cube: sRGB color space in 3D HSV Properties Name: hsv White Point: D65 Coordinates: Name Range h [0, 360) s [0, 1] v [0, 1] HSV color space in 3D HSV is a color space similar to the modern RGB and CMYK models. The HSV color space has three components: hue, saturation and value. 'Value' is sometimes substituted with 'brightness' and then it is known as HSB. HSV models how colors appear under light. Learn about HSV ColorAide Details Channel Aliases: Channels Aliases h hue s saturation v value Inputs: HSV is not supported via the CSS spec and the parser input and string output only supports the color () function format using the custom name --hsv : color ( --hsv 0 0 % 0 % / 1 ) When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"hsv\" , [ 0 , 0 , 0 ], 1 ) Output: The string representation of the color object and default string output will always use the color ( hsv h s v / a ) form. >>> Color ( \"hsv\" , [ 0 , 0 , 0 ], 1 ) color(--hsv 0 0 0 / 1) >>> Color ( \"hsv\" , [ 0 , 0 , 0 ], 1 ) . to_string () color(--hsv 0 0 0) Color(\"hsv\", [0, 0, 0], 1) Color(\"hsv\", [0, 0, 0], 1).to_string() Edit Share Run Cancel HSL Properties Name: hsl White Point: D65 Coordinates: Name Range h [0, 360) s [0, 1] l [0, 1] HSL color space in 3D HSL is an alternative representations of the RGB color model, designed in the 1970s by computer graphics researchers to more closely align with the way human vision perceives color-making attributes. In these models, colors of each hue are arranged in a radial slice, around a central axis of neutral colors which ranges from black at the bottom to white at the top. HSL models the way different paints mix together to create color in the real world, with the lightness dimension resembling the varying amounts of black or white paint in the mixture. Learn about HSL ColorAide Details Channel Aliases: Channels Aliases h hue s saturation l lightness Inputs: Parsed input and string output formats support all valid CSS forms. In addition, we also allow the color () function format using the custom name --hsl : hsl ( h s l / a ) // HSL function hsl ( h , s , l ) // Legacy HSL function hsla ( h , s , l , a ) // Legacy HSLA function color ( --hsl h s l / a ) // Color function When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"hsl\" , [ 0 , 0 , 0 ], 1 ) Output: The string representation of the color object will always default to the color ( --hsl h s l / a ) form, but the default string output will be the hsl ( h s l / a ) form. >>> Color ( \"hsl\" , [ 0 , 0 , 0 ], 1 ) color(--hsl 0 0 0 / 1) >>> Color ( \"hsl\" , [ 0 , 0 , 0 ], 1 ) . to_string () hsl(0 0% 0%) Color(\"hsl\", [0, 0, 0], 1) Color(\"hsl\", [0, 0, 0], 1).to_string() Edit Share Run Cancel HWB Properties Name: hwb White Point: D65 Coordinates: Name Range h [0, 360) w [0, 1] b [0, 1] HWB color space in 3D HWB is a cylindrical-coordinate representation of points in an RGB color model, similar to HSL and HSV. It was developed by HSV 's creator Alvy Ray Smith in 1996 to address some of the issues with HSV. HWB was designed to be more intuitive for humans to use and slightly faster to compute. The first coordinate, H (Hue), is the same as the Hue coordinate in HSL and HSV . W and B stand for Whiteness and Blackness respectively and range from 0-100% (or 0-1). The mental model is that the user can pick a main hue and then \"mix\" it with white and/or black to produce the desired color. Learn about HWB ColorAide Details Channel Aliases: Channels Aliases h hue w whiteness b blackness Inputs: Parsed input and string output formats support all valid CSS forms. In addition, we also allow the color () function format using the custom name --hwb : hwb ( h w b / a ) // HWB function color ( --hwb h w b / a ) // Color function When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"hwb\" , [ 0 , 0 , 100 ], 1 ) Output: The string representation of the color object will always default to the color ( --hwb h w b / a ) form, but the default string output will be the hwb ( h s l / a ) form. >>> Color ( \"hwb\" , [ 0 , 0 , 100 ], 1 ) color(--hwb 0 0 100 / 1) >>> Color ( \"hwb\" , [ 0 , 0 , 100 ], 1 ) . to_string () hwb(0 0% 100%) Color(\"hwb\", [0, 0, 100], 1) Color(\"hwb\", [0, 0, 100], 1).to_string() Edit Share Run Cancel Okhsv Properties Name: okhsv White Point: D65 Coordinates: Name Range h [0, 360) s [0, 1] v [0, 1] Okhsv color space in 3D Okhsv is a color space created by Bj\u00f6rn Ottosson. It is based off his early work and leverages the Oklab color space. The aim was to create a color space that was better suited for being used in color pickers than the current HSV. Learn about Okhsv ColorAide Details Channel Aliases: Channels Aliases h hue s saturation v value Inputs: Okhsv is not currently supported in the CSS spec, the parsed input and string output formats use the color () function format using the custom name --okhsv : color ( --okhsv h s l / a ) // Color function When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"okhsv\" , [ 0 , 0 , 0 ], 1 ) Output: The string representation of the color object and the default string output use the color ( --okhsv h s l / a ) form. >>> Color ( \"okhsv\" , [ 0 , 0 , 0 ], 1 ) color(--okhsv 0 0 0 / 1) >>> Color ( \"okhsv\" , [ 0 , 0 , 0 ], 1 ) . to_string () color(--okhsv 0 0 0) Color(\"okhsv\", [0, 0, 0], 1) Color(\"okhsv\", [0, 0, 0], 1).to_string() Edit Share Run Cancel Okhsl Properties Name: okhsl White Point: D65 Coordinates: Name Range h [0, 360) s [0, 1] l [0, 1] Okhsl color space in 3D Okhsl is a another color space created by Bj\u00f6rn Ottosson. It is based off his early work and leverages the Oklab color space. The aim was to create a color space that was better suited for being used in color pickers than the current HSL. Learn about Okhsv ColorAide Details Channel Aliases: Channels Aliases h hue s saturation l lightness Inputs: Okhsl is not currently supported in the CSS spec, the parsed input and string output formats use the color () function format using the custom name --okhsl : color ( --okhsl h s l / a ) // Color function When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"okhsl\" , [ 0 , 0 , 0 ], 1 ) Output: The string representation of the color object and the default string output use the color ( --okhsl h s l / a ) form. >>> Color ( \"okhsl\" , [ 0 , 0 , 0 ], 1 ) color(--okhsl 0 0 0 / 1) >>> Color ( \"okhsl\" , [ 0 , 0 , 0 ], 1 ) . to_string () color(--okhsl 0 0 0) Color(\"okhsl\", [0, 0, 0], 1) Color(\"okhsl\", [0, 0, 0], 1).to_string() Edit Share Run Cancel HSLuv Properties Name: hsluv White Point: D65 Coordinates: Name Range h [0, 360) s [0, 100] l [0, 100] HSLuv color space in 3D HSLuv is a human-friendly alternative to HSL. It was formerly known as \"HUSL\" and is a variation of the CIELCH uv color space, where the chroma component is replaced by a saturation component which allows you to span all the available chroma as a percentage. HSLuv is constrained to the sRGB gamut. Learn about HSLuv ColorAide Details Channel Aliases: Channels Aliases h hue s saturation l lightness Inputs: HSLuv is not currently supported in the CSS spec, the parsed input and string output formats use the color () function format using the custom name --hsluv : color ( --hsluv h s l / a ) // Color function When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"hsluv\" , [ 0 , 0 , 0 ], 1 ) Output: The string representation of the color object and the default string output use the color ( --hsluv h s l / a ) form. >>> Color ( \"hsluv\" , [ 0 , 0 , 0 ], 1 ) color(--hsluv 0 0 0 / 1) >>> Color ( \"hsluv\" , [ 0 , 0 , 0 ], 1 ) . to_string () color(--hsluv 0 0 0) Color(\"hsluv\", [0, 0, 0], 1) Color(\"hsluv\", [0, 0, 0], 1).to_string() Edit Share Run Cancel XYZ The 1931 CIE XYZ color space encompasses all colors that are visible to a person with average eyesight. It also contains many colors that the human eye cannot see: CIE 1931 xy Chromaticity -- overlaid with the XYZ D65 space. In many color libraries, it is used as a space through which different color conversions are passed through as it is large enough to contain all visible colors. Many conversions use matrices based on this space to do chromatic adaption or just direct translations. While the chromaticity diagrams we've shown all use XYZ with a D65 white point to help generate them, XYZ can be represented with other white points as well. CSS actually allows using either XYZ D50 or XYZ D65 . We also provide both. XYZ D65 Properties Name: xyz-d65 White Point: D65 Coordinates: Name Range x [0.0, 0.95] * y [0.0, 1.0] * z [0.0, 1.089] * * \u2248 range in relation to sRGB rounded to 3 decimal places. Approximation 1 of the sRGB gamut represented within the XYZ D65 color space. The CIE 1931 RGB color space and CIE 1931 XYZ color space were created by the International Commission on Illumination (CIE) in 1931. They resulted from a series of experiments done in the late 1920s by William David Wright using ten observers and John Guild using seven observers. The experimental results were combined into the specification of the CIE RGB color space, from which the CIE XYZ color space was derived. The CIE 1931 color spaces are the first defined quantitative links between distributions of wavelengths in the electromagnetic visible spectrum, and physiologically perceived colors in human color vision. Learn about XYZ ColorAide Details Channel Aliases: Channels Aliases x y z Inputs: Parsed input and string output formats use the color () format with either xyz-d65 or xyz as the identifier with the latter being an alias of the former. color ( xyz x y z / a ) // Color function color ( xyz-d65 x y z / a ) // Color function alternate name When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"xyz-d65\" , [ 0 , 0 , 0 ], 1 ) Output: The string representation of the color object and the default string output will be in the color ( xyz-d65 x y z / a ) form. >>> Color ( \"xyz-d65\" , [ 0 , 0 , 0 ], 1 ) color(xyz-d65 0 0 0 / 1) >>> Color ( \"xyz-d65\" , [ 0 , 0 , 0 ], 1 ) . to_string () color(xyz-d65 0 0 0) Color(\"xyz-d65\", [0, 0, 0], 1) Color(\"xyz-d65\", [0, 0, 0], 1).to_string() Edit Share Run Cancel XYZ D50 Properties Name: xyz-d50 White Point: D50 Coordinates: Name Range x [0.0, 0.964] * y [0.0, 1.0] * z [0.0, 0.825] * * \u2248 range in relation to sRGB rounded to 3 decimal places. Approximation 1 of the sRGB gamut represented within the XYZ D50 color space. XYZ D50 is the same as XYZ D65 except it uses a D50 white point. Learn about XYZ ColorAide Details Channel Aliases: Channels Aliases x y z Inputs: Parsed input and string output formats support all valid CSS forms: color ( xyz-d50 x y z / a ) // Color function When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"xyz-d50\" , [ 0 , 0 , 0 ], 1 ) Output: The string representation of the color object and the default string output will be in the color ( xyz x y z / a ) form. >>> Color ( \"xyz-d50\" , [ 0 , 0 , 0 ], 1 ) color(xyz-d50 0 0 0 / 1) >>> Color ( \"xyz-d50\" , [ 0 , 0 , 0 ], 1 ) . to_string () color(xyz-d50 0 0 0) Color(\"xyz-d50\", [0, 0, 0], 1) Color(\"xyz-d50\", [0, 0, 0], 1).to_string() Edit Share Run Cancel CIELAB CIELAB \u2013 also referred to as L*a*b* \u2013 is another CIE color space. it was created as a perceptually uniform color space. CIELAB doesn't really have a gamut, and pretty much any other color space can be mapped to it. Much like XYZ , CIELAB and CIELCH currently use a D50 white point just like the CSS, but we've also included variants with D65 white points as well. CIELAB D50 Properties Name: lab White Point: D50 Coordinates: Name Range l [0, 100] * a [-79.287, 93.55] * b [-112.029, 93.388] * * \u2248 range in relation to sRGB rounded to 3 decimal places. Approximation 1 of the sRGB gamut represented within the CIELAB D50 color space. The CIELAB color space also referred to as L*a*b* is a color space defined by the International Commission on Illumination (abbreviated CIE) in 1976. It expresses color as three values: L* for perceptual lightness, and a* and b* for the four unique colors of human vision: red, green, blue, and yellow. CIELAB was intended as a perceptually uniform space, where a given numerical change corresponds to similar perceived change in color. While the CIELAB space is not truly perceptually uniform, it nevertheless is useful in industry for detecting small differences in color. Learn about CIELAB ColorAide Details Channel Aliases: Channels Aliases l lightness a b Inputs: Parsed input and string output formats support all valid CSS forms. In addition, we also allow the color () function format using the custom name --lab : lab ( l a b / a ) // Lab function color ( --lab l a b / a ) // Color function When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"lab\" , [ 0 , 0 , 0 ], 1 ) Output: The string representation of the color object will always default to the color ( --lab l a b / a ) form, but the default string output will be the lab ( l a b / a ) form. >>> Color ( \"lab\" , [ 0 , 0 , 0 ], 1 ) color(--lab 0 0 0 / 1) >>> Color ( \"lab\" , [ 0 , 0 , 0 ], 1 ) . to_string () lab(0% 0 0) Color(\"lab\", [0, 0, 0], 1) Color(\"lab\", [0, 0, 0], 1).to_string() Edit Share Run Cancel CIELAB D65 Properties Name: lab-d65 White Point: D65 Coordinates: Name Range l [0, 100] * a [-86.183, 98.234] * b [-107.86, 94.478] * * \u2248 range in relation to sRGB rounded to 3 decimal places. Approximation 1 of the sRGB gamut represented within the CIELAB D50 color space. CIELAB D65 is the same as CIELAB except it uses a D65 white point. Learn about CIELAB ColorAide Details Channel Aliases: Channels Aliases l lightness a b Inputs: As a D65 variant of CIELAB is not currently supported in the CSS spec, the parsed input and string output formats use the color () function format using the custom name --lab-d65 : color ( --lab-d65 l a b / a ) // Color function When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"lab-d65\" , [ 0 , 0 , 0 ], 1 ) Output: The string representation of the color object and the default string output use the color ( --lab-d65 l a b / a ) form. >>> Color ( \"lab-d65\" , [ 0 , 0 , 0 ], 1 ) color(--lab-d65 0 0 0 / 1) >>> Color ( \"lab-d65\" , [ 0 , 0 , 0 ], 1 ) . to_string () color(--lab-d65 0 0 0) Color(\"lab-d65\", [0, 0, 0], 1) Color(\"lab-d65\", [0, 0, 0], 1).to_string() Edit Share Run Cancel CIELCH CIELAB generally is not an intuitive space to work with and instead is often converted to cylindrical coordinates with hues represented as degrees and a chroma and lightness channel. The shape of the color space doesn't really change, just how the colors are manipulated. CIELCH, like CIELAB, is available with a D50 white point that matches CSS and a D65 white point. CIELCH D50 Properties Name: lch White Point: D50 Coordinates: Name Range l [0, 100] * c [0, 131.207] * h [0, 360) * \u2248 range in relation to sRGB rounded to 3 decimal places. Approximation 1 of the sRGB gamut represented within the CIELCH D50 color space. The \"CIELCH\" or \"CIEHLC\" space is a color space based on CIELAB , which uses the polar coordinates C* (chroma, relative saturation) and h\u00b0 (hue angle, angle of the hue in the CIELAB color wheel) instead of the Cartesian coordinates a* and b*. The CIELAB lightness L* remains unchanged. Learn about CIELCH ColorAide Details Channel Aliases: Channels Aliases l lightness c chroma h hue Inputs: Parsed input and string output formats support all valid CSS forms. In addition, we also allow the color () function format using the custom name --lch : lch ( l c h / a ) // Lch function color ( --lch l c h / a ) // Color function When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"lch\" , [ 0 , 0 , 0 ], 1 ) Output: The string representation of the color object will always default to the color ( --lch l c h / a ) form, but the default string output will be the lch ( l c h / a ) form. >>> Color ( \"lch\" , [ 0 , 0 , 0 ], 1 ) color(--lch 0 0 0 / 1) >>> Color ( \"lch\" , [ 0 , 0 , 0 ], 1 ) . to_string () lch(0% 0 0) Color(\"lch\", [0, 0, 0], 1) Color(\"lch\", [0, 0, 0], 1).to_string() Edit Share Run Cancel CIELCH D65 Properties Name: lch-d65 White Point: D65 Coordinates: Name Range l [0, 100] * c [0.0, 133.808] * h [0, 360) * \u2248 range in relation to sRGB rounded to 3 decimal places. Approximation 1 of the sRGB gamut represented within the CIELCH D65 color space. CIELCH D65 is the same as CIELCH except it uses a D65 white point. Learn about CIELCH ColorAide Details Channel Aliases: Channels Aliases l lightness c chroma h hue Inputs: As a D65 variant of CIELCH is not currently supported in the CSS spec, the parsed input and string output formats use the color () function format using the custom name --lch-d65 : color ( --lch-d65 l c h / a ) // Color function When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"lch-d65\" , [ 0 , 0 , 0 ], 1 ) Outputs: The string representation of the color object and the default string output use the color ( --lch-d65 l c h / a ) form. >>> Color ( \"lch-d65\" , [ 0 , 0 , 0 ], 1 ) color(--lch-d65 0 0 0 / 1) >>> Color ( \"lch-d65\" , [ 0 , 0 , 0 ], 1 ) . to_string () color(--lch-d65 0 0 0) Color(\"lch-d65\", [0, 0, 0], 1) Color(\"lch-d65\", [0, 0, 0], 1).to_string() Edit Share Run Cancel Oklab Properties Name: oklab White Point: D65 Coordinates: Name Range l [0, 1] * a [-0.234, 0.276] * b [-0.312, 0.198] * * \u2248 range in relation to sRGB rounded to 3 decimal places. Approximation 1 of the sRGB gamut represented within the Oklab color space. A new perceptual color space that claims to be simple to use, while doing a good job at predicting perceived lightness, chroma and hue. It is called the Oklab color space, because it is an OK Lab color space. Learn about Oklab ColorAide Details Channel Aliases: Channels Aliases l lightness a b Inputs: Oklab is not currently supported in the CSS spec, the parsed input and string output formats use the color () function format using the custom name --oklab : oklab ( l a b / a ) // Oklab function color ( --oklab l a b / a ) // Color function When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"oklab\" , [ 0 , 0 , 0 ], 1 ) Output: The string representation of the color object will always default to the color ( --oklab l a b / a ) form, but the default string output will be the oklab ( l a b / a ) form. >>> Color ( \"oklab\" , [ 0 , 0 , 0 ], 1 ) color(--oklab 0 0 0 / 1) >>> Color ( \"oklab\" , [ 0 , 0 , 0 ], 1 ) . to_string () oklab(0% 0 0) Color(\"oklab\", [0, 0, 0], 1) Color(\"oklab\", [0, 0, 0], 1).to_string() Edit Share Run Cancel Oklch Properties Name: oklch White Point: D65 Coordinates: Name Range l [0, 1] * c [0, 0.323] * h [0, 360) * \u2248 range in relation to sRGB rounded to 3 decimal places. Approximation 1 of the sRGB gamut represented within the Oklch color space. Oklch is the cylindrical form of Oklab . Learn about Oklch ColorAide Details Channel Aliases: Channels Aliases l lightness c chroma h hue Inputs Oklab is not currently supported in the CSS spec, the parsed input and string output formats use the color () function format using the custom name --oklch : oklch ( l c h / a ) // Oklch function color ( --oklch l c h / a ) // Color function Output: The string representation of the color object will always default to the color ( --oklch l c h / a ) form, but the default string output will be the oklch ( l a b / a ) form. >>> Color ( \"oklch\" , [ 0 , 0 , 0 ], 1 ) color(--oklch 0 0 0 / 1) >>> Color ( \"oklch\" , [ 0 , 0 , 0 ], 1 ) . to_string () oklch(0% 0 0) Color(\"oklch\", [0, 0, 0], 1) Color(\"oklch\", [0, 0, 0], 1).to_string() Edit Share Run Cancel CIELUV Properties Name: luv White Point: D65 Coordinates: Name Range l [0, 100] * u [-83.067, 175.01] * v [-134.11, 107.418] * * \u2248 range in relation to sRGB rounded to 3 decimal places. Approximation 1 of the sRGB gamut represented within the CIELUV D65 color space. CIELUV is similar to CIELAB as they were both developed in 1976 as perceptually uniform color spaces, both are derived from the color experiments in 1931 that brought us the XYZ color space, and neither are truly perceptually uniform. The difference between the two comes from their intent. CIELAB attempted to create a space that aligned well with human vision. CIELUV, on the other hand, was designed to be an easier-to-compute transformation of the 1931 CIE XYZ color space. CIELAB is more commonly used in subtractive color applications (printed pages, dyes, etc.), while CIELUV is better suited in additive color applications such as display colorimetry (monitors, TVs, etc.). Learn about CIELUV ColorAide Details Channel Aliases: Channels Aliases l lightness u v Inputs: As CIELUV D65 is not currently supported in the CSS spec, the parsed input and string output formats use the color () function format using the custom name --luv : color ( --luv l u v / a ) // Color function When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"luv\" , [ 0 , 0 , 0 ], 1 ) Outputs The string representation of the color object and the default string output use the color ( --luv l u v / a ) form. >>> Color ( \"luv\" , [ 0 , 0 , 0 ], 1 ) color(--luv 0 0 0 / 1) >>> Color ( \"luv\" , [ 0 , 0 , 0 ], 1 ) . to_string () color(--luv 0 0 0) Color(\"luv\", [0, 0, 0], 1) Color(\"luv\", [0, 0, 0], 1).to_string() Edit Share Run Cancel CIELCH uv Properties Name: lchuv White Point: D65 Coordinates: Name Range l [0, 100] * c [0, 179.038] * h [0, 360) * \u2248 range in relation to sRGB rounded to 3 decimal places. Approximation 1 of the sRGB gamut represented within the CIELCH uv color space. CIELUV is not an intuitive space to work with directly and instead is often converted to cylindrical coordinates with hues represented as degrees and a chroma and lightness channel. The shape of the color space doesn't really change, just how the colors are manipulated. Learn about CIELCH uv ColorAide Details Channel Aliases: Channels Aliases l lightness c chroma h hue Inputs: As CIELCH uv is not currently supported in the CSS spec, the parsed input and string output formats use the color () function format using the custom name --lchuv : color ( --lchuv l c h / a ) // Color function When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"lchuv\" , [ 0 , 0 , 0 ], 1 ) Output: The string representation of the color object and the default string output use the color ( --lchuv l c h / a ) form. >>> Color ( \"lchuv\" , [ 0 , 0 , 0 ], 1 ) color(--lchuv 0 0 0 / 1) >>> Color ( \"lchuv\" , [ 0 , 0 , 0 ], 1 ) . to_string () color(--lchuv 0 0 0) Color(\"lchuv\", [0, 0, 0], 1) Color(\"lchuv\", [0, 0, 0], 1).to_string() Edit Share Run Cancel Jzazbz Properties Name: jzazbz White Point: D65 Coordinates: Name Range jz [0, 0.222] * az [-0.109, 0.13] * bz [-0.186, 0.135] * * \u2248 range in relation to sRGB rounded to 3 decimal places. Approximation 1 of the sRGB gamut represented within the Jzazbz color space. Jzazbz is a a color space designed for perceptual uniformity in high dynamic range (HDR) and wide color gamut (WCG) applications. Conceptually it is similar to CIELAB , but claims the following improvements: Perceptual color difference is predicted by Euclidean distance. Perceptually uniform: MacAdam ellipses of just-noticeable-difference ( JND ) are more circular, and closer to the same sizes. Hue linearity: changing saturation or lightness has less shift in hue. Learn about Jzazbz ColorAide Details Channel Aliases: Channels Aliases jz lightness az a bz b Inputs As Jzazbz is not currently supported in the CSS spec, the parsed input and string output formats use the color () function format using the custom name --jzazbz : color ( --jzazbz jz az bz / a ) // Color function When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"jzazbz\" , [ 0 , 0 , 0 ], 1 ) Output The string representation of the color object and the default string output use the color ( --jzazbz jz az bz / a ) form. >>> Color ( \"jzazbz\" , [ 0 , 0 , 0 ], 1 ) color(--jzazbz 0 0 0 / 1) >>> Color ( \"jzazbz\" , [ 0 , 0 , 0 ], 1 ) . to_string () color(--jzazbz 0 0 0) Color(\"jzazbz\", [0, 0, 0], 1) Color(\"jzazbz\", [0, 0, 0], 1).to_string() Edit Share Run Cancel JzCzhz Properties Name: jzczhz White Point: D65 Coordinates: Name Range jz [0, 0.222] * cz [0, 0.190] * hz [0, 360) * \u2248 range in relation to sRGB rounded to 3 decimal places. Approximation 1 of the sRGB gamut represented within the JzCzhz color space. JzCzhz is the cylindrical form of Jzazbz . Learn about JzCzhz ColorAide Details Channel Aliases: Channels Aliases jz lightness cz chroma hz hue Inputs As JzCzhz is not currently supported in the CSS spec, the parsed input and string output formats use the color () function format using the custom name --jzczhz : color ( --jzczhz jz cz hz / a ) // Color function When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"jzczhz\" , [ 0 , 0 , 0 ], 1 ) Output The string representation of the color object and the default string output use the color ( --jzczhz jz cz hz / a ) form. >>> Color ( \"jzczhz\" , [ 0 , 0 , 0 ], 1 ) color(--jzczhz 0 0 0 / 1) >>> Color ( \"jzczhz\" , [ 0 , 0 , 0 ], 1 ) . to_string () color(--jzczhz 0 0 0) Color(\"jzczhz\", [0, 0, 0], 1) Color(\"jzczhz\", [0, 0, 0], 1).to_string() Edit Share Run Cancel ICtCp Properties Name: ictcp White Point: D65 Coordinates: Name Range i [0, 0.581] * ct [-0.281, 0.277] * cp [-0.161, 0.279] * * \u2248 range in relation to sRGB rounded to 3 decimal places. Approximation 1 of the sRGB gamut represented within the ICtCp color space. ICtCp is a color space format with better perceptual uniformity than CIELAB and is used as a part of the color image pipeline in video and digital photography systems for high dynamic range (HDR) and wide color gamut (WCG) imagery. It was developed by Dolby Laboratories from the IPT color space by Ebner and Fairchild. It was designed with the intention to replace YCbCr. Learn about ICtCp ColorAide Details Channel Aliases: Channels Aliases i ct cp Inputs: As ICtCp is not currently supported in the CSS spec, the parsed input and string output formats use the color () function format using the custom name --ictcp : color ( --ictcp i ct cp / a ) // Color function When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"ictcp\" , [ 0 , 0 , 0 ], 1 ) Output: The string representation of the color object and the default string output use the color ( --ictcp i ct cp / a ) form. >>> Color ( \"ictcp\" , [ 0 , 0 , 0 ], 1 ) color(--ictcp 0 0 0 / 1) >>> Color ( \"ictcp\" , [ 0 , 0 , 0 ], 1 ) . to_string () color(--ictcp 0 0 0) Color(\"ictcp\", [0, 0, 0], 1) Color(\"ictcp\", [0, 0, 0], 1).to_string() Edit Share Run Cancel DIN99o Properties Name: din99o White Point: D65 Coordinates: Name Range l [0, 100] * a [-40.09, 45.501] * b [-40.47, 44.344] * * \u2248 range in relation to sRGB rounded to 3 decimal places. Approximation 1 of the sRGB gamut represented within the DIN99o color space. The DIN99 color space system is a further development of the CIELAB color space system developed by the FNF / FNL 2 Colorimetry Working Committee. It takes the CIELAB space (with a D65 illuminant) and compresses it such that the space yields better equidistant using Euclidean distance. The whole color space is essentially modified to better fit the color distancing algorithm opposed to CIELAB which has adapted the color distancing algorithm to better fit the color space, the latest iteration being \u2206E * 00 . Learn about DIN99o ColorAide Details Channel Aliases: Channels Aliases l lightness a b Inputs: As DIN99o is not currently supported in the CSS spec, the parsed input and string output formats use the color () function format using the custom name --din99o : color ( --din99o l u v / a ) // Color function When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"din99o\" , [ 0 , 0 , 0 ], 1 ) Output: The string representation of the color object and the default string output use the color ( --din99o l u v / a ) form. >>> Color ( \"din99o\" , [ 0 , 0 , 0 ], 1 ) color(--din99o 0 0 0 / 1) >>> Color ( \"din99o\" , [ 0 , 0 , 0 ], 1 ) . to_string () color(--din99o 0 0 0) Color(\"din99o\", [0, 0, 0], 1) Color(\"din99o\", [0, 0, 0], 1).to_string() Edit Share Run Cancel DIN99o Lch Properties Name: lch99o White Point: D65 Coordinates: Name Range l [0, 100] * c [0, 51.484] * h [0, 360) * \u2248 range in relation to sRGB rounded to 3 decimal places. Approximation 1 of the sRGB gamut represented within the DIN99o Lch color space. DIN99o Lch is the cylindrical form of DIN99o . Learn about DIN99o Lch ColorAide Details Channel Aliases: Channels Aliases l lightness c chroma h hue Inputs: As DIN99o Lch is not currently supported in the CSS spec, the parsed input and string output formats use the color () function format using the custom name --lch99o : color ( --lch99o jz cz hz / a ) // Color function When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"lch99o\" , [ 0 , 0 , 0 ], 1 ) Output: The string representation of the color object and the default string output use the color ( --lch99o jz cz hz / a ) form. >>> Color ( \"lch99o\" , [ 0 , 0 , 0 ], 1 ) color(--lch99o 0 0 0 / 1) >>> Color ( \"lch99o\" , [ 0 , 0 , 0 ], 1 ) . to_string () color(--lch99o 0 0 0) Color(\"lch99o\", [0, 0, 0], 1) Color(\"lch99o\", [0, 0, 0], 1).to_string() Edit Share Run Cancel .info-container {display: inline-block;} For the purposes of speed, 3D models are calculated by taking points on the outer shell of the sRGB gamut and mapping those points to the color space of interest. While a more accurate model could be made by taking all points into account, this approach gives a fairly good approximation of the shape of the sRGB gamut within the targeted color space. \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9","title":"Supported Colors"},{"location":"colors/#supported-colors","text":"ColorAide aims to support all the color spaces and models currently offered in modern CSS, such as sRGB, Display P3, CIELAB, Oklab, etc. We also try to include a number of color spaces that are not available in CSS, but are generally popular. It is doubtful that we'll ever include all available color spaces that exist, but ColorAide is extensible and allows for new color spaces and models to be added by anyone, even 3 rd parties. Currently, we also offer a separate package called ColorAide Extras that provides some more color spaces: Hunter Lab, xyY, IPT, etc. We will most likely keep less common and experimental spaces/models over there and be very selective as to what we bring over here. Possible Relocation of Some Color Spaces for 1.0.0 It is possible that before the 1.0.0 release that we may move some color spaces from ColorAide over to ColorAide Extras . Any color spaces and associated \u2206E methods not considered part of the CSS spec could could be considered for relocation. HSLuv, Jzazbz, DIN99o, CIELUV, and ICtCp are all examples of spaces that could be moved to ColorAide Extras in the future. This would provide a leaner package with the option for users to install the additional package and cherry pick the spaces of interest.","title":"Supported Colors"},{"location":"colors/#rgb","text":"RGB is a color model used by a number of different color spaces. The sRGB color space is probably the one most think of when someone mentions RGB. The RGB model represents colors with three channels: red, green, and blue. Though a number of color spaces use the RGB model, how colors translate to those coordinates differs from one color space to another. Depending on the color space, the range of colors within its gamut can be quite different.","title":"RGB"},{"location":"colors/#srgb","text":"Properties Name: srgb White Point: D65 Coordinates: Name Range r [0, 1] g [0, 1] b [0, 1] CIE 1931 xy Chromaticity -- sRGB Chromaticities The sRGB space is a standard RGB (red, green, blue) color space that HP and Microsoft created cooperatively in 1996 to use on monitors, printers, and the Web. SRGB stands for \"Standard RGB\". It is the most widely used color space and is supported by most operating systems, software programs, monitors, and printers. Learn about sRGB ColorAide Details Channel Aliases: Channels Aliases r red g green b blue Inputs: Parsed input and string output formats support all valid CSS forms: black // Color name # RRGGBBAA // Hex rgb ( r g b / a ) // RGB function rgb ( r , g , b ) // Legacy RGB Function rgba ( r , g , b , a ) // Legacy RGBA function color ( srgb r g b / a ) // Color function When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"srgb\" , [ 0 , 0 , 0 ], 1 ) Output: The string representation of the color object will always default to the color ( srgb r g b / a ) form, but the default string output will be the rgb ( r g b / a ) form. >>> Color ( \"srgb\" , [ 0 , 0 , 0 ], 1 ) color(srgb 0 0 0 / 1) >>> Color ( \"srgb\" , [ 0 , 0 , 0 ], 1 ) . to_string () rgb(0 0 0) Color(\"srgb\", [0, 0, 0], 1) Color(\"srgb\", [0, 0, 0], 1).to_string() Edit Share Run Cancel","title":"sRGB"},{"location":"colors/#srgb-linear","text":"Properties Name: srgb-linear White Point: D65 Coordinates: Name Range r [0, 1] g [0, 1] b [0, 1] CIE 1931 xy Chromaticity -- sRGB Linear Chromaticities The sRGB Linear space is the same as sRGB except that the transfer function is linear-light (there is no gamma-encoding). Learn about sRGB ColorAide Details Channel Aliases: Channels Aliases r red g green b blue Inputs: Parsed input and string output formats support all valid CSS forms: color ( srgb-linear r g b / a ) // Color function When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"srgb-linear\" , [ 0 , 0 , 0 ], 1 ) Output: The string representation of the color object and the default string output will be in the color ( srgb-linear r g b / a ) form. >>> Color ( \"srgb-linear\" , [ 0 , 0 , 0 ], 1 ) color(srgb-linear 0 0 0 / 1) >>> Color ( \"srgb-linear\" , [ 0 , 0 , 0 ], 1 ) . to_string () color(srgb-linear 0 0 0) Color(\"srgb-linear\", [0, 0, 0], 1) Color(\"srgb-linear\", [0, 0, 0], 1).to_string() Edit Share Run Cancel","title":"sRGB Linear"},{"location":"colors/#display-p3","text":"Properties Name: display-p3 White Point: D65 Coordinates: Name Range r [0, 1] g [0, 1] b [0, 1] CIE 1931 xy Chromaticity -- Display P3 Chromaticities Display P3 is a combination of the DCI-P3 color gamut with the D65 white point together with the sRGB gamma curve. It originated from the DCI-P3 color gamut's implementation in digital cinema projectors, as this standard offers more vibrant greens and reds than the traditional sRGB color gamut. Learn about Display P3 ColorAide Details Channel Aliases: Channels Aliases r red g green b blue Inputs Parsed input and string output formats support all valid CSS forms: color ( display-p3 r g b / a ) // Color function When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"display-p3\" , [ 0 , 0 , 0 ], 1 ) Output The string representation of the color object and the default string output will be in the color ( display-p3 r g b / a ) form. >>> Color ( \"display-p3\" , [ 0 , 0 , 0 ], 1 ) color(display-p3 0 0 0 / 1) >>> Color ( \"display-p3\" , [ 0 , 0 , 0 ], 1 ) . to_string () color(display-p3 0 0 0) Color(\"display-p3\", [0, 0, 0], 1) Color(\"display-p3\", [0, 0, 0], 1).to_string() Edit Share Run Cancel","title":"Display P3"},{"location":"colors/#a98-rgb","text":"Properties Name: a98-rgb White Point: D65 Coordinates: Name Range r [0, 1] g [0, 1] b [0, 1] CIE 1931 xy Chromaticity -- Adobe RGB 1998 Chromaticities The Adobe RGB (1998) color space or opRGB is a color space developed by Adobe Systems, Inc. in 1998. It was designed to encompass most of the colors achievable on CMYK color printers, but by using RGB primary colors on a device such as a computer display. The Adobe RGB (1998) color space encompasses roughly 50% of the visible colors specified by the CIELAB color space - improving upon the gamut of the sRGB color space, primarily in cyan-green hues. Learn about A98 RGB ColorAide Details Channel Aliases: Channels Aliases r red g green b blue Inputs: Parsed input and string output formats support all valid CSS forms: color ( a98-rgb r g b / a ) // Color function When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"a98-rgb\" , [ 0 , 0 , 0 ], 1 ) Output The string representation of the color object and the default string output will be in the color ( a98-rgb r g b / a ) form. >>> Color ( \"a98-rgb\" , [ 0 , 0 , 0 ], 1 ) color(a98-rgb 0 0 0 / 1) >>> Color ( \"a98-rgb\" , [ 0 , 0 , 0 ], 1 ) . to_string () color(a98-rgb 0 0 0) Color(\"a98-rgb\", [0, 0, 0], 1) Color(\"a98-rgb\", [0, 0, 0], 1).to_string() Edit Share Run Cancel","title":"A98 RGB"},{"location":"colors/#rec-2020","text":"Properties Name: rec2020 White Point: D65 Coordinates: Name Range r [0, 1] g [0, 1] b [0, 1] CIE 1931 xy Chromaticity -- Rec. 2020 Chromaticities The Rec. 2020 color space is a very wide gamut RGB color space which is used in 4k and 8k UHDTV. ITU-R Recommendation BT.2020, more commonly known by the abbreviations Rec. 2020 or BT.2020, defines various aspects of ultra-high-definition television (UHDTV) with standard dynamic range (SDR) and wide color gamut (WCG), including picture resolutions, frame rates with progressive scan, bit depths, color primaries, RGB and luma-chroma color representations, chroma subsamplings, and an opto-electronic transfer function. Learn about REC.2020 ColorAide Details Channel Aliases: Channels Aliases r red g green b blue Inputs: Parsed input and string output formats support all valid CSS forms: color ( rec2020 r g b / a ) // Color function When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"rec2020\" , [ 0 , 0 , 0 ], 1 ) Output: The string representation of the color object and the default string output will be in the color ( rec2020 r g b / a ) form. >>> Color ( \"rec2020\" , [ 0 , 0 , 0 ], 1 ) color(rec2020 0 0 0 / 1) >>> Color ( \"rec2020\" , [ 0 , 0 , 0 ], 1 ) . to_string () color(rec2020 0 0 0) Color(\"rec2020\", [0, 0, 0], 1) Color(\"rec2020\", [0, 0, 0], 1).to_string() Edit Share Run Cancel","title":"REC. 2020"},{"location":"colors/#prophoto","text":"Properties Name: prophoto-rgb White Point: D50 Coordinates: Name Range r [0, 1] g [0, 1] b [0, 1] CIE 1931 xy Chromaticity -- ProPhoto RGB Chromaticities The ProPhoto RGB color space, also known as ROMM RGB (Reference Output Medium Metric), is an output referred RGB color space developed by Kodak. It offers an especially large gamut designed for use with photographic output in mind. The ProPhoto RGB color space encompasses over 90% of possible surface colors in the CIE L*a*b* color space, and 100% of likely occurring real-world surface colors documented by Pointer in 1980. ColorAide Details Channel Aliases: Channels Aliases r red g green b blue Inputs: Parsed input and string output formats support all valid CSS forms: color ( prophoto-rgb r g b / a ) // Color function When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"prophoto-rgb\" , [ 0 , 0 , 0 ], 1 ) Output: The string representation of the color object and the default string output will be in the color ( prophoto-rgb r g b / a ) form. >>> Color ( \"prophoto-rgb\" , [ 0 , 0 , 0 ], 1 ) color(prophoto-rgb 0 0 0 / 1) >>> Color ( \"prophoto-rgb\" , [ 0 , 0 , 0 ], 1 ) . to_string () color(prophoto-rgb 0 0 0) Color(\"prophoto-rgb\", [0, 0, 0], 1) Color(\"prophoto-rgb\", [0, 0, 0], 1).to_string() Edit Share Run Cancel Learn about ProPhoto","title":"ProPhoto"},{"location":"colors/#cylindrical-srgb-spaces","text":"The sRGB color space has been represented in a number of cylindrical models. Each model was an attempt to either align the color with human perception or make it more intuitive to work with. The term \"cylindrical\" is used as the spaces take on the shape of a cylinder, whereas the RGB model is very much a cube: sRGB color space in 3D","title":"Cylindrical sRGB Spaces"},{"location":"colors/#hsv","text":"Properties Name: hsv White Point: D65 Coordinates: Name Range h [0, 360) s [0, 1] v [0, 1] HSV color space in 3D HSV is a color space similar to the modern RGB and CMYK models. The HSV color space has three components: hue, saturation and value. 'Value' is sometimes substituted with 'brightness' and then it is known as HSB. HSV models how colors appear under light. Learn about HSV ColorAide Details Channel Aliases: Channels Aliases h hue s saturation v value Inputs: HSV is not supported via the CSS spec and the parser input and string output only supports the color () function format using the custom name --hsv : color ( --hsv 0 0 % 0 % / 1 ) When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"hsv\" , [ 0 , 0 , 0 ], 1 ) Output: The string representation of the color object and default string output will always use the color ( hsv h s v / a ) form. >>> Color ( \"hsv\" , [ 0 , 0 , 0 ], 1 ) color(--hsv 0 0 0 / 1) >>> Color ( \"hsv\" , [ 0 , 0 , 0 ], 1 ) . to_string () color(--hsv 0 0 0) Color(\"hsv\", [0, 0, 0], 1) Color(\"hsv\", [0, 0, 0], 1).to_string() Edit Share Run Cancel","title":"HSV"},{"location":"colors/#hsl","text":"Properties Name: hsl White Point: D65 Coordinates: Name Range h [0, 360) s [0, 1] l [0, 1] HSL color space in 3D HSL is an alternative representations of the RGB color model, designed in the 1970s by computer graphics researchers to more closely align with the way human vision perceives color-making attributes. In these models, colors of each hue are arranged in a radial slice, around a central axis of neutral colors which ranges from black at the bottom to white at the top. HSL models the way different paints mix together to create color in the real world, with the lightness dimension resembling the varying amounts of black or white paint in the mixture. Learn about HSL ColorAide Details Channel Aliases: Channels Aliases h hue s saturation l lightness Inputs: Parsed input and string output formats support all valid CSS forms. In addition, we also allow the color () function format using the custom name --hsl : hsl ( h s l / a ) // HSL function hsl ( h , s , l ) // Legacy HSL function hsla ( h , s , l , a ) // Legacy HSLA function color ( --hsl h s l / a ) // Color function When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"hsl\" , [ 0 , 0 , 0 ], 1 ) Output: The string representation of the color object will always default to the color ( --hsl h s l / a ) form, but the default string output will be the hsl ( h s l / a ) form. >>> Color ( \"hsl\" , [ 0 , 0 , 0 ], 1 ) color(--hsl 0 0 0 / 1) >>> Color ( \"hsl\" , [ 0 , 0 , 0 ], 1 ) . to_string () hsl(0 0% 0%) Color(\"hsl\", [0, 0, 0], 1) Color(\"hsl\", [0, 0, 0], 1).to_string() Edit Share Run Cancel","title":"HSL"},{"location":"colors/#hwb","text":"Properties Name: hwb White Point: D65 Coordinates: Name Range h [0, 360) w [0, 1] b [0, 1] HWB color space in 3D HWB is a cylindrical-coordinate representation of points in an RGB color model, similar to HSL and HSV. It was developed by HSV 's creator Alvy Ray Smith in 1996 to address some of the issues with HSV. HWB was designed to be more intuitive for humans to use and slightly faster to compute. The first coordinate, H (Hue), is the same as the Hue coordinate in HSL and HSV . W and B stand for Whiteness and Blackness respectively and range from 0-100% (or 0-1). The mental model is that the user can pick a main hue and then \"mix\" it with white and/or black to produce the desired color. Learn about HWB ColorAide Details Channel Aliases: Channels Aliases h hue w whiteness b blackness Inputs: Parsed input and string output formats support all valid CSS forms. In addition, we also allow the color () function format using the custom name --hwb : hwb ( h w b / a ) // HWB function color ( --hwb h w b / a ) // Color function When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"hwb\" , [ 0 , 0 , 100 ], 1 ) Output: The string representation of the color object will always default to the color ( --hwb h w b / a ) form, but the default string output will be the hwb ( h s l / a ) form. >>> Color ( \"hwb\" , [ 0 , 0 , 100 ], 1 ) color(--hwb 0 0 100 / 1) >>> Color ( \"hwb\" , [ 0 , 0 , 100 ], 1 ) . to_string () hwb(0 0% 100%) Color(\"hwb\", [0, 0, 100], 1) Color(\"hwb\", [0, 0, 100], 1).to_string() Edit Share Run Cancel","title":"HWB"},{"location":"colors/#okhsv","text":"Properties Name: okhsv White Point: D65 Coordinates: Name Range h [0, 360) s [0, 1] v [0, 1] Okhsv color space in 3D Okhsv is a color space created by Bj\u00f6rn Ottosson. It is based off his early work and leverages the Oklab color space. The aim was to create a color space that was better suited for being used in color pickers than the current HSV. Learn about Okhsv ColorAide Details Channel Aliases: Channels Aliases h hue s saturation v value Inputs: Okhsv is not currently supported in the CSS spec, the parsed input and string output formats use the color () function format using the custom name --okhsv : color ( --okhsv h s l / a ) // Color function When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"okhsv\" , [ 0 , 0 , 0 ], 1 ) Output: The string representation of the color object and the default string output use the color ( --okhsv h s l / a ) form. >>> Color ( \"okhsv\" , [ 0 , 0 , 0 ], 1 ) color(--okhsv 0 0 0 / 1) >>> Color ( \"okhsv\" , [ 0 , 0 , 0 ], 1 ) . to_string () color(--okhsv 0 0 0) Color(\"okhsv\", [0, 0, 0], 1) Color(\"okhsv\", [0, 0, 0], 1).to_string() Edit Share Run Cancel","title":"Okhsv"},{"location":"colors/#okhsl","text":"Properties Name: okhsl White Point: D65 Coordinates: Name Range h [0, 360) s [0, 1] l [0, 1] Okhsl color space in 3D Okhsl is a another color space created by Bj\u00f6rn Ottosson. It is based off his early work and leverages the Oklab color space. The aim was to create a color space that was better suited for being used in color pickers than the current HSL. Learn about Okhsv ColorAide Details Channel Aliases: Channels Aliases h hue s saturation l lightness Inputs: Okhsl is not currently supported in the CSS spec, the parsed input and string output formats use the color () function format using the custom name --okhsl : color ( --okhsl h s l / a ) // Color function When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"okhsl\" , [ 0 , 0 , 0 ], 1 ) Output: The string representation of the color object and the default string output use the color ( --okhsl h s l / a ) form. >>> Color ( \"okhsl\" , [ 0 , 0 , 0 ], 1 ) color(--okhsl 0 0 0 / 1) >>> Color ( \"okhsl\" , [ 0 , 0 , 0 ], 1 ) . to_string () color(--okhsl 0 0 0) Color(\"okhsl\", [0, 0, 0], 1) Color(\"okhsl\", [0, 0, 0], 1).to_string() Edit Share Run Cancel","title":"Okhsl"},{"location":"colors/#hsluv","text":"Properties Name: hsluv White Point: D65 Coordinates: Name Range h [0, 360) s [0, 100] l [0, 100] HSLuv color space in 3D HSLuv is a human-friendly alternative to HSL. It was formerly known as \"HUSL\" and is a variation of the CIELCH uv color space, where the chroma component is replaced by a saturation component which allows you to span all the available chroma as a percentage. HSLuv is constrained to the sRGB gamut. Learn about HSLuv ColorAide Details Channel Aliases: Channels Aliases h hue s saturation l lightness Inputs: HSLuv is not currently supported in the CSS spec, the parsed input and string output formats use the color () function format using the custom name --hsluv : color ( --hsluv h s l / a ) // Color function When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"hsluv\" , [ 0 , 0 , 0 ], 1 ) Output: The string representation of the color object and the default string output use the color ( --hsluv h s l / a ) form. >>> Color ( \"hsluv\" , [ 0 , 0 , 0 ], 1 ) color(--hsluv 0 0 0 / 1) >>> Color ( \"hsluv\" , [ 0 , 0 , 0 ], 1 ) . to_string () color(--hsluv 0 0 0) Color(\"hsluv\", [0, 0, 0], 1) Color(\"hsluv\", [0, 0, 0], 1).to_string() Edit Share Run Cancel","title":"HSLuv"},{"location":"colors/#xyz","text":"The 1931 CIE XYZ color space encompasses all colors that are visible to a person with average eyesight. It also contains many colors that the human eye cannot see: CIE 1931 xy Chromaticity -- overlaid with the XYZ D65 space. In many color libraries, it is used as a space through which different color conversions are passed through as it is large enough to contain all visible colors. Many conversions use matrices based on this space to do chromatic adaption or just direct translations. While the chromaticity diagrams we've shown all use XYZ with a D65 white point to help generate them, XYZ can be represented with other white points as well. CSS actually allows using either XYZ D50 or XYZ D65 . We also provide both.","title":"XYZ"},{"location":"colors/#xyz-d65","text":"Properties Name: xyz-d65 White Point: D65 Coordinates: Name Range x [0.0, 0.95] * y [0.0, 1.0] * z [0.0, 1.089] * * \u2248 range in relation to sRGB rounded to 3 decimal places. Approximation 1 of the sRGB gamut represented within the XYZ D65 color space. The CIE 1931 RGB color space and CIE 1931 XYZ color space were created by the International Commission on Illumination (CIE) in 1931. They resulted from a series of experiments done in the late 1920s by William David Wright using ten observers and John Guild using seven observers. The experimental results were combined into the specification of the CIE RGB color space, from which the CIE XYZ color space was derived. The CIE 1931 color spaces are the first defined quantitative links between distributions of wavelengths in the electromagnetic visible spectrum, and physiologically perceived colors in human color vision. Learn about XYZ ColorAide Details Channel Aliases: Channels Aliases x y z Inputs: Parsed input and string output formats use the color () format with either xyz-d65 or xyz as the identifier with the latter being an alias of the former. color ( xyz x y z / a ) // Color function color ( xyz-d65 x y z / a ) // Color function alternate name When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"xyz-d65\" , [ 0 , 0 , 0 ], 1 ) Output: The string representation of the color object and the default string output will be in the color ( xyz-d65 x y z / a ) form. >>> Color ( \"xyz-d65\" , [ 0 , 0 , 0 ], 1 ) color(xyz-d65 0 0 0 / 1) >>> Color ( \"xyz-d65\" , [ 0 , 0 , 0 ], 1 ) . to_string () color(xyz-d65 0 0 0) Color(\"xyz-d65\", [0, 0, 0], 1) Color(\"xyz-d65\", [0, 0, 0], 1).to_string() Edit Share Run Cancel","title":"XYZ D65"},{"location":"colors/#xyz-d50","text":"Properties Name: xyz-d50 White Point: D50 Coordinates: Name Range x [0.0, 0.964] * y [0.0, 1.0] * z [0.0, 0.825] * * \u2248 range in relation to sRGB rounded to 3 decimal places. Approximation 1 of the sRGB gamut represented within the XYZ D50 color space. XYZ D50 is the same as XYZ D65 except it uses a D50 white point. Learn about XYZ ColorAide Details Channel Aliases: Channels Aliases x y z Inputs: Parsed input and string output formats support all valid CSS forms: color ( xyz-d50 x y z / a ) // Color function When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"xyz-d50\" , [ 0 , 0 , 0 ], 1 ) Output: The string representation of the color object and the default string output will be in the color ( xyz x y z / a ) form. >>> Color ( \"xyz-d50\" , [ 0 , 0 , 0 ], 1 ) color(xyz-d50 0 0 0 / 1) >>> Color ( \"xyz-d50\" , [ 0 , 0 , 0 ], 1 ) . to_string () color(xyz-d50 0 0 0) Color(\"xyz-d50\", [0, 0, 0], 1) Color(\"xyz-d50\", [0, 0, 0], 1).to_string() Edit Share Run Cancel","title":"XYZ D50"},{"location":"colors/#cielab","text":"CIELAB \u2013 also referred to as L*a*b* \u2013 is another CIE color space. it was created as a perceptually uniform color space. CIELAB doesn't really have a gamut, and pretty much any other color space can be mapped to it. Much like XYZ , CIELAB and CIELCH currently use a D50 white point just like the CSS, but we've also included variants with D65 white points as well.","title":"CIELAB"},{"location":"colors/#cielab-d50","text":"Properties Name: lab White Point: D50 Coordinates: Name Range l [0, 100] * a [-79.287, 93.55] * b [-112.029, 93.388] * * \u2248 range in relation to sRGB rounded to 3 decimal places. Approximation 1 of the sRGB gamut represented within the CIELAB D50 color space. The CIELAB color space also referred to as L*a*b* is a color space defined by the International Commission on Illumination (abbreviated CIE) in 1976. It expresses color as three values: L* for perceptual lightness, and a* and b* for the four unique colors of human vision: red, green, blue, and yellow. CIELAB was intended as a perceptually uniform space, where a given numerical change corresponds to similar perceived change in color. While the CIELAB space is not truly perceptually uniform, it nevertheless is useful in industry for detecting small differences in color. Learn about CIELAB ColorAide Details Channel Aliases: Channels Aliases l lightness a b Inputs: Parsed input and string output formats support all valid CSS forms. In addition, we also allow the color () function format using the custom name --lab : lab ( l a b / a ) // Lab function color ( --lab l a b / a ) // Color function When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"lab\" , [ 0 , 0 , 0 ], 1 ) Output: The string representation of the color object will always default to the color ( --lab l a b / a ) form, but the default string output will be the lab ( l a b / a ) form. >>> Color ( \"lab\" , [ 0 , 0 , 0 ], 1 ) color(--lab 0 0 0 / 1) >>> Color ( \"lab\" , [ 0 , 0 , 0 ], 1 ) . to_string () lab(0% 0 0) Color(\"lab\", [0, 0, 0], 1) Color(\"lab\", [0, 0, 0], 1).to_string() Edit Share Run Cancel","title":"CIELAB D50"},{"location":"colors/#cielab-d65","text":"Properties Name: lab-d65 White Point: D65 Coordinates: Name Range l [0, 100] * a [-86.183, 98.234] * b [-107.86, 94.478] * * \u2248 range in relation to sRGB rounded to 3 decimal places. Approximation 1 of the sRGB gamut represented within the CIELAB D50 color space. CIELAB D65 is the same as CIELAB except it uses a D65 white point. Learn about CIELAB ColorAide Details Channel Aliases: Channels Aliases l lightness a b Inputs: As a D65 variant of CIELAB is not currently supported in the CSS spec, the parsed input and string output formats use the color () function format using the custom name --lab-d65 : color ( --lab-d65 l a b / a ) // Color function When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"lab-d65\" , [ 0 , 0 , 0 ], 1 ) Output: The string representation of the color object and the default string output use the color ( --lab-d65 l a b / a ) form. >>> Color ( \"lab-d65\" , [ 0 , 0 , 0 ], 1 ) color(--lab-d65 0 0 0 / 1) >>> Color ( \"lab-d65\" , [ 0 , 0 , 0 ], 1 ) . to_string () color(--lab-d65 0 0 0) Color(\"lab-d65\", [0, 0, 0], 1) Color(\"lab-d65\", [0, 0, 0], 1).to_string() Edit Share Run Cancel","title":"CIELAB D65"},{"location":"colors/#cielch","text":"CIELAB generally is not an intuitive space to work with and instead is often converted to cylindrical coordinates with hues represented as degrees and a chroma and lightness channel. The shape of the color space doesn't really change, just how the colors are manipulated. CIELCH, like CIELAB, is available with a D50 white point that matches CSS and a D65 white point.","title":"CIELCH"},{"location":"colors/#cielch-d50","text":"Properties Name: lch White Point: D50 Coordinates: Name Range l [0, 100] * c [0, 131.207] * h [0, 360) * \u2248 range in relation to sRGB rounded to 3 decimal places. Approximation 1 of the sRGB gamut represented within the CIELCH D50 color space. The \"CIELCH\" or \"CIEHLC\" space is a color space based on CIELAB , which uses the polar coordinates C* (chroma, relative saturation) and h\u00b0 (hue angle, angle of the hue in the CIELAB color wheel) instead of the Cartesian coordinates a* and b*. The CIELAB lightness L* remains unchanged. Learn about CIELCH ColorAide Details Channel Aliases: Channels Aliases l lightness c chroma h hue Inputs: Parsed input and string output formats support all valid CSS forms. In addition, we also allow the color () function format using the custom name --lch : lch ( l c h / a ) // Lch function color ( --lch l c h / a ) // Color function When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"lch\" , [ 0 , 0 , 0 ], 1 ) Output: The string representation of the color object will always default to the color ( --lch l c h / a ) form, but the default string output will be the lch ( l c h / a ) form. >>> Color ( \"lch\" , [ 0 , 0 , 0 ], 1 ) color(--lch 0 0 0 / 1) >>> Color ( \"lch\" , [ 0 , 0 , 0 ], 1 ) . to_string () lch(0% 0 0) Color(\"lch\", [0, 0, 0], 1) Color(\"lch\", [0, 0, 0], 1).to_string() Edit Share Run Cancel","title":"CIELCH D50"},{"location":"colors/#cielch-d65","text":"Properties Name: lch-d65 White Point: D65 Coordinates: Name Range l [0, 100] * c [0.0, 133.808] * h [0, 360) * \u2248 range in relation to sRGB rounded to 3 decimal places. Approximation 1 of the sRGB gamut represented within the CIELCH D65 color space. CIELCH D65 is the same as CIELCH except it uses a D65 white point. Learn about CIELCH ColorAide Details Channel Aliases: Channels Aliases l lightness c chroma h hue Inputs: As a D65 variant of CIELCH is not currently supported in the CSS spec, the parsed input and string output formats use the color () function format using the custom name --lch-d65 : color ( --lch-d65 l c h / a ) // Color function When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"lch-d65\" , [ 0 , 0 , 0 ], 1 ) Outputs: The string representation of the color object and the default string output use the color ( --lch-d65 l c h / a ) form. >>> Color ( \"lch-d65\" , [ 0 , 0 , 0 ], 1 ) color(--lch-d65 0 0 0 / 1) >>> Color ( \"lch-d65\" , [ 0 , 0 , 0 ], 1 ) . to_string () color(--lch-d65 0 0 0) Color(\"lch-d65\", [0, 0, 0], 1) Color(\"lch-d65\", [0, 0, 0], 1).to_string() Edit Share Run Cancel","title":"CIELCH D65"},{"location":"colors/#oklab","text":"Properties Name: oklab White Point: D65 Coordinates: Name Range l [0, 1] * a [-0.234, 0.276] * b [-0.312, 0.198] * * \u2248 range in relation to sRGB rounded to 3 decimal places. Approximation 1 of the sRGB gamut represented within the Oklab color space. A new perceptual color space that claims to be simple to use, while doing a good job at predicting perceived lightness, chroma and hue. It is called the Oklab color space, because it is an OK Lab color space. Learn about Oklab ColorAide Details Channel Aliases: Channels Aliases l lightness a b Inputs: Oklab is not currently supported in the CSS spec, the parsed input and string output formats use the color () function format using the custom name --oklab : oklab ( l a b / a ) // Oklab function color ( --oklab l a b / a ) // Color function When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"oklab\" , [ 0 , 0 , 0 ], 1 ) Output: The string representation of the color object will always default to the color ( --oklab l a b / a ) form, but the default string output will be the oklab ( l a b / a ) form. >>> Color ( \"oklab\" , [ 0 , 0 , 0 ], 1 ) color(--oklab 0 0 0 / 1) >>> Color ( \"oklab\" , [ 0 , 0 , 0 ], 1 ) . to_string () oklab(0% 0 0) Color(\"oklab\", [0, 0, 0], 1) Color(\"oklab\", [0, 0, 0], 1).to_string() Edit Share Run Cancel","title":"Oklab"},{"location":"colors/#oklch","text":"Properties Name: oklch White Point: D65 Coordinates: Name Range l [0, 1] * c [0, 0.323] * h [0, 360) * \u2248 range in relation to sRGB rounded to 3 decimal places. Approximation 1 of the sRGB gamut represented within the Oklch color space. Oklch is the cylindrical form of Oklab . Learn about Oklch ColorAide Details Channel Aliases: Channels Aliases l lightness c chroma h hue Inputs Oklab is not currently supported in the CSS spec, the parsed input and string output formats use the color () function format using the custom name --oklch : oklch ( l c h / a ) // Oklch function color ( --oklch l c h / a ) // Color function Output: The string representation of the color object will always default to the color ( --oklch l c h / a ) form, but the default string output will be the oklch ( l a b / a ) form. >>> Color ( \"oklch\" , [ 0 , 0 , 0 ], 1 ) color(--oklch 0 0 0 / 1) >>> Color ( \"oklch\" , [ 0 , 0 , 0 ], 1 ) . to_string () oklch(0% 0 0) Color(\"oklch\", [0, 0, 0], 1) Color(\"oklch\", [0, 0, 0], 1).to_string() Edit Share Run Cancel","title":"Oklch"},{"location":"colors/#cieluv","text":"Properties Name: luv White Point: D65 Coordinates: Name Range l [0, 100] * u [-83.067, 175.01] * v [-134.11, 107.418] * * \u2248 range in relation to sRGB rounded to 3 decimal places. Approximation 1 of the sRGB gamut represented within the CIELUV D65 color space. CIELUV is similar to CIELAB as they were both developed in 1976 as perceptually uniform color spaces, both are derived from the color experiments in 1931 that brought us the XYZ color space, and neither are truly perceptually uniform. The difference between the two comes from their intent. CIELAB attempted to create a space that aligned well with human vision. CIELUV, on the other hand, was designed to be an easier-to-compute transformation of the 1931 CIE XYZ color space. CIELAB is more commonly used in subtractive color applications (printed pages, dyes, etc.), while CIELUV is better suited in additive color applications such as display colorimetry (monitors, TVs, etc.). Learn about CIELUV ColorAide Details Channel Aliases: Channels Aliases l lightness u v Inputs: As CIELUV D65 is not currently supported in the CSS spec, the parsed input and string output formats use the color () function format using the custom name --luv : color ( --luv l u v / a ) // Color function When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"luv\" , [ 0 , 0 , 0 ], 1 ) Outputs The string representation of the color object and the default string output use the color ( --luv l u v / a ) form. >>> Color ( \"luv\" , [ 0 , 0 , 0 ], 1 ) color(--luv 0 0 0 / 1) >>> Color ( \"luv\" , [ 0 , 0 , 0 ], 1 ) . to_string () color(--luv 0 0 0) Color(\"luv\", [0, 0, 0], 1) Color(\"luv\", [0, 0, 0], 1).to_string() Edit Share Run Cancel","title":"CIELUV"},{"location":"colors/#cielchuv","text":"Properties Name: lchuv White Point: D65 Coordinates: Name Range l [0, 100] * c [0, 179.038] * h [0, 360) * \u2248 range in relation to sRGB rounded to 3 decimal places. Approximation 1 of the sRGB gamut represented within the CIELCH uv color space. CIELUV is not an intuitive space to work with directly and instead is often converted to cylindrical coordinates with hues represented as degrees and a chroma and lightness channel. The shape of the color space doesn't really change, just how the colors are manipulated. Learn about CIELCH uv ColorAide Details Channel Aliases: Channels Aliases l lightness c chroma h hue Inputs: As CIELCH uv is not currently supported in the CSS spec, the parsed input and string output formats use the color () function format using the custom name --lchuv : color ( --lchuv l c h / a ) // Color function When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"lchuv\" , [ 0 , 0 , 0 ], 1 ) Output: The string representation of the color object and the default string output use the color ( --lchuv l c h / a ) form. >>> Color ( \"lchuv\" , [ 0 , 0 , 0 ], 1 ) color(--lchuv 0 0 0 / 1) >>> Color ( \"lchuv\" , [ 0 , 0 , 0 ], 1 ) . to_string () color(--lchuv 0 0 0) Color(\"lchuv\", [0, 0, 0], 1) Color(\"lchuv\", [0, 0, 0], 1).to_string() Edit Share Run Cancel","title":"CIELCHuv"},{"location":"colors/#jzazbz","text":"Properties Name: jzazbz White Point: D65 Coordinates: Name Range jz [0, 0.222] * az [-0.109, 0.13] * bz [-0.186, 0.135] * * \u2248 range in relation to sRGB rounded to 3 decimal places. Approximation 1 of the sRGB gamut represented within the Jzazbz color space. Jzazbz is a a color space designed for perceptual uniformity in high dynamic range (HDR) and wide color gamut (WCG) applications. Conceptually it is similar to CIELAB , but claims the following improvements: Perceptual color difference is predicted by Euclidean distance. Perceptually uniform: MacAdam ellipses of just-noticeable-difference ( JND ) are more circular, and closer to the same sizes. Hue linearity: changing saturation or lightness has less shift in hue. Learn about Jzazbz ColorAide Details Channel Aliases: Channels Aliases jz lightness az a bz b Inputs As Jzazbz is not currently supported in the CSS spec, the parsed input and string output formats use the color () function format using the custom name --jzazbz : color ( --jzazbz jz az bz / a ) // Color function When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"jzazbz\" , [ 0 , 0 , 0 ], 1 ) Output The string representation of the color object and the default string output use the color ( --jzazbz jz az bz / a ) form. >>> Color ( \"jzazbz\" , [ 0 , 0 , 0 ], 1 ) color(--jzazbz 0 0 0 / 1) >>> Color ( \"jzazbz\" , [ 0 , 0 , 0 ], 1 ) . to_string () color(--jzazbz 0 0 0) Color(\"jzazbz\", [0, 0, 0], 1) Color(\"jzazbz\", [0, 0, 0], 1).to_string() Edit Share Run Cancel","title":"Jzazbz"},{"location":"colors/#jzczhz","text":"Properties Name: jzczhz White Point: D65 Coordinates: Name Range jz [0, 0.222] * cz [0, 0.190] * hz [0, 360) * \u2248 range in relation to sRGB rounded to 3 decimal places. Approximation 1 of the sRGB gamut represented within the JzCzhz color space. JzCzhz is the cylindrical form of Jzazbz . Learn about JzCzhz ColorAide Details Channel Aliases: Channels Aliases jz lightness cz chroma hz hue Inputs As JzCzhz is not currently supported in the CSS spec, the parsed input and string output formats use the color () function format using the custom name --jzczhz : color ( --jzczhz jz cz hz / a ) // Color function When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"jzczhz\" , [ 0 , 0 , 0 ], 1 ) Output The string representation of the color object and the default string output use the color ( --jzczhz jz cz hz / a ) form. >>> Color ( \"jzczhz\" , [ 0 , 0 , 0 ], 1 ) color(--jzczhz 0 0 0 / 1) >>> Color ( \"jzczhz\" , [ 0 , 0 , 0 ], 1 ) . to_string () color(--jzczhz 0 0 0) Color(\"jzczhz\", [0, 0, 0], 1) Color(\"jzczhz\", [0, 0, 0], 1).to_string() Edit Share Run Cancel","title":"JzCzhz"},{"location":"colors/#ictcp","text":"Properties Name: ictcp White Point: D65 Coordinates: Name Range i [0, 0.581] * ct [-0.281, 0.277] * cp [-0.161, 0.279] * * \u2248 range in relation to sRGB rounded to 3 decimal places. Approximation 1 of the sRGB gamut represented within the ICtCp color space. ICtCp is a color space format with better perceptual uniformity than CIELAB and is used as a part of the color image pipeline in video and digital photography systems for high dynamic range (HDR) and wide color gamut (WCG) imagery. It was developed by Dolby Laboratories from the IPT color space by Ebner and Fairchild. It was designed with the intention to replace YCbCr. Learn about ICtCp ColorAide Details Channel Aliases: Channels Aliases i ct cp Inputs: As ICtCp is not currently supported in the CSS spec, the parsed input and string output formats use the color () function format using the custom name --ictcp : color ( --ictcp i ct cp / a ) // Color function When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"ictcp\" , [ 0 , 0 , 0 ], 1 ) Output: The string representation of the color object and the default string output use the color ( --ictcp i ct cp / a ) form. >>> Color ( \"ictcp\" , [ 0 , 0 , 0 ], 1 ) color(--ictcp 0 0 0 / 1) >>> Color ( \"ictcp\" , [ 0 , 0 , 0 ], 1 ) . to_string () color(--ictcp 0 0 0) Color(\"ictcp\", [0, 0, 0], 1) Color(\"ictcp\", [0, 0, 0], 1).to_string() Edit Share Run Cancel","title":"ICtCp"},{"location":"colors/#din99o","text":"Properties Name: din99o White Point: D65 Coordinates: Name Range l [0, 100] * a [-40.09, 45.501] * b [-40.47, 44.344] * * \u2248 range in relation to sRGB rounded to 3 decimal places. Approximation 1 of the sRGB gamut represented within the DIN99o color space. The DIN99 color space system is a further development of the CIELAB color space system developed by the FNF / FNL 2 Colorimetry Working Committee. It takes the CIELAB space (with a D65 illuminant) and compresses it such that the space yields better equidistant using Euclidean distance. The whole color space is essentially modified to better fit the color distancing algorithm opposed to CIELAB which has adapted the color distancing algorithm to better fit the color space, the latest iteration being \u2206E * 00 . Learn about DIN99o ColorAide Details Channel Aliases: Channels Aliases l lightness a b Inputs: As DIN99o is not currently supported in the CSS spec, the parsed input and string output formats use the color () function format using the custom name --din99o : color ( --din99o l u v / a ) // Color function When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"din99o\" , [ 0 , 0 , 0 ], 1 ) Output: The string representation of the color object and the default string output use the color ( --din99o l u v / a ) form. >>> Color ( \"din99o\" , [ 0 , 0 , 0 ], 1 ) color(--din99o 0 0 0 / 1) >>> Color ( \"din99o\" , [ 0 , 0 , 0 ], 1 ) . to_string () color(--din99o 0 0 0) Color(\"din99o\", [0, 0, 0], 1) Color(\"din99o\", [0, 0, 0], 1).to_string() Edit Share Run Cancel","title":"DIN99o"},{"location":"colors/#din99o-lch","text":"Properties Name: lch99o White Point: D65 Coordinates: Name Range l [0, 100] * c [0, 51.484] * h [0, 360) * \u2248 range in relation to sRGB rounded to 3 decimal places. Approximation 1 of the sRGB gamut represented within the DIN99o Lch color space. DIN99o Lch is the cylindrical form of DIN99o . Learn about DIN99o Lch ColorAide Details Channel Aliases: Channels Aliases l lightness c chroma h hue Inputs: As DIN99o Lch is not currently supported in the CSS spec, the parsed input and string output formats use the color () function format using the custom name --lch99o : color ( --lch99o jz cz hz / a ) // Color function When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used: Color ( \"lch99o\" , [ 0 , 0 , 0 ], 1 ) Output: The string representation of the color object and the default string output use the color ( --lch99o jz cz hz / a ) form. >>> Color ( \"lch99o\" , [ 0 , 0 , 0 ], 1 ) color(--lch99o 0 0 0 / 1) >>> Color ( \"lch99o\" , [ 0 , 0 , 0 ], 1 ) . to_string () color(--lch99o 0 0 0) Color(\"lch99o\", [0, 0, 0], 1) Color(\"lch99o\", [0, 0, 0], 1).to_string() Edit Share Run Cancel .info-container {display: inline-block;} For the purposes of speed, 3D models are calculated by taking points on the outer shell of the sRGB gamut and mapping those points to the color space of interest. While a more accurate model could be made by taking all points into account, this approach gives a fairly good approximation of the shape of the sRGB gamut within the targeted color space. \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9","title":"DIN99o Lch"},{"location":"plugins/","text":"ColorAide Plugins ColorAide implements extendable portions of the Color object as plugins. This makes adding things such as new \u2206E methods or even new color spaces quite easy. Currently, ColorAide implements the following areas as plugins: \u2206E methods Gamut mapping Color spaces Delta E \u2206E plugins allow for getting color differences with different methods. ColorAide provides a number of methods by default which are documented under Color Distance and Delta E . All of the default \u2206E methods are provided as plugins, and users can create their own as well. Plugin Class \u2206E plugins are subclassed from coloraide . distance . DeltaE . class DeltaE ( ABCMeta ): \"\"\"Delta E plugin class.\"\"\" NAME = '' @classmethod @abstractmethod def distance ( cls , color : 'Color' , sample : 'Color' , ** kwargs : Any ) -> float : \"\"\"Get distance between color and sample.\"\"\" The plugin should provide a unique NAME and the distancing logic under distance () where color is the current color and sample is the secondary, provided color: Color ( 'color' ) . delta_e ( 'sample' , method = 'NAME' ) . The return value should be a float indicating the distance. Additional plugin specific options can be provided via new keyword arguments. Fit/Gamut Mapping Fit plugins (or gamut mapping plugins) allow for mapping an out of gamut color to be within the current color space's gamut. All default gamut mapping methods provided by ColorAide are provided via plugins. Plugin Class Plugins are are created by subclassing coloraide . gamut . Fit . class Fit ( ABCMeta ): \"\"\"Fit plugin class.\"\"\" NAME = '' @classmethod @abstractmethod def fit ( cls , color : 'Color' , ** kwargs ) -> None : \"\"\"Get coordinates of the new gamut mapped color.\"\"\" The plugin should provide a unique NAME and the fitting/mapping logic under fit () . The method does not return anything and should modify the color directly to be in gamut. Reserved Name clip is a special, reserved name and the associated plugin cannot be overridden. Another clip plugin can be written, but it cannot override the original. Color Space All color spaces supported by ColorAide are specified via color space plugins. These Space objects specify color channel properties, gamut bounds, input matching/parsing logic, string output logic, conversion to and from a specified base color, etc. Color space plugins are a little more complex compared to Delta E and Fit plugins. Plugin Class In general, a color space plugin is created by subclassing from coloraide . spaces . Space . When defining a color space, there are a couple things that must be defined. Using XYZ as an example, we will go over them. Chromatic Adaptation Color spaces do not perform chromatic adaptation. That is handled by the Color object. Color spaces should never change the white point, but simply provide the appropriate BASE linkage so that the color can resolve eventually to XYZ D65. Other XYZ color spaces should all have xyz-d65 as their base. Chromatic adaptation should automatically occur on transitions between two XYZ spaces with different white points white points, e.g., xyz-d65 to xyz-d50 . from coloraide import cat from coloraide.gamut import bounds class XYZD65 ( Space ): \"\"\"XYZ D65 class.\"\"\" # A base color though which a color is converted through. # XYZ is our absolute base, so it doesn't have a real base, # but something like HSL might have a base color of `srgb`. BASE = \"xyz-d65\" # The name of the color space. NAME = \"xyz-d65\" # One or more accepted identifiers that are allowed for the `color(space ...)` format. # For this this specific color space, both `color(xyz x y z / a)` and `color(xyz-d65 x y z / a)` are accepted. # As `xyz` is listed first, `xyz` is the default used when printing in this format. SERIALIZE = ( \"xyz-d65\" , \"xyz\" ) # Channel names for non-alpha channels listed in order of how they are stored. CHANNEL_NAMES = ( \"x\" , \"y\" , \"z\" ) # A dictionary containing a mapping of aliases to `CHANNEL_NAMES` found above. CHANNEL_ALIASES = {} # If you'd like this color space to parse as a `color(space ...)` format. # If set to `False` the space will not recognize the color format as an input. # To override output of the color format, you will also need to override the `to_string` method. COLOR_FORMAT = True # Specify the white point that the color space uses # White point should be a `tuple` containing the x and y chromaticity points. WHITE = cat . WHITES [ '2deg' ][ 'D65' ] # Specify the bounds of the non-alpha color channels. # Each channel is specified with either a `GamutBound` or `GamutUnbound` object. # \"Bound\" channels can be out of gamut and the actual minimum and maximum values # have significant. \"Unbound\" channels have values that are more informational purposes # and may be suggested ranges. # # Flags can also be provided: GamutBound(0.0, 360.0, FLG_ANGLE). # - FLG_ANGLE: denotes that channel is a angle or degree value. # - FLG_PERCENT: denotes the value is considered a percent. # Channels with this expect the value to be between 0 - 100 # - FLG_OPT_PERCENT: denotes the value can optionally be considered as a percent. # Channels with this are expected to be between 0 - 1. # # NOTE: Behavior of percent flags may change depending on how CSS Level 4 plans to handle non rectangular # colors in the `color(space ...)` format (if they handle them at all). BOUNDS = ( bounds . GamutUnbound ( 0.0 , 1.0 ), bounds . GamutUnbound ( 0.0 , 1.0 ), bounds . GamutUnbound ( 0.0 , 1.0 ) ) # If `GAMUT_CHECK` is set to a color space name, the provided color space will be used to verify the an \"in gamut\" # check in addition to the current color space's channel ranges. This is often used with color spaces such as: # HSL, HSV, and HWB where `GAMUT_CHECK` will be set to `srgb`. # # Gamut checking: # The specified color space will be checked first followed by the original. Assuming the parent color space fits, # the original should fit as well, but there are some cases when a parent color space that is slightly out of # gamut, when evaluated with a threshold, may appear to be in gamut enough, but when checking the original color # space, the values can be greatly out of specification (looking at you HSL). GAMUT_CHECK = None # When set to `True`, this denotes that the color space has the ability to represent out of gamut in colors in an # extended range. When interpolation is done, if colors are interpolated in a smaller gamut than the colors being # interpolated, the colors will usually be gamut mapped, but if the interpolation space happens to support extended # ranges, then the colors will not be gamut mapped even if their gamut is larger than the target interpolation # space. EXTENDED_RANGE = False ############################ # Getters and setters for non-alpha properties ############################ @property def x ( self ) -> float : \"\"\"X channel.\"\"\" return self . _coords [ 0 ] @x . setter def x ( self , value : float ) -> None : \"\"\"Shift the X.\"\"\" self . _coords [ 0 ] = self . _handle_input ( value ) @property def y ( self ) -> float : \"\"\"Y channel.\"\"\" return self . _coords [ 1 ] @y . setter def y ( self , value : float ) -> None : \"\"\"Set Y.\"\"\" self . _coords [ 1 ] = self . _handle_input ( value ) @property def z ( self ) -> float : \"\"\"Z channel.\"\"\" return self . _coords [ 2 ] @z . setter def z ( self , value : float ) -> None : \"\"\"Set Z channel.\"\"\" self . _coords [ 2 ] = self . _handle_input ( value ) ############################ # To and from conversion functions that transform the color to and from the `BASE` color. ############################ @classmethod def to_base ( cls , coords : Vector ) -> Vector : \"\"\" To XYZ (no change). Any needed chromatic adaptation is handled in the parent Color object. \"\"\" return coords @classmethod def from_base ( cls , coords : Vector ) -> Vector : \"\"\" From XYZ (no change). Any needed chromatic adaptation is handled in the parent Color object. \"\"\" return coords In addition to the above methods, some color spaces, such as cylindrical spaces, have some additional logic that determines when a hue is undefined. This function provides access to this logic in case normalize is called from the the Color object. In the case of such color spaces, it may be necessary to define null_adjust as well. Below is an example from HSL that sets hue to undefined when saturation is 0 or lightness is equal to 0 or 1 . @classmethod def null_adjust ( cls , coords : Vector , alpha : float ) -> Tuple [ Vector , float ]: \"\"\"On color update.\"\"\" coords = util . no_nans ( coords ) if coords [ 1 ] == 0 or coords [ 2 ] in ( 0 , 1 ): coords [ 0 ] = util . NaN return coords , util . no_nan ( alpha ) Mix-ins If the color is a cylindrical space, Lab-ish space, or Lch-ish space, you can additionally add in the respective mix-in class: Cylindrical , Labish , or Lchish . It should be noted that Lchish is subclassed from Cylindrical . Cylindrical Labish Lchish class Cylindrical : \"\"\"Cylindrical space.\"\"\" @classmethod def hue_name ( cls ) -> str : \"\"\"Hue channel name.\"\"\" return \"h\" @classmethod def hue_index ( cls ) -> int : \"\"\"Get hue index.\"\"\" return cast ( Type [ 'Space' ], cls ) . CHANNEL_NAMES . index ( cls . hue_name ()) class Labish : \"\"\"Lab-ish color spaces.\"\"\" @classmethod def labish_names ( cls ) -> Tuple [ str , ... ]: \"\"\"Return Lab-ish names in the order L a b.\"\"\" return cast ( Type [ 'Space' ], cls ) . CHANNEL_NAMES [: 3 ] @classmethod def labish_indexes ( cls ) -> List [ int ]: \"\"\"Return the index of the Lab-ish channels.\"\"\" names = cls . labish_names () return [ cast ( Type [ 'Space' ], cls ) . CHANNEL_NAMES . index ( name ) for name in names ] class Lchish ( Cylindrical ): \"\"\"Lch-ish color spaces.\"\"\" @classmethod def lchish_names ( cls ) -> Tuple [ str , ... ]: \"\"\"Return Lch-ish names in the order L c h.\"\"\" return cast ( Type [ 'Space' ], cls ) . CHANNEL_NAMES [: 3 ] @classmethod def lchish_indexes ( cls ) -> List [ int ]: \"\"\"Return the index of the Lab-ish channels.\"\"\" names = cls . lchish_names () return [ cast ( Type [ 'Space' ], cls ) . CHANNEL_NAMES . index ( name ) for name in names ] Mix-in classes are mainly available so that a color space can be inspected to see if it falls into a specific generic color space type in order to allow for some generic handling of the color. For instance, you may not care specifically what color space you are dealing with, but you may want to extract the hue from all cylindrical spaces, or grab the lightness (or lightness equivalent) from all Lab-ish color spaces. The mix-in classes provide methods mainly to extract expected channels on color spaces that may use different names for similar channels or to determine the index of a specific channel type. Occasionally, these methods may need to be overridden for a color space. Below, we can see that both jzazbz and ictcp identify as Lab-ish spaces. If we just care about accessing the equivalent of Lab lightness on these spaces, we can simply can access them with the following logic. >>> from coloraide.spaces import Labish >>> srgb = Color ( 'red' ) >>> jzazbz = srgb . convert ( 'jzazbz' ) >>> ictcp = srgb . convert ( 'ictcp' ) >>> for c in ( srgb , jzazbz , ictcp ): ... if isinstance ( c . _space , Labish ): ... print ( 'color: ' , c ) ... l = c . _space . labish_names ()[ 0 ] ... print ( 'channel: ' , l ) ... print ( 'value: ' , c . get ( l )) ... color: color(--jzazbz 0.13438 0.11789 0.11188 / 1) channel: jz value: 0.13438473104350318 color: color(--ictcp 0.42785 -0.11574 0.2788 / 1) channel: i value: 0.4278524836087273 from coloraide.spaces import Labish srgb = Color('red') jzazbz = srgb.convert('jzazbz') ictcp = srgb.convert('ictcp') for c in (srgb, jzazbz, ictcp): if isinstance(c._space, Labish): print('color: ', c) l = c._space.labish_names()[0] print('channel: ', l) print('value: ', c.get(l)) Edit Share Run Cancel It should be noted that just because a color space identifies in a specific, generic category, it doesn't mean it is precisely that thing. For instance, the color space CIELAB is clearly a Lab-ish space, or more precisely, it is a Lab color space. Oklab, DIN99o, and others are very much Lab spaces as well. ICtCp, on the other hand, is very Lab like as its Ct and Cp channels control redness/greenness and blueness/yellowness, but the I channel represents intensity, not lightness which is similar but not precisely the same thing. Adding New Input/Output Formats One common thing that may be desired is altering an existing color space to accept and output a specialized format. While using hex color codes or rgb () formats are fairly common, there are many places were other forms are used to represent colors. It may be beneficial for a user working with colors in some more obscure form to repurpose a color space to handle different input/output formats. The base of every color space is defined to accept and output the color ( space ... ) format. As this is a common input form across all color spaces, it is handled generically for all spaces in one action for performance reasons. Iterating each color space to perform the same match with a different color spaces name is obviously slower. A color can opt out of this input format by simply setting COLOR_FORMAT to False . This only disables input parsing. In order to disable this format during serialization the color space's #py3 to_string() method would need to be overridden. New, per color space matching logic can be achieved by simply by overriding the match () method. If it is desired to also accept the color ( space ... ) format, just keep the COLOR_FORMAT flag enabled; otherwise, disable it. As an example, let's consider the default sRGB space. We wanted to add additional CSS formats in addition to the color ( space ... ) format. While we won't go into the specific parsing logic, the general top-level logic can be seen below. We simply override the match () method and call into our CSS parser. The parser will handle the appropriate syntax for our color spaces. It is not configured to process the color ( space ... ) format as that is already handled more efficiently when with COLOR_FORMAT enabled. Also, notice that match () is expected to return two things: a tuple containing the color channel coordinates and the alpha value, and the end position ( ([ r , g , b ], a ), end ). If the match fails, it simply returns None . from coloraide.spaces import srgb as base from coloraide.css import parse class SRGB ( base . SRGB ): \"\"\"SRGB class.\"\"\" # This color class should opt into the generic `color(space ...)` format. # This is `True` by default, but shown for demonstration purposes. COLOR_FORMAT : True @classmethod def match ( cls , string : str , start : int = 0 , fullmatch : bool = True ) -> Optional [ Tuple [ Tuple [ Vector , float ], int ]]: \"\"\"Match a CSS color string.\"\"\" return parse . parse_css ( cls , string , start , fullmatch ) Additionally, we control the output formats by overriding the to_string () function. We ensure that it accepts all the parameters we need, in our case we accept the common parameters and later check for our special inputs in kwargs . def to_string ( self , parent : 'Color' , * , alpha : Optional [ bool ] = None , precision : Optional [ int ] = None , fit : Union [ bool , str ] = True , none : bool = False , ** kwargs : Any ) -> str : \"\"\"Convert to CSS.\"\"\" return serialize . serialize_css ( parent , func = 'rgb' , alpha = alpha , precision = precision , fit = fit , none = none , color = kwargs . get ( 'color' , False ), hexa = kwargs . get ( 'hex' , False ), name = kwargs . get ( 'names' , False ), legacy = kwargs . get ( 'comma' , False ), upper = kwargs . get ( 'upper' , False ), percent = kwargs . get ( 'percent' , False ), compress = kwargs . get ( 'compress' , False ), scale = 255 ) As all ColorAide color spaces are defined as plugins, there should be ample examples to help someone start writing a new color space.","title":"ColorAide Plugins"},{"location":"plugins/#coloraide-plugins","text":"ColorAide implements extendable portions of the Color object as plugins. This makes adding things such as new \u2206E methods or even new color spaces quite easy. Currently, ColorAide implements the following areas as plugins: \u2206E methods Gamut mapping Color spaces","title":"ColorAide Plugins"},{"location":"plugins/#delta-e","text":"\u2206E plugins allow for getting color differences with different methods. ColorAide provides a number of methods by default which are documented under Color Distance and Delta E . All of the default \u2206E methods are provided as plugins, and users can create their own as well.","title":"Delta E"},{"location":"plugins/#plugin-class","text":"\u2206E plugins are subclassed from coloraide . distance . DeltaE . class DeltaE ( ABCMeta ): \"\"\"Delta E plugin class.\"\"\" NAME = '' @classmethod @abstractmethod def distance ( cls , color : 'Color' , sample : 'Color' , ** kwargs : Any ) -> float : \"\"\"Get distance between color and sample.\"\"\" The plugin should provide a unique NAME and the distancing logic under distance () where color is the current color and sample is the secondary, provided color: Color ( 'color' ) . delta_e ( 'sample' , method = 'NAME' ) . The return value should be a float indicating the distance. Additional plugin specific options can be provided via new keyword arguments.","title":"Plugin Class"},{"location":"plugins/#fitgamut-mapping","text":"Fit plugins (or gamut mapping plugins) allow for mapping an out of gamut color to be within the current color space's gamut. All default gamut mapping methods provided by ColorAide are provided via plugins.","title":"Fit/Gamut Mapping"},{"location":"plugins/#plugin-class_1","text":"Plugins are are created by subclassing coloraide . gamut . Fit . class Fit ( ABCMeta ): \"\"\"Fit plugin class.\"\"\" NAME = '' @classmethod @abstractmethod def fit ( cls , color : 'Color' , ** kwargs ) -> None : \"\"\"Get coordinates of the new gamut mapped color.\"\"\" The plugin should provide a unique NAME and the fitting/mapping logic under fit () . The method does not return anything and should modify the color directly to be in gamut. Reserved Name clip is a special, reserved name and the associated plugin cannot be overridden. Another clip plugin can be written, but it cannot override the original.","title":"Plugin Class"},{"location":"plugins/#color-space","text":"All color spaces supported by ColorAide are specified via color space plugins. These Space objects specify color channel properties, gamut bounds, input matching/parsing logic, string output logic, conversion to and from a specified base color, etc. Color space plugins are a little more complex compared to Delta E and Fit plugins.","title":"Color Space"},{"location":"plugins/#plugin-class_2","text":"In general, a color space plugin is created by subclassing from coloraide . spaces . Space . When defining a color space, there are a couple things that must be defined. Using XYZ as an example, we will go over them. Chromatic Adaptation Color spaces do not perform chromatic adaptation. That is handled by the Color object. Color spaces should never change the white point, but simply provide the appropriate BASE linkage so that the color can resolve eventually to XYZ D65. Other XYZ color spaces should all have xyz-d65 as their base. Chromatic adaptation should automatically occur on transitions between two XYZ spaces with different white points white points, e.g., xyz-d65 to xyz-d50 . from coloraide import cat from coloraide.gamut import bounds class XYZD65 ( Space ): \"\"\"XYZ D65 class.\"\"\" # A base color though which a color is converted through. # XYZ is our absolute base, so it doesn't have a real base, # but something like HSL might have a base color of `srgb`. BASE = \"xyz-d65\" # The name of the color space. NAME = \"xyz-d65\" # One or more accepted identifiers that are allowed for the `color(space ...)` format. # For this this specific color space, both `color(xyz x y z / a)` and `color(xyz-d65 x y z / a)` are accepted. # As `xyz` is listed first, `xyz` is the default used when printing in this format. SERIALIZE = ( \"xyz-d65\" , \"xyz\" ) # Channel names for non-alpha channels listed in order of how they are stored. CHANNEL_NAMES = ( \"x\" , \"y\" , \"z\" ) # A dictionary containing a mapping of aliases to `CHANNEL_NAMES` found above. CHANNEL_ALIASES = {} # If you'd like this color space to parse as a `color(space ...)` format. # If set to `False` the space will not recognize the color format as an input. # To override output of the color format, you will also need to override the `to_string` method. COLOR_FORMAT = True # Specify the white point that the color space uses # White point should be a `tuple` containing the x and y chromaticity points. WHITE = cat . WHITES [ '2deg' ][ 'D65' ] # Specify the bounds of the non-alpha color channels. # Each channel is specified with either a `GamutBound` or `GamutUnbound` object. # \"Bound\" channels can be out of gamut and the actual minimum and maximum values # have significant. \"Unbound\" channels have values that are more informational purposes # and may be suggested ranges. # # Flags can also be provided: GamutBound(0.0, 360.0, FLG_ANGLE). # - FLG_ANGLE: denotes that channel is a angle or degree value. # - FLG_PERCENT: denotes the value is considered a percent. # Channels with this expect the value to be between 0 - 100 # - FLG_OPT_PERCENT: denotes the value can optionally be considered as a percent. # Channels with this are expected to be between 0 - 1. # # NOTE: Behavior of percent flags may change depending on how CSS Level 4 plans to handle non rectangular # colors in the `color(space ...)` format (if they handle them at all). BOUNDS = ( bounds . GamutUnbound ( 0.0 , 1.0 ), bounds . GamutUnbound ( 0.0 , 1.0 ), bounds . GamutUnbound ( 0.0 , 1.0 ) ) # If `GAMUT_CHECK` is set to a color space name, the provided color space will be used to verify the an \"in gamut\" # check in addition to the current color space's channel ranges. This is often used with color spaces such as: # HSL, HSV, and HWB where `GAMUT_CHECK` will be set to `srgb`. # # Gamut checking: # The specified color space will be checked first followed by the original. Assuming the parent color space fits, # the original should fit as well, but there are some cases when a parent color space that is slightly out of # gamut, when evaluated with a threshold, may appear to be in gamut enough, but when checking the original color # space, the values can be greatly out of specification (looking at you HSL). GAMUT_CHECK = None # When set to `True`, this denotes that the color space has the ability to represent out of gamut in colors in an # extended range. When interpolation is done, if colors are interpolated in a smaller gamut than the colors being # interpolated, the colors will usually be gamut mapped, but if the interpolation space happens to support extended # ranges, then the colors will not be gamut mapped even if their gamut is larger than the target interpolation # space. EXTENDED_RANGE = False ############################ # Getters and setters for non-alpha properties ############################ @property def x ( self ) -> float : \"\"\"X channel.\"\"\" return self . _coords [ 0 ] @x . setter def x ( self , value : float ) -> None : \"\"\"Shift the X.\"\"\" self . _coords [ 0 ] = self . _handle_input ( value ) @property def y ( self ) -> float : \"\"\"Y channel.\"\"\" return self . _coords [ 1 ] @y . setter def y ( self , value : float ) -> None : \"\"\"Set Y.\"\"\" self . _coords [ 1 ] = self . _handle_input ( value ) @property def z ( self ) -> float : \"\"\"Z channel.\"\"\" return self . _coords [ 2 ] @z . setter def z ( self , value : float ) -> None : \"\"\"Set Z channel.\"\"\" self . _coords [ 2 ] = self . _handle_input ( value ) ############################ # To and from conversion functions that transform the color to and from the `BASE` color. ############################ @classmethod def to_base ( cls , coords : Vector ) -> Vector : \"\"\" To XYZ (no change). Any needed chromatic adaptation is handled in the parent Color object. \"\"\" return coords @classmethod def from_base ( cls , coords : Vector ) -> Vector : \"\"\" From XYZ (no change). Any needed chromatic adaptation is handled in the parent Color object. \"\"\" return coords In addition to the above methods, some color spaces, such as cylindrical spaces, have some additional logic that determines when a hue is undefined. This function provides access to this logic in case normalize is called from the the Color object. In the case of such color spaces, it may be necessary to define null_adjust as well. Below is an example from HSL that sets hue to undefined when saturation is 0 or lightness is equal to 0 or 1 . @classmethod def null_adjust ( cls , coords : Vector , alpha : float ) -> Tuple [ Vector , float ]: \"\"\"On color update.\"\"\" coords = util . no_nans ( coords ) if coords [ 1 ] == 0 or coords [ 2 ] in ( 0 , 1 ): coords [ 0 ] = util . NaN return coords , util . no_nan ( alpha )","title":"Plugin Class"},{"location":"plugins/#mix-ins","text":"If the color is a cylindrical space, Lab-ish space, or Lch-ish space, you can additionally add in the respective mix-in class: Cylindrical , Labish , or Lchish . It should be noted that Lchish is subclassed from Cylindrical . Cylindrical Labish Lchish class Cylindrical : \"\"\"Cylindrical space.\"\"\" @classmethod def hue_name ( cls ) -> str : \"\"\"Hue channel name.\"\"\" return \"h\" @classmethod def hue_index ( cls ) -> int : \"\"\"Get hue index.\"\"\" return cast ( Type [ 'Space' ], cls ) . CHANNEL_NAMES . index ( cls . hue_name ()) class Labish : \"\"\"Lab-ish color spaces.\"\"\" @classmethod def labish_names ( cls ) -> Tuple [ str , ... ]: \"\"\"Return Lab-ish names in the order L a b.\"\"\" return cast ( Type [ 'Space' ], cls ) . CHANNEL_NAMES [: 3 ] @classmethod def labish_indexes ( cls ) -> List [ int ]: \"\"\"Return the index of the Lab-ish channels.\"\"\" names = cls . labish_names () return [ cast ( Type [ 'Space' ], cls ) . CHANNEL_NAMES . index ( name ) for name in names ] class Lchish ( Cylindrical ): \"\"\"Lch-ish color spaces.\"\"\" @classmethod def lchish_names ( cls ) -> Tuple [ str , ... ]: \"\"\"Return Lch-ish names in the order L c h.\"\"\" return cast ( Type [ 'Space' ], cls ) . CHANNEL_NAMES [: 3 ] @classmethod def lchish_indexes ( cls ) -> List [ int ]: \"\"\"Return the index of the Lab-ish channels.\"\"\" names = cls . lchish_names () return [ cast ( Type [ 'Space' ], cls ) . CHANNEL_NAMES . index ( name ) for name in names ] Mix-in classes are mainly available so that a color space can be inspected to see if it falls into a specific generic color space type in order to allow for some generic handling of the color. For instance, you may not care specifically what color space you are dealing with, but you may want to extract the hue from all cylindrical spaces, or grab the lightness (or lightness equivalent) from all Lab-ish color spaces. The mix-in classes provide methods mainly to extract expected channels on color spaces that may use different names for similar channels or to determine the index of a specific channel type. Occasionally, these methods may need to be overridden for a color space. Below, we can see that both jzazbz and ictcp identify as Lab-ish spaces. If we just care about accessing the equivalent of Lab lightness on these spaces, we can simply can access them with the following logic. >>> from coloraide.spaces import Labish >>> srgb = Color ( 'red' ) >>> jzazbz = srgb . convert ( 'jzazbz' ) >>> ictcp = srgb . convert ( 'ictcp' ) >>> for c in ( srgb , jzazbz , ictcp ): ... if isinstance ( c . _space , Labish ): ... print ( 'color: ' , c ) ... l = c . _space . labish_names ()[ 0 ] ... print ( 'channel: ' , l ) ... print ( 'value: ' , c . get ( l )) ... color: color(--jzazbz 0.13438 0.11789 0.11188 / 1) channel: jz value: 0.13438473104350318 color: color(--ictcp 0.42785 -0.11574 0.2788 / 1) channel: i value: 0.4278524836087273 from coloraide.spaces import Labish srgb = Color('red') jzazbz = srgb.convert('jzazbz') ictcp = srgb.convert('ictcp') for c in (srgb, jzazbz, ictcp): if isinstance(c._space, Labish): print('color: ', c) l = c._space.labish_names()[0] print('channel: ', l) print('value: ', c.get(l)) Edit Share Run Cancel It should be noted that just because a color space identifies in a specific, generic category, it doesn't mean it is precisely that thing. For instance, the color space CIELAB is clearly a Lab-ish space, or more precisely, it is a Lab color space. Oklab, DIN99o, and others are very much Lab spaces as well. ICtCp, on the other hand, is very Lab like as its Ct and Cp channels control redness/greenness and blueness/yellowness, but the I channel represents intensity, not lightness which is similar but not precisely the same thing.","title":"Mix-ins"},{"location":"plugins/#adding-new-inputoutput-formats","text":"One common thing that may be desired is altering an existing color space to accept and output a specialized format. While using hex color codes or rgb () formats are fairly common, there are many places were other forms are used to represent colors. It may be beneficial for a user working with colors in some more obscure form to repurpose a color space to handle different input/output formats. The base of every color space is defined to accept and output the color ( space ... ) format. As this is a common input form across all color spaces, it is handled generically for all spaces in one action for performance reasons. Iterating each color space to perform the same match with a different color spaces name is obviously slower. A color can opt out of this input format by simply setting COLOR_FORMAT to False . This only disables input parsing. In order to disable this format during serialization the color space's #py3 to_string() method would need to be overridden. New, per color space matching logic can be achieved by simply by overriding the match () method. If it is desired to also accept the color ( space ... ) format, just keep the COLOR_FORMAT flag enabled; otherwise, disable it. As an example, let's consider the default sRGB space. We wanted to add additional CSS formats in addition to the color ( space ... ) format. While we won't go into the specific parsing logic, the general top-level logic can be seen below. We simply override the match () method and call into our CSS parser. The parser will handle the appropriate syntax for our color spaces. It is not configured to process the color ( space ... ) format as that is already handled more efficiently when with COLOR_FORMAT enabled. Also, notice that match () is expected to return two things: a tuple containing the color channel coordinates and the alpha value, and the end position ( ([ r , g , b ], a ), end ). If the match fails, it simply returns None . from coloraide.spaces import srgb as base from coloraide.css import parse class SRGB ( base . SRGB ): \"\"\"SRGB class.\"\"\" # This color class should opt into the generic `color(space ...)` format. # This is `True` by default, but shown for demonstration purposes. COLOR_FORMAT : True @classmethod def match ( cls , string : str , start : int = 0 , fullmatch : bool = True ) -> Optional [ Tuple [ Tuple [ Vector , float ], int ]]: \"\"\"Match a CSS color string.\"\"\" return parse . parse_css ( cls , string , start , fullmatch ) Additionally, we control the output formats by overriding the to_string () function. We ensure that it accepts all the parameters we need, in our case we accept the common parameters and later check for our special inputs in kwargs . def to_string ( self , parent : 'Color' , * , alpha : Optional [ bool ] = None , precision : Optional [ int ] = None , fit : Union [ bool , str ] = True , none : bool = False , ** kwargs : Any ) -> str : \"\"\"Convert to CSS.\"\"\" return serialize . serialize_css ( parent , func = 'rgb' , alpha = alpha , precision = precision , fit = fit , none = none , color = kwargs . get ( 'color' , False ), hexa = kwargs . get ( 'hex' , False ), name = kwargs . get ( 'names' , False ), legacy = kwargs . get ( 'comma' , False ), upper = kwargs . get ( 'upper' , False ), percent = kwargs . get ( 'percent' , False ), compress = kwargs . get ( 'compress' , False ), scale = 255 ) As all ColorAide color spaces are defined as plugins, there should be ample examples to help someone start writing a new color space.","title":"Adding New Input/Output Formats"}]}