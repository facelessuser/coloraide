{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"ColorAide Overview ColorAide is a color library for Python. It was written to handle most modern CSS colors that are available and that will be available. Most of the conversion algorithms come straight from the CSS specifications . In the process of developing this library, we also stumbled upon Color.js which is created/maintained by the co-authors of some of the recent CSS color specifications. This project became heavily influenced by Color.js. While our aim was not to port that library, it did leave a clear impression on our API. We also leveraged the work related to gamut mapping and color interpolation. Currently this project is in an early stage, and while usable, some things may change as we get closer to a stable release. With ColorAide, you can specify a color, convert it to other color spaces, mix it with other colors, output it in different CSS formats, and various other things. >>> from coloraide import Color >>> c = Color ( \"red\" ) >>> c . to_string () 'rgb(255 0 0)' >>> c . convert ( 'hsl' ) . to_string () 'hsl(0 100% 50%)' >>> c . set ( \"lch.chroma\" , 30 ) . to_string () 'rgb(173.81 114.29 97.218)' >>> Color ( \"blue\" ) . mix ( \"yellow\" , space = \"lch\" ) . to_string () 'rgb(255 65.751 107.47)' Installation You can install ColorAide via Python's pip : pip install coloraide . Availability ColorAide is not yet available on PyPI.","title":"ColorAide"},{"location":"#coloraide","text":"","title":"ColorAide"},{"location":"#overview","text":"ColorAide is a color library for Python. It was written to handle most modern CSS colors that are available and that will be available. Most of the conversion algorithms come straight from the CSS specifications . In the process of developing this library, we also stumbled upon Color.js which is created/maintained by the co-authors of some of the recent CSS color specifications. This project became heavily influenced by Color.js. While our aim was not to port that library, it did leave a clear impression on our API. We also leveraged the work related to gamut mapping and color interpolation. Currently this project is in an early stage, and while usable, some things may change as we get closer to a stable release. With ColorAide, you can specify a color, convert it to other color spaces, mix it with other colors, output it in different CSS formats, and various other things. >>> from coloraide import Color >>> c = Color ( \"red\" ) >>> c . to_string () 'rgb(255 0 0)' >>> c . convert ( 'hsl' ) . to_string () 'hsl(0 100% 50%)' >>> c . set ( \"lch.chroma\" , 30 ) . to_string () 'rgb(173.81 114.29 97.218)' >>> Color ( \"blue\" ) . mix ( \"yellow\" , space = \"lch\" ) . to_string () 'rgb(255 65.751 107.47)'","title":"Overview"},{"location":"#installation","text":"You can install ColorAide via Python's pip : pip install coloraide . Availability ColorAide is not yet available on PyPI.","title":"Installation"},{"location":"color/","text":"The Color Object Creating Colors The Color object can be imported from coloraide . from coloraide import Color Afterwards, you can begin working with colors. You can import CSS syntax: >>> Color ( \"red\" ) color(srgb 1 0 0 / 1) >>> Color ( \"#ff0000\" ) color(srgb 1 0 0 / 1) >>> Color ( \"rgb(255 0 0 / 1)\" ) color(srgb 1 0 0 / 1) You can see, that we can use all sorts of valid CSS syntax, and we get the same color red . You can also insert raw data points directly, but notice, when doing this, you are required to enter the data as it is used internally, and in the case for sRGB, the channels are in the range of [0, 1]. >>> Color ( \"srgb\" , [ 0.5 , 0 , 1 ], 0.3 ) color(srgb 0.5 0 1 / 0.3) So in the example above, the raw data is parsed, and we get a transparent color in the sRGB space: color(srgb 0.5 0 1 / 0.3) . You can also pass in other color objects, which is really only useful if you've subclassed the Color object and want to cast the object between the classes. The same color creation can be preformed from a color's new class method as well. New accepts the same inputs as the class object itself. >>> color1 = Color ( \"red\" ) >>> color2 = color1 . new ( \"blue\" ) >>> color1 , color2 (color(srgb 1 0 0 / 1), color(srgb 0 0 1 / 1)) Cloning The clone method is an easy way to duplicate the current color object. Here we clone the green object so we have two. >>> c1 = Color ( \"green\" ) >>> c2 = c1 . clone () >>> c1 , c2 (color(srgb 0 0.50196 0 / 1), color(srgb 0 0.50196 0 / 1)) Updating A color can be \"updated\" using another color object. When an update occurs, the current color space is updated with the data from the second color, but the color space does not change. It is basically the equivalent of converting the second color to the color space of the first and then updating all the coordinates (including alpha). The input parameters are identical to the new method, so you can use a color object, a color string, or even raw data points. Here we update the color red to the color blue : >>> color1 = Color ( \"red\" ) >>> color2 = Color ( \"blue\" ) >>> color1 . update ( color2 ) color(srgb 0 0 1 / 1) >>> color1 , color2 (color(srgb 0 0 1 / 1), color(srgb 0 0 1 / 1)) Here we update the sRGB red with the color lch(100% 50 130) . Notice that the result is still in the sRGB color space, but the color is bigger than the sRGB color space making the color out of gamut: color(srgb 0.82374 1.0663 0.69484 / 1) . >>> Color ( \"red\" ) . update ( \"lch(100% 50 130)\" ) color(srgb 0.82374 1.0663 0.69484 / 1) Mutating \"Mutating\" is similar to updating except that it will update the color and the color space from another color. The input parameters are identical to the new method, so you can use a color object, a color string, or even raw data points. Here the red color object literally becomes lch(50% 50 130) . >>> Color ( \"red\" ) . mutate ( \"lch(50% 50 130)\" ) color(lch 50 50 130 / 1) Converting Colors can be converted to other color spaces as needed. Converting will always return a new color unless in_place is set True . For instance, if we had a color yellow , and we needed to work with it in another color space, we could simply call the convert method. In the example below, we convert the color yellow , which is in the sRGB color space, to the Lab color space which gives us color(lab 97.607 -15.753 93.388 / 1) . >>> Color ( 'yellow' ) . convert ( \"Lab\" ) color(lab 97.607 -15.753 93.388 / 1) Color Matching Color objects can take in raw data points with a color space name or CSS style inputs. This CSS style input logic is exposed via the match method. By default, you can just give it a string, and it will return a ColorMatch object. The ColorMatch object will have the matched color as a Color object, and the start and end points it was located at. >>> Color . match ( \"red\" ) ColorMatch(color=color(srgb 1 0 0 / 1), start=0, end=3) By default it matches at the start of the buffer and returns a color if it finds one. If desired, you can do a fullmatch which requires the entire buffer match the color. >>> Color . match ( \"red and yellow\" ) ColorMatch(color=color(srgb 1 0 0 / 1), start=0, end=3) >>> Color . match ( \"red and yellow\" , fullmatch = True ) You can also target adjust the start position of the search. In this case, by adjusting the start position to 8 characters later, we will match yellow instead of red . >>> Color . match ( \"red and yellow\" , start = 8 ) ColorMatch(color=color(srgb 1 1 0 / 1), start=8, end=14) If desired, you can also filter out the CSS syntax of certain color spaces. Here we will only target HSL colors. >>> Color . match ( \"red and yellow\" , filters = [ \"hsl\" ]) >>> Color . match ( \"hsl(130 30 % 75% )\" , filters = [ \"hsl\" ]) ColorMatch(color=color(hsl 130 30 75 / 1), start=0, end=16) A method to find all colors in a buffer is not provided as looping through all the color spaces and matching all potential colors on every character is not really efficient. What is recommended would be to apply this with some logic to find potential places in the buffer to test, and only test those places. In this example we construct a regex to find all valid formats, but we also try and filter out cases that are unfavorable, particularly in HTML or CSS. We don't want to match hex in HTML entities or color names that are part of color variables ( var ( --color-red ) ). Code import re from coloraide.css import Color RE_COLOR_START = re . compile ( r \"(?i)(?:\\b(?<![-#&])(?:color|hsla?|gray|lch|lab|hwb|rgba?)\\(|\\b(?<![-#&])[\\w]{3,}(?!\\()\\b|(?<![&])#)\" ) text = \"\"\"Red and yellow are colors. So are #ff0033 and lch(90% 50 50).\"\"\" for m in RE_COLOR_START . finditer ( text ): start = m . start () mcolor = Color . match ( text , start = start ) if mcolor is not None : print ( 'Found {} @ index {} ' . format ( mcolor . color . to_string (), start )) Output Found rgb(255 0 0) @ index 0 Found rgb(255 255 0) @ index 8 Found rgb(255 0 51) @ index 34 Found lch(90% 50 50) @ index 46","title":"The Color Object"},{"location":"color/#the-color-object","text":"","title":"The Color Object"},{"location":"color/#creating-colors","text":"The Color object can be imported from coloraide . from coloraide import Color Afterwards, you can begin working with colors. You can import CSS syntax: >>> Color ( \"red\" ) color(srgb 1 0 0 / 1) >>> Color ( \"#ff0000\" ) color(srgb 1 0 0 / 1) >>> Color ( \"rgb(255 0 0 / 1)\" ) color(srgb 1 0 0 / 1) You can see, that we can use all sorts of valid CSS syntax, and we get the same color red . You can also insert raw data points directly, but notice, when doing this, you are required to enter the data as it is used internally, and in the case for sRGB, the channels are in the range of [0, 1]. >>> Color ( \"srgb\" , [ 0.5 , 0 , 1 ], 0.3 ) color(srgb 0.5 0 1 / 0.3) So in the example above, the raw data is parsed, and we get a transparent color in the sRGB space: color(srgb 0.5 0 1 / 0.3) . You can also pass in other color objects, which is really only useful if you've subclassed the Color object and want to cast the object between the classes. The same color creation can be preformed from a color's new class method as well. New accepts the same inputs as the class object itself. >>> color1 = Color ( \"red\" ) >>> color2 = color1 . new ( \"blue\" ) >>> color1 , color2 (color(srgb 1 0 0 / 1), color(srgb 0 0 1 / 1))","title":"Creating Colors"},{"location":"color/#cloning","text":"The clone method is an easy way to duplicate the current color object. Here we clone the green object so we have two. >>> c1 = Color ( \"green\" ) >>> c2 = c1 . clone () >>> c1 , c2 (color(srgb 0 0.50196 0 / 1), color(srgb 0 0.50196 0 / 1))","title":"Cloning"},{"location":"color/#updating","text":"A color can be \"updated\" using another color object. When an update occurs, the current color space is updated with the data from the second color, but the color space does not change. It is basically the equivalent of converting the second color to the color space of the first and then updating all the coordinates (including alpha). The input parameters are identical to the new method, so you can use a color object, a color string, or even raw data points. Here we update the color red to the color blue : >>> color1 = Color ( \"red\" ) >>> color2 = Color ( \"blue\" ) >>> color1 . update ( color2 ) color(srgb 0 0 1 / 1) >>> color1 , color2 (color(srgb 0 0 1 / 1), color(srgb 0 0 1 / 1)) Here we update the sRGB red with the color lch(100% 50 130) . Notice that the result is still in the sRGB color space, but the color is bigger than the sRGB color space making the color out of gamut: color(srgb 0.82374 1.0663 0.69484 / 1) . >>> Color ( \"red\" ) . update ( \"lch(100% 50 130)\" ) color(srgb 0.82374 1.0663 0.69484 / 1)","title":"Updating"},{"location":"color/#mutating","text":"\"Mutating\" is similar to updating except that it will update the color and the color space from another color. The input parameters are identical to the new method, so you can use a color object, a color string, or even raw data points. Here the red color object literally becomes lch(50% 50 130) . >>> Color ( \"red\" ) . mutate ( \"lch(50% 50 130)\" ) color(lch 50 50 130 / 1)","title":"Mutating"},{"location":"color/#converting","text":"Colors can be converted to other color spaces as needed. Converting will always return a new color unless in_place is set True . For instance, if we had a color yellow , and we needed to work with it in another color space, we could simply call the convert method. In the example below, we convert the color yellow , which is in the sRGB color space, to the Lab color space which gives us color(lab 97.607 -15.753 93.388 / 1) . >>> Color ( 'yellow' ) . convert ( \"Lab\" ) color(lab 97.607 -15.753 93.388 / 1)","title":"Converting"},{"location":"color/#color-matching","text":"Color objects can take in raw data points with a color space name or CSS style inputs. This CSS style input logic is exposed via the match method. By default, you can just give it a string, and it will return a ColorMatch object. The ColorMatch object will have the matched color as a Color object, and the start and end points it was located at. >>> Color . match ( \"red\" ) ColorMatch(color=color(srgb 1 0 0 / 1), start=0, end=3) By default it matches at the start of the buffer and returns a color if it finds one. If desired, you can do a fullmatch which requires the entire buffer match the color. >>> Color . match ( \"red and yellow\" ) ColorMatch(color=color(srgb 1 0 0 / 1), start=0, end=3) >>> Color . match ( \"red and yellow\" , fullmatch = True ) You can also target adjust the start position of the search. In this case, by adjusting the start position to 8 characters later, we will match yellow instead of red . >>> Color . match ( \"red and yellow\" , start = 8 ) ColorMatch(color=color(srgb 1 1 0 / 1), start=8, end=14) If desired, you can also filter out the CSS syntax of certain color spaces. Here we will only target HSL colors. >>> Color . match ( \"red and yellow\" , filters = [ \"hsl\" ]) >>> Color . match ( \"hsl(130 30 % 75% )\" , filters = [ \"hsl\" ]) ColorMatch(color=color(hsl 130 30 75 / 1), start=0, end=16) A method to find all colors in a buffer is not provided as looping through all the color spaces and matching all potential colors on every character is not really efficient. What is recommended would be to apply this with some logic to find potential places in the buffer to test, and only test those places. In this example we construct a regex to find all valid formats, but we also try and filter out cases that are unfavorable, particularly in HTML or CSS. We don't want to match hex in HTML entities or color names that are part of color variables ( var ( --color-red ) ). Code import re from coloraide.css import Color RE_COLOR_START = re . compile ( r \"(?i)(?:\\b(?<![-#&])(?:color|hsla?|gray|lch|lab|hwb|rgba?)\\(|\\b(?<![-#&])[\\w]{3,}(?!\\()\\b|(?<![&])#)\" ) text = \"\"\"Red and yellow are colors. So are #ff0033 and lch(90% 50 50).\"\"\" for m in RE_COLOR_START . finditer ( text ): start = m . start () mcolor = Color . match ( text , start = start ) if mcolor is not None : print ( 'Found {} @ index {} ' . format ( mcolor . color . to_string (), start )) Output Found rgb(255 0 0) @ index 0 Found rgb(255 255 0) @ index 8 Found rgb(255 0 51) @ index 34 Found lch(90% 50 50) @ index 46","title":"Color Matching"},{"location":"contrast/","text":"Contrast Relative Luminance ColorAide provides a couple of contrast related tools out of the box. Relative luminance is used to calculate the contrast ratio. To get the luminance, simply call the luminance method: >>> Color ( \"black\" ) . luminance () 0.0 >>> Color ( \"white\" ) . luminance () 1.00000009242344 >>> Color ( \"blue\" ) . luminance () 0.06061693873868999 Contrast Ratio To get the contrast ratio between two colors, simply pass in the second color: >>> Color ( \"blue\" ) . contrast_ratio ( \"red\" ) 2.463497175178265","title":"Contrast"},{"location":"contrast/#contrast","text":"","title":"Contrast"},{"location":"contrast/#relative-luminance","text":"ColorAide provides a couple of contrast related tools out of the box. Relative luminance is used to calculate the contrast ratio. To get the luminance, simply call the luminance method: >>> Color ( \"black\" ) . luminance () 0.0 >>> Color ( \"white\" ) . luminance () 1.00000009242344 >>> Color ( \"blue\" ) . luminance () 0.06061693873868999","title":"Relative Luminance"},{"location":"contrast/#contrast-ratio","text":"To get the contrast ratio between two colors, simply pass in the second color: >>> Color ( \"blue\" ) . contrast_ratio ( \"red\" ) 2.463497175178265","title":"Contrast Ratio"},{"location":"distance/","text":"Color Distance and Delta E Color Distance ColorAide provides a simple euclidean color distance function. By default, it evaluates the distance in the Lab color space, but it can be configured to evaluate in any color space. It may be less useful in some color spaces compared to others: >>> Color ( \"red\" ) . distance ( \"blue\" , space = \"srgb\" ) 1.4142135623730951 >>> Color ( \"red\" ) . distance ( \"blue\" , space = \"lab\" ) 184.01293277712057 Delta E The delta function gives access to various delta E implementations. >>> Color ( \"red\" ) . delta ( \"blue\" ) 184.01293277712057 >>> Color ( \"red\" ) . delta ( \"blue\" , method = \"2000\" ) 55.79762200630985 The default implementation is Delta E 1976. Originally, when the Lab color space was created, it was thought that it was more perceptually uniform than it actually was. At first, the distance algorithm was a simple euclidean implementation (Delta E 1976), but over time it has been tweaked to make corrections to account for the fact that it is not perfectly uniform. There are areas and industries that still use many of these for different reasons. ColorAide implements the following delta E methods: Name Parameter Name Weighted Parameters CIE76 76 CMC l:c (1984) cmc l=2, c=1 CIE94 94 kl=1, k1=0.045, k2=0.015 CIEDE2000 2000 kl=1, kc=1, kh=1","title":"Color Distance and Delta E"},{"location":"distance/#color-distance-and-delta-e","text":"","title":"Color Distance and Delta E"},{"location":"distance/#color-distance","text":"ColorAide provides a simple euclidean color distance function. By default, it evaluates the distance in the Lab color space, but it can be configured to evaluate in any color space. It may be less useful in some color spaces compared to others: >>> Color ( \"red\" ) . distance ( \"blue\" , space = \"srgb\" ) 1.4142135623730951 >>> Color ( \"red\" ) . distance ( \"blue\" , space = \"lab\" ) 184.01293277712057","title":"Color Distance"},{"location":"distance/#delta-e","text":"The delta function gives access to various delta E implementations. >>> Color ( \"red\" ) . delta ( \"blue\" ) 184.01293277712057 >>> Color ( \"red\" ) . delta ( \"blue\" , method = \"2000\" ) 55.79762200630985 The default implementation is Delta E 1976. Originally, when the Lab color space was created, it was thought that it was more perceptually uniform than it actually was. At first, the distance algorithm was a simple euclidean implementation (Delta E 1976), but over time it has been tweaked to make corrections to account for the fact that it is not perfectly uniform. There are areas and industries that still use many of these for different reasons. ColorAide implements the following delta E methods: Name Parameter Name Weighted Parameters CIE76 76 CMC l:c (1984) cmc l=2, c=1 CIE94 94 kl=1, k1=0.045, k2=0.015 CIEDE2000 2000 kl=1, kc=1, kh=1","title":"Delta E"},{"location":"gamut/","text":"Gamut Mapping Overview Many color spaces have bounds. The bounds represent the limits a color space can represent a color. Some color spaces are theoretically unbounded, but past a point, the eye can't see them. When moving from a large color space like Lab to a small color space like sRGB, many Lab colors will not fit without mapping to the color to one that does fit. Checking Gamut A color can be checked to see if it fits in its own gamut or the gamut of another color space. Some color spaces may have recommended limits for usability purposes, but may not have actual limits. Let's assume we may have a color rgb(30% 105% 0%) which is not in its own gamut. We can check this via the in_gamut method, and we can see that it is not in gamut. >>> Color ( \"rgb(30 % 105% 0%)\" ) . in_gamut () False We can also check if a color space that is not in sRGB is in sRGB gamut as well. By doing this, we can quickly see that lch(100% 50 75) is not in gamut. >>> Color ( \"lch(100% 50 75)\" ) . in_gamut ( \"srgb\" ) False Mapping Colors An often recommended approach for mapping colors is to compress the chroma while in the Lch color space (overly simplified). This is the approach that our reference ( colorjs ) chose, so we ported it over here as well. In this example, we will take the color lch(100% 50 75) , which is out of the sRGB gamut, and fit it. After fitting, we get a color that can now be rendered in the sRGB color space: If desired we can force the color in gamut via the fit method. By doing this, we get a color we can render in the sRGB color space: lch(99.438% 5.2201 99.658) . >>> Color ( \"lch(100% 50 75)\" ) . fit ( \"srgb\" ) . to_string () 'lch(99.438% 5.2201 99.658)' If desired, simple clipping can be used instead of the default gamut fitting. Generally this is not recommended, but there are times and places for everything. To do so, you can specify the fitting method via the method parameter. Here we take the same color in the previous example ( lch(100% 50 75) ) and perform a simple clipping to get lch(95.817% 42.313 96.905) . Notice the difference when compared to the previous fitting result: lch(99.438% 5.2201 99.658) . >>> Color ( \"lch(100% 50 75)\" ) . fit ( \"srgb\" , method = \"clip\" ) . to_string () 'lch(95.817% 42.313 96.905)' Gamut fitting will always return a new color unless in_place is set True .","title":"Gamut Mapping"},{"location":"gamut/#gamut-mapping","text":"","title":"Gamut Mapping"},{"location":"gamut/#overview","text":"Many color spaces have bounds. The bounds represent the limits a color space can represent a color. Some color spaces are theoretically unbounded, but past a point, the eye can't see them. When moving from a large color space like Lab to a small color space like sRGB, many Lab colors will not fit without mapping to the color to one that does fit.","title":"Overview"},{"location":"gamut/#checking-gamut","text":"A color can be checked to see if it fits in its own gamut or the gamut of another color space. Some color spaces may have recommended limits for usability purposes, but may not have actual limits. Let's assume we may have a color rgb(30% 105% 0%) which is not in its own gamut. We can check this via the in_gamut method, and we can see that it is not in gamut. >>> Color ( \"rgb(30 % 105% 0%)\" ) . in_gamut () False We can also check if a color space that is not in sRGB is in sRGB gamut as well. By doing this, we can quickly see that lch(100% 50 75) is not in gamut. >>> Color ( \"lch(100% 50 75)\" ) . in_gamut ( \"srgb\" ) False","title":"Checking Gamut"},{"location":"gamut/#mapping-colors","text":"An often recommended approach for mapping colors is to compress the chroma while in the Lch color space (overly simplified). This is the approach that our reference ( colorjs ) chose, so we ported it over here as well. In this example, we will take the color lch(100% 50 75) , which is out of the sRGB gamut, and fit it. After fitting, we get a color that can now be rendered in the sRGB color space: If desired we can force the color in gamut via the fit method. By doing this, we get a color we can render in the sRGB color space: lch(99.438% 5.2201 99.658) . >>> Color ( \"lch(100% 50 75)\" ) . fit ( \"srgb\" ) . to_string () 'lch(99.438% 5.2201 99.658)' If desired, simple clipping can be used instead of the default gamut fitting. Generally this is not recommended, but there are times and places for everything. To do so, you can specify the fitting method via the method parameter. Here we take the same color in the previous example ( lch(100% 50 75) ) and perform a simple clipping to get lch(95.817% 42.313 96.905) . Notice the difference when compared to the previous fitting result: lch(99.438% 5.2201 99.658) . >>> Color ( \"lch(100% 50 75)\" ) . fit ( \"srgb\" , method = \"clip\" ) . to_string () 'lch(95.817% 42.313 96.905)' Gamut fitting will always return a new color unless in_place is set True .","title":"Mapping Colors"},{"location":"interpolation/","text":"Color Interpolation Interpolating The interpolate method allows a user to create an interpolation function. This can be used to create a list of gradient colors, or whatever is needed. This function drives most of the features handled by interpolation. Interpolation functions accept an input between 0 - 1, if values are provided out of this range, the color will be extrapolated and the results may be surprising. Here we create a an interpolation between lch(50% 50 0) and lch(90% 50 20) . We then step through values of 0.1 , 0.2 , and 0.3 which creates: [ , , ]. >>> i = Color ( \"lch(50% 50 0)\" ) . interpolate ( \"lch(90% 50 20)\" ) >>> i ( 0.1 ) color(lch 54 49.728 1.9707 / 1) >>> i ( 0.2 ) color(lch 58 49.515 3.9608 / 1) >>> i ( 0.3 ) color(lch 62 49.363 5.9656 / 1) If desired, we can target specific channels for mixing which will keep all the other channels constant on the base color. In this example, we have a base color of lch(52% 58.1 22.7) which we mix with lch(56% 49.1 257.1) . We also specify that we want to only mix the hue channel. The final color is lch(52% 58.1 351.59) . Notice that when comparing to the base color that only the hue has changed. >>> i = Color ( \"lch(52% 58.1 22.7)\" ) . interpolate ( \"lch(56% 49.1 257.1)\" , space = \"lch\" , adjust = [ \"hue\" ]) >>> i ( 0.2477 ) . to_string () 'lch(52% 58.1 351.59)' Additionally, hues are special, and we can control the way the interpolation is evaluated. The hue parameter accepts such values as longer or shorter , shorter being the default (see API for all options). In this example, we run the same command, but specify that the interpolation should use the longer angle between the two hues. This time, when we mix lch(52% 58.1 22.7) and lch(56% 49.1 257.1) , we get a different color ( lch(52% 58.1 80.761) ) as we interpolated between the larger angle instead of the shorter angle. >>> i = Color ( \"lch(52% 58.1 22.7)\" ) . interpolate ( \"lch(56% 49.1 257.1)\" , space = \"lch\" , adjust = [ \"hue\" ], hue = \"longer\" ) >>> i ( 0.2477 ) . to_string () 'lch(52% 58.1 80.761)' Tip It is important to note that you must specify the channels of the space the interpolation is occurring in. Specifying hue while interpolating in the sRGB color space would target no channels and would be ignored. You can also do non-linear interpolation by providing a function. Here we use a function that returns p ** 3 creating the colors: [ , , ]. >>> i = Color ( \"lch(50% 50 0)\" ) . interpolate ( \"lch(90% 50 20)\" , progress = lambda p : p ** 3 ) >>> i ( 0.1 ) color(lch 50.04 49.997 0.0196 / 1) >>> i ( 0.2 ) color(lch 50.32 49.976 0.15685 / 1) >>> i ( 0.3 ) color(lch 51.08 49.921 0.52995 / 1) Color Mixing Colors can be mixed together to create new colors. Mixing is built on top of the interpolate function and will return a color between the current and specified color. If colors are requested to be interpolated within a color space smaller than the original, the colors will be gamut mapped into the desired color space. Tip Mix, just like interpolation, also accepts the accept and hue parameters. As an example, if we had the color red and the color blue , and we wanted to mix them, we can just call the mix method, and we'll get the color rgb(127.5 0 127.5) . >>> red = Color ( \"red\" ) >>> blue = Color ( \"blue\" ) >>> red . mix ( blue ) . to_string () 'rgb(127.5 0 127.5)' The mix method will mix the two colors in the color space of the color calling the method. If needed a different color space can be specified with the space parameter. Notice that this creates a different color: rgb(180.38 44.003 76.616) . The results of mixing in a different color space may be more desirable as color mixing may be more natural. >>> red = Color ( \"red\" ) >>> blue = Color ( \"blue\" ) >>> red . mix ( blue , space = \"lab\" ) . to_string () 'rgb(180.38 44.003 76.616)' By default, colors are mixed at 50%, but the percentage can be controlled. Here we mix the color blue into the color red at 20%. This gives us the color of rgb(204 0 51) . >>> red = Color ( \"red\" ) >>> blue = Color ( \"blue\" ) >>> red . mix ( blue , 0.2 ) . to_string () 'rgb(204 0 51)' Mix can also accept a string and will create the color for you which is great if you don't need to work with the second color afterwards. >>> Color ( \"red\" ) . mix ( \"blue\" , 0.2 ) . to_string () 'rgb(204 0 51)' Mixing will always return a new color unless in_place is set True . Steps The steps method creates a list of discrete colors. Like mixing, it is also built on the interplate . steps. The steps to take between the two colors can be configured with the three options, steps (minimum number of steps), max_steps , and max_delta (max allowable delta E distance between steps). The default delta E method is delta E 76, which is a simple euclidean distancing in the Lab color space. In this example we we specify the color Color(\"display-p3\", [0, 1, 0]) and interpolate steps between red . The result gives us an array of colors: [ , , , , , , , , , , , , , , , , , , , , ]. >>> color = Color ( \"display-p3\" , [ 0 , 1 , 0 ]) >>> for x in color . steps ( \"red\" , space = \"lch\" , out_space = \"srgb\" , max_delta = 20 , steps = 10 ): ... print ( x . to_string ( percent = True )) ... rgb(0% 98.694% 11.114%) rgb(25.043% 95.745% 0%) rgb(38.1% 92.729% 0%) rgb(47.023% 89.644% 0%) rgb(54.067% 86.49% 0%) rgb(59.956% 83.266% 0%) rgb(65.025% 79.973% 0%) rgb(69.455% 76.61% 0%) rgb(73.353% 73.18% 0%) rgb(76.786% 69.684% 0%) rgb(79.796% 66.125% 0%) rgb(82.412% 62.507% 0%) rgb(84.651% 58.835% 0%) rgb(86.526% 55.112% 0%) rgb(88.045% 51.345% 0%) rgb(89.213% 47.54% 0%) rgb(90.034% 43.704% 0%) rgb(90.512% 39.844% 0%) rgb(90.648% 35.967% 6.5514%) rgb(90.448% 32.079% 12.235%) rgb(100% 0.00023% -0.00002%) Overlaying Colors The overlay method allows a transparent color to be overlaid on top of another color creating the composite of the two. To perform an overlay, a background color must be provided to the color along with an optional color space. If a color is to be overlaid within a smaller color space, the colors will be mapped to the smaller space. It is probably, not recommended to overlay in cylindrical color spaces, but there is no restrictions prohibiting such actions. In the example below, we take the rgb(100% 0% 0% / 0.5) and overlay it on the color black . This yields the color: rgb(127.5 0 0) . >>> color = Color ( \"rgb(100 % 0% 0% / 0.5)\" ) >>> color . overlay ( \"black\" ) . to_string () 'rgb(127.5 0 0)' A new color will be returned instead of modifying the current color unless in_place is set True . Null Hues Color spaces that have hue coordinates often have rules about when the hue is considered relevant. For instance, in the HSL color space, if saturation is zero, the hue is considered null. This is because the color is \"without color\"; therefore, it has no hue, or the hue is undefined. Many libraries, like d3-color , chroma.js , and color.js all represent null hues with NaN (not a number). This is usually done to make color interpolation easier. Some, like d3-color, are a bit more liberal with NaN and will target special cases that are above and beyond the normal rules to help ensure good interpolation. For instance, they not only mark hue null on HSL colors when saturation is zero, but also when lightness is zero or one hundred (essentially appearing black or white). In fact, they'll mark saturation as NaN when lightness indicates \"black\" or \"white\". Additionally, some libraries allow marking non-hue channels as NaN ; color.js allows a user to manually specify channels with NaN so they can mask off channels for interpolation. ColorAide also uses NaN during interpolating, but we do not carry that baggage around outside of interpolating. Colors will not return NaN in their coordinates, so the user doesn't have to worry about checking for those cases when assigning values, but it will calculate when hues are null when doing interpolation. If a space needs to account for hue when interpolating (mainly cylindrical color spaces) then ColorAide will flag the hue channel as null by assigning the coordinate a NaN prior to the actual interpolation. ColorAide will consider the following color spaces as having a null hue in the following cases: Color Space Null Condition HSV s<=0 or very near 0% 1 HSL s<=0 or very near 0% 1 HWB (w + b)>=100 or very near 100% 1 LCH c<=0 or very near 0% 1 When determining whether a hue is null, we use a threshold of 0.0005 \"nearness\". \u21a9 \u21a9 \u21a9 \u21a9 To determine at any time if a hue is considered null, the is_hue_null method can be used. Any space that considers hue will return True or False if their hue is null or not null respectively. Any space that does not specifically calculate hue, will simply return False . The method will consider the current color space by default, but you can query any color spaces by providing a different one. >>> Color ( \"lab(53.389% 0 0)\" ) . is_hue_null () False >>> Color ( \"lab(53.389% 0 0)\" ) . is_hue_null ( \"lch\" ) True >>> Color ( \"lab(53.389% 0 0)\" ) . is_hue_null ( \"hsl\" ) True >>> Color ( \"lab(53.389% 0 0)\" ) . is_hue_null ( \"hsv\" ) True >>> Color ( \"lab(53.389% 0 0)\" ) . is_hue_null ( \"hwb\" ) True Due to the way colors convert, all spaces may not yield the same value as in this example, so it is best to test in the space that is being targeted.","title":"Color Interpolation"},{"location":"interpolation/#color-interpolation","text":"","title":"Color Interpolation"},{"location":"interpolation/#interpolating","text":"The interpolate method allows a user to create an interpolation function. This can be used to create a list of gradient colors, or whatever is needed. This function drives most of the features handled by interpolation. Interpolation functions accept an input between 0 - 1, if values are provided out of this range, the color will be extrapolated and the results may be surprising. Here we create a an interpolation between lch(50% 50 0) and lch(90% 50 20) . We then step through values of 0.1 , 0.2 , and 0.3 which creates: [ , , ]. >>> i = Color ( \"lch(50% 50 0)\" ) . interpolate ( \"lch(90% 50 20)\" ) >>> i ( 0.1 ) color(lch 54 49.728 1.9707 / 1) >>> i ( 0.2 ) color(lch 58 49.515 3.9608 / 1) >>> i ( 0.3 ) color(lch 62 49.363 5.9656 / 1) If desired, we can target specific channels for mixing which will keep all the other channels constant on the base color. In this example, we have a base color of lch(52% 58.1 22.7) which we mix with lch(56% 49.1 257.1) . We also specify that we want to only mix the hue channel. The final color is lch(52% 58.1 351.59) . Notice that when comparing to the base color that only the hue has changed. >>> i = Color ( \"lch(52% 58.1 22.7)\" ) . interpolate ( \"lch(56% 49.1 257.1)\" , space = \"lch\" , adjust = [ \"hue\" ]) >>> i ( 0.2477 ) . to_string () 'lch(52% 58.1 351.59)' Additionally, hues are special, and we can control the way the interpolation is evaluated. The hue parameter accepts such values as longer or shorter , shorter being the default (see API for all options). In this example, we run the same command, but specify that the interpolation should use the longer angle between the two hues. This time, when we mix lch(52% 58.1 22.7) and lch(56% 49.1 257.1) , we get a different color ( lch(52% 58.1 80.761) ) as we interpolated between the larger angle instead of the shorter angle. >>> i = Color ( \"lch(52% 58.1 22.7)\" ) . interpolate ( \"lch(56% 49.1 257.1)\" , space = \"lch\" , adjust = [ \"hue\" ], hue = \"longer\" ) >>> i ( 0.2477 ) . to_string () 'lch(52% 58.1 80.761)' Tip It is important to note that you must specify the channels of the space the interpolation is occurring in. Specifying hue while interpolating in the sRGB color space would target no channels and would be ignored. You can also do non-linear interpolation by providing a function. Here we use a function that returns p ** 3 creating the colors: [ , , ]. >>> i = Color ( \"lch(50% 50 0)\" ) . interpolate ( \"lch(90% 50 20)\" , progress = lambda p : p ** 3 ) >>> i ( 0.1 ) color(lch 50.04 49.997 0.0196 / 1) >>> i ( 0.2 ) color(lch 50.32 49.976 0.15685 / 1) >>> i ( 0.3 ) color(lch 51.08 49.921 0.52995 / 1)","title":"Interpolating"},{"location":"interpolation/#color-mixing","text":"Colors can be mixed together to create new colors. Mixing is built on top of the interpolate function and will return a color between the current and specified color. If colors are requested to be interpolated within a color space smaller than the original, the colors will be gamut mapped into the desired color space. Tip Mix, just like interpolation, also accepts the accept and hue parameters. As an example, if we had the color red and the color blue , and we wanted to mix them, we can just call the mix method, and we'll get the color rgb(127.5 0 127.5) . >>> red = Color ( \"red\" ) >>> blue = Color ( \"blue\" ) >>> red . mix ( blue ) . to_string () 'rgb(127.5 0 127.5)' The mix method will mix the two colors in the color space of the color calling the method. If needed a different color space can be specified with the space parameter. Notice that this creates a different color: rgb(180.38 44.003 76.616) . The results of mixing in a different color space may be more desirable as color mixing may be more natural. >>> red = Color ( \"red\" ) >>> blue = Color ( \"blue\" ) >>> red . mix ( blue , space = \"lab\" ) . to_string () 'rgb(180.38 44.003 76.616)' By default, colors are mixed at 50%, but the percentage can be controlled. Here we mix the color blue into the color red at 20%. This gives us the color of rgb(204 0 51) . >>> red = Color ( \"red\" ) >>> blue = Color ( \"blue\" ) >>> red . mix ( blue , 0.2 ) . to_string () 'rgb(204 0 51)' Mix can also accept a string and will create the color for you which is great if you don't need to work with the second color afterwards. >>> Color ( \"red\" ) . mix ( \"blue\" , 0.2 ) . to_string () 'rgb(204 0 51)' Mixing will always return a new color unless in_place is set True .","title":"Color Mixing"},{"location":"interpolation/#steps","text":"The steps method creates a list of discrete colors. Like mixing, it is also built on the interplate . steps. The steps to take between the two colors can be configured with the three options, steps (minimum number of steps), max_steps , and max_delta (max allowable delta E distance between steps). The default delta E method is delta E 76, which is a simple euclidean distancing in the Lab color space. In this example we we specify the color Color(\"display-p3\", [0, 1, 0]) and interpolate steps between red . The result gives us an array of colors: [ , , , , , , , , , , , , , , , , , , , , ]. >>> color = Color ( \"display-p3\" , [ 0 , 1 , 0 ]) >>> for x in color . steps ( \"red\" , space = \"lch\" , out_space = \"srgb\" , max_delta = 20 , steps = 10 ): ... print ( x . to_string ( percent = True )) ... rgb(0% 98.694% 11.114%) rgb(25.043% 95.745% 0%) rgb(38.1% 92.729% 0%) rgb(47.023% 89.644% 0%) rgb(54.067% 86.49% 0%) rgb(59.956% 83.266% 0%) rgb(65.025% 79.973% 0%) rgb(69.455% 76.61% 0%) rgb(73.353% 73.18% 0%) rgb(76.786% 69.684% 0%) rgb(79.796% 66.125% 0%) rgb(82.412% 62.507% 0%) rgb(84.651% 58.835% 0%) rgb(86.526% 55.112% 0%) rgb(88.045% 51.345% 0%) rgb(89.213% 47.54% 0%) rgb(90.034% 43.704% 0%) rgb(90.512% 39.844% 0%) rgb(90.648% 35.967% 6.5514%) rgb(90.448% 32.079% 12.235%) rgb(100% 0.00023% -0.00002%)","title":"Steps"},{"location":"interpolation/#overlaying-colors","text":"The overlay method allows a transparent color to be overlaid on top of another color creating the composite of the two. To perform an overlay, a background color must be provided to the color along with an optional color space. If a color is to be overlaid within a smaller color space, the colors will be mapped to the smaller space. It is probably, not recommended to overlay in cylindrical color spaces, but there is no restrictions prohibiting such actions. In the example below, we take the rgb(100% 0% 0% / 0.5) and overlay it on the color black . This yields the color: rgb(127.5 0 0) . >>> color = Color ( \"rgb(100 % 0% 0% / 0.5)\" ) >>> color . overlay ( \"black\" ) . to_string () 'rgb(127.5 0 0)' A new color will be returned instead of modifying the current color unless in_place is set True .","title":"Overlaying Colors"},{"location":"interpolation/#null-hues","text":"Color spaces that have hue coordinates often have rules about when the hue is considered relevant. For instance, in the HSL color space, if saturation is zero, the hue is considered null. This is because the color is \"without color\"; therefore, it has no hue, or the hue is undefined. Many libraries, like d3-color , chroma.js , and color.js all represent null hues with NaN (not a number). This is usually done to make color interpolation easier. Some, like d3-color, are a bit more liberal with NaN and will target special cases that are above and beyond the normal rules to help ensure good interpolation. For instance, they not only mark hue null on HSL colors when saturation is zero, but also when lightness is zero or one hundred (essentially appearing black or white). In fact, they'll mark saturation as NaN when lightness indicates \"black\" or \"white\". Additionally, some libraries allow marking non-hue channels as NaN ; color.js allows a user to manually specify channels with NaN so they can mask off channels for interpolation. ColorAide also uses NaN during interpolating, but we do not carry that baggage around outside of interpolating. Colors will not return NaN in their coordinates, so the user doesn't have to worry about checking for those cases when assigning values, but it will calculate when hues are null when doing interpolation. If a space needs to account for hue when interpolating (mainly cylindrical color spaces) then ColorAide will flag the hue channel as null by assigning the coordinate a NaN prior to the actual interpolation. ColorAide will consider the following color spaces as having a null hue in the following cases: Color Space Null Condition HSV s<=0 or very near 0% 1 HSL s<=0 or very near 0% 1 HWB (w + b)>=100 or very near 100% 1 LCH c<=0 or very near 0% 1 When determining whether a hue is null, we use a threshold of 0.0005 \"nearness\". \u21a9 \u21a9 \u21a9 \u21a9 To determine at any time if a hue is considered null, the is_hue_null method can be used. Any space that considers hue will return True or False if their hue is null or not null respectively. Any space that does not specifically calculate hue, will simply return False . The method will consider the current color space by default, but you can query any color spaces by providing a different one. >>> Color ( \"lab(53.389% 0 0)\" ) . is_hue_null () False >>> Color ( \"lab(53.389% 0 0)\" ) . is_hue_null ( \"lch\" ) True >>> Color ( \"lab(53.389% 0 0)\" ) . is_hue_null ( \"hsl\" ) True >>> Color ( \"lab(53.389% 0 0)\" ) . is_hue_null ( \"hsv\" ) True >>> Color ( \"lab(53.389% 0 0)\" ) . is_hue_null ( \"hwb\" ) True Due to the way colors convert, all spaces may not yield the same value as in this example, so it is best to test in the space that is being targeted.","title":"Null Hues"},{"location":"manipulation/","text":"Manipulating Colors Reading Coordinates To get the numerical value of coordinates, there are various ways. You can read the channel property directly: >>> color = Color ( \"orange\" ) >>> color . red 1.0 You can also call the get method and send in the name of the channel. >>> color = Color ( \"orange\" ) >>> color . get ( \"green\" ) 0.6470588235294118 You can retrieve all the coordinates at once. >>> color = Color ( \"orange\" ) >>> color . coords () [1.0, 0.6470588235294118, 0.0] Alpha is never included in coords and must be accessed via the alpha property. If you need to get a color coordinate from another color space, but don't want to go the usual convert route, you can pass in the space and coordinate and it will all happen behind the scenes: >>> Color ( \"blue\" ) . get ( \"lch.chroma\" ) 131.20704008299427 Modifying Coordinates You can change the value of the current color by adjusting the channel coordinates directly via the named property. Here we modify red and change it to rgb(255 127.5 0) . >>> color = Color ( \"red\" ) >>> color . to_string () 'rgb(255 0 0)' >>> color . green = 0.5 >>> color . to_string () 'rgb(255 127.5 0)' When doing so, keep in mind, you are adjusting the internal coordinate, and you must modify it within the range in which it is stored, and for sRGB, it is in the range of [0, 1]. If you'd like to modify it with parameters similar to what you'd use in CSS, you can specify coordinates as a string, and they will be parsed accordingly. Here we change red and change it to rgb(255 128 0) . >>> color = Color ( \"red\" ) >>> color . to_string () 'rgb(255 0 0)' >>> color . green = \"128\" >>> color . to_string () 'rgb(255 128 0)' In most cases, this would be identical to the units used in CSS, but sRGB has to distinguish the hex form from normal floats and integers, so you have to append # to sRGB coordinates if you wish to treat them as hex. Here we change red and change it to rgb(255 51 0) . >>> color = Color ( \"red\" ) >>> color . to_string () 'rgb(255 0 0)' >>> color . green = \"#33\" >>> color . to_string () 'rgb(255 51 0)' If desired, you can also set attributes with the set method. As these methods return a reference to the class, you can chain these settings together. Chaining the changes together, we can transform white to rgb(0 127.5 255) . >>> Color ( \"white\" ) . set ( \"red\" , \"0%\" ) . set ( \"green\" , \"50%\" ) . to_string () 'rgb(0 127.5 255)' You can also use set to set the attributes in other color spaces as well. Here we alter the the color blue in the LCH color space and get rgb(19.403 81.154 0) . >>> Color ( \"blue\" ) . set ( 'lch.hue' , 130 ) . to_string () 'rgb(19.403 81.154 0)' You can also pass a function to modify the attribute. Here we do a relative adjustment of the green channel and transform the color pink to rgb(255 249.6 203) . >>> Color ( \"pink\" ) . set ( 'green' , lambda g : g * 1.3 ) . to_string () 'rgb(255 249.6 203)'","title":"Manipulating Colors"},{"location":"manipulation/#manipulating-colors","text":"","title":"Manipulating Colors"},{"location":"manipulation/#reading-coordinates","text":"To get the numerical value of coordinates, there are various ways. You can read the channel property directly: >>> color = Color ( \"orange\" ) >>> color . red 1.0 You can also call the get method and send in the name of the channel. >>> color = Color ( \"orange\" ) >>> color . get ( \"green\" ) 0.6470588235294118 You can retrieve all the coordinates at once. >>> color = Color ( \"orange\" ) >>> color . coords () [1.0, 0.6470588235294118, 0.0] Alpha is never included in coords and must be accessed via the alpha property. If you need to get a color coordinate from another color space, but don't want to go the usual convert route, you can pass in the space and coordinate and it will all happen behind the scenes: >>> Color ( \"blue\" ) . get ( \"lch.chroma\" ) 131.20704008299427","title":"Reading Coordinates"},{"location":"manipulation/#modifying-coordinates","text":"You can change the value of the current color by adjusting the channel coordinates directly via the named property. Here we modify red and change it to rgb(255 127.5 0) . >>> color = Color ( \"red\" ) >>> color . to_string () 'rgb(255 0 0)' >>> color . green = 0.5 >>> color . to_string () 'rgb(255 127.5 0)' When doing so, keep in mind, you are adjusting the internal coordinate, and you must modify it within the range in which it is stored, and for sRGB, it is in the range of [0, 1]. If you'd like to modify it with parameters similar to what you'd use in CSS, you can specify coordinates as a string, and they will be parsed accordingly. Here we change red and change it to rgb(255 128 0) . >>> color = Color ( \"red\" ) >>> color . to_string () 'rgb(255 0 0)' >>> color . green = \"128\" >>> color . to_string () 'rgb(255 128 0)' In most cases, this would be identical to the units used in CSS, but sRGB has to distinguish the hex form from normal floats and integers, so you have to append # to sRGB coordinates if you wish to treat them as hex. Here we change red and change it to rgb(255 51 0) . >>> color = Color ( \"red\" ) >>> color . to_string () 'rgb(255 0 0)' >>> color . green = \"#33\" >>> color . to_string () 'rgb(255 51 0)' If desired, you can also set attributes with the set method. As these methods return a reference to the class, you can chain these settings together. Chaining the changes together, we can transform white to rgb(0 127.5 255) . >>> Color ( \"white\" ) . set ( \"red\" , \"0%\" ) . set ( \"green\" , \"50%\" ) . to_string () 'rgb(0 127.5 255)' You can also use set to set the attributes in other color spaces as well. Here we alter the the color blue in the LCH color space and get rgb(19.403 81.154 0) . >>> Color ( \"blue\" ) . set ( 'lch.hue' , 130 ) . to_string () 'rgb(19.403 81.154 0)' You can also pass a function to modify the attribute. Here we do a relative adjustment of the green channel and transform the color pink to rgb(255 249.6 203) . >>> Color ( \"pink\" ) . set ( 'green' , lambda g : g * 1.3 ) . to_string () 'rgb(255 249.6 203)'","title":"Modifying Coordinates"},{"location":"strings/","text":"Convert to Strings Colors can be output back into strings by using the to_string method. The CSS color class will convert any of the supported color classes into CSS strings of various formats. >>> color = Color ( \"srgb\" , [ 0.5 , 0 , 1 ], 0.3 ) >>> color . to_string () 'rgb(127.5 0 255 / 0.3)' All color spaces support the following parameters: alpha : set to None by default, alpha will only be shown if less than 100%, but if set to True , alpha will always be shown. Setting to False will cause alpha to be ignored in the output. precision : precision controls the precision of the output values. It will actually adjust the precision and scale. The default is 5. In some cases, like sRGB hex output, precision may not really come into play as those getting rounded off to the nearest whole number anyways. >>> Color ( \"rgb(30 % 75% 100%)\" ) . to_string ( precision = 5 ) 'rgb(76.5 191.25 255)' >>> Color ( \"rgb(30 % 75% 100%)\" ) . to_string ( precision = 4 ) 'rgb(76.5 191.3 255)' >>> Color ( \"rgb(30 % 75% 100%)\" ) . to_string ( precision = 3 ) 'rgb(76.5 191 255)' >>> Color ( \"rgb(30 % 75% 100%)\" ) . to_string ( precision = 2 ) 'rgb(77 190 260)' >>> Color ( \"rgb(30 % 75% 100%)\" ) . to_string ( precision = 1 ) 'rgb(80 200 300)' Providing a precision of 0 will simply enable simple rounding to the nearest whole number. >>> Color ( \"rgb(30 % 75% 100%)\" ) . to_string ( precision = 0 ) 'rgb(77 191 255)' Providing a precision of -1 is a special input that will give the highest precision that can be given. >>> Color ( \"rgb(30.3 % 75.7% 100%)\" ) . to_string ( precision =- 1 ) 'rgb(77.2650000000000005684341886080801486968994140625 193.034999999999996589394868351519107818603515625 255)' fit : True by default, controls whether colors are fit to their gamut. Some color spaces are technically unbounded, so no fitting may occur in those color spaces. Color formats like sRGB hex, must fit into the gamut or they cannot be output correctly, so hex values will always be fit to the gamut. >>> Color ( \"rgb(30 % 105% 0%)\" ) . to_string () 'rgb(138 255 98.203)' >>> Color ( \"rgb(30 % 105% 0%)\" ) . to_string ( fit = False ) 'rgb(76.5 267.75 0)' color : For some color spaces, this is the default output, but for others you can explicitly request this output via setting color to True . If set to True , this will usually take priority over other format options. >>> Color ( \"rebeccapurple\" ) . to_string ( color = True ) 'color(srgb 0.4 0.2 0.6)' In general, a color in a given color space may share the same options as listed above, but a given color space may also have options unique to itself. sRGB Specific sRGB can output colors to a hex format which is unique compared to HSL and others. Simply enable hex . >>> color . to_string ( hex = True ) '#8000ff4d' sRGB also can output color names. If a color evaluates to a hex code which also evaluates to a color name in the internal CSS color name mapping, then a color name will be returned. If the color does not match a color name, it will fallback to whatever the other options dictate. Simply enable names . >>> Color ( \"rebeccapurple\" ) . to_string ( names = True ) 'rebeccapurple' >>> Color ( \"rgb(100 30 75)\" ) . to_string ( names = True ) 'rgb(100 30 75)' Lab Specific If a Lab color's a and b coordinates are very close to zero, the color will be considered achromatic. When this is true, and gray is enabled, colors will be output into the CSS gray() format. >>> Color ( 'lab(50% 0 0)' ) . to_string ( gray = True ) 'gray(50)' >>> Color ( 'lab(50% 1 0)' ) . to_string ( gray = True ) 'lab(50% 1 0)' Comma Format Certain color spaces we allow a comma format. Those are srgb , hsl , hwb , lch , and lab . Basically, the only formats that do not allow comma format at this time are the colors that only support the color() format. If we want commas, we can force the comma syntax by setting comma to True . This can alter some color space output in other subtle ways. As the comma format is the old legacy approach, when sRGB has commas enabled, it will use rgba instead of the rgb . If using the default space syntax, rgb is always used, even when the color has transparency. >>> Color ( \"rgb(30 75 100 / 20%)\" ) . to_string ( comma = True ) 'rgba(30, 75, 100, 0.2)'","title":"String Output"},{"location":"strings/#convert-to-strings","text":"Colors can be output back into strings by using the to_string method. The CSS color class will convert any of the supported color classes into CSS strings of various formats. >>> color = Color ( \"srgb\" , [ 0.5 , 0 , 1 ], 0.3 ) >>> color . to_string () 'rgb(127.5 0 255 / 0.3)' All color spaces support the following parameters: alpha : set to None by default, alpha will only be shown if less than 100%, but if set to True , alpha will always be shown. Setting to False will cause alpha to be ignored in the output. precision : precision controls the precision of the output values. It will actually adjust the precision and scale. The default is 5. In some cases, like sRGB hex output, precision may not really come into play as those getting rounded off to the nearest whole number anyways. >>> Color ( \"rgb(30 % 75% 100%)\" ) . to_string ( precision = 5 ) 'rgb(76.5 191.25 255)' >>> Color ( \"rgb(30 % 75% 100%)\" ) . to_string ( precision = 4 ) 'rgb(76.5 191.3 255)' >>> Color ( \"rgb(30 % 75% 100%)\" ) . to_string ( precision = 3 ) 'rgb(76.5 191 255)' >>> Color ( \"rgb(30 % 75% 100%)\" ) . to_string ( precision = 2 ) 'rgb(77 190 260)' >>> Color ( \"rgb(30 % 75% 100%)\" ) . to_string ( precision = 1 ) 'rgb(80 200 300)' Providing a precision of 0 will simply enable simple rounding to the nearest whole number. >>> Color ( \"rgb(30 % 75% 100%)\" ) . to_string ( precision = 0 ) 'rgb(77 191 255)' Providing a precision of -1 is a special input that will give the highest precision that can be given. >>> Color ( \"rgb(30.3 % 75.7% 100%)\" ) . to_string ( precision =- 1 ) 'rgb(77.2650000000000005684341886080801486968994140625 193.034999999999996589394868351519107818603515625 255)' fit : True by default, controls whether colors are fit to their gamut. Some color spaces are technically unbounded, so no fitting may occur in those color spaces. Color formats like sRGB hex, must fit into the gamut or they cannot be output correctly, so hex values will always be fit to the gamut. >>> Color ( \"rgb(30 % 105% 0%)\" ) . to_string () 'rgb(138 255 98.203)' >>> Color ( \"rgb(30 % 105% 0%)\" ) . to_string ( fit = False ) 'rgb(76.5 267.75 0)' color : For some color spaces, this is the default output, but for others you can explicitly request this output via setting color to True . If set to True , this will usually take priority over other format options. >>> Color ( \"rebeccapurple\" ) . to_string ( color = True ) 'color(srgb 0.4 0.2 0.6)' In general, a color in a given color space may share the same options as listed above, but a given color space may also have options unique to itself.","title":"Convert to Strings"},{"location":"strings/#srgb-specific","text":"sRGB can output colors to a hex format which is unique compared to HSL and others. Simply enable hex . >>> color . to_string ( hex = True ) '#8000ff4d' sRGB also can output color names. If a color evaluates to a hex code which also evaluates to a color name in the internal CSS color name mapping, then a color name will be returned. If the color does not match a color name, it will fallback to whatever the other options dictate. Simply enable names . >>> Color ( \"rebeccapurple\" ) . to_string ( names = True ) 'rebeccapurple' >>> Color ( \"rgb(100 30 75)\" ) . to_string ( names = True ) 'rgb(100 30 75)'","title":"sRGB Specific"},{"location":"strings/#lab-specific","text":"If a Lab color's a and b coordinates are very close to zero, the color will be considered achromatic. When this is true, and gray is enabled, colors will be output into the CSS gray() format. >>> Color ( 'lab(50% 0 0)' ) . to_string ( gray = True ) 'gray(50)' >>> Color ( 'lab(50% 1 0)' ) . to_string ( gray = True ) 'lab(50% 1 0)'","title":"Lab Specific"},{"location":"strings/#comma-format","text":"Certain color spaces we allow a comma format. Those are srgb , hsl , hwb , lch , and lab . Basically, the only formats that do not allow comma format at this time are the colors that only support the color() format. If we want commas, we can force the comma syntax by setting comma to True . This can alter some color space output in other subtle ways. As the comma format is the old legacy approach, when sRGB has commas enabled, it will use rgba instead of the rgb . If using the default space syntax, rgb is always used, even when the color has transparency. >>> Color ( \"rgb(30 75 100 / 20%)\" ) . to_string ( comma = True ) 'rgba(30, 75, 100, 0.2)'","title":"Comma Format"},{"location":"about/changelog/","text":"Changelog Current Not yet released","title":"Changelog"},{"location":"about/changelog/#changelog","text":"","title":"Changelog"},{"location":"about/changelog/#current","text":"Not yet released","title":"Current"},{"location":"about/contributing/","text":"Contributing & Support Become a Sponsor Open source projects take time and money. Help support the project by becoming a sponsor. You can add your support at any tier you feel comfortable with. No amount is too little. We also accept one time contributions via PayPal. GitHub Sponsors PayPal Bug Reports Please read the documentation and search the issue tracker to try and find the answer to your question before posting an issue. When creating an issue on the repository, please provide as much info as possible: Version being used. Operating system. Version of Python. Errors in console. Detailed description of the problem. Examples for reproducing the error. You can post pictures, but if specific text or code is required to reproduce the issue, please provide the text in a plain text format for easy copy/paste. The more info provided, the greater the chance someone will take the time to answer, implement, or fix the issue. Be prepared to answer questions and provide additional information if required. Issues in which the creator refuses to respond to follow up questions will be marked as stale and closed. Reviewing Code Take part in reviewing pull requests and/or reviewing direct commits. Make suggestions to improve the code and discuss solutions to overcome weakness in the algorithm. Answer Questions in Issues Take time and answer questions and offer suggestions to people who've created issues in the issue tracker. Often people will have questions that you might have an answer for. Or maybe you know how to help them accomplish a specific task they are asking about. Feel free to share your experience to help others out. Pull Requests Pull requests are welcome, and a great way to help fix bugs and add new features. Documentation Improvements A ton of time has been spent not only creating and supporting this tool and related extensions, but also spent making this documentation. If you feel it is still lacking, show your appreciation for the tool and/or extensions by helping to improve the documentation.","title":"Contributing &amp; Support"},{"location":"about/contributing/#contributing--support","text":"","title":"Contributing &amp; Support"},{"location":"about/contributing/#become-a-sponsor","text":"Open source projects take time and money. Help support the project by becoming a sponsor. You can add your support at any tier you feel comfortable with. No amount is too little. We also accept one time contributions via PayPal. GitHub Sponsors PayPal","title":"Become a Sponsor "},{"location":"about/contributing/#bug-reports","text":"Please read the documentation and search the issue tracker to try and find the answer to your question before posting an issue. When creating an issue on the repository, please provide as much info as possible: Version being used. Operating system. Version of Python. Errors in console. Detailed description of the problem. Examples for reproducing the error. You can post pictures, but if specific text or code is required to reproduce the issue, please provide the text in a plain text format for easy copy/paste. The more info provided, the greater the chance someone will take the time to answer, implement, or fix the issue. Be prepared to answer questions and provide additional information if required. Issues in which the creator refuses to respond to follow up questions will be marked as stale and closed.","title":"Bug Reports"},{"location":"about/contributing/#reviewing-code","text":"Take part in reviewing pull requests and/or reviewing direct commits. Make suggestions to improve the code and discuss solutions to overcome weakness in the algorithm.","title":"Reviewing Code"},{"location":"about/contributing/#answer-questions-in-issues","text":"Take time and answer questions and offer suggestions to people who've created issues in the issue tracker. Often people will have questions that you might have an answer for. Or maybe you know how to help them accomplish a specific task they are asking about. Feel free to share your experience to help others out.","title":"Answer Questions in Issues"},{"location":"about/contributing/#pull-requests","text":"Pull requests are welcome, and a great way to help fix bugs and add new features.","title":"Pull Requests"},{"location":"about/contributing/#documentation-improvements","text":"A ton of time has been spent not only creating and supporting this tool and related extensions, but also spent making this documentation. If you feel it is still lacking, show your appreciation for the tool and/or extensions by helping to improve the documentation.","title":"Documentation Improvements"},{"location":"about/license/","text":"License ColorAide The MIT License (MIT) Copyright \u00a9 2020 Isaac Muse Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"about/license/#license","text":"","title":"License"},{"location":"about/license/#coloraide","text":"The MIT License (MIT) Copyright \u00a9 2020 Isaac Muse Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"ColorAide"},{"location":"api/","text":"Color API Warning Under Construction","title":"Color API"},{"location":"api/#color-api","text":"Warning Under Construction","title":"Color API"},{"location":"colors/","text":"Supported Colors HSV Learn about HSV White Point D65 Coordinates Name Range hue 0 - 360 saturation 0 - 100 value 0 - 100 Supported Inputs >>> Color ( 'hsv' , [ 0 , 0 , 100 ]) color(hsv 0 0 100 / 1) >>> Color ( 'color(hsv 0 0 100)' ) color(hsv 0 0 100 / 1) sRGB Learn about sRGB White Point D65 Coordinates Name Range red 0 - 1 green 0 - 1 blue 0 - 1 Supported Inputs >>> Color ( \"srgb\" , [ 1 , 1 , 1 ]) color(srgb 1 1 1 / 1) >>> Color ( \"white\" ) color(srgb 1 1 1 / 1) >>> Color ( \"#ffffff\" ) color(srgb 1 1 1 / 1) >>> Color ( \"rgb(100 % 100% 100%)\" ) color(srgb 1 1 1 / 1) >>> Color ( \"rgb(255 255 255)\" ) color(srgb 1 1 1 / 1) >>> Color ( \"rgb(255 255 255 / 1)\" ) color(srgb 1 1 1 / 1) >>> Color ( \"rgba(255, 255, 255, 1)\" ) color(srgb 1 1 1 / 1) >>> Color ( \"rgb(255, 255, 255)\" ) color(srgb 1 1 1 / 1) HSL Learn about HSL White Point D65 Coordinates Name Range hue 0 - 360 saturation 0 - 100 lightness 0 - 100 Supported Inputs >>> Color ( \"hsl\" , [ 0 , 0 , 100 ]) color(hsl 0 0 100 / 1) >>> Color ( \"hsl(0 0 % 100% )\" ) color(hsl 0 0 100 / 1) >>> Color ( \"hsl(0, 0%, 100%)\" ) color(hsl 0 0 100 / 1) >>> Color ( \"hsl(0 0 % 100% / 1)\" ) color(hsl 0 0 100 / 1) >>> Color ( \"hsla(0, 0%, 100%, 1)\" ) color(hsl 0 0 100 / 1) HWB Learn about HWB White Point D65 Coordinates Name Range hue 0 - 360 whiteness 0 - 100 blackness 0 - 100 Supported Inputs >>> Color ( \"hwb\" , [ 0 , 100 , 0 ]) color(hwb 0 100 0 / 1) >>> Color ( \"color(hwb 0 100 0)\" ) color(hwb 0 100 0 / 1) >>> Color ( \"hwb(0 100 % 0% )\" ) color(hwb 0 100 0 / 1) >>> Color ( \"hwb(0, 100%, 0%)\" ) color(hwb 0 100 0 / 1) >>> Color ( \"hwb(0 100 % 0% / 1)\" ) color(hwb 0 100 0 / 1) >>> Color ( \"hwb(0, 100%, 0%, 1)\" ) color(hwb 0 100 0 / 1) Lab Learn about Lab White Point D50 Coordinates Name Range lightness 0 - 100 a \u00b1160 - \u00b1160 b \u00b1160 - \u00b1160 Supported Inputs >>> Color ( \"lab\" , [ 100 , 0 , 0 ]) color(lab 100 0 0 / 1) >>> Color ( \"color(lab 100 0 0)\" ) color(lab 100 0 0 / 1) >>> Color ( \"lab(100% 0 0)\" ) color(lab 100 0 0 / 1) >>> Color ( \"lab(100%, 0, 0, 1)\" ) color(lab 100 0 0 / 1) >>> Color ( \"lab(100% 0 0 / 1)\" ) color(lab 100 0 0 / 1) LCH Learn about LCH White Point D50 Coordinates Name Range lightness 0 - 100 chroma 0 - 100 hue 0 - 360 Supported Inputs >>> Color ( \"lch\" , [ 100 , 0 , 0 ]) color(lch 100 0 0 / 1) >>> Color ( \"color(lch 100 0 0)\" ) color(lch 100 0 0 / 1) >>> Color ( \"lch(100% 0 0)\" ) color(lch 100 0 0 / 1) >>> Color ( \"lch(100%, 0, 0, 1)\" ) color(lch 100 0 0 / 1) >>> Color ( \"lch(100% 0 0 / 1)\" ) color(lch 100 0 0 / 1) XYZ Learn about XYZ White Point D50 Coordinates Name Range x 0 - 1 y 0 - 1 z 0 - 1 Supported Inputs >>> Color ( \"xyz\" , [ 0.96422 , 1 , 0.82521 ]) color(xyz 0.96422 1 0.82521 / 1) >>> Color ( \"color(xyz 0.96422 1 0.82521 / 1)\" ) color(xyz 0.96422 1 0.82521 / 1) Display P3 Learn about Display P3 White Point D50 Coordinates Name Range red 0 - 1 green 0 - 1 blue 0 - 1 Supported Inputs >>> Color ( \"display-p3\" , [ 1 , 1 , 1 ]) color(display-p3 1 1 1 / 1) >>> Color ( \"color(display-p3 1 1 1)\" ) color(display-p3 1 1 1 / 1) Adobe\u00ae RGB Compatible Learn about Adobe\u00ae RGB Compatible White Point D65 Coordinates Name Range red 0 - 1 green 0 - 1 blue 0 - 1 Supported Inputs >>> Color ( \"a98-rgb\" , [ 1 , 1 , 1 ]) color(a98-rgb 1 1 1 / 1) >>> Color ( \"color(a98-rgb 1 1 1)\" ) color(a98-rgb 1 1 1 / 1) REC.2020 Learn about REC.2020 White Point D65 Coordinates Name Range red 0 - 1 green 0 - 1 blue 0 - 1 Supported Inputs >>> Color ( \"rec2020\" , [ 1 , 1 , 1 ]) color(rec2020 1 1 1 / 1) >>> Color ( \"color(rec2020 1 1 1)\" ) color(rec2020 1 1 1 / 1) ProPhoto Learn about ProPhoto White Point D50 Coordinates Name Range red 0 - 1 green 0 - 1 blue 0 - 1 Supported Inputs >>> Color ( \"prophoto-rgb\" , [ 1 , 1 , 1 ]) color(prophoto-rgb 1 1 1 / 1) >>> Color ( \"color(prophoto-rgb 1 1 1)\" ) color(prophoto-rgb 1 1 1 / 1)","title":"Supported Colors"},{"location":"colors/#supported-colors","text":"","title":"Supported Colors"},{"location":"colors/#hsv","text":"Learn about HSV White Point D65 Coordinates Name Range hue 0 - 360 saturation 0 - 100 value 0 - 100 Supported Inputs >>> Color ( 'hsv' , [ 0 , 0 , 100 ]) color(hsv 0 0 100 / 1) >>> Color ( 'color(hsv 0 0 100)' ) color(hsv 0 0 100 / 1)","title":"HSV"},{"location":"colors/#srgb","text":"Learn about sRGB White Point D65 Coordinates Name Range red 0 - 1 green 0 - 1 blue 0 - 1 Supported Inputs >>> Color ( \"srgb\" , [ 1 , 1 , 1 ]) color(srgb 1 1 1 / 1) >>> Color ( \"white\" ) color(srgb 1 1 1 / 1) >>> Color ( \"#ffffff\" ) color(srgb 1 1 1 / 1) >>> Color ( \"rgb(100 % 100% 100%)\" ) color(srgb 1 1 1 / 1) >>> Color ( \"rgb(255 255 255)\" ) color(srgb 1 1 1 / 1) >>> Color ( \"rgb(255 255 255 / 1)\" ) color(srgb 1 1 1 / 1) >>> Color ( \"rgba(255, 255, 255, 1)\" ) color(srgb 1 1 1 / 1) >>> Color ( \"rgb(255, 255, 255)\" ) color(srgb 1 1 1 / 1)","title":"sRGB"},{"location":"colors/#hsl","text":"Learn about HSL White Point D65 Coordinates Name Range hue 0 - 360 saturation 0 - 100 lightness 0 - 100 Supported Inputs >>> Color ( \"hsl\" , [ 0 , 0 , 100 ]) color(hsl 0 0 100 / 1) >>> Color ( \"hsl(0 0 % 100% )\" ) color(hsl 0 0 100 / 1) >>> Color ( \"hsl(0, 0%, 100%)\" ) color(hsl 0 0 100 / 1) >>> Color ( \"hsl(0 0 % 100% / 1)\" ) color(hsl 0 0 100 / 1) >>> Color ( \"hsla(0, 0%, 100%, 1)\" ) color(hsl 0 0 100 / 1)","title":"HSL"},{"location":"colors/#hwb","text":"Learn about HWB White Point D65 Coordinates Name Range hue 0 - 360 whiteness 0 - 100 blackness 0 - 100 Supported Inputs >>> Color ( \"hwb\" , [ 0 , 100 , 0 ]) color(hwb 0 100 0 / 1) >>> Color ( \"color(hwb 0 100 0)\" ) color(hwb 0 100 0 / 1) >>> Color ( \"hwb(0 100 % 0% )\" ) color(hwb 0 100 0 / 1) >>> Color ( \"hwb(0, 100%, 0%)\" ) color(hwb 0 100 0 / 1) >>> Color ( \"hwb(0 100 % 0% / 1)\" ) color(hwb 0 100 0 / 1) >>> Color ( \"hwb(0, 100%, 0%, 1)\" ) color(hwb 0 100 0 / 1)","title":"HWB"},{"location":"colors/#lab","text":"Learn about Lab White Point D50 Coordinates Name Range lightness 0 - 100 a \u00b1160 - \u00b1160 b \u00b1160 - \u00b1160 Supported Inputs >>> Color ( \"lab\" , [ 100 , 0 , 0 ]) color(lab 100 0 0 / 1) >>> Color ( \"color(lab 100 0 0)\" ) color(lab 100 0 0 / 1) >>> Color ( \"lab(100% 0 0)\" ) color(lab 100 0 0 / 1) >>> Color ( \"lab(100%, 0, 0, 1)\" ) color(lab 100 0 0 / 1) >>> Color ( \"lab(100% 0 0 / 1)\" ) color(lab 100 0 0 / 1)","title":"Lab"},{"location":"colors/#lch","text":"Learn about LCH White Point D50 Coordinates Name Range lightness 0 - 100 chroma 0 - 100 hue 0 - 360 Supported Inputs >>> Color ( \"lch\" , [ 100 , 0 , 0 ]) color(lch 100 0 0 / 1) >>> Color ( \"color(lch 100 0 0)\" ) color(lch 100 0 0 / 1) >>> Color ( \"lch(100% 0 0)\" ) color(lch 100 0 0 / 1) >>> Color ( \"lch(100%, 0, 0, 1)\" ) color(lch 100 0 0 / 1) >>> Color ( \"lch(100% 0 0 / 1)\" ) color(lch 100 0 0 / 1)","title":"LCH"},{"location":"colors/#xyz","text":"Learn about XYZ White Point D50 Coordinates Name Range x 0 - 1 y 0 - 1 z 0 - 1 Supported Inputs >>> Color ( \"xyz\" , [ 0.96422 , 1 , 0.82521 ]) color(xyz 0.96422 1 0.82521 / 1) >>> Color ( \"color(xyz 0.96422 1 0.82521 / 1)\" ) color(xyz 0.96422 1 0.82521 / 1)","title":"XYZ"},{"location":"colors/#display-p3","text":"Learn about Display P3 White Point D50 Coordinates Name Range red 0 - 1 green 0 - 1 blue 0 - 1 Supported Inputs >>> Color ( \"display-p3\" , [ 1 , 1 , 1 ]) color(display-p3 1 1 1 / 1) >>> Color ( \"color(display-p3 1 1 1)\" ) color(display-p3 1 1 1 / 1)","title":"Display P3"},{"location":"colors/#adober-rgb-compatible","text":"Learn about Adobe\u00ae RGB Compatible White Point D65 Coordinates Name Range red 0 - 1 green 0 - 1 blue 0 - 1 Supported Inputs >>> Color ( \"a98-rgb\" , [ 1 , 1 , 1 ]) color(a98-rgb 1 1 1 / 1) >>> Color ( \"color(a98-rgb 1 1 1)\" ) color(a98-rgb 1 1 1 / 1)","title":"Adobe(r) RGB Compatible"},{"location":"colors/#rec2020","text":"Learn about REC.2020 White Point D65 Coordinates Name Range red 0 - 1 green 0 - 1 blue 0 - 1 Supported Inputs >>> Color ( \"rec2020\" , [ 1 , 1 , 1 ]) color(rec2020 1 1 1 / 1) >>> Color ( \"color(rec2020 1 1 1)\" ) color(rec2020 1 1 1 / 1)","title":"REC.2020"},{"location":"colors/#prophoto","text":"Learn about ProPhoto White Point D50 Coordinates Name Range red 0 - 1 green 0 - 1 blue 0 - 1 Supported Inputs >>> Color ( \"prophoto-rgb\" , [ 1 , 1 , 1 ]) color(prophoto-rgb 1 1 1 / 1) >>> Color ( \"color(prophoto-rgb 1 1 1)\" ) color(prophoto-rgb 1 1 1 / 1)","title":"ProPhoto"}]}