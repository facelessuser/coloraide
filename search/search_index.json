{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":""},{"location":"#what-is-coloraide","title":"What is ColorAide?","text":"<p>ColorAide is a pure Python, object oriented approach to colors.</p> <pre><code>&gt;&gt;&gt; from coloraide import Color\n&gt;&gt;&gt; Color.steps(['lch(75% 50 0)', 'lch(75% 50 300)'], steps=8, space='lch', hue='longer')\n[color(--lch 75 50 0 / 1), color(--lch 75 50 42.857 / 1), color(--lch 75 50 85.714 / 1), color(--lch 75 50 128.57 / 1), color(--lch 75 50 171.43 / 1), color(--lch 75 50 214.29 / 1), color(--lch 75 50 257.14 / 1), color(--lch 75 50 300 / 1)]\n</code></pre> Gamut: srgb <p>ColorAide particularly has a focus on the following:</p> <ul> <li> <p> Accurate colors.</p> </li> <li> <p> Proper round tripping (where reasonable).</p> </li> <li> <p> Be generally easy to pick up for the average user.</p> </li> <li> <p> Support modern CSS color spaces and syntax.</p> </li> <li> <p> Make accessible many new and old non-CSS color spaces.</p> </li> <li> <p> Provide a number of useful utilities such as interpolation, color distancing, blending, gamut mapping, filters,     correlated color temperature, color vision deficiency simulation, color harmonies, etc.</p> </li> <li> <p> Provide a plugin API to extend supported color spaces and approaches to various utilities.</p> </li> <li> <p> Allow users to configure defaults to their liking.</p> </li> </ul> <p>ColorAide is not meant to be the one library to replace all other color libraries. There are many great libraries out there such as: Colour Science, Colorio, Python Color Math, and many others. Some focus on the scientific aspects of colors and provide a wealth of various spaces, illuminants, access to complex color space visualizers, and numerous esoteric tools. Some are highly focused on speed. Some are powerful, but can be more complex to pick up by the average user.</p> <p>At its heart, ColorAide was designed for convenience, flexibility, and to be very easy to pick up and work with. There are, of course, some trade offs with speed when using a pure Python, object oriented approach, but there are also many advantages as well. ColorAide might not always be the tool for every job, but hopefully it is a great tool all the same.</p>"},{"location":"#installation","title":"Installation","text":"<p>ColorAide can be installed via Python's <code>pip</code>:</p> <pre><code>$ pip install coloraide\n</code></pre>"},{"location":"advanced/","title":"Advanced Topics","text":"<p>Colors are complicated, and sometimes it may not be understood why colors or color transformations yield the results that they do. Here we'd like to cover more advanced or specific topics that don't fit well in existing topics or are too verbose to be included elsewhere.</p>"},{"location":"advanced/#css-compatibility","title":"CSS Compatibility","text":"<p>CSS is a convenient color syntax that people are familiar with, so it makes a great text representation of colors. ColorAide supports the input and output of CSS syntax, but that doesn't mean it is attempting to be a CSS color library. CSS goals and ColorAide goals are at times different, and some of the decisions they make are at odds with how we feel colors should be treated in general. While we may not have all of CSS's behaviors enabled by default, we do provide a way to simulate most CSS logic.</p>"},{"location":"advanced/#what-is-not-supported","title":"What is Not Supported?","text":"<p>It should be noted that ColorAide does not provide compatibility for CSS parse-time clamping. CSS clamps RGB channels when using <code>rgb()</code> syntax, it clamps lightness of Lab and LCh color spaces (Oklab and OkLCh included), it clamps hues, chroma, and saturation in many cylindrical color spaces. ColorAide does not do any of this.</p> <ul> <li>ColorAide only clamps channels if the conversion algorithm requires it or when performing gamut mapping/clipping.</li> <li>Hues are left as specified except when converted to another color space, gamut mapping/clipping, or when normalizing   a color.</li> </ul> <p>Currently, the only thing ColorAide clamps is the <code>alpha</code> channel as there is no practical use for transparency or opaqueness beyond the range of [0, 1]. ColorAide clamps alpha on every set.</p>"},{"location":"advanced/#what-is-supported","title":"What is Supported?","text":"<p>There are four features that allow ColorAide to mimic CSS behavior. All four features can be used on demand via special parameters when using the appropriate, related functions, but if desired, they can be forced to be enabled for a <code>Color</code> class. It should be noted that while all of these are defined in the CSS spec, some may not actually be implemented at this time. The four features are as follows:</p> <ol> <li> <p>Gamut mapping with <code>oklch-chroma</code> is the current CSS recommended approach. It provides a color space with better     hue preservation, but the space does become a bit more distorted at very wide gamuts and can cause sane gamut     mapping to break down. Gamut mapping colors that fall within the Rec. 2020 and Display P3 range should work     reasonably well.</p> </li> <li> <p>The <code>css-linear</code> interpolator follows CSS interpolation logic which differs from ColorAide's default interpolation     logic. CSS specifically treats interpolation between achromatic hues and non-achromatic hues as if there is a hue     arc. This means that when using <code>longer</code> hue fix-ups when interpolating between a color with a undefined hue and a     color with a defined hue, you will interpolate a full 360 degrees. We do not agree with this approach and feel in     both <code>shorter</code> and <code>longer</code> hue fix-ups that there should be no arc to interpolate along.</p> </li> <li> <p>CSS defines a concept of auto powerless handling in CSS will force hues to be interpolated as powerless if under     certain circumstances. This usually happens when a color space's chroma/saturation components are zero. While this     behavior does make general sense, and ensures that a user is always treating achromatic colors as achromatic, it     cripples the user's control of how a color is interpolated.</p> <p>ColorAide, by default, respects what the user has explicitly specified. If a user has a component set as undefined, it is treated as undefined, if it is explicitly set to a numerical value, it is treated defined. This makes interpolation very transparent. Only through natural conversions or explicit user intervention do hues become achromatic. If a user has explicitly defined a hue, they need to use <code>normalize()</code> to force ColorAide to update powerless hues.</p> <p>With all of this said, there are times when a user may want to force powerless hues, even when not explicitly defined, in these cases ColorAide can enforce this behavior during interpolation via the <code>powerless</code> parameter.</p> </li> <li> <p>CSS also defines the idea of carrying forward undefined values during interpolation. Essentially, if a user     specifies an undefined component, but interpolation is performed in a different color space, after conversion, if     the two color spaces have compatible components, the undefined values will be carried forward to the like     components. This means that an undefined hue in HSL would be carried forward to LCh. A red component in sRGB would     be carried over to Display P3.</p> <p>The concept is interesting, but it can sometimes be a bit surprising in some cases. Currently, ColorAide does not enable this by default, but it can be done so via the <code>carryforward</code> parameter when interpolating.</p> </li> </ol> <p>If a CSS compatible color object that has all these features enabled by default is required, one can be derived from the base <code>Color</code> class. All four features can be forced as enabled by default as shown below.</p> <pre><code>from coloraide import Color as Base\n\nclass Color(base):\n    FIT = 'oklch-chroma'\n    INTERPOLATOR = 'css-linear'\n    POWERLESS = True\n    CARRYFORWARD = True\n</code></pre>"},{"location":"advanced/#round-trip-accuracy","title":"Round Trip Accuracy","text":"<p>In general, ColorAide is careful to provide good round trip conversions where practical. What this means is that we try to maintain a high level of accuracy so that when a color is converted to a different color and back that it will be very close, if not exactly, the same.</p> <p>In general, we are able to keep decent round tripping by not clipping values during conversion and maintaining as high a level of precision as we can, but there are some cases where the high level of round trip accuracy cannot be maintained, or even at all. There are even reasons where we willfully choose to sacrifice some accuracy for convenience in order to uphold intuitive expectations for the user.</p> <p>If you are a color scientist or you work in certain industries, there are definite reasons to uphold accuracy at all costs, but sometimes, you just want the colors to do the what you expect them to do. ColorAide tries to live in the space between. We try to provide accurate color round tripping except when it comes at the cost of practicality.</p>"},{"location":"advanced/#limitations-of-the-color-space","title":"Limitations of The Color Space","text":"<p>One situation that can affect round tripping is when one color model cannot properly handle a color due to its gamut being beyond the conversion algorithm's capabilities.</p> <p>Consider a wide gamut, HDR color space like Jzazbz. Jzazbz is an unbounded color space with plenty of headroom for HDR. Now, let's compare it to HSLuv, an SDR color space derived from the Luv color space and confined to the sRGB gamut. It is essentially a more perceptually uniform version of HSL, but the algorithm specifically requires lightness to be clamped to the SDR range. If we convert an HDR color from Jzazbz to HSLuv, round trip will be broken as the color space simply does not support the HDR range.</p> <p> <pre><code>&gt;&gt;&gt; jz = Color('jzazbz(0.25 0 0)')\n&gt;&gt;&gt; jz\ncolor(--jzazbz 0.25 0 0 / 1)\n&gt;&gt;&gt; hsluv = jz.convert('hsluv')\n&gt;&gt;&gt; hsluv\ncolor(--hsluv none 0 100 / 1)\n&gt;&gt;&gt; hsluv.convert('jzazbz')\ncolor(--jzazbz 0.22207 -0.00016 -0.00012 / 1)\n</code></pre> Gamut: srgb  If a color space algorithm does not support a specific color, the conversion may be clamped or come back with an unexpected value.</p>"},{"location":"advanced/#floating-point-math","title":"Floating Point Math","text":"<p>Floating point math can also be responsible for some differences in round tripping. Floating point issues are not specific to this library or even the language of Python, but to all computers in general. For example, computers cannot store infinite repeating decimals to properly represent all floating point numbers.</p> <p>What this means is that no matter how much floating point precision you maintain, some error is introduced when doing floating point operations. Certain rounding conventions are used in order to average out the errors to stay as close as possible to the intended, real value, but it does not prevent floating point errors. This is simply the nature of computers and floating point math.</p> <pre><code>&gt;&gt;&gt; color = Color('white')\n&gt;&gt;&gt; color[:]\n[1.0, 1.0, 1.0, 1.0]\n&gt;&gt;&gt; color.convert('prophoto-rgb').convert('srgb')[:]\n[1.0000000000000004, 0.9999999999999997, 0.9999999999999997, 1.0]\n</code></pre> Gamut: srgb"},{"location":"advanced/#special-handling-cylindrical-spaces","title":"Special Handling: Cylindrical Spaces","text":"<p>Sometimes, round trip accuracy can be compromised further for practical reasons. A common case where we make compromises is with cylindrical color models.</p> <p>ColorAide aims to make colors easy to use, but the one case that can frustrate users is interpolating with an achromatic color using a cylindrical color space.</p> <p>Achromatic colors do not have a hue, but all conversions end up yielding something for hue, even it has no practical meaning. This can cause odd color shifts when interpolating with an achromatic color. In order to get logical results when doing interpolation, we detect when a color is achromatic (or very close to achromatic) and set the hues to undefined. This helps us to identify achromatic cases and helps us to prevent weird color shifts when interpolating between achromatic colors. Only if a user manually defines a hue do we respect it.</p> <pre><code>&gt;&gt;&gt; Color.interpolate(['lch(75 100 180)', 'lch(75 0 0)'], space='lch')\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x7f46548856d0&gt;\n&gt;&gt;&gt; Color.interpolate(['lch(75 100 180)', 'lch(75 0 none)'], space='lch')\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x7f4654885bd0&gt;\n</code></pre> Gamut: srgb <p>Because of floating point issues, conversions to cylindrical color spaces do not always satisfy the requirements to be recognized as achromatic colors.</p> <p>As an example, HSL colors are achromatic when the sRGB color it is derived from has all color channels equal to each other. Let's say we convert the color <code>darkgray</code> to the XYZ D65 color space and then back again. We can see that what was once a color with all color channels equal to each other is now a color that has color channels very nearly equal to each other.</p> <pre><code>&gt;&gt;&gt; c1 = Color('darkgray')\n&gt;&gt;&gt; c1[:-1]\n[0.6627450980392157, 0.6627450980392157, 0.6627450980392157]\n&gt;&gt;&gt; c2 = c1.convert('xyz-d65').convert('srgb')\n&gt;&gt;&gt; c2[:-1]\n[0.6627450980392157, 0.6627450980392156, 0.6627450980392156]\n</code></pre> Gamut: srgb <p>These two colors are intended to be the same, but one satisfies the requirement to have the HSL hue set to <code>NaN</code>, but the other does not. This is a case where accuracy vs practicality comes into play. We all know the color is essentially still <code>darkgray</code>, and that is what the user intends. To allow this to work seamlessly, we apply a little leniency to the achromatic rules and state that if the color is very, very close to being achromatic, we will consider it achromatic, and we sacrifice a little accuracy to gain practicality. Or maybe it is better to say that we compensate for the natural inaccuracies that exist.</p> <pre><code>&gt;&gt;&gt; Color('darkgray').convert('hsl')[:-1]\n[nan, 0.0, 0.6627450980392157]\n&gt;&gt;&gt; Color('darkgray').convert('xyz-d65').convert('hsl')[:-1]\n[nan, 3.2919403637141254e-16, 0.6627450980392156]\n</code></pre> Gamut: srgb <p>This problem can exist in various scenarios in pretty much all cylindrical color spaces. Some have tighter algorithms and may give really good results with sRGB, but then when converting from some other color space we'll see maybe not as tight a translation to and from.</p>"},{"location":"average/","title":"Color Averaging","text":"<p>Color averaging is the process of calculating an average color from a set of other colors by taking the mean of each color channel.</p> <p>Averaging under ColorAide can take as many colors as desired and will return a color that represents the average. This is not to be confused with interpolation which employs a different technique, but in certain situations, it can sort of function like mixing multiple colors.</p>"},{"location":"average/#rectangular-space-averaging","title":"Rectangular Space Averaging","text":"<p>ColorAide, by default, averages in rectangular color spaces, the default being Linear sRGB. If desired, other color spaces can be used, such as perceptually uniform spaces like Oklab.</p> <pre><code>&gt;&gt;&gt; Color.average(['red', 'blue'])\ncolor(srgb-linear 0.5 0 0.5 / 1)\n&gt;&gt;&gt; Color.average(['red', 'blue'], space='srgb')\ncolor(srgb 0.5 0 0.5 / 1)\n&gt;&gt;&gt; Color.average(['red', 'blue'], space='oklab')\ncolor(--oklab 0.53998 0.0962 -0.09284 / 1)\n</code></pre> Gamut: srgb <p>Averaging is not restricted to any certain amount of colors.</p> <pre><code>&gt;&gt;&gt; Color.average(['red', 'yellow', 'orange', 'green'])\ncolor(srgb-linear 0.75 0.39803 0 / 1)\n</code></pre> Gamut: srgb"},{"location":"average/#cylindrical-space-averaging","title":"Cylindrical Space Averaging","text":"<p>ColorAide can average colors in rectangular spaces and cylindrical spaces. When applying averaging in a cylindrical space, hues will be averaged taking the circular mean.</p> <p>Colors that appear to be achromatic will have their hue treated as undefined, even if the hue is defined.</p> <p>Cylindrical averaging may provide very different results that averaging in rectangular spaces.</p> <pre><code>&gt;&gt;&gt; Color.average(['purple', 'green', 'blue'])\ncolor(srgb-linear 0.07195 0.07195 0.40529 / 1)\n&gt;&gt;&gt; Color.average(['purple', 'green', 'blue'], space='hsl')\ncolor(--hsl 240 1 0.33399 / 1)\n</code></pre> Gamut: srgb <p>It should be noted that when averaging colors with hues which are evenly distributed around the color wheel, the result will produce an achromatic hue. When achromatic hues are produced during circular mean, the color will discard chroma/saturation information, producing an achromatic color.</p> <pre><code>&gt;&gt;&gt; Color.average(['red', 'green', 'blue'], space='hsl')\ncolor(--hsl none 0 0.41699 / 1)\n</code></pre> Gamut: srgb"},{"location":"average/#averaging-with-transparency","title":"Averaging with Transparency","text":"<p>ColorAide, by default, will account for transparency when averaging colors. Colors which are more transparent will have less of an impact on the average. This is done by premultiplying the colors before averaging, essentially weighting the color components where more opaque colors have a greater influence on the average.</p> <pre><code>&gt;&gt;&gt; for i in range(12):\n...     Color.average(\n...         [f'color(srgb 0 1 0 / {i / 11})', 'color(srgb 0 0 1)']\n...     )\n... \ncolor(srgb-linear 0 0 1 / 0.5)\ncolor(srgb-linear 0 0.08333 0.91667 / 0.54545)\ncolor(srgb-linear 0 0.15385 0.84615 / 0.59091)\ncolor(srgb-linear 0 0.21429 0.78571 / 0.63636)\ncolor(srgb-linear 0 0.26667 0.73333 / 0.68182)\ncolor(srgb-linear 0 0.3125 0.6875 / 0.72727)\ncolor(srgb-linear 0 0.35294 0.64706 / 0.77273)\ncolor(srgb-linear 0 0.38889 0.61111 / 0.81818)\ncolor(srgb-linear 0 0.42105 0.57895 / 0.86364)\ncolor(srgb-linear 0 0.45 0.55 / 0.90909)\ncolor(srgb-linear 0 0.47619 0.52381 / 0.95455)\ncolor(srgb-linear 0 0.5 0.5 / 1)\n</code></pre> Gamut: srgb <p>There are cases where this approach of averaging may not be desired. It may be that color averaging is desired without considering transparency. If so, <code>premultiplied</code> can be disabled by setting it to <code>False</code>. While the average of transparency is calculated, it can be discarded from the final result if desired.</p> <p>It should be noted that when a color is fully transparent, its color components will be ignored, regardless of the <code>premultiplied</code> parameter, as fully transparent colors provide no meaningful color information.</p> <pre><code>&gt;&gt;&gt; for i in range(12):\n...     Color.average(\n...         [f'color(srgb 0 1 0 / {i / 11})', 'color(srgb 0 0 1)'],\n...         premultiplied=False,\n...     )\n... \ncolor(srgb-linear 0 0 1 / 0.5)\ncolor(srgb-linear 0 0.5 0.5 / 0.54545)\ncolor(srgb-linear 0 0.5 0.5 / 0.59091)\ncolor(srgb-linear 0 0.5 0.5 / 0.63636)\ncolor(srgb-linear 0 0.5 0.5 / 0.68182)\ncolor(srgb-linear 0 0.5 0.5 / 0.72727)\ncolor(srgb-linear 0 0.5 0.5 / 0.77273)\ncolor(srgb-linear 0 0.5 0.5 / 0.81818)\ncolor(srgb-linear 0 0.5 0.5 / 0.86364)\ncolor(srgb-linear 0 0.5 0.5 / 0.90909)\ncolor(srgb-linear 0 0.5 0.5 / 0.95455)\ncolor(srgb-linear 0 0.5 0.5 / 1)\n</code></pre> Gamut: srgb"},{"location":"average/#averaging-with-undefined-values","title":"Averaging with Undefined Values","text":"<p>When averaging with undefined values, ColorAide will not consider the undefined values in the average. This is mainly provided for averaging cylindrical colors, particularly achromatic colors.</p> <pre><code>&gt;&gt;&gt; Color.average(['white', 'color(srgb 0 0 1)'], space='hsl')\ncolor(--hsl 240 0.5 0.75 / 1)\n</code></pre> Gamut: srgb <p>When averaging hues in a polar space, implied achromatic hues are also treated as undefined as counting such hues would distort the average in a non-meaningful way.</p> <pre><code>&gt;&gt;&gt; Color.average(['hsl(30 0 100)', 'hsl(240 100 50 / 1)'], space='hsl')\ncolor(--hsl 240 0.5 0.75 / 1)\n</code></pre> Gamut: srgb <p>While undefined logic is intended to handle achromatic hues, this logic will be applied to any channel. It should be noted that no attempt to carry forward the undefined values through conversion is made at this time. Conversions will remove any undefined status unless the channel is an achromatic hues.</p> <pre><code>&gt;&gt;&gt; for i in range(12):\n...     Color.average(['darkgreen', f'color(srgb 0 none 0 / {i / 11})', 'color(srgb 0 0 1)'])\n... \ncolor(srgb-linear 0 0.06372 0.5 / 0.66667)\ncolor(srgb-linear 0 0.06095 0.47826 / 0.69697)\ncolor(srgb-linear 0 0.05841 0.45833 / 0.72727)\ncolor(srgb-linear 0 0.05607 0.44 / 0.75758)\ncolor(srgb-linear 0 0.05392 0.42308 / 0.78788)\ncolor(srgb-linear 0 0.05192 0.40741 / 0.81818)\ncolor(srgb-linear 0 0.05006 0.39286 / 0.84848)\ncolor(srgb-linear 0 0.04834 0.37931 / 0.87879)\ncolor(srgb-linear 0 0.04673 0.36667 / 0.90909)\ncolor(srgb-linear 0 0.04522 0.35484 / 0.93939)\ncolor(srgb-linear 0 0.04381 0.34375 / 0.9697)\ncolor(srgb-linear 0 0.04248 0.33333 / 1)\n</code></pre> Gamut: srgb <p>When <code>premultiplied</code> is enabled, premultiplication will not be applied to a color if its <code>alpha</code> is undefined as it is unknown how to weight the color, instead the color is treated with full weight.</p> <pre><code>&gt;&gt;&gt; Color.average(['darkgreen', f'color(srgb 0 0.50196 0 / none)', 'color(srgb 0 0 1)'])\ncolor(srgb-linear 0 0.11443 0.33333 / 1)\n</code></pre> Gamut: srgb"},{"location":"cat/","title":"Chromatic Adaptation","text":"<p>Chromatic adaptation is the human visual system's ability to adjust to changes in illumination in order to preserve the appearance of object colors. It is responsible for the stable appearance of object colors despite the wide variation of light which might be reflected from an object and observed by our eyes. A chromatic adaptation transform (CAT) emulates this important aspect of color perception in color appearance models.</p> <p>In short, colors look different under different lighting, and CATs are used to predict what a color should look like from one lighting source to another.</p>"},{"location":"cat/#illuminants","title":"Illuminants","text":"<p>Viewing a color in daylight will look different than viewing it by candle light. Color spaces usually define a reference illuminant that clarifies the assumed lighting for the given space. For instance, sRGB is a color space defined with an illuminant of D65 (light in the shade - no direct sunlight - at noon). On the other hand, the ProPhoto RGB space uses a D50 illuminant (direct sunlight at noon).</p> <p></p> <p>When translating a color from one illuminant to another, it is desirable to ensure that the color under the original illuminant appears as it should under the new illuminant, just as it would in real life. CATs are used to predict what the new color under the new illuminant should be in order to fulfill these requirements.</p> <p>For a quick example, let's take the color <code>blue</code> under sRGB (D65 white point) and the same <code>blue</code> under Pro Photo RGB (D50 white point). If we take the raw chromaticity points from the color under each color space and use them to generate a color, both under the same color space (in this case sRGB), we can see that the values are different. We can see the values are different.</p> <pre><code>&gt;&gt;&gt; d65 = Color('blue').split_chromaticity()\n&gt;&gt;&gt; d50 = Color('blue').convert('prophoto-rgb').split_chromaticity()\n&gt;&gt;&gt; color_d50 = Color.chromaticity('srgb', d50)\n&gt;&gt;&gt; color_d65 = Color.chromaticity('srgb', d65)\n&gt;&gt;&gt; Row([color_d50, color_d65])\n[color(srgb 0.12557 0.05823 0.88102 / 1), color(srgb 0 0 1 / 1)]\n</code></pre> Gamut: srgb <p>The same color looks different because it is reflecting a different light source. The illuminant of a color space can affect how the color appears, and each illuminant has a different color temperature which can provide a warmer or cooler color tone to the colors under a particular color space.</p> <p>We can visualize this concept a bit more clearly by taking the raw chromaticities from the D50 and D65 <code>white</code> and scaling them both under the same color space. Here we will take both the D50 and D65 white point and first scale them under the D65 sRGB color space and then scale them under the D50 Pro Photo color space. Notice that the D50 white (Pro Photo) has a red shift when rendered under sRGB, but the D65 white (sRGB) has a blue shift under Pro Photo. Relative to each other, the D65 white has a cooler temperature than D50, and this changes the color.</p> <pre><code>&gt;&gt;&gt; d65 = Color('srgb', [1, 1, 1]).split_chromaticity()\n&gt;&gt;&gt; d50 = Color('prophoto-rgb', [1, 1, 1]).split_chromaticity()\n&gt;&gt;&gt; color_d50 = Color.chromaticity('srgb', d50, scale=True)\n&gt;&gt;&gt; color_d65 = Color.chromaticity('srgb', d65, scale=True)\n&gt;&gt;&gt; Row([color_d50, color_d65])\n[color(srgb 1 0.92084 0.80569 / 1), color(srgb 1 1 1 / 1)]\n&gt;&gt;&gt; color_d50 = Color.chromaticity('prophoto-rgb', d50, scale=True)\n&gt;&gt;&gt; color_d65 = Color.chromaticity('prophoto-rgb', d65, scale=True)\n&gt;&gt;&gt; Row([color_d50, color_d65])\n[color(prophoto-rgb 1 1 1 / 1), color(prophoto-rgb 0.82447 0.84559 0.97953 / 1)]\n</code></pre> Gamut: srgb <p>In order to account for the differences in illuminants, we use chromatic adaptation to modify the chromaticities of the color so that they account for the different illuminant and appear as they should under the new light source. This happens automatically when we do call <code>convert()</code>. We can see that the white point gets adjusted such that the D50 white looks like the D65 white when in sRGB and D65 white looks like D50 white under Pro Photo.</p> <pre><code>&gt;&gt;&gt; color_d50 = Color('prophoto-rgb', [1, 1, 1]).convert('srgb')\n&gt;&gt;&gt; color_d65 = Color('srgb', [1, 1, 1])\n&gt;&gt;&gt; Row([color_d50, color_d65])\n[color(srgb 1 1 1 / 1), color(srgb 1 1 1 / 1)]\n</code></pre> Gamut: srgb <p>Generally, chromatic adaptation takes place within the XYZ color space. So in ColorAide, any color transform that must account for the differences of illuminants between two color spaces must go through chromatic adaptation, and it must occur in the XYZ color space. ColorAide satisfies this by making the registration of the XYZ D65 color space mandatory and using it as the transition color space when chromatic adaptation is needed.</p> <p>For instance, if a color space such as Pro Photo is being translated to sRGB, Pro Photo will first be transformed to XYZ D50, then it will be chromatically adapted to XYZ D65, next it will be transformed sRGB.</p> <p>So, we can actually do this manually and compare the results to <code>convert()</code> which automatically handles chromatic adaptation. In order to do this, we need to provide the specified \"white point\" for the source color and the \"white point\" for the destination color along with the XYZ coordinates we wish to transform. ColorAide uses the Bradford CAT by default, so we will specify that CAT for consistency.</p> <pre><code>&gt;&gt;&gt; from coloraide import cat\n&gt;&gt;&gt; xyzd50 = Color('prophoto-rgb', [1, 1, 1]).convert('xyz-d50').coords()\n&gt;&gt;&gt; xyzd50\n[0.9642956764295677, 1.0, 0.8251046025104602]\n&gt;&gt;&gt; xyzd65 = Color.chromatic_adaptation(cat.WHITES['2deg'][\"D50\"], cat.WHITES['2deg'][\"D65\"], xyzd50, method='bradford')\n&gt;&gt;&gt; manual = Color('xyz-d65', xyzd65).convert('srgb')\n&gt;&gt;&gt; auto = Color('prophoto-rgb', [1, 1, 1]).convert('srgb')\n&gt;&gt;&gt; manual, auto\n(color(srgb 1 1 1 / 1), color(srgb 1 1 1 / 1))\n</code></pre> Gamut: srgb <p>ColorAide, currently defines the following illuminants for both 2\u02da observer and 10\u02da observer, but most people are probably only concerned with D65 and D50 (2\u02da degree observer) which are the only the illuminants used in the default color spaces provided by ColorAide. Illuminants are not restricted to what is listed below, but those are the ones available by default.</p> Illuminants <code>A</code> <code>B</code> <code>C</code> <code>D50</code> <code>D55</code> <code>D65</code> <code>D75</code> <code>E</code> <code>F2</code> <code>F7</code> <code>F11</code>"},{"location":"cat/#supported-cats","title":"Supported CATs","text":"<p>There are various CATs, all varying in complexity and accuracy. We will not go through all of them and instead will leave that up to the user to research as needed. Suffice it to say, the Bradford CAT is currently the industry standard (in most cases), but there are a variety of options available, and research continues to try and improve upon CATs of the past to come up with better CATs for the future.</p> <p>Currently, ColorAide only supports single step, von Kries type CATs (named after an early 20<sup>th</sup> century color scientist), or CATs that are similar to and/or are built upon the original von Kries CAT. We also do not currently support every known von Kries CAT out there.</p> <p>Below is a list of the various matrices that can be used during chromatic adaptation. It should be noted that there are a few matrices below that are designed to be used in more complex, two step chromatic adaptation, but we currently only apply them as simple, single step chromatic adaptation.</p> CAT <code>bradford</code> <code>von-kries</code> <code>xyz-scaling</code> <code>sharp</code> <code>cat02</code> <code>cat16</code> <code>cmccat97</code> <code>cmccat2000</code>"},{"location":"cat/#changing-the-default-cat","title":"Changing the Default CAT","text":"<p>Changing the default CAT is easy and follows the same pattern as the rest of the available class overrides. Simply derive a new <code>Color()</code> class from the original and override the <code>CHROMATIC_ADAPTATION</code> property with the name of the desired CAT. Afterwards, all color transforms will use the specified CAT.</p> <pre><code>&gt;&gt;&gt; class Custom(Color):\n...     CHROMATIC_ADAPTATION = 'von-kries'\n... \n&gt;&gt;&gt; d50 = Custom('color(xyz-d50 0.11627 0.07261 0.23256 / 1)')\n&gt;&gt;&gt; d65 = d50.convert('xyz-d65')\n&gt;&gt;&gt; d50, d65\n(color(xyz-d50 0.11627 0.07261 0.23256 / 1), color(xyz-d65 0.12624 0.07254 0.30696 / 1))\n</code></pre> Gamut: srgb"},{"location":"chromaticity/","title":"Chromaticity Coordinates","text":"<p>Colors are generally composed of two parts, luminance and chromaticity. Luminance refers to the brightness while chromaticity refers to the hue and colorfulness.</p> <p>Separating out chromaticity from luminance, we can create a 2D from the chromaticity where we are able to plot the full spectrum of visible color. Over time, there have been multiple approaches to expressing chromaticity, the most common being: CIE 1931, CIE 1964, or CIE 1976.</p> 1931 xy Chromaticity Diagram1960 uv Chromaticity Diagram1931 u'v' Chromaticity Diagram <p></p> <p></p> <p></p> <p>Chromaticity coordinates are an important part of color science and are often used to define characteristics of color spaces, including gamuts and white points. This is often why depictions of white points and gamuts are overlaid onto chromaticity diagrams.</p> <p></p> <p>When combined with luminance, we can add depth when viewing a gamut within the chromaticity space.</p> <p></p>"},{"location":"chromaticity/#getting-chromaticity-coordinates","title":"Getting Chromaticity Coordinates","text":"<p>ColorAide provides a few  ways to access chromaticity. The first method, <code>split_chromaticity()</code>, allows for decomposing a color into it's two basic parts: chromaticity and luminance. The result is a 3 coordinates list containing the 2D chromaticity coordinates followed by the luminance. By default, values are exported in the format u'v'Y, where u'v' is the chromaticity coordinates in the CIE 1976 system and Y is the luminance taken directly from XYZ.</p> <pre><code>&gt;&gt;&gt; Color('red').split_chromaticity()\n[0.4507042253521127, 0.522887323943662, 0.21263900587151024]\n</code></pre> Gamut: srgb <p>If chromaticity coordinates are desired in a different format, any of the following can be manually specified.</p> Key Output Description <code>xy-1931</code> [x, y, Y] Chromaticity in the CIE 1931 xy system and luminance. <code>uv-1960</code> [u, v, Y] Chromaticity in the CIE 1960 uv system and luminance. <code>uv-1976</code> [u', v', Y] Chromaticity in the CIE 1976 u'v' system and luminance. <pre><code>&gt;&gt;&gt; Color('red').split_chromaticity('xy-1931')\n[0.64, 0.33, 0.21263900587151024]\n</code></pre> Gamut: srgb <p>All results are returned with chromaticities being relative to the current color's white point. This allows you to get the true chromaticities of that color space. If a pair of white point chromaticities are provided, the values will be chromatically adapted to match the given white point. <code>white</code> must be specified as an xy chromaticity pair. If you have chromaticity values in a non-xy pair, see converting chromaticity coordinates to learn how to convert them to the expected format.</p> <pre><code>&gt;&gt;&gt; from coloraide import cat\n&gt;&gt;&gt; Color('red').split_chromaticity(white=cat.WHITES['2deg']['D50'])\n[0.45718361011203107, 0.5248532543501369, 0.22249317711056513]\n</code></pre> Gamut: srgb <p>Tip</p> <p>If you ever need to get the white point from an already registered, supported color space, ColorAide makes these available via <code>white()</code>. The value is returned by default as the tristimulus values (XYZ coordinates), but it can also be returned as any of the supported chromaticity coordinate formats by specifying the desired output.</p> <pre><code>&gt;&gt;&gt; Color('red').white()\n[0.9504559270516716, 1.0, 1.0890577507598784]\n&gt;&gt;&gt; Color('red').white('uv-1960')\n[0.1978300066428368, 0.312213329959194]\n</code></pre> Gamut: srgb <p>If all that is desired is the 2D chromaticity coordinates, you can also use the two, simple convenience methods: <code>xy()</code> and <code>uv()</code>. <code>xy()</code> will return chromaticity in the CIE 1931 xy system and <code>uv()</code> will return chromaticity within the CIE 1976 u'v' system (default) or the CIE 1960 uv system, uv output is controlled by explicitly passing the desired year of the uv system.</p> <pre><code>&gt;&gt;&gt; Color('red').xy()\n[0.64, 0.33]\n&gt;&gt;&gt; Color('red').uv()\n[0.4507042253521127, 0.522887323943662]\n&gt;&gt;&gt; Color('red').uv('1960')\n[0.4507042253521127, 0.3485915492957747]\n</code></pre> Gamut: srgb <p>The <code>white</code> parameter is also accepted by <code>xy()</code> and <code>uv()</code>.</p> <p>Luminance</p> <p>ColorAide also allows for grabbing luminance via the <code>luminance()</code> method. It should be noted that by default this function returns luminance relative to the D65 white point as it is common for people to use luminance normalized like this, but if you'd like to quickly get luminance and have it relative to the current color's white point, just set <code>white</code> to <code>None</code> and ColorAide will calculate the value relative to the current color.</p> <pre><code>&gt;&gt;&gt; Color('red').luminance(white=None)\n0.21263900587151024\n</code></pre> Gamut: srgb <p>New 2.4</p> <ul> <li><code>split_chromaticity()</code> is new in 2.4.</li> <li>Chromaticity specifier in <code>white()</code> is new in 2.4.</li> <li><code>white</code> parameter of <code>luminance()</code> is new in 2.4.</li> </ul>"},{"location":"chromaticity/#create-color-from-chromaticity-coordinates","title":"Create Color From Chromaticity Coordinates","text":"<p>New 2.4</p> <p>ColorAide also provides an easy way to create colors from chromaticity coordinates. <code>chromaticity()</code> is a generalized method that takes a color space to create the color in and a set of chromaticity coordinates. The coordinates should be supplied using the same white point as the targeted color space. Chromaticity coordinates can be passed as 2D coordinates without luminance or with luminance. When passed with luminance the color should be identical to the original.</p> <pre><code>&gt;&gt;&gt; uvY = Color('red').uv()\n&gt;&gt;&gt; Color.chromaticity('srgb', uvY)\ncolor(srgb 1.9559 0 0 / 1)\n</code></pre> Gamut: srgb <p>If only 2D chromaticity points are given, Y will be assumed as 1. When luminance is maxed out like this, it may be desirable to normalize/scale the color in a linear RGB space to make the color displayable. This can be done by enabling <code>scale</code> which, by default, scales the color in linear sRGB. If a wider gamut is needed, you can change it via  <code>scale_space</code>. Using a non-linear RGB space is not recommended as non-linear spaces will cause the chromaticity coordinates to shift.</p> <pre><code>&gt;&gt;&gt; uv = Color('red').uv()\n&gt;&gt;&gt; Color.chromaticity('srgb', uv, scale=True)\ncolor(srgb 1 0 0 / 1)\n&gt;&gt;&gt; uv = Color('display-p3', [1, 0, 0]).uv()\n&gt;&gt;&gt; Color.chromaticity('display-p3', uv, scale=True, scale_space='display-p3-linear')\ncolor(display-p3 1 0 0 / 1)\n</code></pre> Gamut: srgb <p>This generally preserves chromaticity, scaling luminance, but if a color is out of gamut, the chromaticity of the resultant color will be affected.</p> <p>Tip</p> <p>There is no RGB color space that perfectly encompasses the entire visible gamut. No matter what scaling space is selected, colors outside the gamut of the scaling space will not exactly match the specified chromaticity coordinates. If exact values are needed, scaling should be avoided. If displaying the colors is desired, then sacrificing accuracy of the colors by scaling or some other gamut mapping method is necessary. Scaling/normalization is how we colorize all of our chromaticity diagrams in these documents.</p> <p>It is important to be consistent with white point usage. If we wanted to create a color in sRGB with ProPhoto chromaticities, it is important that we create the color first under a color space that uses the same white point. ProPhoto uses D50 and sRGB uses D65. So if we had ProPhoto chromaticities, it makes sense to first create the color under ProPhoto and then convert to sRGB.</p> <pre><code>&gt;&gt;&gt; c1 = Color('prophoto-rgb', [1, 0, 0])\n&gt;&gt;&gt; c2 = Color.chromaticity('prophoto-rgb', c1.split_chromaticity()).convert('srgb')\n&gt;&gt;&gt; c1, c2.convert('prophoto-rgb')\n(color(prophoto-rgb 1 0 0 / 1), color(prophoto-rgb 1 0 0 / 1))\n</code></pre> Gamut: srgb <p>With that said, there may be times when you have chromaticity coordinates that use a white point which no current supported color space supports. <code>chromaticity()</code> does provide a way of gamut mapping such coordinates by simply specifying the white point of the provided chromaticity coordinates. To illustrate, we'll take the same example, but this time create a color under sRGB directly with ProPhoto chromaticities, the difference is that we will pass ProPhoto's white point.</p> <pre><code>&gt;&gt;&gt; c1 = Color('prophoto-rgb', [1, 0, 0])\n&gt;&gt;&gt; c2 = Color.chromaticity('srgb', c1.split_chromaticity(), white=c1.white('xy-1931'))\n&gt;&gt;&gt; c1, c2.convert('prophoto-rgb')\n(color(prophoto-rgb 1 0 0 / 1), color(prophoto-rgb 1 0 0 / 1))\n</code></pre> Gamut: srgb"},{"location":"chromaticity/#converting-chromaticity-coordinates","title":"Converting Chromaticity Coordinates","text":"<p>New 2.4</p> <p>ColorAide normally expects you are working with chromaticity points that are compatible with at least one of the registered color spaces. In general, the API is set up with this expectation to make things easy for users. Normally, the user will not need to manually specify a white point, but it is possible that a user may be working with or exporting chromaticity coordinates to/from an unsupported, external space using an altogether different white point. We may need to specify that white point, but it may be in a format that ColorAide doesn't expect. Luckily, ColorAide provides a simple way to convert from between various chromaticity formats and convert to and from tristimulus (XYZ) values.</p> <pre><code>&gt;&gt;&gt; from coloraide import util\n&gt;&gt;&gt; Color('white').xy()\n[0.3127, 0.329]\n&gt;&gt;&gt; Color.convert_chromaticity('uv-1976', 'xy-1931', Color('white').uv())\n[0.3126999999999999, 0.32899999999999985, 1.0]\n&gt;&gt;&gt; Color.convert_chromaticity('uv-1960', 'xy-1931', Color('white').uv('1960'))\n[0.3126999999999999, 0.3289999999999999, 1.0]\n&gt;&gt;&gt; Color.convert_chromaticity('xyz', 'xy-1931', Color('white').convert('xyz-d65').coords())\n[0.3127, 0.329, 0.9999999999999999]\n</code></pre> Gamut: srgb <p>Tip</p> <p>When converting from XYZ tristimulus values to chromaticity values, the color <code>black</code> resolves to <code>[0, 0]</code> in xy, uv, or u'v'. This does not align with other achromatic values within the color space if displaying in 3D. This isn't technically incorrect as any chromaticity pair with zero luminance will be equal to <code>black</code> in XYZ. ColorAide normally accounts for this and aligns the point using the targeted color's white point, but when manually converting using <code>convert_chromaticity()</code>, such context is unavailable. If you are converting external XYZ values to chromaticity coordinates and would like to align, <code>black</code> on the achromatic axis, simply pass in the white point for context.</p> <pre><code>&gt;&gt;&gt; black = Color('black')\n&gt;&gt;&gt; black.xy()\n[0.3127, 0.329]\n&gt;&gt;&gt; Color.convert_chromaticity('xyz', 'xy-1931', black.convert('xyz-d65').coords())\n[0.0, 0.0, 0.0]\n&gt;&gt;&gt; Color.convert_chromaticity('xyz', 'xy-1931', black.convert('xyz-d65').coords(), white=black.white('xy-1931'))\n[0.3127, 0.329, 0.0]\n</code></pre> Gamut: srgb"},{"location":"color/","title":"The Color Object","text":"<p>The <code>Color</code> object is where all the magic of ColorAide happens and provides access to all the color manipulation methods available. The <code>Color</code> object is used to represent a given color within a particular color space. In order to perform most operations, you will need to create a color instance to begin.</p> <p>There are a number of ways to instantiate new colors. Here we will cover the basics of creating colors, cloning colors, converting colors, and a few other <code>Color</code> class specific topics.</p>"},{"location":"color/#importing","title":"Importing","text":"<p>The <code>Color</code> object contains all the logic to create and manipulate colors. It can be imported from <code>coloraide</code>.</p> <pre><code>from coloraide import Color\n</code></pre> <p>By default, the <code>Color</code> object registers only a subset of the available color spaces and features that are shipped with ColorAide. This keeps the object a bit lighter and provides the more commonly used color spaces and features. Color spaces, additional color distancing algorithms, gamut mapping algorithms, etc. are implemented via plugins. The normal way to get access to these additional spaces and features is to subclass the <code>Color</code> object and resister the desired spaces and features that are needed, but if you just want to explore all that ColorAide offers, you can import the <code>ColorAll</code> object from <code>everything</code>.</p> <pre><code>from coloraide.everything import ColorAll as Color\n</code></pre> <p>Custom Color Objects</p> <p>To add more plugins or tweak color defaults, see Custom Color Classes for more.</p>"},{"location":"color/#creating-colors","title":"Creating Colors","text":"<p>Once the <code>Color</code> class is imported, colors can be created using various forms of input, including: numerical inputs, dictionaries, CSS color strings, and even other <code>Color</code> instances.</p> <p>Note</p> <p>Reference of supported color space IDs can be found here. Reference of color spaces that registered by default can be found here.</p>"},{"location":"color/#numerical-inputs","title":"Numerical Inputs","text":"<p>The quickest way to create a color is by simply specifying the color space, color coordinates, and the optional alpha channel. Numerical inputs require very little processing, but it should be noted that inputs must be specified according to the way the color points are stored. Some people may be aware of the old CSS convention of specifying sRGB colors with a range of 0 - 255, but ColorAide stores these as values between 0 - 1. If transparency is omitted, transparency is assumed to be fully opaque, or a value of 1.</p> <pre><code>&gt;&gt;&gt; Color(\"srgb\", [0.5, 0, 1], 0.3)\ncolor(srgb 0.5 0 1 / 0.3)\n&gt;&gt;&gt; Color(\"srgb\", [0.5, 0, 1])\ncolor(srgb 0.5 0 1 / 1)\n</code></pre> Gamut: srgb"},{"location":"color/#dictionary-inputs","title":"Dictionary Inputs","text":"<p>It may be desired to store and retrieve colors from some serialized format such as JSON. To make this easier, ColorAide allows exporting and importing colors via dictionaries as well.</p> <p>Dictionaries must define the <code>space</code> key and the <code>coords</code> key containing values for all of the color channels. The <code>alpha</code> channel is kept separate and can be omitted, and if so, will be assumed as 1.</p> <pre><code>&gt;&gt;&gt; d = Color('purple').to_dict()\n&gt;&gt;&gt; print(d)\n{'space': 'srgb', 'coords': [0.5019607843137255, 0.0, 0.5019607843137255], 'alpha': 1.0}\n&gt;&gt;&gt; Color(d)\ncolor(srgb 0.50196 0 0.50196 / 1)\n</code></pre> Gamut: srgb <p>You can also control the precision of your output values with the <code>precision</code> parameter. For more information or to learn more about more advanced controls of precision, see the sections on precision and rounding which applies to both serialization and coordinate retrieval.</p> <pre><code>&gt;&gt;&gt; d = Color('purple').to_dict(precision=3)\n&gt;&gt;&gt; print(d)\n{'space': 'srgb', 'coords': [0.502, 0.0, 0.502], 'alpha': 1.0}\n&gt;&gt;&gt; Color(d)\ncolor(srgb 0.502 0 0.502 / 1)\n</code></pre> Gamut: srgb <p>If you need to control channel precision separately for a given channel, you can provide a list of <code>precision</code> and/or <code>decimal</code> values where each index in the list corresponds to the channel at that index. Omitted channels will assume the default precision and <code>decimal</code> place rounding respectively.</p> <pre><code>&gt;&gt;&gt; d = Color('purple').set('alpha', 0.75).convert('lab').to_dict(precision=[0, 0, 0, 3])\n&gt;&gt;&gt; print(d)\n{'space': 'lab', 'coords': [30.0, 56.0, -36.0], 'alpha': 0.75}\n&gt;&gt;&gt; Color(d)\ncolor(--lab 30 56 -36 / 0.75)\n</code></pre> Gamut: srgb <p>New in 4.0: Precision Output Control</p>"},{"location":"color/#string-inputs","title":"String Inputs","text":"<p>By default, ColorAide accepts input strings as outlined in the CSS color specification. Accepted syntax includes legacy CSS color formats as defined in CSS Level 3, but also allows for CSS Level 4 Color syntax!</p> <pre><code>&gt;&gt;&gt; Color(\"red\")\ncolor(srgb 1 0 0 / 1)\n&gt;&gt;&gt; Color(\"#00ff00\")\ncolor(srgb 0 1 0 / 1)\n&gt;&gt;&gt; Color(\"rgb(0 0 255 / 1)\")\ncolor(srgb 0 0 1 / 1)\n</code></pre> Gamut: srgb <p>ColorAide supports all the color spaces as defined in the CSS Level 4 Color spec, but is not restricted to only supported CSS colors. In order to support color strings for all colors, ColorAide allows for non-CSS color spaces to be represented via the Level 4 CSS <code>color()</code> function. Essentially, we've adopted the <code>color()</code> function as the universal way in which to serialize color strings.</p> <p>It should also be noted that <code>color()</code> can be used to describe any color regardless of whether it is supported in the CSS spec in this way or not. For any color that is not explicitly supported in CSS via the <code>color()</code> function, ColorAide will allow using this form if the color space uses a <code>--</code> prefix for the color space identifier. Check the documentation of the given color space to discover the appropriate CSS identifier name.</p> <pre><code>&gt;&gt;&gt; Color('color(--hsl 130 40% 75% / 0.5)')\ncolor(--hsl 130 0.4 0.75 / 0.5)\n</code></pre> Gamut: srgb"},{"location":"color/#color-instance-inputs","title":"Color Instance Inputs","text":"<p>If another color instance is passed as the input, a new color object will be created using the color data from the input. This essentially clones the passed object.</p> <pre><code>&gt;&gt;&gt; c1 = Color('red')\n&gt;&gt;&gt; c2 = Color(c1)\n&gt;&gt;&gt; c1, c2\n(color(srgb 1 0 0 / 1), color(srgb 1 0 0 / 1))\n</code></pre> Gamut: srgb <p>You can also use the <code>new</code> method to generate new colors from already instantiated color objects.</p> <pre><code>&gt;&gt;&gt; color1 = Color(\"red\")\n&gt;&gt;&gt; color1\ncolor(srgb 1 0 0 / 1)\n&gt;&gt;&gt; color1.new(\"blue\")\ncolor(srgb 0 0 1 / 1)\n</code></pre> Gamut: srgb <p>Tip</p> <p>If the <code>Color</code> class has be subclassed, this is an easy way to convert between the different subclasses, assuming the registered color spaces are compatible between the two different <code>Color</code> classes.</p>"},{"location":"color/#random","title":"Random","text":"<p>If you'd like to generate a random color, simply call <code>Color.random</code> with a given color space and one will be generated.</p> <pre><code>&gt;&gt;&gt; [Color.random('srgb') for _ in range(10)]\n[color(srgb 0.10905 0.56715 0.19896 / 1), color(srgb 0.27912 0.80155 0.877 / 1), color(srgb 0.59124 0.4905 0.00638 / 1), color(srgb 0.38763 0.50241 0.731 / 1), color(srgb 0.33553 0.7783 0.56049 / 1), color(srgb 0.04912 0.17083 0.46935 / 1), color(srgb 0.26775 0.81355 0.07032 / 1), color(srgb 0.45571 0.03195 0.19759 / 1), color(srgb 0.48617 0.37521 0.38975 / 1), color(srgb 0.35659 0.27085 0.03131 / 1)]\n</code></pre> Gamut: srgb <p>Ranges are based on the color space's defined channel range. For color spaces with defined gamuts, the values will be confined to appropriate ranges. For color space's without defined gamuts, the ranges may be quite arbitrary in some cases. For color spaces with no hard, defined gamut, or gamuts that far exceed practical usage it is recommend to fit the colors to whatever gamut you'd like, or simply use a target space with a clear defined gamut.</p> <pre><code>&gt;&gt;&gt; Color.random('lab').fit('srgb')\ncolor(--lab 52.065 48.937 -54.781 / 1)\n</code></pre> Gamut: srgb <p>Lastly, if you'd like to further constrain the limits, you can provide a list of constraints. A constraint should be a sequence of two values specifying the minimum and maximum for the channel. If <code>None</code> is provided, that constraint will be ignored. If the list doesn't have enough values, those missing indexes will be ignored. If the list has too many values, those extra values will be ignored.</p> <pre><code>&gt;&gt;&gt; Color.random('srgb', limits=[(0.25, 0.75)] * 3)\ncolor(srgb 0.58839 0.66944 0.32471 / 1)\n</code></pre> Gamut: srgb"},{"location":"color/#cloning","title":"Cloning","text":"<p>The <code>clone</code> method is an easy way to duplicate the current color object.</p> <p>Here we clone the <code>green</code> color object, giving us two.</p> <pre><code>&gt;&gt;&gt; c1 = Color(\"green\")\n&gt;&gt;&gt; c1\ncolor(srgb 0 0.50196 0 / 1)\n&gt;&gt;&gt; c1.clone()\ncolor(srgb 0 0.50196 0 / 1)\n</code></pre> Gamut: srgb"},{"location":"color/#updating","title":"Updating","text":"<p>A color can be \"updated\" using another color input. When an update occurs, the current color is updated from the data of the second color, but the color space does not change. Using <code>update</code> is the equivalent of converting the second color to the color space of the first and then updating all the coordinates (including alpha). The input parameters are identical to the <code>new</code> method, so we can use a color object, a color string, dictionary, or even raw data points.</p> <p>Here we update the color <code>red</code> to the color <code>blue</code>:</p> <pre><code>&gt;&gt;&gt; Color(\"red\")\ncolor(srgb 1 0 0 / 1)\n&gt;&gt;&gt; Color(\"red\").update(Color(\"blue\"))\ncolor(srgb 0 0 1 / 1)\n</code></pre> Gamut: srgb <p>Here we update the sRGB <code>red</code> with the color <code>lch(80% 50 130)</code>.</p> <pre><code>&gt;&gt;&gt; Color(\"red\").update(\"lch(80% 50 130)\")\ncolor(srgb 0.60392 0.8398 0.48396 / 1)\n</code></pre> Gamut: srgb <p>Note</p> <p>Reference of supported color space IDs can be found here. Reference of color spaces that registered by default can be found here.</p>"},{"location":"color/#mutating","title":"Mutating","text":"<p>\"Mutating\" is similar to updating except that it will update the color and the color space from another color. The input parameters are identical to the <code>new</code> method, so we can use a color object, a color string, dictionary, or even raw data points.</p> <p>In this example, the <code>red</code> color object literally becomes the specified CIELCh color of <code>lch(80% 50 130)</code>.</p> <pre><code>&gt;&gt;&gt; Color(\"red\").mutate(\"lch(80% 50 130)\")\ncolor(--lch 80 50 130 / 1)\n</code></pre> Gamut: srgb"},{"location":"color/#converting","title":"Converting","text":"<p>Colors can be converted to other color spaces as needed. Converting will always return a new color unless the <code>in_place</code> parameter is set to <code>True</code>, in which case, the current color will be mutated to the new converted color and a reference to itself is returned.</p> <p>For instance, if we had a color <code>yellow</code>, and we needed to work with it in another color space, we could simply call the <code>convert</code> method with the desired color space.</p> <pre><code>&gt;&gt;&gt; Color('yellow').convert(\"lab\")\ncolor(--lab 97.607 -15.75 93.394 / 1)\n</code></pre> Gamut: srgb <p>Note</p> <p>Reference of supported color space IDs can be found here. Reference of color spaces that registered by default can be found here.</p> <p>Notes on Round Trip Accuracy</p>"},{"location":"color/#color-matching","title":"Color Matching","text":"<p>As previously mentioned, the <code>Color()</code> object can parse CSS style string inputs. The string matching logic is exposed via the <code>match</code> method. We can simply pass <code>match</code> a string, and, if the string is a valid color, a <code>ColorMatch</code> object will be returned. The <code>ColorMatch</code> object has a simple structure that contains the matched <code>color</code> as a <code>Color</code> object, and the <code>start</code> and <code>end</code> points it was located at.</p> <pre><code>&gt;&gt;&gt; Color.match(\"red\")\nColorMatch(color=color(srgb 1 0 0 / 1), start=0, end=3)\n</code></pre> Gamut: srgb <p>By default it matches at the start of the buffer and returns a color if it finds one. If desired, we can do a <code>fullmatch</code> which requires the entire buffer to match a color.</p> <pre><code>&gt;&gt;&gt; Color.match(\"red and yellow\")\nColorMatch(color=color(srgb 1 0 0 / 1), start=0, end=3)\n&gt;&gt;&gt; Color.match(\"red and yellow\", fullmatch=True)\n</code></pre> Gamut: srgb <p>We can also adjust the start position of the search. In this case, by adjusting the start position to 8 characters later, we will match <code>yellow</code> instead of <code>red</code>.</p> <pre><code>&gt;&gt;&gt; Color.match(\"red and yellow\", start=8)\nColorMatch(color=color(srgb 1 1 0 / 1), start=8, end=14)\n</code></pre> Gamut: srgb <p>A method to find all colors in a buffer is not currently provided as looping through all the color spaces and matching all potential colors on every character is not really efficient. Additionally, some buffers may require additional context that is not available to the match function. If such behavior is desired, it is recommended to apply some additional logic to sniff out areas with high likelihood of having a color.</p> <p>In the following example, we construct a regular expression to find places within the buffer that potentially have a valid color. As the buffer is an HTML document we also want to incorporate some context to avoid matching HTML entities or color names that are part of a CSS variable.</p> <p>Once we've crafted our regular expression, we can search the buffer to find locations in the buffer that are likely to be colors. Then we can run <code>Color.match()</code> on those positions within the buffer to see if we find a valid color. This ends up being much more efficient!</p> <pre><code>&gt;&gt;&gt; import re\n&gt;&gt;&gt; from coloraide import Color\n&gt;&gt;&gt; RE_COLOR_START = re.compile(\n...     r\"\"\"(?ix)\n...     (?:\n...         # CSS functions\n...         \\b(?&lt;![-#&amp;$])(?:color\\((?!\\s*-)|(?:hsla?|(?:ok)?(?:lch|lab)|jzczhz|jzazbz|ictcp|hwb|rgba?)\\()|\n...         # Color words\n...         \\b(?&lt;![-#&amp;$])[\\w]{3,}(?![(-])\\b|\n...         # Hex codes\n...         (?&lt;![&amp;])\\#\n...     )\n...     \"\"\"\n... )\n&gt;&gt;&gt; text = \"\"\"\n... &lt;html&gt;\n... &lt;head&gt;\n... &lt;style&gt;\n... body {\n...     background-color: red;\n...     color: yellow;\n... }\n... &lt;/style&gt;\n... &lt;/head&gt;\n... &lt;body&gt;\n... &lt;p&gt;This is a test &lt;span style=\"background-color: #000088; color: lch(75% 50 50)\"&gt;test&lt;/span&gt;&lt;/p&gt;\n... &lt;/body&gt;\n... &lt;/html&gt;\n... \"\"\"\n&gt;&gt;&gt; for m in RE_COLOR_START.finditer(text):\n...     start = m.start()\n...     mcolor = Color.match(text, start=start)\n...     if mcolor is not None:\n...         mcolor.color.to_string()\n... \n'rgb(255 0 0)'\n'rgb(255 255 0)'\n'rgb(0 0 136)'\n'lch(75 50 50)'\n</code></pre> Gamut: srgb"},{"location":"color/#custom-color-classes","title":"Custom Color Classes","text":"<p>The <code>Color</code> object was created to be extensible and has implemented various functionalities as plugins. Things like color spaces, distancing algorithms, filters, etc. are all implemented as plugins. In order to keep things light, ColorAide does not register all the of the plugins by default unless the user as imported the <code>ColorAll</code> object.</p> <p>Additionally, ColorAide has implemented a number of defaults that can be tweaked within the <code>Color</code> class to alter how things are handled.</p> <p>Creating a custom class allows for a user to change some of the default settings and add or remove plugins to gain access to more color spaces, distancing algorithms, filters, and other functionality.</p> <p>In general, it is always recommended to subclass the <code>Color</code> object when setting up custom preferences or adding or removing plugins. This prevents modifying the base class which may affect other libraries relying on the module. When <code>Color</code> is subclassed, it is safe to then update global overrides or register and deregister plugins without the worry of affecting the base class.</p>"},{"location":"color/#override-default-settings","title":"Override Default Settings","text":"<p>ColorAide has a number of preferences that can be altered in the <code>Color</code> class. Most of these options can be configured on demand when calling into a related function that uses them, but it may be useful to set them up one time on a new <code>Color</code> object.</p> <pre><code>&gt;&gt;&gt; class Color2(Color):\n...     PRECISION = 3\n... \n&gt;&gt;&gt; Color('rgb(128.12345 0 128.12345)').to_string()\n'rgb(128.12 0 128.12)'\n&gt;&gt;&gt; Color2('rgb(128.12345 0 128.12345)').to_string()\n'rgb(128 0 128)'\n</code></pre> Gamut: srgb Properties Defaults Description <code>FIT</code> <code>\"lch-chroma\"</code> The default gamut mapping method used by the <code>Color</code> object. <code>INTERPOLATE</code> <code>\"oklab\"</code> The default color space used for interpolation. <code>INTERPOLATOR</code> <code>\"linear\"</code> The default interpolator to use. <code>DELTA_E</code> <code>\"76\"</code> The default \u2206E algorithm used. This applies to when <code>delta_e()</code> is called without specifying a method or when using color distancing to separate color when using the interpolation method called <code>steps</code>. <code>PRECISION</code> <code>5</code> The default significant figures to round to.<code>0</code> forces integer rounding and <code>-1</code> applies no restriction. <code>DECIMAL</code> <code>True</code> The default decimal place to round a number to. <code>True</code> assumes the same value as the current precision and <code>False</code> ignores decimal rounding. <code>CHROMATIC_ADAPTATION</code> <code>\"bradford\"</code> Chromatic adaptation method used when converting between two color spaces with different white points. See Chromatic Adaptation for more information. <code>HARMONY</code> <code>\"oklch\"</code> Default color space to use for calculating color harmonies. This should be a cylindrical color space. <code>CONTRAST</code> <code>\"wcag21\"</code> Default contrast algorithm. <code>AVERAGE</code> <code>\"average\"</code> Default color space for averaging. <code>CCT</code> <code>\"robertson-1968</code> Default CCT method. <code>POWERLESS</code> <code>False</code> Experimental option that controls default powerless interpolation behavior. If <code>True</code>, if a color is considered achromatic, but has an explicit hue, it will be treated as powerless during interpolation. <code>CARRYFORWARD</code> <code>False</code> Experimental option that controls default carrying-forward behavior during interpolation. If <code>True</code>, supported, undefined values will be carried over to the interpolating color space after conversion."},{"location":"color/#plugins","title":"Plugins","text":"<p>Currently, color spaces, delta E methods, chromatic adaptation, filters, contrast, interpolation, and gamut mapping methods are exposed as plugins. As previously mentioned, <code>Color</code> does not register all plugins, and <code>ColorAll</code> is often more than a user needs by default. Registering exactly what you need is normally the recommend approach when more functionality is required.</p> <p>While we won't go into a lot of details about creating plugins here, we will go over how to register new plugins and deregister existing plugins. To learn more about creating plugins, checkout the plugin documentation.</p> <p>Registration is performed by the <code>register</code> method. It can take a single plugin or a list of plugins. Based on the plugin's type, The Color object will determine how to properly register the plugin. If the plugin attempts to overwrite a plugin already registered with the same name (as dictated by the plugin) the operation will fail. If <code>overwrite</code> is set to <code>True</code>, the overwrite will not fail and the new plugin will be registered with the specified name in place of the existing plugin.</p> <pre><code>&gt;&gt;&gt; from coloraide import Color\n&gt;&gt;&gt; from coloraide.spaces.xyy import xyY\n&gt;&gt;&gt; try:\n...     Color('red').convert('xyy')\n... except:\n...     print('Nope')\n... \nNope\n&gt;&gt;&gt; class Custom(Color): ...\n... \n&gt;&gt;&gt; Custom.register(xyY())\n&gt;&gt;&gt; Custom('red').convert('xyy')\ncolor(--xyy 0.64 0.33 0.21264 / 1)\n</code></pre> Gamut: srgb <p>Used in conjunction with default settings override, we can not only change a default \u2206E, but we can alter a \u2206E method's configuration by registering it with different defaults:</p> <pre><code>&gt;&gt;&gt; Color('red').delta_e('blue', method='cmc')\n108.56925233888809\n&gt;&gt;&gt; from coloraide.distance.delta_e_cmc import DECMC\n&gt;&gt;&gt; class Custom(Color):\n...     DELTA_E = \"cmc\"\n... \n&gt;&gt;&gt; Custom.register(DECMC(l=1, c=1), overwrite=True)\n&gt;&gt;&gt; Custom('red').delta_e('blue')\n109.7597278634398\n</code></pre> Gamut: srgb <p>If a deregistration is desired, the <code>deregister</code> method can be used. It takes a string that describes the plugin to deregister: <code>category:name</code>.</p> <p>Valid categories are <code>space</code>, <code>delta-e</code>, <code>cat</code>, <code>contrast</code>, <code>filter</code>, <code>interpolate</code>, <code>fit</code>, and <code>cct</code>.</p> <p>If the given plugin is not found, an error will be thrown, but if this notification is found to be unnecessary, <code>silent</code> can be enabled and the there will be no error thrown.</p> <pre><code>&gt;&gt;&gt; class Custom(Color): ...\n... \n&gt;&gt;&gt; Custom.deregister('space:lab-d65')\n&gt;&gt;&gt; try:\n...     Custom('red').convert('lab-d65')\n... except ValueError:\n...     print('Could not convert to Lab D65 as it is no longer registered')\n... \nCould not convert to Lab D65 as it is no longer registered\n</code></pre> Gamut: srgb <p>Use of <code>*</code> with <code>deregister</code> will remove all plugins. Use of <code>category:*</code> will remove all plugins of that category.</p>"},{"location":"compositing/","title":"Compositing and Blending","text":"<p>Alpha compositing and blending are tied together under the umbrella of compositing. Each is just an aspect of the overall compositing of colors. Compositing simply controls how colors are resolved when they are layered on top of each other.</p> <p>ColorAide implements both alpha compositing and blending as described in the Compositing and Blending Level 1 specification. Alpha composting is based on Porter Duff compositing. By default, the <code>layer</code> method is used to layer colors on top of each other applying the appropriate compositing, using the <code>normal</code> blend mode and the <code>source-over</code> Porter Duff operator by default.</p> <p>Deprecated 4.0</p> <p><code>compose</code> method was deprecated in favor of the new <code>layer</code> method and will be removed at some future time.</p> <p>New in 4.0</p> <p>A new <code>layer</code> method was added which uses a more intuitive name and aligns with how multiple colors are handled in other similar APIs such as <code>average()</code>, <code>interpolate()</code>, etc.</p>"},{"location":"compositing/#blending","title":"Blending","text":"<p>Blending is the aspect of compositing that calculates the mixing of colors where the source element and backdrop overlap. Conceptually, the colors in the source element (top layer) are blended in place with the backdrop (bottom layer).</p> <p>There are various blend modes, the most common is the <code>normal</code> blend mode which is the default blending mode for browsers. The <code>normal</code> blend mode simply returns the top layer's color when one is overlaid onto another.</p> <p> </p> <p>But there are many blend modes that could be used, all of which yield different results. If we were to apply a <code>multiply</code> blend mode, we would get something very different:</p> <p> </p> <p>When layering colors, the blend mode can be controlled separately in ColorAide. Below, we use the <code>multiply</code> example and replicate it in ColorAide. To apply various blend modes in ColorAide, simply call <code>layer</code> with a list of colors. Colors will be layered on top of each other where the left most color is on top and the right most color will be on the bottom.</p> Display P3sRGB <pre><code>&gt;&gt;&gt; c1 = Color('#07c7ed')\n&gt;&gt;&gt; c2 = Color('#fc3d99')\n&gt;&gt;&gt; c1, c2\n(color(srgb 0.02745 0.78039 0.92941 / 1), color(srgb 0.98824 0.23922 0.6 / 1))\n&gt;&gt;&gt; Color.layer([c1, c2], blend='multiply', space=\"display-p3\")\ncolor(display-p3 0.32281 0.23703 0.54084 / 1)\n</code></pre> Gamut: srgb <pre><code>&gt;&gt;&gt; c1 = Color('#07c7ed')\n&gt;&gt;&gt; c2 = Color('#fc3d99')\n&gt;&gt;&gt; c1, c2\n(color(srgb 0.02745 0.78039 0.92941 / 1), color(srgb 0.98824 0.23922 0.6 / 1))\n&gt;&gt;&gt; Color.layer([c1, c2], blend='multiply', space=\"srgb\")\ncolor(srgb 0.02713 0.18668 0.55765 / 1)\n</code></pre> Gamut: srgb <p>Tip</p> <p><code>layer()</code> can output the results in any color space you need by setting <code>out_space</code>.</p> <pre><code>&gt;&gt;&gt; Color.layer(['#07c7ed', '#fc3d99'], blend='multiply', space='srgb', out_space='hsl')\ncolor(--hsl 221.95 0.90722 0.29239 / 1)\n</code></pre> Gamut: srgb <p>Display Differences</p> <p>As some browsers apply compositing based on the display's current color space, we've provided examples in both sRGB and Display P3 so that the examples can be compared on different displays. Which of the above matches your browser?</p> <p>ColorAide allows for layering any number of colors as well, simply list of as many colors as you like ordered from left to right, left being the top most color.</p> <p> </p> Display P3sRGB <pre><code>&gt;&gt;&gt; c1 = Color('#07c7ed')\n&gt;&gt;&gt; c2 = Color('#fc3d99')\n&gt;&gt;&gt; c3 = Color('#f5d311')\n&gt;&gt;&gt; c1, c2, c3\n(color(srgb 0.02745 0.78039 0.92941 / 1), color(srgb 0.98824 0.23922 0.6 / 1), color(srgb 0.96078 0.82745 0.06667 / 1))\n&gt;&gt;&gt; Color.layer([c1, c2, c3], blend='multiply', space=\"display-p3\")\ncolor(display-p3 0.3031 0.19729 0.15625 / 1)\n</code></pre> Gamut: srgb <pre><code>&gt;&gt;&gt; c1 = Color('#07c7ed')\n&gt;&gt;&gt; c2 = Color('#fc3d99')\n&gt;&gt;&gt; c3 = Color('#f5d311')\n&gt;&gt;&gt; c1, c2, c3\n(color(srgb 0.02745 0.78039 0.92941 / 1), color(srgb 0.98824 0.23922 0.6 / 1), color(srgb 0.96078 0.82745 0.06667 / 1))\n&gt;&gt;&gt; Color.layer([c1, c2, c3], blend='multiply', space=\"srgb\")\ncolor(srgb 0.02606 0.15447 0.03718 / 1)\n</code></pre> Gamut: srgb <p>Lastly, if for any reason, it is desired to layer the colors with the blending step disabled (e.g. just run alpha compositing), then you can simply set <code>blend</code> to <code>False</code>.</p> <p><code>multiply</code> is just one of many blend modes that are offered in ColorAide, check out Blend Modes to learn about other blend modes.</p>"},{"location":"compositing/#alpha-compositing","title":"Alpha Compositing","text":"<p>Alpha compositing or alpha blending is the process of combining one image with a background to create the appearance of partial or full transparency.</p> <p>When dealing with layers, there are many possible ways to handle them:</p> <p></p> <p>Porter Duff compositing covers all possible configurations of layers. Many of these configurations can be useful for all sorts of operations, such as masking. While this library supports all of them, the most commonly used one is <code>source-over</code> which is used to implement simple alpha compositing to simulate semi-transparent layers on top of each other.</p> <p> </p> <p>Given two colors layered on top of each other, ColorAide can replicate this behavior and determine the resultant color by applying alpha compositing. We will use the demonstration above and replicate the result in the example below by setting the source color to <code>rgb(7 199 237 / 0.5)</code> and the backdrop color to <code>#fc3d99</code> and then running it through the <code>layer</code> method.</p> Display P3sRGB <pre><code>&gt;&gt;&gt; c1 = Color('#07c7ed').set('alpha', 0.5)\n&gt;&gt;&gt; c2 = Color('#fc3d99')\n&gt;&gt;&gt; c1, c2\n(color(srgb 0.02745 0.78039 0.92941 / 0.5), color(srgb 0.98824 0.23922 0.6 / 1))\n&gt;&gt;&gt; Color.layer([c1, c2], space=\"display-p3\")\ncolor(display-p3 0.63261 0.53855 0.75261 / 1)\n</code></pre> Gamut: srgb <pre><code>&gt;&gt;&gt; c1 = Color('#07c7ed').set('alpha', 0.5)\n&gt;&gt;&gt; c2 = Color('#fc3d99')\n&gt;&gt;&gt; c1, c2\n(color(srgb 0.02745 0.78039 0.92941 / 0.5), color(srgb 0.98824 0.23922 0.6 / 1))\n&gt;&gt;&gt; Color.layer([c1, c2], space=\"srgb\")\ncolor(srgb 0.50784 0.5098 0.76471 / 1)\n</code></pre> Gamut: srgb <p>Display Differences</p> <p>As some browsers apply compositing based on the display's current color space, we've provided examples in both sRGB and Display P3 so that the examples can be compared on different displays. Which of the above matches your browser?</p> <p>While the average user will be content with the default alpha compositing, Porter Duff offers many other configurations. If desired, we can change the Porter Duff operator used and apply different composite logic. For instance, in this case we can get the resultant of the backdrop over the source color by setting the <code>operator</code> to <code>destination-over</code>. As the backdrop is fully opaque, we just get the backdrop color unaltered.</p> <p> </p> Display P3sRGB <pre><code>&gt;&gt;&gt; c1 = Color('#07c7ed').set('alpha', 0.5)\n&gt;&gt;&gt; c2 = Color('#fc3d99')\n&gt;&gt;&gt; c1, c2\n(color(srgb 0.02745 0.78039 0.92941 / 0.5), color(srgb 0.98824 0.23922 0.6 / 1))\n&gt;&gt;&gt; Color.layer([c1, c2], operator='destination-over', space=\"display-p3\")\ncolor(display-p3 0.91078 0.30832 0.59266 / 1)\n</code></pre> Gamut: srgb <pre><code>&gt;&gt;&gt; c1 = Color('#07c7ed').set('alpha', 0.5)\n&gt;&gt;&gt; c2 = Color('#fc3d99')\n&gt;&gt;&gt; c1, c2\n(color(srgb 0.02745 0.78039 0.92941 / 0.5), color(srgb 0.98824 0.23922 0.6 / 1))\n&gt;&gt;&gt; Color.layer([c1, c2], operator='destination-over', space=\"srgb\")\ncolor(srgb 0.98824 0.23922 0.6 / 1)\n</code></pre> Gamut: srgb <p>You can also apply alpha compositing to multiple layers at once. Simply send in a list of colors of any length, and the colors will be layered on top of each other from right to left with the right most color being on the bottom of the stack and the left color (the source) being on the very top.</p> <p>Here we are using the normal blend mode and 50% transparency on all the circles with an opaque white background. We will calculate the center color where all three layers overlap.</p> Display P3sRGB <pre><code>&gt;&gt;&gt; c1 = Color('#07c7ed').set('alpha', 0.5)\n&gt;&gt;&gt; c2 = Color('#fc3d99').set('alpha', 0.5)\n&gt;&gt;&gt; c3 = Color('#f5d311').set('alpha', 0.5)\n&gt;&gt;&gt; bg = Color('white')\n&gt;&gt;&gt; c1, c2, c3, bg\n(color(srgb 0.02745 0.78039 0.92941 / 0.5), color(srgb 0.98824 0.23922 0.6 / 0.5), color(srgb 0.96078 0.82745 0.06667 / 0.5), color(srgb 1 1 1 / 1))\n&gt;&gt;&gt; Color.layer([c1, c2, c3, bg], blend='normal', space=\"display-p3\")\ncolor(display-p3 0.64728 0.69051 0.76555 / 1)\n</code></pre> Gamut: srgb <pre><code>&gt;&gt;&gt; c1 = Color('#07c7ed').set('alpha', 0.5)\n&gt;&gt;&gt; c2 = Color('#fc3d99').set('alpha', 0.5)\n&gt;&gt;&gt; c3 = Color('#f5d311').set('alpha', 0.5)\n&gt;&gt;&gt; bg = Color('white')\n&gt;&gt;&gt; c1, c2, c3, bg\n(color(srgb 0.02745 0.78039 0.92941 / 0.5), color(srgb 0.98824 0.23922 0.6 / 0.5), color(srgb 0.96078 0.82745 0.06667 / 0.5), color(srgb 1 1 1 / 1))\n&gt;&gt;&gt; Color.layer([c1, c2, c3, bg], blend='normal', space=\"srgb\")\ncolor(srgb 0.50588 0.67843 0.74804 / 1)\n</code></pre> Gamut: srgb <p>Lastly, if for any reason, it is desired to layer colors with alpha compositing disabled (e.g. just run blending), then you can simply set <code>operator</code> to <code>False</code>.</p> <p>Check out Compositing Operators to learn about the many variations that are supported.</p>"},{"location":"compositing/#complex-compositing","title":"Complex Compositing","text":"<p>We've covered alpha compositing and blending and have demonstrated their use with simple two color examples and multi-layered examples, but what about different blend modes mixed with alpha compositing?</p> <p>In this example, we will consider three circles, each with a unique color: <code>#07c7ed</code>, <code>#fc3d99</code>, and <code>#f5d311</code>. We apply 50% transparency to all the circles and place them on a <code>white</code> background. We then perform a <code>multiply</code> blend on all the circles but isolate them so the <code>multiply</code> blend does not apply to the background. The circles are all represented with CSS. We will now try and replicate the colors with ColorAide.</p> <p>So in the code below, we work our way from the bottom of the stack to the top. Since the background is isolated from the <code>multiply</code> blending, in each region, we start by performing a <code>normal</code> blend on the bottom circle against the background. We then apply <code>multiply</code> blending on each color that is stacked on top. We've provided both the P3 and sRGB outputs to make it easy to compare in case your browser blends in one instead of the other.</p> Display P3sRGB <pre><code>&gt;&gt;&gt; c1 = Color('#07c7ed').set('alpha', 0.5)\n&gt;&gt;&gt; c2 = Color('#fc3d99').set('alpha', 0.5)\n&gt;&gt;&gt; c3 = Color('#f5d311').set('alpha', 0.5)\n&gt;&gt;&gt; cw2 = Color.layer([c2, 'white'], blend='normal', space='display-p3')\n&gt;&gt;&gt; cw3 = Color.layer([c3, 'white'], blend='normal', space='display-p3')\n&gt;&gt;&gt; r1 = Color.layer([c2, cw3], blend='multiply', space='display-p3')\n&gt;&gt;&gt; r2 = Color.layer([c1, cw2], blend='multiply', space='display-p3')\n&gt;&gt;&gt; r3 = Color.layer([c1, cw3], blend='multiply', space='display-p3')\n&gt;&gt;&gt; r1, r2, r3\n(color(display-p3 0.92621 0.59932 0.5132 / 1), color(display-p3 0.64701 0.57853 0.76151 / 1), color(display-p3 0.65654 0.81024 0.61627 / 1))\n&gt;&gt;&gt; Color.layer([c1, c2, cw3], blend='multiply', space='display-p3')\ncolor(display-p3 0.62725 0.53003 0.49076 / 1)\n</code></pre> Gamut: srgb <pre><code>&gt;&gt;&gt; c1 = Color('#07c7ed').set('alpha', 0.5)\n&gt;&gt;&gt; c2 = Color('#fc3d99').set('alpha', 0.5)\n&gt;&gt;&gt; c3 = Color('#f5d311').set('alpha', 0.5)\n&gt;&gt;&gt; cw2 = Color.layer([c2, 'white'], blend='normal', space='srgb')\n&gt;&gt;&gt; cw3 = Color.layer([c3, 'white'], blend='normal', space='srgb')\n&gt;&gt;&gt; r1 = Color.layer([c2, cw3], blend='multiply', space='srgb')\n&gt;&gt;&gt; r2 = Color.layer([c1, cw2], blend='multiply', space='srgb')\n&gt;&gt;&gt; r3 = Color.layer([c1, cw3], blend='multiply', space='srgb')\n&gt;&gt;&gt; r1, r2, r3\n(color(srgb 0.97463 0.56615 0.42667 / 1), color(srgb 0.5107 0.55157 0.77176 / 1), color(srgb 0.50365 0.81339 0.51451 / 1))\n&gt;&gt;&gt; Color.layer([c1, c2, cw3], blend='multiply', space='srgb')\ncolor(srgb 0.50069 0.50399 0.41161 / 1)\n</code></pre> Gamut: srgb <p>Results may vary depending on the browser, but we can see (ignoring rounding differences) that the colors match up. This was performed on Chrome in macOS using a display that uses <code>display-p3</code>.</p> <p></p>"},{"location":"compositing/#blend-modes","title":"Blend Modes","text":""},{"location":"compositing/#normal","title":"Normal","text":"<p>The blending formula simply selects the source color.</p> <p>Specified as <code>'normal'</code>.</p>"},{"location":"compositing/#multiply","title":"Multiply","text":"<p>The source color is multiplied by the destination color and replaces the destination. The resultant color is always at least as dark as either the source or destination color. Multiplying any color with black results in black. Multiplying any color with white preserves the original color.</p> <p>Specified as <code>'multiply'</code>.</p>"},{"location":"compositing/#screen","title":"Screen","text":"<p>Multiplies the complements of the backdrop and source color values, then complements the result. The result color is always at least as light as either of the two constituent colors. Screening any color with white produces white; screening with black leaves the original color unchanged. The effect is similar to projecting multiple photographic slides simultaneously onto a single screen.</p> <p>Specified as <code>'screen'</code>.</p>"},{"location":"compositing/#overlay","title":"Overlay","text":"<p>Multiplies or screens the colors, depending on the backdrop color value. Source colors overlay the backdrop while preserving its highlights and shadows. The backdrop color is not replaced but is mixed with the source color to reflect the lightness or darkness of the backdrop.</p> <p>Specified as <code>'overlay'</code>.</p>"},{"location":"compositing/#darken","title":"Darken","text":"<p>Selects the darker of the backdrop and source colors. The backdrop is replaced with the source where the source is darker; otherwise, it is left unchanged.</p> <p>Specified as <code>'darken'</code>.</p>"},{"location":"compositing/#lighten","title":"Lighten","text":"<p>Selects the lighter of the backdrop and source colors. The backdrop is replaced with the source where the source is lighter; otherwise, it is left unchanged.</p> <p>Specified as <code>'lighten'</code>.</p>"},{"location":"compositing/#color-dodge","title":"Color Dodge","text":"<p>Brightens the backdrop color to reflect the source color. Painting with black produces no changes.</p> <p>Specified as <code>'color-dodge'</code>.</p>"},{"location":"compositing/#color-burn","title":"Color Burn","text":"<p>Darkens the backdrop color to reflect the source color. Painting with white produces no change.</p> <p>Specified as <code>'color-burn'</code>.</p>"},{"location":"compositing/#hard-light","title":"Hard Light","text":"<p>Multiplies or screens the colors, depending on the source color value. The effect is similar to shining a harsh spotlight on the backdrop.</p> <p>Specified as <code>'hard-light'</code>.</p>"},{"location":"compositing/#soft-light","title":"Soft Light","text":"<p>Darkens or lightens the colors, depending on the source color value. The effect is similar to shining a diffused spotlight on the backdrop.</p> <p>Specified as <code>'soft-light'</code>.</p>"},{"location":"compositing/#difference","title":"Difference","text":"<p>Subtracts the darker of the two constituent colors from the lighter color. Painting with white inverts the backdrop color; painting with black produces no change.</p> <p>Specified as <code>'difference'</code>.</p>"},{"location":"compositing/#exclusion","title":"Exclusion","text":"<p>Produces an effect similar to that of the Difference mode but lower in contrast. Painting with white inverts the backdrop color; painting with black produces no change.</p> <p>Specified as <code>'exclusion'</code>.</p>"},{"location":"compositing/#hue","title":"Hue","text":"<p>Creates a color with the hue of the source color and the saturation and luminosity of the backdrop color.</p> <p>Specified as <code>'hue'</code>.</p>"},{"location":"compositing/#saturation","title":"Saturation","text":"<p>Creates a color with the saturation of the source color and the hue and luminosity of the backdrop color. Painting with this mode in an area of the backdrop that is a pure gray (no saturation) produces no change.</p> <p>Specified as <code>'saturation'</code>.</p>"},{"location":"compositing/#luminosity","title":"Luminosity","text":"<p>Creates a color with the luminosity of the source color and the hue and saturation of the backdrop color. This produces an inverse effect to that of the Color mode. This mode is the one you can use to create monochrome \"tinted\" image effects like the ones you can see in different website headers.</p> <p>Specified as <code>'luminosity'</code>.</p>"},{"location":"compositing/#color","title":"Color","text":"<p>Creates a color with the hue and saturation of the source color and the luminosity of the backdrop color. This preserves the gray levels of the backdrop and is useful for coloring monochrome images or tinting color images.</p> <p>Specified as <code>'color'</code>.</p>"},{"location":"compositing/#compositing-operators","title":"Compositing Operators","text":""},{"location":"compositing/#clear","title":"Clear","text":"<p>No regions are enabled.</p> Source Destination Result <p>Specified as <code>'clear'</code>.</p>"},{"location":"compositing/#copy","title":"Copy","text":"<p>Only the source will be present.</p> Source Destination Result <p>Specified as <code>'copy'</code>.</p>"},{"location":"compositing/#destination","title":"Destination","text":"<p>Only the destination will be present.</p> Source Destination Result <p>Specified as <code>'destination'</code>.</p>"},{"location":"compositing/#source-over","title":"Source Over","text":"<p>Source is placed over the destination.</p> Source Destination Result <p>Specified as <code>'source-over'</code>.</p>"},{"location":"compositing/#destination-over","title":"Destination Over","text":"<p>Destination is placed over the source.</p> Source Destination Result <p>Specified as <code>'destination-over'</code>.</p>"},{"location":"compositing/#source-in","title":"Source In","text":"<p>The source that overlaps the destination, replaces the destination.</p> Source Destination Result <p>Specified as <code>'source-in'</code>.</p>"},{"location":"compositing/#destination-in","title":"Destination In","text":"<p>Destination which overlaps the source, replaces the source.</p> Source Destination Result <p>Specified as <code>'destination-in'</code>.</p>"},{"location":"compositing/#source-out","title":"Source Out","text":"<p>Source is placed, where it falls outside of the destination.</p> Source Destination Result <p>Specified as <code>'source-out'</code>.</p>"},{"location":"compositing/#destination-out","title":"Destination Out","text":"<p>Destination is placed, where it falls outside of the source.</p> Source Destination Result <p>Specified as <code>'destination-out'</code>.</p>"},{"location":"compositing/#source-atop","title":"Source Atop","text":"<p>Source which overlaps the destination, replaces the destination. Destination is placed elsewhere.</p> Source Destination Result <p>Specified as <code>'source-atop'</code>.</p>"},{"location":"compositing/#destination-atop","title":"Destination Atop","text":"<p>Destination which overlaps the source replaces the source. Source is placed elsewhere.</p> Source Destination Result <p>Specified as <code>'destination-atop'</code>.</p>"},{"location":"compositing/#xor","title":"XOR","text":"<p>Destination which overlaps the source replaces the source. Source is placed elsewhere.</p> Source Destination Result <p>Specified as <code>'xor'</code>.</p>"},{"location":"compositing/#lighter","title":"Lighter","text":"<p>Display the sum of the source image and destination image.</p> Source Destination Result <p>Specified as <code>'lighter'</code>.</p>"},{"location":"contrast/","title":"Contrast","text":"<p>ColorAide provides a number of utilities related to luminance and contrast.</p>"},{"location":"contrast/#relative-luminance","title":"Relative Luminance","text":"<p>In the CIE XYZ and xyY color spaces, the Y parameter is linear to changes in the volume of light. Specifically this refers to the amount of reflected light where 1.0 is assumed to be a perfect reflector in relation to the reference white.</p> <p>The <code>luminance</code> method exposes access to this value to make it quick and easy to query the relative luminance.</p> <pre><code>&gt;&gt;&gt; Color(\"black\").luminance()\n0.0\n&gt;&gt;&gt; Color(\"white\").luminance()\n0.9999999999999999\n&gt;&gt;&gt; Color(\"blue\").luminance()\n0.07219231536073371\n</code></pre> Gamut: srgb <p>It should be noted that this luminance is relative to the XYZ D65 color space by default as this is how it is defined in the WCAG 2.1. What this means is that luminance is equivalent to the Y value of XYZ D65. We follow this convention as many people expect it in this format.</p> <p>Luminance and WCAG 2.1</p> <p>Luminance as described in the WCAG 2.1 spec is essentially the exact same as what the luminance method returns. The only difference is the lower precision by which they calculate the value:</p> <pre><code>&gt;&gt;&gt; r, g, b = Color('purple')[:-1]\n&gt;&gt;&gt; r = r / 12.92 if r &lt;= 0.03928 else ((r + 0.055) / 1.055) ** 2.4\n&gt;&gt;&gt; g = g / 12.92 if g &lt;= 0.03928 else ((g + 0.055) / 1.055) ** 2.4\n&gt;&gt;&gt; b = b / 12.92 if b &lt;= 0.03928 else ((b + 0.055) / 1.055) ** 2.4\n&gt;&gt;&gt; l = (0.2126 * r + 0.7152 * g + 0.0722 * b)\n&gt;&gt;&gt; print(l)\n0.06147707043243851\n&gt;&gt;&gt; Color('purple').convert('xyz-d65')['y']\n0.06148383144929487\n</code></pre> Gamut: srgb <p>If you'd like to have luminance in relation to a given color's white point, you can set <code>white</code> to <code>None</code>. If you'd like to get the luminance relative to some other white point, you can specify the white point as xy chromaticity points.</p> <pre><code>&gt;&gt;&gt; from coloraide import cat\n&gt;&gt;&gt; Color('prophoto-rgb', [1, 0, 0]).luminance()\n0.26831828062163154\n&gt;&gt;&gt; Color('prophoto-rgb', [1, 0, 0]).luminance(white=None)\n0.2880711282292934\n&gt;&gt;&gt; Color('prophoto-rgb', [1, 0, 0]).luminance(white=cat.WHITES['2deg']['E'])\n0.2905597743108222\n</code></pre> Gamut: srgb <p>New 2.4</p> <p>The <code>white</code> parameter is new in 2.4.</p>"},{"location":"contrast/#contrast_1","title":"Contrast","text":"<p>Chromatic contrast refers to the ability to see the difference of a colored object against a colored background. This can be very important when it comes to visual design and other fields. Determining contrast has been explored in many different ways and, depending on the application, there may be approaches to contrast that are more favorable. In the context of the web, contrast often refers to the ability to see text on a colored background and is of particular importance to those that suffer from visual impairments or disabilities.</p> <p>It should be noted that as we talk about contrast, we will refer to the colors as the text and background as this is often the context in which such a function is used. As far as ColorAide is concerned, the text is always the calling color and the background is the input parameter. It is important to note this as not all contrast algorithms are symmetrical, and can differ depending which color is referenced as text, and which is referenced as the background.</p> <p>At this time, ColorAide only offers a handful of contrast approaches, and they can be by using the <code>contrast()</code> method.</p> <pre><code>&gt;&gt;&gt; Color(\"blue\").contrast(\"red\")\n2.149390533243867\n</code></pre> Gamut: srgb <p>To select different contrast methods, simply use the <code>method</code> parameter.</p> <pre><code>&gt;&gt;&gt; Color(\"blue\").contrast(\"red\", method='wcag21')\n2.149390533243867\n</code></pre> Gamut: srgb Methods Symmetrical Description <code>wcag21</code> WCAG 2.1 contrast ratio. <code>lstar</code> Color difference between two tones in the HCT color space."},{"location":"contrast/#wcag-21-contrast-ratio","title":"WCAG 2.1 Contrast Ratio","text":"<p>The WCAG 2.1 contrast ratio is registered in <code>Color</code> by default</p> <p>ColorAide implements the color contrast ratio as outlined in the WCAG 2.1 spec. This is currently, the default contrast method. It is not without fault, but is currently the standard outlined for the web.</p> <p>The contrast ratio as outlined in the WCAG 2.1 specification is simply the ratio of color luminance from a foreground and background color and is very easy to determine if you are able to acquire the luminance of the two colors.</p> <pre><code># Where `l1` is the lighter luminance and `l2` the darker\ncontrast_ratio = (l1 + 0.05) / (l2 + 0.05)\n</code></pre> <p>This method can be used by specifying <code>wcag21</code> as the contrast method.</p> <pre><code>&gt;&gt;&gt; Color(\"blue\").contrast(\"red\", method='wcag21')\n2.149390533243867\n</code></pre> Gamut: srgb"},{"location":"contrast/#lstar-lightness-difference","title":"Lstar Lightness Difference","text":"<p>The Lstar contrast method is not registered in <code>Color</code> by default</p> <p>Google's Material Design uses a new color space called HCT. It uses the hue and chroma from CAM16 and the tone/lightness from CIELab. For contrast, they determined using tones that are \"far enough apart\" in the HCT color space was a good indication of sufficient contrast. Since HCT tone is exactly the same as CIELab's lightness (also known as L*), we've referred to this approach as Lstar.</p> <p>Lstar's color difference approach to contrast is quite simple, it's literally the difference between two color's lightness as provided by CIELab. This method does not care which color is text or background.</p> <pre><code>&gt;&gt;&gt; Color('hct', [30, 20, 70]).contrast(Color('hct', [30, 20, 50]), method='lstar')\n19.99999999995792\n</code></pre> Gamut: srgb <p>In order to use this contrast method, the plugin must be registered. This assumes the CIELab color space is currently registered, which it is by default.</p> <pre><code>from coloraide import Color as Base\nfrom coloraide.contrast.lstar import LstarContrast\n\nclass Color(Base): ...\n\nColor.register(LstarContrast())\n</code></pre>"},{"location":"distance/","title":"Color Distance and Delta E","text":"<p>The difference or distance between two colors allows for a quantified analysis of how far apart two colors are from one another. This metric is of particular interest in the field of color science, but it has practical applications in color libraries working with colors.</p> <p>Usually, color distance is applied to near perceptual uniform color spaces in order to obtain a metric regarding a color's visual, perceptual distance from another color. This can be useful in gamut mapping or even determining that colors are close enough or far enough away from each other.</p>"},{"location":"distance/#color-distance","title":"Color Distance","text":"<p>ColorAide provides a simple euclidean color distance function. By default, it evaluates the distance in the CIELab color space, but it can be configured to evaluate in any color space, such as Oklab, etc. It may be less useful in some color spaces compared to others. Cylindrical spaces with polar coordinates will be converted to rectangular coordinates if specified. Some spaces might not be as very perceptually uniform.</p> <pre><code>&gt;&gt;&gt; Color(\"red\").distance(\"blue\", space=\"srgb\")\n1.4142135623730951\n&gt;&gt;&gt; Color(\"red\").distance(\"blue\", space=\"lab\")\n184.0190486209969\n</code></pre> Gamut: srgb <p>New 3.3</p> <p>Handling spaces with polar coordinates is new in 3.3.</p>"},{"location":"distance/#delta-e","title":"Delta E","text":"<p>The <code>delta_e</code> function gives access to various \u2206E implementations, which are just different algorithms to calculate distance. Some are simply Euclidean distance withing a certain color space, some are far more complex.</p> <p>If no <code>method</code> is specified, the default implementation is \u2206E<sup>*</sup><sub>ab</sub> (CIE76) which uses a simple Euclidean distancing algorithm on the CIELab color space. It is fast, but not as accurate as later iterations of the algorithm as CIELab is not actually as perceptually uniform as it was thought when CIELab was originally developed.</p> <pre><code>&gt;&gt;&gt; Color(\"red\").delta_e(\"blue\")\n176.3084955965824\n</code></pre> Gamut: srgb <p>When <code>method</code> is set, the specified \u2206E algorithm will be used instead. For instance, below we use \u2206E<sup>*</sup><sub>00</sub> which is a more complex algorithm that accounts for the CIELab's weakness in perceptually uniformity. It does come at the cost of being a little slower.</p> <pre><code>&gt;&gt;&gt; Color(\"red\").delta_e(\"blue\", method=\"2000\")\n52.87819528592645\n</code></pre> Gamut: srgb <p>Distancing and Symmetry</p> <p>It should be noted that not all distancing algorithms are symmetrical. Some are order dependent.</p>"},{"location":"distance/#delta-e-cie76","title":"Delta E CIE76","text":"<p>The \u2206E<sub>ab</sub> distancing algorithm is registered in <code>Color</code> by default</p> Delta\u00a0E Symmetrical Name Parameters \u2206E<sup>*</sup><sub>ab</sub>\u00a0(CIE76) <code>76</code> <code>space='lab-d65'</code> <p>One of the first approaches to color distancing and is actually just Euclidean distancing in the CIELab color space.</p> <p>Note</p> <p>By default, Lab D65 is used for color distancing. In the print industry, it is common for Lab D50 to be used. If Lab D50 is desired, simply specify it as the <code>space</code> color space. <code>space</code> must be a CIE Lab color space.</p> <pre><code>&gt;&gt;&gt; Color(\"red\").delta_e(\"blue\", method=\"76\")\n176.3084955965824\n&gt;&gt;&gt; Color(\"red\").delta_e(\"blue\", method=\"76\", space='lab')\n184.0190486209969\n</code></pre> Gamut: srgb"},{"location":"distance/#delta-e-cmc-1984","title":"Delta E CMC (1984)","text":"<p>The \u2206E<sub>cmc</sub> distancing algorithm is registered in <code>Color</code> by default</p> Delta\u00a0E Symmetrical Name Parameters \u2206E<sup>*</sup><sub>cmc</sub>\u00a0(CMC\u00a0l:c\u00a0(1984)) <code>cmc</code> <code>l=2, c=1, space='lab-d65'</code> <p>Delta E CMC is based on the CIELCh color space. The CMC calculation mathematically defines an ellipsoid around the standard color with semi-axis corresponding to hue, chroma and lightness.</p> Parameter Acceptability Perceptibility <code>l</code> 2 1 <code>c</code> 1 1 <p>Note</p> <p>By default, Lab D65 is used for color distancing. In the print industry, it is common for Lab D50 to be used. If Lab D50 is desired, simply specify it as the <code>space</code> color space. <code>space</code> must be a CIE Lab color space.</p> <pre><code>&gt;&gt;&gt; Color(\"red\").delta_e(\"blue\", method=\"cmc\")\n108.56925233888809\n&gt;&gt;&gt; Color(\"red\").delta_e(\"blue\", method=\"cmc\", space='lab')\n114.2301281201658\n</code></pre> Gamut: srgb"},{"location":"distance/#delta-e-cie94","title":"Delta E CIE94","text":"<p>The \u2206E<sup>*</sup><sub>94</sub> distancing algorithm is registered in <code>Color</code> by default</p> Delta\u00a0E Symmetrical Name Parameters \u2206E<sup>*</sup><sub>94</sub>\u00a0(CIE94) <code>94</code> <code>kl=1, k1=0.045, k2=0.015, space='lab-d65'</code> <p>The 1976 definition was extended to address perceptual non-uniformities, while retaining the CIELab color space, by the introduction of application-specific weights derived from an automotive paint test's tolerance data.</p> Parameter Graphic\u00a0Arts Textiles <code>kl</code> 1 2 <code>k1</code> 0.045 0.048 <code>k2</code> 0.015 0.014 <p>Note</p> <p>By default, Lab D65 is used for color distancing. In the print industry, it is common for Lab D50 to be used. If Lab D50 is desired, simply specify it as the <code>space</code> color space. <code>space</code> must be a CIE Lab color space.</p> <pre><code>&gt;&gt;&gt; Color(\"red\").delta_e(\"blue\", method=\"94\")\n70.57699903580162\n&gt;&gt;&gt; Color(\"red\").delta_e(\"blue\", method=\"94\", space='lab')\n73.82677591958294\n</code></pre> Gamut: srgb"},{"location":"distance/#delta-e-ciede2000","title":"Delta E CIEDE2000","text":"<p>The \u2206E<sup>*</sup><sub>00</sub> distancing algorithm is registered in <code>Color</code> by default</p> Delta\u00a0E Symmetrical Name Parameters \u2206E<sup>*</sup><sub>00</sub>\u00a0(CIEDE2000) <code>2000</code> <code>kl=1, kc=1, kh=1, space='lab-d65'</code> <p>Since the 1994 definition did not adequately resolve the perceptual uniformity issue, the CIE refined their definition, adding five corrections:</p> <ul> <li>A hue rotation term (RT), to deal with the problematic blue region (hue angles in the neighborhood of 275\u00b0)</li> <li>Compensation for neutral colors (the primed values in the LCh differences)</li> <li>Compensation for lightness (SL)</li> <li>Compensation for chroma (SC)</li> <li>Compensation for hue (SH)</li> </ul> <p>Note</p> <p>By default, Lab D65 is used for color distancing. In the print industry, it is common for Lab D50 to be used. If Lab D50 is desired, simply specify it as the <code>space</code> color space. <code>space</code> must be a CIE Lab color space.</p> <pre><code>&gt;&gt;&gt; Color(\"red\").delta_e(\"blue\", method=\"2000\")\n52.87819528592645\n&gt;&gt;&gt; Color(\"red\").delta_e(\"blue\", method=\"2000\", space='lab')\n55.79977339019779\n</code></pre> Gamut: srgb"},{"location":"distance/#delta-e-hyab","title":"Delta E HyAB","text":"<p>The \u2206E<sub>HyAB</sub> distancing algorithm is registered in <code>Color</code> by default</p> Delta\u00a0E Symmetrical Name Parameters \u2206E<sub>HyAB</sub>\u00a0(HyAB) <code>hyab</code> <code>space=\"lab-d65\"</code> <p>A combination of a Euclidean metric in hue and chroma with a city\u2010block metric to incorporate lightness differences. It can be used on any Lab like color space, the default being CIELab D65.</p>"},{"location":"distance/#delta-e-ok","title":"Delta E OK","text":"<p>The \u2206E<sub>ok</sub> distancing algorithm is registered in <code>Color</code> by default</p> Delta\u00a0E Symmetrical Name Parameters \u2206E<sub>ok</sub> <code>ok</code> <code>scalar=1</code> <p>A color distancing algorithm that performs Euclidean distancing in the Oklab color space. This is used in the OkLCh Chroma gamut mapping algorithm. The <code>scalar</code> parameter allows you to scale the result up if desired.</p>"},{"location":"distance/#delta-e-itp","title":"Delta E ITP","text":"<p>The \u2206E<sub>itp</sub> distancing algorithm is registered in <code>Color</code> by default</p> Delta\u00a0E Symmetrical Name Parameters \u2206E<sub>itp</sub>\u00a0(ICtCp) <code>itp</code> <code>scalar=720</code> <p>Various algorithms are designed for and perform decently in the SDR range, but \u2206E<sub>itp</sub> aims to provide good distancing in the HDR range using the ICtCp color space (must be registered in order to use \u2206E<sub>itp</sub>). It was determined that a <code>scalar</code> of 240 was more comparable to the average \u2206E<sup>*</sup><sub>00</sub> result from the JND data set and 720 equates them to a JND.</p>"},{"location":"distance/#delta-e-z","title":"Delta E Z","text":"<p>The \u2206E<sub>z</sub> distancing algorithm is registered in <code>Color</code> by default</p> Delta\u00a0E Symmetrical Name Parameters \u2206E<sub>z</sub>\u00a0(Jzazbz) <code>jz</code> <p>Performs Euclidean distancing in the Jzazbz color space, useful for the HDR range.</p>"},{"location":"distance/#delta-e-99o","title":"Delta E 99o","text":"<p>The \u2206E<sub>99o</sub> distancing algorithm is not registered in <code>Color</code> by default</p> Delta\u00a0E Symmetrical Name Parameters \u2206E<sub>99o</sub>\u00a0(DIN99o) <code>99o</code> <p>\u2206E<sub>99o</sub> performs Euclidean distancing in the DIN99o color space.</p> <p>Both the DIN99o color space and the \u2206E algorithm must be registered to use.</p> <pre><code>from coloraide import Color as Base\nfrom coloraide.distance.delta_e_99o import DE99o\nfrom coloraide.spaces.din99o import DIN99o\n\nclass Color(Base): ...\n\nColor.register([DIN99o(), DE99o()])\n</code></pre>"},{"location":"distance/#delta-e-cam16","title":"Delta E CAM16","text":"<p>The \u2206E<sub>cam16</sub> distancing algorithm is not registered in <code>Color</code> by default</p> Delta\u00a0E Symmetrical Name Parameters \u2206E<sub>cam16</sub> <code>cam16</code> <code>space='cam16-ucs'</code> <p>The CAM16 UCS uniform color space applies an additional nonlinear transformation to lightness and colorfulness so that a color difference metric \u0394E can be based more closely on Euclidean distance. This algorithm performs distancing using the CAM16 UCS color space. If desired <code>model</code> can be changed to use the SCD or LCD model for \"small\" and \"large\" distancing respectively</p> Parameter Default Description <code>space</code> <code>cam16-ucs</code> The CAM16 color space derived from the <code>CAM16UCS</code> space. <code>cam16-ucs</code>, <code>cam16-scd</code>, and <code>cam16-lcd</code> are provided in ColorAide (unregistered by default). Variants using different lighting environments can be created and registered and provided as the UCS space to operate in. <p>Deprecated <code>model</code> parameter</p> <p>In 3.3 the <code>model</code> parameter was deprecated and will be removed at some future time. <code>space</code> is more flexible and should be used instead.</p> <p>The CAM16 JMh color space, one or more of the CAM16 (UCS/SCD/LCD) color spaces, and the \u2206E algorithm must be registered to use this \u2206E method.</p> <pre><code>from coloraide import Color as Base\nfrom coloraide.distance.delta_e_cam16 import DECAM16\nfrom coloraide.spaces.cam16_ucs import CAM16UCS, CAM16SCD, CAM16LCD\nfrom coloraide.spaces.cam16 import CAM16JMh\n\nclass Color(Base): ...\n\nColor.register([CAM16JMh(), CAM16UCS(), CAM16SCD(), CAM16LCD(), DECAM16()])\n</code></pre>"},{"location":"distance/#delta-e-hct","title":"Delta E HCT","text":"<p>The \u2206E<sub>hct</sub> distancing algorithm is not registered in <code>Color</code> by default</p> <p>Warning</p> <p>This approach was specifically added to help produce tonal palettes, but with the recent addition of the ray trace approach to chroma reduction in any perceptual space, users can defer to the ray tracing approach which does not require a special \u2206E method and it performs much faster.</p> <p>On occasions, MINDE approach can be slightly more accurate very close to white due to the way ray trace handles HCT's atypical achromatic response, but differences should be imperceptible to the eye at such lightness levels making the improved performance of the ray trace approach much more desirable.</p> <pre><code>&gt;&gt;&gt; c = Color('hct', [325, 24, 50])\n&gt;&gt;&gt; tones = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 95, 100]\n&gt;&gt;&gt; Steps([c.clone().set('tone', tone).convert('srgb').to_string(hex=True, fit={'method': 'raytrace', 'pspace': 'hct'}) for tone in tones])\n['#000000', '#29132e', '#3f2844', '#573e5b', '#705574', '#8a6d8d', '#a587a8', '#c1a1c3', '#debcdf', '#fbd7fc', '#ffebfd', '#ffffff']\n</code></pre> Gamut: srgb Delta\u00a0E Symmetrical Name Parameters \u2206E<sub>HCT</sub> <code>hct</code> <p>This takes the HCT color space C and H components (CAM16's M and h) and converts them to CAM16 UCS M and h, and applies Euclidean distancing on them along with the T component (CIELab's L*). This is necessary for the HCT Chroma gamut mapping approach.</p> <pre><code>from coloraide import Color as Base\nfrom coloraide.distance.delta_e_hct import DEHCT\nfrom coloraide.spaces.HCT import HCT\n\nclass Color(Base): ...\n\nColor.register([HCT(), DEHCT()])\n</code></pre>"},{"location":"distance/#finding-closest-color","title":"Finding Closest Color","text":"<p>ColorAide implements a simple way to find the closest color, given a list of colors, to another color. The method is called <code>closest</code> and takes a list of colors that are to be compared to the calling color object. The first color with the smallest distance between the calling color object and itself will be considered the nearest/closest color.</p> <p>Consider the following example. Here we provide a list of colors to compare against <code>red</code>. After comparing all the colors, the closest ends up being <code>maroon</code>.</p> <pre><code>&gt;&gt;&gt; Color('red').closest(['pink', 'yellow', 'green', 'blue', 'purple', 'maroon'])\ncolor(srgb 0.50196 0 0 / 1)\n</code></pre> Gamut: srgb <p>The default distancing method is used if one is not supplied, but others can be used:</p> <pre><code>&gt;&gt;&gt; Color('red').closest(['pink', 'yellow', 'green', 'blue', 'purple', 'maroon'], method='2000')\ncolor(srgb 0.50196 0 0 / 1)\n</code></pre> Gamut: srgb"},{"location":"distance/#configuring-delta-e-defaults","title":"Configuring Delta E Defaults","text":"<p>A number of distancing algorithms have configurable features that can be set on demand. If you'd like to have these options set by default, you create a custom class and register the plugins with the defaults of your choice.</p> <p>In this example, we will configure \u2206E<sup>*</sup><sub>00</sub> to use CIE Lab D50 instead of D65 by default.</p> <pre><code>&gt;&gt;&gt; from coloraide import Color as Base\n&gt;&gt;&gt; from coloraide.distance.delta_e_2000 import DE2000\n&gt;&gt;&gt; class Color(Base):\n...     ...\n... \n&gt;&gt;&gt; Color.register(DE2000(space='lab'), overwrite=True)\n&gt;&gt;&gt; Color('red').delta_e('blue', method='2000')\n55.79977339019779\n&gt;&gt;&gt; Color('red').delta_e('blue', method='2000', space='lab-d65')\n52.87819528592645\n</code></pre> Gamut: srgb"},{"location":"filters/","title":"Filters","text":"<p>ColorAide implements a number of filters with each filter being provided as a plugin. Filters simply apply some logic to transform a color in some specific way. Filters can be used to lighten colors, adjust saturation, or completely change the color. Filters can even be used to simulate things like color vision deficiencies.</p>"},{"location":"filters/#w3c-filter-effects","title":"W3C Filter Effects","text":"<p>The W3C Filter Effects Module Level 1 specification outline a number of filters for use in SVG and CSS. ColorAide implements all the filters that directly apply to colors. By default, filters are applied in the Linear sRGB color space, but can be applied in sRGB if requested. All other color spaces will throw an error.</p> NormalBrightnessSaturateContrastOpacityInvertHue RotateSepiaGrayscale <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p>To apply a specific filter in ColorAide, just call the <code>filter()</code> method with the name of the filter you wish to use. If an <code>amount</code> is not provided, the default according to the W3C spec will be used instead.</p> <pre><code>&gt;&gt;&gt; inputs = ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet']\n&gt;&gt;&gt; colors = Color.steps(inputs, steps=10, space='srgb')\n&gt;&gt;&gt; Steps(colors)\n[color(srgb 1 0 0 / 1), color(srgb 1 0.43137 0 / 1), color(srgb 1 0.76471 0 / 1), color(srgb 1 1 0 / 1), color(srgb 0.33333 0.66797 0 / 1), color(srgb 0 0.33464 0.33333 / 1), color(srgb 0 0 1 / 1), color(srgb 0.19608 0 0.6732 / 1), color(srgb 0.50719 0.16993 0.65098 / 1), color(srgb 0.93333 0.5098 0.93333 / 1)]\n&gt;&gt;&gt; Steps([c.filter('brightness', 0.5).clip() for c in colors])\n[color(srgb-linear 0.5 0 0 / 1), color(srgb-linear 0.5 0.07796 0 / 1), color(srgb-linear 0.5 0.27286 0 / 1), color(srgb-linear 0.5 0.5 0 / 1), color(srgb-linear 0.04542 0.20186 0 / 1), color(srgb-linear 0 0.04579 0.04542 / 1), color(srgb-linear 0 0 0.5 / 1), color(srgb-linear 0.01595 0 0.20539 / 1), color(srgb-linear 0.11038 0.01225 0.19066 / 1), color(srgb-linear 0.4275 0.11161 0.4275 / 1)]\n&gt;&gt;&gt; Steps([c.filter('saturate', 0.5).clip() for c in colors])\n[color(srgb-linear 0.6065 0.1065 0.1065 / 1), color(srgb-linear 0.66224 0.24021 0.16224 / 1), color(srgb-linear 0.8016 0.57446 0.3016 / 1), color(srgb-linear 0.964 0.964 0.464 / 1), color(srgb-linear 0.19943 0.35587 0.15401 / 1), color(srgb-linear 0.03601 0.0818 0.08143 / 1), color(srgb-linear 0.036 0.036 0.536 / 1), color(srgb-linear 0.03413 0.01818 0.22357 / 1), color(srgb-linear 0.15637 0.05825 0.23666 / 1), color(srgb-linear 0.62914 0.31325 0.62914 / 1)]\n&gt;&gt;&gt; Steps([c.filter('contrast', 0.8).clip() for c in colors])\n[color(srgb-linear 0.9 0.1 0.1 / 1), color(srgb-linear 0.9 0.22474 0.1 / 1), color(srgb-linear 0.9 0.53658 0.1 / 1), color(srgb-linear 0.9 0.9 0.1 / 1), color(srgb-linear 0.17267 0.42298 0.1 / 1), color(srgb-linear 0.1 0.17326 0.17267 / 1), color(srgb-linear 0.1 0.1 0.9 / 1), color(srgb-linear 0.12552 0.1 0.42862 / 1), color(srgb-linear 0.2766 0.1196 0.40506 / 1), color(srgb-linear 0.78399 0.27858 0.78399 / 1)]\n&gt;&gt;&gt; Steps([c.filter('opacity', 0.5).clip() for c in colors])\n[color(srgb-linear 1 0 0 / 0.5), color(srgb-linear 1 0.15593 0 / 0.5), color(srgb-linear 1 0.54572 0 / 0.5), color(srgb-linear 1 1 0 / 0.5), color(srgb-linear 0.09084 0.40373 0 / 0.5), color(srgb-linear 0 0.09158 0.09084 / 0.5), color(srgb-linear 0 0 1 / 0.5), color(srgb-linear 0.0319 0 0.41077 / 0.5), color(srgb-linear 0.22076 0.0245 0.38133 / 0.5), color(srgb-linear 0.85499 0.22323 0.85499 / 0.5)]\n&gt;&gt;&gt; Steps([c.filter('invert', 1).clip() for c in colors])\n[color(srgb-linear 0 1 1 / 1), color(srgb-linear 0 0.84407 1 / 1), color(srgb-linear 0 0.45428 1 / 1), color(srgb-linear 0 0 1 / 1), color(srgb-linear 0.90916 0.59627 1 / 1), color(srgb-linear 1 0.90842 0.90916 / 1), color(srgb-linear 1 1 0 / 1), color(srgb-linear 0.9681 1 0.58923 / 1), color(srgb-linear 0.77924 0.9755 0.61867 / 1), color(srgb-linear 0.14501 0.77677 0.14501 / 1)]\n&gt;&gt;&gt; Steps([c.filter('hue-rotate', 90).clip() for c in colors])\n[color(srgb-linear 0 0.356 0 / 1), color(srgb-linear 0 0.48932 0 / 1), color(srgb-linear 0 0.82259 0.20639 / 1), color(srgb-linear 0 1 0.856 / 1), color(srgb-linear 0 0.37753 0.52519 / 1), color(srgb-linear 0.09084 0.05913 0.14404 / 1), color(srgb-linear 1 0 0.144 / 1), color(srgb-linear 0.41077 0 0.04084 / 1), color(srgb-linear 0.38133 0.01908 0 / 1), color(srgb-linear 0.85499 0.31483 0 / 1)]\n&gt;&gt;&gt; Steps([c.filter('sepia', 1).clip() for c in colors])\n[color(srgb-linear 0.393 0.349 0.272 / 1), color(srgb-linear 0.51291 0.45597 0.35526 / 1), color(srgb-linear 0.81266 0.72337 0.56342 / 1), color(srgb-linear 1 1 0.806 / 1), color(srgb-linear 0.34617 0.30866 0.2403 / 1), color(srgb-linear 0.08759 0.07808 0.0608 / 1), color(srgb-linear 0.189 0.168 0.131 / 1), color(srgb-linear 0.09017 0.08014 0.06249 / 1), color(srgb-linear 0.17767 0.15791 0.12308 / 1), color(srgb-linear 0.66927 0.59517 0.46377 / 1)]\n&gt;&gt;&gt; Steps([c.filter('grayscale', 1).clip() for c in colors])\n[color(srgb-linear 0.2126 0.2126 0.2126 / 1), color(srgb-linear 0.32412 0.32412 0.32412 / 1), color(srgb-linear 0.6029 0.6029 0.6029 / 1), color(srgb-linear 0.9278 0.9278 0.9278 / 1), color(srgb-linear 0.30806 0.30806 0.30806 / 1), color(srgb-linear 0.07205 0.07205 0.07205 / 1), color(srgb-linear 0.0722 0.0722 0.0722 / 1), color(srgb-linear 0.03644 0.03644 0.03644 / 1), color(srgb-linear 0.09199 0.09199 0.09199 / 1), color(srgb-linear 0.40315 0.40315 0.40315 / 1)]\n</code></pre> Gamut: srgb <p>Tip</p> <p><code>filter()</code> can output the results in any color space you need by setting <code>out_space</code>.</p> <pre><code>&gt;&gt;&gt; Color('#07c7ed').filter('grayscale', 1, out_space='hsl')\ncolor(--hsl none 0 0.71528 / 1)\n</code></pre> Gamut: srgb"},{"location":"filters/#color-vision-deficiency-simulation","title":"Color Vision Deficiency Simulation","text":"<p>Color blindness or color vision deficiency (CVD) affects approximately 1 in 12 men (8%) and 1 in 200 women. CVD affects millions of people in the world, and many people have no idea that they are color blind and not seeing the full spectrum that others see.</p> <p>CVD simulation allows those who do not suffer with one of the many different variations of color blindness, to simulate what someone with a CVD would see. Keep in mind that these are just approximations, and that a given type of CVD can be quite different from person to person in severity.</p> <p>The human eye has 3 types of cones that are used to perceive colors. Each of these cones can become deficient, either through genetics, or other means. Each type of cone is responsible for perceiving different wavelengths of light. A CVD occurs when one or more of these cones are missing or not functioning properly. There are severe cases where one of the three cones will not perceive color at all, and there are others where the cones may just be less sensitive.</p>"},{"location":"filters/#dichromacy","title":"Dichromacy","text":"<p>Dichromacy is a type of CVD that has the characteristics of essentially causing the person to only have two functioning cones for perceiving colors. This essentially flattens the color spectrum into a 2D plane. Protanopia describes the CVD where the cone responsible for long wavelengths does not function, deuteranopia describes the CVD affecting the cone responsible for processing medium wavelengths, and tritanopia describes deficiencies with the cone responsible for short wavelengths.</p> NormalProtanopiaDeuteranopiaTritanopia <p></p> <p></p> <p></p> <p></p> <p>One misconception is that people with CVD have a color blindness for just red and green or something similar as that can often be how it is described, and while the statement is true that certain people with CVD may have trouble with red and green, they often can have trouble with other colors as well.</p> <p>The LMS color space was created to mimic the response of the human eye. Each channel represents one of the 3 cones with each cone responsible for seeing light waves of different frequencies: long (L), medium (M), and short (S). Protanopia represents deficiencies with the L cone, deuteranopia with the M cone, and tritanopia with the S cone. Any color whose properties only vary in the properties specific to a person's deficient cone(s) will have the potential to cause confusion for that person.</p> <p>Consider the example below. First we do a little setup so we can translate colors to the LMS space.</p> <pre><code>&gt;&gt;&gt; from coloraide import Color as Base\n&gt;&gt;&gt; from coloraide.cat import WHITES\n&gt;&gt;&gt; from coloraide.spaces import Space\n&gt;&gt;&gt; from coloraide import algebra as alg\n&gt;&gt;&gt; from coloraide.types import Vector\n&gt;&gt;&gt; from coloraide.channels import Channel\n&gt;&gt;&gt; class LMS(Space):\n...     \"\"\"The LMS class.\"\"\"\n... \n...     BASE = \"srgb-linear\"\n...     NAME = \"lms\"\n...     SERIALIZE = (\"--lms\",)\n...     CHANNELS = (\n...         Channel(\"l\", 0.0, 1.0),\n...         Channel(\"m\", 0.0, 1.0),\n...         Channel(\"s\", 0.0, 1.0)\n...     )\n...     CHANNEL_ALIASES = {\n...         \"long\": \"l\",\n...         \"medium\": \"m\",\n...         \"short\": \"s\"\n...     }\n...     WHITE = WHITES['2deg']['D65']\n... \n...     LRGB_TO_LMS = [\n...         [0.178824041258, 0.4351609057000001, 0.04119349692],\n...         [0.034556423182, 0.27155382458, 0.038671308360000003],\n...         [0.000299565576, 0.0018430896, 0.01467086136]\n...     ]\n... \n...     LMS_TO_LRGB = [\n...         [8.094435598032371, -13.050431460496926, 11.672058453917323],\n...         [-1.0248505586646686, 5.401931309674973, -11.361471490598712],\n...         [-0.03652974715933318, -0.412162807001268, 69.35132423820858]\n...     ]\n... \n...     def to_base(self, coords: Vector) -&gt; Vector:\n...         \"\"\"To XYZ.\"\"\"\n... \n...         return alg.dot(self.LMS_TO_LRGB, coords, dims=alg.D2_D1)\n... \n...     def from_base(self, coords: Vector) -&gt; Vector:\n...         \"\"\"From XYZ.\"\"\"\n... \n...         return alg.dot(self.LRGB_TO_LMS, coords, dims=alg.D2_D1)\n... \n&gt;&gt;&gt; class Color(Base):\n...     ...\n... \n&gt;&gt;&gt; Color.register(LMS())\n&gt;&gt;&gt; def get_limit(c, channel, upper=False):\n... \n...     if upper:\n...         low = c[channel]\n...         high = 1\n...     else:\n...         high = c[channel]\n...         low = 0\n... \n...     temp = c.clone()\n... \n...     while abs(high - low) &gt;= 0.002:\n...         value = (high + low) * 0.5\n...         temp[channel] = value\n...         if temp.in_gamut('srgb', tolerance=0.01):\n...             if upper:\n...                 low = value\n...             else:\n...                 high = value\n...         else:\n...             if upper:\n...                 high = value\n...             else:\n...                 low = value\n... \n...     return temp.clip('srgb')\n... \n&gt;&gt;&gt; def confusion_line(c, cone):\n...     \"\"\"Generate colors on a line of confusion.\"\"\"\n... \n...     lms = c.convert('lms')\n...     high = get_limit(lms, cone, upper=True)\n...     low = get_limit(lms, cone)\n...     return Color.steps([low, high], steps=6, space='lms', out_space='srgb')\n... \n</code></pre> Session: cvd Gamut: srgb <p>Editing Examples</p> <p>The LMS code above is part of the same session as the examples below (as noted in the bottom right corner). If you want to edit the examples, run the LMS code above at least once.</p> <p>Then We generate 3 different color series, each specifically targeting a specific deficiency. This is done by generating a series of colors that have all properties equal except that they have variance in a different cone response. The first row varies only with the L cone response, the second only with the M cone response, and the third only with the S cone response. We then apply the filters for protanopia, deuteranopia, and tritanopia. We can see that while many of the colors are altered, the row that targets the deficient cone specific to the CVD all appear to be of the same color making it difficult to distinguish between any of them.</p> NormalProtanopiaDeuteranopiaTritanopia <pre><code>&gt;&gt;&gt; confusing_colors = confusion_line(Color('orange'), 'l')\n&gt;&gt;&gt; Steps([c.clip() for c in confusing_colors])\n[color(srgb 0 0.73785 0.0565 / 1), color(srgb 0.48453 0.72034 0.0466 / 1), color(srgb 0.66519 0.70225 0.03524 / 1), color(srgb 0.79774 0.68354 0.02349 / 1), color(srgb 0.90633 0.66414 0.01175 / 1), color(srgb 1 0.64398 0 / 1)]\n&gt;&gt;&gt; confusing_colors = confusion_line(Color('hotpink'), 'm')\n&gt;&gt;&gt; Steps([c.clip() for c in confusing_colors])\n[color(srgb 1 0.40107 0.70629 / 1), color(srgb 0.90666 0.5039 0.70182 / 1), color(srgb 0.7985 0.58535 0.69731 / 1), color(srgb 0.66664 0.65439 0.69277 / 1), color(srgb 0.48742 0.71511 0.68818 / 1), color(srgb 0.04172 0.76977 0.68356 / 1)]\n&gt;&gt;&gt; confusing_colors = confusion_line(Color('seagreen'), 's')\n&gt;&gt;&gt; Steps([c.clip() for c in confusing_colors])\n[color(srgb 0.18039 0.5451 0.34118 / 1), color(srgb 0.26982 0.51394 0.56225 / 1), color(srgb 0.33367 0.4802 0.70642 / 1), color(srgb 0.38543 0.44317 0.81991 / 1), color(srgb 0.42983 0.40182 0.91581 / 1), color(srgb 0.46916 0.35444 1 / 1)]\n</code></pre> Session: cvd Gamut: srgb <pre><code>&gt;&gt;&gt; confusing_colors = confusion_line(Color('orange'), 'l')\n&gt;&gt;&gt; Steps([c.filter('protan').clip() for c in confusing_colors])\n[color(srgb-linear 0.44718 0.44718 0.00253 / 1), color(srgb-linear 0.44632 0.44632 0.00253 / 1), color(srgb-linear 0.44545 0.44545 0.00252 / 1), color(srgb-linear 0.44459 0.44459 0.00252 / 1), color(srgb-linear 0.44372 0.44372 0.00252 / 1), color(srgb-linear 0.44286 0.44286 0.00251 / 1)]\n&gt;&gt;&gt; confusing_colors = confusion_line(Color('hotpink'), 'm')\n&gt;&gt;&gt; Steps([c.filter('protan').clip() for c in confusing_colors])\n[color(srgb-linear 0.23099 0.23099 0.46046 / 1), color(srgb-linear 0.28318 0.28318 0.45292 / 1), color(srgb-linear 0.33538 0.33538 0.44537 / 1), color(srgb-linear 0.38758 0.38758 0.43782 / 1), color(srgb-linear 0.43978 0.43978 0.43027 / 1), color(srgb-linear 0.49197 0.49197 0.42273 / 1)]\n&gt;&gt;&gt; confusing_colors = confusion_line(Color('seagreen'), 's')\n&gt;&gt;&gt; Steps([c.filter('protan').clip() for c in confusing_colors])\n[color(srgb-linear 0.23224 0.23224 0.09438 / 1), color(srgb-linear 0.20829 0.20829 0.27557 / 1), color(srgb-linear 0.18435 0.18435 0.45676 / 1), color(srgb-linear 0.16041 0.16041 0.63795 / 1), color(srgb-linear 0.13646 0.13646 0.81914 / 1), color(srgb-linear 0.11252 0.11252 1 / 1)]\n</code></pre> Session: cvd Gamut: srgb <pre><code>&gt;&gt;&gt; confusing_colors = confusion_line(Color('orange'), 'l')\n&gt;&gt;&gt; Steps([c.filter('deutan').clip() for c in confusing_colors])\n[color(srgb-linear 0.35631 0.35631 0.0158 / 1), color(srgb-linear 0.39626 0.39626 0.00984 / 1), color(srgb-linear 0.43622 0.43622 0.00387 / 1), color(srgb-linear 0.47617 0.47617 0 / 1), color(srgb-linear 0.51612 0.51612 0 / 1), color(srgb-linear 0.55607 0.55607 0 / 1)]\n&gt;&gt;&gt; confusing_colors = confusion_line(Color('hotpink'), 'm')\n&gt;&gt;&gt; Steps([c.filter('deutan').clip() for c in confusing_colors])\n[color(srgb-linear 0.38725 0.38725 0.43764 / 1), color(srgb-linear 0.38833 0.38833 0.43756 / 1), color(srgb-linear 0.38941 0.38941 0.43748 / 1), color(srgb-linear 0.3905 0.3905 0.43739 / 1), color(srgb-linear 0.39158 0.39158 0.43731 / 1), color(srgb-linear 0.39266 0.39266 0.43723 / 1)]\n&gt;&gt;&gt; confusing_colors = confusion_line(Color('seagreen'), 's')\n&gt;&gt;&gt; Steps([c.filter('deutan').clip() for c in confusing_colors])\n[color(srgb-linear 0.1906 0.1906 0.10046 / 1), color(srgb-linear 0.17799 0.17799 0.28 / 1), color(srgb-linear 0.16539 0.16539 0.45953 / 1), color(srgb-linear 0.15278 0.15278 0.63907 / 1), color(srgb-linear 0.14018 0.14018 0.8186 / 1), color(srgb-linear 0.12757 0.12757 0.99814 / 1)]\n</code></pre> Session: cvd Gamut: srgb <pre><code>&gt;&gt;&gt; confusing_colors = confusion_line(Color('orange'), 'l')\n&gt;&gt;&gt; Steps([c.filter('tritan').clip() for c in confusing_colors])\n[color(srgb-linear 0.09504 0.41129 0.56924 / 1), color(srgb-linear 0.27752 0.40204 0.46424 / 1), color(srgb-linear 0.46584 0.38712 0.3939 / 1), color(srgb-linear 0.66496 0.36167 0.3878 / 1), color(srgb-linear 0.86409 0.33623 0.38171 / 1), color(srgb-linear 1 0.31078 0.37561 / 1)]\n&gt;&gt;&gt; confusing_colors = confusion_line(Color('hotpink'), 'm')\n&gt;&gt;&gt; Steps([c.filter('tritan').clip() for c in confusing_colors])\n[color(srgb-linear 0.96312 0.16951 0.23789 / 1), color(srgb-linear 0.77356 0.24403 0.28965 / 1), color(srgb-linear 0.584 0.31855 0.34142 / 1), color(srgb-linear 0.39444 0.39306 0.39318 / 1), color(srgb-linear 0.22435 0.44862 0.56064 / 1), color(srgb-linear 0.05436 0.50409 0.7287 / 1)]\n&gt;&gt;&gt; confusing_colors = confusion_line(Color('seagreen'), 's')\n&gt;&gt;&gt; Steps([c.filter('tritan').clip() for c in confusing_colors])\n[color(srgb-linear 0.06253 0.22391 0.30451 / 1), color(srgb-linear 0.06359 0.22288 0.30244 / 1), color(srgb-linear 0.06464 0.22186 0.30038 / 1), color(srgb-linear 0.0657 0.22083 0.29831 / 1), color(srgb-linear 0.06675 0.2198 0.29624 / 1), color(srgb-linear 0.06781 0.21877 0.29417 / 1)]\n</code></pre> Session: cvd Gamut: srgb <p>By default, ColorAide uses the Brettel 1997 method to simulate tritanopia as it is the only option that has decent accuracy for tritanopia. Vi\u00e9not, Brettel, and Mollon 1999 approach is used to simulate protanopia and deuteranopia as it is not only faster than Brettel, but it handles extreme cases a little better. Machado 2009 has its strengths as well which we will cover in Anomalous Trichromacy.</p> <pre><code>&gt;&gt;&gt; inputs = ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet']\n&gt;&gt;&gt; colors = Color.steps(inputs, steps=10, space='srgb')\n&gt;&gt;&gt; Steps(colors)\n[color(srgb 1 0 0 / 1), color(srgb 1 0.43137 0 / 1), color(srgb 1 0.76471 0 / 1), color(srgb 1 1 0 / 1), color(srgb 0.33333 0.66797 0 / 1), color(srgb 0 0.33464 0.33333 / 1), color(srgb 0 0 1 / 1), color(srgb 0.19608 0 0.6732 / 1), color(srgb 0.50719 0.16993 0.65098 / 1), color(srgb 0.93333 0.5098 0.93333 / 1)]\n&gt;&gt;&gt; Steps([c.filter('protan').clip() for c in colors])\n[color(srgb-linear 0.11238 0.11238 0.00401 / 1), color(srgb-linear 0.25079 0.25079 0.00338 / 1), color(srgb-linear 0.59678 0.59678 0.00182 / 1), color(srgb-linear 1 1 0 / 1), color(srgb-linear 0.36856 0.36856 0 / 1), color(srgb-linear 0.08129 0.08129 0.09047 / 1), color(srgb-linear 0 0 1 / 1), color(srgb-linear 0.00358 0.00358 0.4109 / 1), color(srgb-linear 0.04655 0.04655 0.38211 / 1), color(srgb-linear 0.29423 0.29423 0.85752 / 1)]\n&gt;&gt;&gt; Steps([c.filter('deutan').clip() for c in colors])\n[color(srgb-linear 0.29275 0.29275 0 / 1), color(srgb-linear 0.40303 0.40303 0 / 1), color(srgb-linear 0.67871 0.67871 0 / 1), color(srgb-linear 1 1 0 / 1), color(srgb-linear 0.31213 0.31213 0.00699 / 1), color(srgb-linear 0.06477 0.06477 0.09289 / 1), color(srgb-linear 0 0 1 / 1), color(srgb-linear 0.00934 0.00934 0.41006 / 1), color(srgb-linear 0.08195 0.08195 0.37694 / 1), color(srgb-linear 0.40818 0.40818 0.84088 / 1)]\n&gt;&gt;&gt; Steps([c.filter('tritan').clip() for c in colors])\n[color(srgb-linear 1 0 0.07589 / 1), color(srgb-linear 1 0.12293 0.20142 / 1), color(srgb-linear 1 0.46132 0.5152 / 1), color(srgb-linear 1 0.85569 0.88089 / 1), color(srgb-linear 0.16172 0.33473 0.42114 / 1), color(srgb-linear 0.00588 0.08585 0.12579 / 1), color(srgb-linear 0 0.1232 0.24795 / 1), color(srgb-linear 0 0.05257 0.08987 / 1), color(srgb-linear 0.17036 0.07355 0.08189 / 1), color(srgb-linear 0.7694 0.30654 0.34642 / 1)]\n</code></pre> Gamut: srgb <p>If desired, any of the three available methods can be used.</p> <pre><code>&gt;&gt;&gt; inputs = ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet']\n&gt;&gt;&gt; colors = Color.steps(inputs, steps=10, space='srgb')\n&gt;&gt;&gt; Steps(colors)\n[color(srgb 1 0 0 / 1), color(srgb 1 0.43137 0 / 1), color(srgb 1 0.76471 0 / 1), color(srgb 1 1 0 / 1), color(srgb 0.33333 0.66797 0 / 1), color(srgb 0 0.33464 0.33333 / 1), color(srgb 0 0 1 / 1), color(srgb 0.19608 0 0.6732 / 1), color(srgb 0.50719 0.16993 0.65098 / 1), color(srgb 0.93333 0.5098 0.93333 / 1)]\n&gt;&gt;&gt; Steps([c.filter('tritan', method='brettel').clip() for c in colors])\n[color(srgb-linear 1 0 0.07589 / 1), color(srgb-linear 1 0.12293 0.20142 / 1), color(srgb-linear 1 0.46132 0.5152 / 1), color(srgb-linear 1 0.85569 0.88089 / 1), color(srgb-linear 0.16172 0.33473 0.42114 / 1), color(srgb-linear 0.00588 0.08585 0.12579 / 1), color(srgb-linear 0 0.1232 0.24795 / 1), color(srgb-linear 0 0.05257 0.08987 / 1), color(srgb-linear 0.17036 0.07355 0.08189 / 1), color(srgb-linear 0.7694 0.30654 0.34642 / 1)]\n&gt;&gt;&gt; Steps([c.filter('tritan', method='vienot').clip() for c in colors])\n[color(srgb-linear 1 0 0 / 1), color(srgb-linear 1 0.13398 0.13398 / 1), color(srgb-linear 1 0.46891 0.46891 / 1), color(srgb-linear 1 0.85924 0.85924 / 1), color(srgb-linear 0.14923 0.3469 0.3469 / 1), color(srgb-linear 0.00011 0.09147 0.09147 / 1), color(srgb-linear 0 0.14076 0.14076 / 1), color(srgb-linear 0 0.05782 0.05782 / 1), color(srgb-linear 0.16915 0.07473 0.07473 / 1), color(srgb-linear 0.76363 0.31216 0.31216 / 1)]\n&gt;&gt;&gt; Steps([c.filter('tritan', method='machado').clip() for c in colors])\n[color(srgb-linear 1 0 0.00473 / 1), color(srgb-linear 1 0.06673 0.11254 / 1), color(srgb-linear 1 0.42955 0.38203 / 1), color(srgb-linear 1 0.8524 0.6961 / 1), color(srgb-linear 0.08307 0.36867 0.27955 / 1), color(srgb-linear 0 0.09865 0.09092 / 1), color(srgb-linear 0 0.1476 0.3039 / 1), color(srgb-linear 0 0.05813 0.12498 / 1), color(srgb-linear 0.20711 0.06178 0.13387 / 1), color(srgb-linear 0.90348 0.26694 0.41821 / 1)]\n</code></pre> Gamut: srgb"},{"location":"filters/#anomalous-trichromacy","title":"Anomalous Trichromacy","text":"<p>While Dichromacy is probably the more severe case with only two functional cones, a more common CVD type is anomalous trichromacy. In this case, a person will have three functioning cones, but not all of the cones function with full sensitivity. Sometimes, the sensitivity can be so low, that their ability to perceive color may be close to someone with dichromacy.</p> <p>While dichromacy may be considered a severity 1, a given case of anomalous trichromacy could be anywhere between 0 and 1, where 0 would be no CVD.</p> <p>Like dichromacy, the related deficiencies are named in a similar manner: protanomaly (reduced red sensitivity), deuteranomaly (reduced green sensitivity), and tritanomaly (reduced blue sensitivity).</p> NormalProtanomaly Severity 0.5Protanomaly Severity 0.7Protanomaly Severity 0.9 <p></p> <p></p> <p></p> <p></p> <p>To represent anomalous trichromacy, ColorAide leans on the Machado 2009 approach which has a more nuanced approach to handling severity levels below 1. This research associated with this method did not really focus on tritanopia though, and Brettel is still a better choice for tritanopia. Instead of relying on the Machado approach for tritanomaly, we instead just use linear interpolation between the severity 1 results and the severity 0 (no CVD) results.</p> <pre><code>&gt;&gt;&gt; inputs = ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet']\n&gt;&gt;&gt; colors = Color.steps(inputs, steps=10, space='srgb')\n&gt;&gt;&gt; Steps(colors)\n[color(srgb 1 0 0 / 1), color(srgb 1 0.43137 0 / 1), color(srgb 1 0.76471 0 / 1), color(srgb 1 1 0 / 1), color(srgb 0.33333 0.66797 0 / 1), color(srgb 0 0.33464 0.33333 / 1), color(srgb 0 0 1 / 1), color(srgb 0.19608 0 0.6732 / 1), color(srgb 0.50719 0.16993 0.65098 / 1), color(srgb 0.93333 0.5098 0.93333 / 1)]\n&gt;&gt;&gt; Steps([c.filter('protan', 0.3).clip() for c in colors])\n[color(srgb-linear 0.63032 0.06918 0 / 1), color(srgb-linear 0.70293 0.20796 0 / 1), color(srgb-linear 0.88443 0.5549 0 / 1), color(srgb-linear 1 0.95923 0 / 1), color(srgb-linear 0.24525 0.36562 0 / 1), color(srgb-linear 0.03392 0.08521 0.09141 / 1), color(srgb-linear 0 0.04077 1 / 1), color(srgb-linear 0 0.01895 0.41633 / 1), color(srgb-linear 0.11396 0.05262 0.3851 / 1), color(srgb-linear 0.56082 0.29269 0.85987 / 1)]\n&gt;&gt;&gt; Steps([c.filter('protan', 0.5).clip() for c in colors])\n[color(srgb-linear 0.45806 0.09279 0 / 1), color(srgb-linear 0.56403 0.22475 0 / 1), color(srgb-linear 0.82893 0.55464 0 / 1), color(srgb-linear 1 0.9391 0 / 1), color(srgb-linear 0.31598 0.35011 0 / 1), color(srgb-linear 0.04973 0.08304 0.09151 / 1), color(srgb-linear 0 0.0609 1 / 1), color(srgb-linear 0 0.02798 0.42051 / 1), color(srgb-linear 0.06528 0.06444 0.38853 / 1), color(srgb-linear 0.42566 0.32032 0.86561 / 1)]\n&gt;&gt;&gt; Steps([c.filter('protan', 0.9).clip() for c in colors])\n[color(srgb-linear 0.20388 0.11298 0 / 1), color(srgb-linear 0.3583 0.23687 0 / 1), color(srgb-linear 0.74433 0.54658 0 / 1), color(srgb-linear 1 0.90752 0 / 1), color(srgb-linear 0.41835 0.33104 0 / 1), color(srgb-linear 0.07305 0.08116 0.09129 / 1), color(srgb-linear 0 0.09248 1 / 1), color(srgb-linear 0 0.04159 0.42961 / 1), color(srgb-linear 0 0.07967 0.39681 / 1), color(srgb-linear 0.22933 0.35303 0.88092 / 1)]\n</code></pre> Gamut: srgb <p>The Brettel and Vi\u00e9not approach can be used for severities below 1 as well, but, like Brettel with tritanopia, they will employ simple linear interpolation between a severity 1 case ans the actual color. It is probably debatable as to whether this approach is sufficient or not.</p>"},{"location":"filters/#usage-details","title":"Usage Details","text":"<p>To use filters, a filter name must be given, followed by an optional amount. If an amount is omitted, suitable default will be used. The exact range a given filter accepts varies depending on the filter. If a value exceeds the filter range , the value will be clamped.</p> Filters Name Default Brightness <code>brightness</code> <code>1</code> Saturation <code>saturate</code> <code>1</code> Contrast <code>contrast</code> <code>1</code> Opacity <code>opacity</code> <code>1</code> Invert <code>invert</code> <code>1</code> Hue\u00a0rotation <code>hue-rotate</code> <code>0</code> Sepia <code>sepia</code> <code>1</code> Grayscale <code>grayscale</code> <code>1</code> Protan <code>protan</code> <code>1</code> Deutan <code>deutan</code> <code>1</code> Tritan <code>tritan</code> <code>1</code> <p>All of the filters that are supported allow filtering in the Linear sRGB color space and will do so by default. Additionally, the W3C filter effects also support filtering in the sRGB color space. The CVD filters are specifically designed to be applied in the Linear sRGB space, and cannot be used in any other color space.</p> <pre><code>&gt;&gt;&gt; inputs = ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet']\n&gt;&gt;&gt; colors = Color.steps(inputs, steps=10, space='srgb')\n&gt;&gt;&gt; Steps(colors)\n[color(srgb 1 0 0 / 1), color(srgb 1 0.43137 0 / 1), color(srgb 1 0.76471 0 / 1), color(srgb 1 1 0 / 1), color(srgb 0.33333 0.66797 0 / 1), color(srgb 0 0.33464 0.33333 / 1), color(srgb 0 0 1 / 1), color(srgb 0.19608 0 0.6732 / 1), color(srgb 0.50719 0.16993 0.65098 / 1), color(srgb 0.93333 0.5098 0.93333 / 1)]\n&gt;&gt;&gt; Steps([c.filter('sepia', 1, space='srgb-linear').clip() for c in colors])\n[color(srgb-linear 0.393 0.349 0.272 / 1), color(srgb-linear 0.51291 0.45597 0.35526 / 1), color(srgb-linear 0.81266 0.72337 0.56342 / 1), color(srgb-linear 1 1 0.806 / 1), color(srgb-linear 0.34617 0.30866 0.2403 / 1), color(srgb-linear 0.08759 0.07808 0.0608 / 1), color(srgb-linear 0.189 0.168 0.131 / 1), color(srgb-linear 0.09017 0.08014 0.06249 / 1), color(srgb-linear 0.17767 0.15791 0.12308 / 1), color(srgb-linear 0.66927 0.59517 0.46377 / 1)]\n&gt;&gt;&gt; Steps([c.filter('sepia', 1, space='srgb').clip() for c in colors])\n[color(srgb 0.393 0.349 0.272 / 1), color(srgb 0.72473 0.64492 0.50235 / 1), color(srgb 0.98106 0.87359 0.68035 / 1), color(srgb 1 1 0.806 / 1), color(srgb 0.64467 0.57456 0.44736 / 1), color(srgb 0.32034 0.28556 0.22236 / 1), color(srgb 0.189 0.168 0.131 / 1), color(srgb 0.20429 0.18153 0.14152 / 1), color(srgb 0.45304 0.40295 0.31398 / 1), color(srgb 0.93524 0.83226 0.64837 / 1)]\n</code></pre> Gamut: srgb <p>Processing Lots of Colors</p> <p>One logical application for filters is to apply them directly to images. If you are performing these operations on millions of pixels, you may notice that ColorAide, with all of its convenience, may not always be the fastest. There is a cost due to the overhead of convenience and a cost due to the pure Python approach as well. With that said, there are tricks that can dramatically make things much faster in most cases!</p> <p><code>functools.lru_cache</code> is your friend in such cases. We actually process all the images on this page with ColorAide to demonstrate the filters. The key to making it a quick and painless process was to cache repetitive operations. When processing images, it is highly likely that you will be performing the same operations on thousands of identical pixels. Caching the work you've already done can speed this process up exponentially.</p> <p>There are certainly some images that could be constructed in such a way to elicit a worse case scenario where the cache would not be able to compensate as well, but for most images, caching dramatically reduces processing time.</p> <p>We can crawl the pixels in a file, and using a simple function like below, we will only process a pixel once (at least until our cache fills and we start having to overwrite existing colors).</p> <pre><code>@lru_cache(maxsize=1024 * 1024)\ndef apply_filter(name, amount, space, method, p, fit):\n    \"\"\"Apply filter.\"\"\"\n\n    has_alpha = len(p) &gt; 3\n    color = Color('srgb', [x / 255 for x in p[:3]], p[3] / 255 if has_alpha else 1)\n    if method is not None:\n        # This is a CVD filter that allows specifying the method\n        color.filter(name, amount, space=space, in_place=True, method=method)\n    else:\n        # General filter.\n        color.filter(name, amount, space=space, in_place=True)\n    # Fit the color back into the color gamut and return the results\n    return tuple([int(x * 255) for x in color.fit(method=fit)[:3 if has_alpha else -1]])\n</code></pre> <p>When processing a 4608x2456 image (15,925,248 pixels) during our testing, it turned a ~7 minute process into a ~25 second process<sup>*</sup>. Using gamut mapping opposed to simple clipping only increases time by to about ~56 seconds. The much smaller images shown on this page process much, much faster.</p> <p>The full script can be viewed here.</p> <p>* Tests were performed using the Pillow library. Results may vary depending on the size of the image, pixel configuration, number of unique pixels, etc. Cache size can be tweaked to optimize the results.</p>"},{"location":"gamut/","title":"Gamut Mapping","text":"<p>Many color spaces are designed to represent a specific range of colors. This is often done to target specific display types or mediums. The monitor this is being displayed on can likely display millions of colors, but there are still  colors it is not capable of displaying. So color spaces are often designed to represent such mediums to make it easy for authors and artists to know exactly where those color boundaries are. This range of colors that a color space is limited to and designed for is called a color gamut.</p> <p>There are some color spaces that are theoretically unbounded, and even some color spaces that are bounded but can actually still give meaningful data if extended, but often, when it comes time to display a color, paint a product, or print a book, the actual colors are limited to what that device or process can handle.</p> <p>The sRGB and Display P3 color spaces are both RGB color spaces, but they actually can represent a different amount of colors. Display P3 has a wider gamut and allows for greener greens and redder reds, etc. In the image below, we show four different RGB color spaces, each with varying different gamut sizes. Display P3 contains all the colors in sRGB and extends it even further. Rec. 2020, another RGB color space, is even wider. ProPhoto is so wide that it contains colors that the human eye can't even see.</p> <p></p> <p>In order to visually represent a color from a wider gamut color space, such as Display P3, in a more narrow color space, such as sRGB, a suitable color within the more narrow color space must be selected and be shown in its place. This selecting of a suitable replacement is called gamut mapping.</p> <p>ColorAide defines a couple methods to help identify when a color is outside the gamut bounds of a color space and to help find a suitable, alternative color that is within the gamut.</p>"},{"location":"gamut/#checking-gamut","title":"Checking Gamut","text":"<p>When dealing with colors, it can be important to know whether a color is within its own gamut. Let's say we are working with colors in Display P3, but we want to output to an sRGB display. Let's say the color of interest is <code>color(display-p3 1 0 0)</code>. If we plot the color as shown below, we can see that it is in Display P3, the faint transparent shell, but it is outside the sRGB gamut, the color solid in the middle. We'd like to detect these cases and make an adjustment to ensure we don't get unexpected behavior.</p> <p></p> <p>The <code>in_gamut</code> function allows for comparing the current color's specified values against the target color space's gamut.</p> <p>Let's assume we have a color <code>rgb(30% 105% 0%)</code>. The color is out of gamut due to the green channel exceeding the channel's limit of <code>100%</code>. When we execute <code>in_gamut</code>, we can see that the color is not in its own gamut.</p> <pre><code>&gt;&gt;&gt; Color(\"rgb(30% 105% 0%)\").in_gamut()\nFalse\n</code></pre> Gamut: srgb <p>On the other hand, some color spaces do not have a limit. CIELab and Oklab are such color spaces and can be represented in any gamut that'd you'd like.</p> <p></p> <p>Sometimes limits will be placed on the color space's channels (as done above) for practicality, but theoretically, there are no exact bounds.</p> <p>When we check a CIELab color, we will find that it is always considered in gamut as it has no gamut itself.</p> <pre><code>&gt;&gt;&gt; Color(\"lab(200% -20 40 / 1)\").in_gamut()\nTrue\n</code></pre> Gamut: srgb <p>While checking CIELab's own gamut isn't very useful, we can test it against a different color space's gamut. By simply passing in the name of a different color space, the current color will be converted to the provided space and then will run <code>in_gamut</code> on the new color. You could do this manually, but using <code>in_gamut</code> in this manner can be very convenient. In the example below, we can see that the CIELab color of <code>lab(200% -20 40 / 1)</code> is outside the narrow gamut of sRGB.</p> <pre><code>&gt;&gt;&gt; Color(\"lab(200% -20 40 / 1)\").in_gamut('srgb')\nFalse\n</code></pre> Gamut: srgb"},{"location":"gamut/#tolerance","title":"Tolerance","text":"<p>Generally, ColorAide does not round off values in order to guarantee the best possible values for round tripping, but due to limitations of floating-point arithmetic and precision of conversion algorithms, there can be edge cases where colors don't round trip perfectly. By default, <code>in_gamut</code> allows for a tolerance of <code>0.000075</code> to account for such cases where a color is \"close enough\". If desired, this \"tolerance\" can be adjusted.</p> <p>Let's consider the oRGB color model. When converting from sRGB to oRGB, both of which share the same gamut, we can see that the conversion back is very, very close to being correct, but still technically out of gamut with one channel value falling below zero, but only slightly. This is due to the perils of floating point arithmetic.</p> <pre><code>&gt;&gt;&gt; Color('red').convert('orgb')[:]\n[0.299, 1.905283832848159e-05, 0.9999779995764854, 1.0]\n&gt;&gt;&gt; Color('red').convert('orgb').convert('srgb')[:]\n[1.0, 1.1102230246251565e-16, -1.3877787807814457e-16, 1.0]\n</code></pre> Gamut: srgb <p>When testing with a tolerance, the color is considered in gamut, but when testing with no tolerance (a tolerance of zero), the color is considered out of gamut. Depending on what you are doing, this may not be an issue up until you are ready to finalize the color as very close to in gamut is usually good enough, so sometimes it may be desirable to have some tolerance, and other times not.</p> <pre><code>&gt;&gt;&gt; Color('red').convert('orgb').convert('srgb')[:]\n[1.0, 1.1102230246251565e-16, -1.3877787807814457e-16, 1.0]\n&gt;&gt;&gt; Color('red').convert('orgb').convert('srgb').in_gamut()\nTrue\n&gt;&gt;&gt; Color('red').convert('orgb').convert('srgb').in_gamut(tolerance=0)\nFalse\n</code></pre> Gamut: srgb <p>Let's consider some color models that handle out of gamut colors in a less subtle way. HSL, HSV, and HWB are color models designed to represent an RGB color space in a cylindrical format, traditionally sRGB. Each of these spaces isolate different attributes of a color: saturation, whiteness, lightness, etc. Because these models are just representing the color space in a different way, they share the same gamut as the reference RGB color space. So it stands to reason that simply using the sRGB gamut check for them should be sufficient, and if we are using strict tolerance, this would be true.</p> <pre><code>&gt;&gt;&gt; Color('rgb(255 255 255)').in_gamut('srgb', tolerance=0)\nTrue\n&gt;&gt;&gt; Color('hsl(0 0% 100%)').in_gamut('srgb', tolerance=0)\nTrue\n&gt;&gt;&gt; Color('color(--hsv 0 0% 100%)').in_gamut('srgb', tolerance=0)\nTrue\n&gt;&gt;&gt; Color('rgb(255.05 255 255)').in_gamut('srgb', tolerance=0)\nFalse\n&gt;&gt;&gt; Color('hsl(0 0% 100.05%)').in_gamut('srgb', tolerance=0)\nFalse\n&gt;&gt;&gt; Color('color(--hsv 0 0% 100.05%)').in_gamut('srgb', tolerance=0)\nFalse\n</code></pre> Gamut: srgb <p>But when we are using a tolerance, and we check one of these models only using the sRGB gamut, there are some cases where these cylindrical colors can exhibit coordinates wildly outside of the model's range but still very close to the sRGB gamut. This isn't an error or a bug, but simply how the color model behaves with out of gamut colors. These values can still convert right back to the original color, but this might not always be the case with all color models.</p> <p>In this example, we have an sRGB color that is extremely close to being in gamut, but when we convert it to HSL, we can see wildly large saturation. But since it round trips back to sRGB just fine, it can exhibit extreme saturation, but can still be considered in the sRGB gamut.</p> <pre><code>&gt;&gt;&gt; hsl = Color('color(srgb 0.999999 1.000002 0.999999)').convert('hsl')\n&gt;&gt;&gt; hsl\ncolor(--hsl none 3 1 / 1)\n&gt;&gt;&gt; hsl.in_gamut('srgb')\nTrue\n</code></pre> Gamut: srgb <p>This happens because these cylindrical color models do not represent out of gamut colors in a very sane way. When lightness exceeds the SDR range of 0 - 1 (or <code>0 - 100%</code> as people generally associate HSL), they can return extremely high saturation. So even a slightly out of gamut sRGB color could translate to a value way outside the cylindrical color model's boundaries.</p> <p>For this reason, gamut checks in the HSL, HSV, and HWB models apply tolerance checks on the color's coordinates in the sRGB color space and the respective cylindrical model ensuring we have coordinates that are close to the color's actual gamut and reasonably close to the cylindrical model's constraints as well. But if we specifically request <code>srgb</code>, we will see that only <code>srgb</code> is referenced.</p> <pre><code>&gt;&gt;&gt; hsl = Color('color(srgb 0.999999 1.000002 0.999999)').convert('hsl')\n&gt;&gt;&gt; hsl\ncolor(--hsl none 3 1 / 1)\n&gt;&gt;&gt; hsl.in_gamut()\nFalse\n&gt;&gt;&gt; hsl.in_gamut('hsl')\nFalse\n&gt;&gt;&gt; hsl.in_gamut('srgb')\nTrue\n</code></pre> Gamut: srgb <p>In short, ColorAide will figure out what best to test unless you explicitly tell it to use something else. If the Cartesian check is the only desired check, and the strange cylindrical values that are returned are not a problem, <code>srgb</code> can always be specified. <code>tolerance=0</code> can also be used to constrain the check to values exactly in the gamut.</p> <p>HSL has a very tight conversion to and from sRGB, so when an sRGB color is precisely in gamut, it will remain in gamut throughout the conversion to and from HSL, both forwards and backwards. On the other hand, there may be color models that have a looser conversion algorithm. There may even be cases where it may be beneficial to increase the threshold.</p>"},{"location":"gamut/#gamut-mapping-colors","title":"Gamut Mapping Colors","text":"<p>Gamut mapping is the process of taking a color that is out of gamut and adjusting it in such a way that it fits within the gamut. Essentially, gamut mapping takes a color that is out of gamut and maps it to some place on the target gamut that makes sense.</p> <p></p> <p>There are various ways to map or compress values of an out of bound color to an in bound color, each with their own pros and cons. ColorAide offers a couple of methods related to gamut mapping: <code>clip()</code> and <code>fit()</code>. <code>clip()</code> is a dedicated function that performs the speedy, yet naive, approach of simply truncating a color channel's value to fit within the specified gamut, and <code>fit()</code> is a method that allows using more advanced gamut mapping approaches that, while often not as performant and simple as naive clipping, generally yield much better results in certain contexts.</p> <p>While clipping won't always yield the most perceptually correct results, it can be a useful way get a color back into gamut. There may be better approaches, but clipping is still very important and can be used to trim channel noise after certain mathematical operations or even used in other gamut mapping algorithms if used carefully. For this reason, clip has its own dedicated method for quick access: <code>clip()</code>.</p> <pre><code>&gt;&gt;&gt; Color('rgb(270 30 120)').clip()\ncolor(srgb 1 0.11765 0.47059 / 1)\n</code></pre> Gamut: srgb <p>The <code>fit()</code> method, is the generic gamut mapping method that exposes access to all the different gamut mapping methods available. By default, <code>fit()</code> uses a more advanced method of gamut mapping that tries to preserve hue and lightness, hue being the attribute the human eye is most sensitive to. If desired, a user can also specify any currently registered gamut mapping algorithm via the <code>method</code> parameter.</p> <pre><code>&gt;&gt;&gt; Color('rgb(270 30 120)').fit()\ncolor(srgb 1 0.18296 0.47421 / 1)\n&gt;&gt;&gt; Color('rgb(270 30 120)').fit(method='clip')\ncolor(srgb 1 0.11765 0.47059 / 1)\n</code></pre> Gamut: srgb <p>Gamut mapping can also be used to indirectly fit colors in another gamut. For instance, fitting a Display P3 color into an sRGB gamut.</p> <pre><code>&gt;&gt;&gt; c1 = Color('color(display-p3 1 1 0)')\n&gt;&gt;&gt; c1.in_gamut('srgb')\nFalse\n&gt;&gt;&gt; c1.fit('srgb')\ncolor(display-p3 0.9986 0.99232 0.32855 / 1)\n&gt;&gt;&gt; c1.in_gamut()\nTrue\n</code></pre> Gamut: srgb <p>This can also be done with <code>clip()</code>.</p> <pre><code>&gt;&gt;&gt; Color('color(display-p3 1 1 0)').clip('srgb')\ncolor(display-p3 1 1 0.3309 / 1)\n</code></pre> Gamut: srgb <p>Indirectly Gamut Mapping a Color Space</p> <p>When indirectly gamut mapping in another color space, results may vary depending on what color space you are in and what color space you are using to fit the color. The operation may not get the color precisely in gamut. This is because we must convert the color to the gamut mapping space, apply the gamut mapping, and then convert it back to the original color. The process will be subject to any errors that occur in the round trip to and from the targeted space. This is mainly mentioned as fitting in one color space and round tripping back may not give exact results and, in some cases, exceed \"in gamut\" thresholds.</p> <p>There are actually many different ways to gamut map a color. Some are computationally expensive, some are quite simple, and many do really good in some cases and not so well in others. There is probably no perfect gamut mapping method, but some are better than others.</p>"},{"location":"gamut/#clip","title":"Clip","text":"<p>The <code>clip</code> gamut mapping is registered in <code>Color</code> by default and cannot be unregistered</p> <p>Clipping is a simple and naive approach to gamut mapping. If the color space is bounded by a gamut, clip will compare each channel's value against the bounds for that channel and set the value to the limit it exceeds.</p> <p>Clip can be performed via <code>fit</code> by using the method name <code>clip</code> or by using the <code>clip()</code> method.</p> <pre><code>&gt;&gt;&gt; c = Color('srgb', [2, 1, 1.5])\n&gt;&gt;&gt; c.fit(method='clip')\ncolor(srgb 1 1 1 / 1)\n&gt;&gt;&gt; c = Color('srgb', [2, 1, 1.5])\n&gt;&gt;&gt; c.clip()\ncolor(srgb 1 1 1 / 1)\n</code></pre> Gamut: srgb <p>Clipping is unique to all other clipping methods in that it has its own dedicated method <code>clip()</code> method and that its method name <code>clip</code> is reserved. While not always the best approach for all gamut mapping needs in general, clip is very important and its speed and simplicity are of great value.</p>"},{"location":"gamut/#minde-chroma-reduction","title":"MINDE Chroma Reduction","text":"<p>Chroma reduction is an approach that reduces the chroma in a polar color space until the color is within the gamut of a targeted color space. Pure chroma reduction has the advantage of preserving as much lightness and hue as possible, and when performed within a perceptual space, it can preserve perceptual hue and lightness, but it comes at the cost of colorfulness/chroma. Pure chroma reduction may not always be desirable when gamut mapping images as some colorfulness will be lost.</p> <p>MINDE is an approach that tries to find the in gamut color with the shortest distance to out of gamut color. This can be better at finding an in gamut color with closer colorfulness but often comes at the cost of larger hue shifts and variances in lightness.</p> <p>Combining both chroma reduction and something similar to MINDE can allow you to reduce the chroma of a color, but along the way, if there is a color near the chroma reduction path below the \"just noticeable difference\" (JND) in color distance, it can be returned early.</p> <p>The way this works is as follows. A given out of gamut color will have its chroma reduced via bisection to bring the color into gamut. In addition, local clipping will be applied at each step and the distance between that clipped color and the chroma reduced color will be compared. If the distance between the clipped and chroma reduced color is close enough to the JND, the clipped color will be returned.</p> <p>Visually, MINDE chroma reduction will allow a color that has decent constant lightness and will allow some hue shift as long as it is under what is noticeable by the eye. This doesn't mean no hue shift, and in certain regions, such as very dark colors or very light colors, hue shift can be greater because it is more difficult to notice in such lightness ranges. Every perceptual space is different and some do better than others and may allow for a larger or smaller JND limits, so the JND is relative to the color space and the \u2206E color distancing algorithm used.</p> <p>Preserving lightness in this way is useful when creating tones or mixing and interpolating colors. A constant lightness can also be useful when trying to control contrast.</p> <p>Computationally, chroma reduction is slower to compute than clipping. Chroma reduction by bisecting can have varying performance as it is unknown how many iterations will be required to reduce the color into the gamut. Additionally, by combining the reduction with MINDE, the algorithm takes additional performance hits has it must now perform costly color distancing checks. Using a perceptual space with more uniform color distancing can reducing the complexity required to determine the color distance and, in turn, can speed up the process.</p> <p>Lastly, all provided MINDE chroma reduction methods allow the controlling of the JND. This is useful if you want to adjust how close to the gamut boundary you approach before clipping. A larger JND may provide even more colorful colors while a lower JND will provide more accurate colors (relative to the perceptual space). If desired, setting the JND to 0 can improve performance by bypassing the MINDE logic altogether, but keep in mind that some perceptual spaces can have a geometry that can cause overly under-saturated colors just due to how the colors are distributed in the color space.</p> <p>Consider the color <code>color(display-p3 1 1 0)</code>. If we were to gamut map it in CIELCh with a very low JND, we can see that the odd shape of CIELCh in the yellow region can cause us to get a very desaturated color. By using the default JND of 2 for CIELCh, the MINDE logic will catch a more saturated yellow before it reduces chroma all the way to the gamut surface. Such geometric quirks aren't present in all color spaces, so in a space like OkLCh, it will have a less noticeable difference.</p> JND 0JND 2 <p></p> <p></p> <p>As a final note, it should be noted that most color spaces that have a defined gamut are tied to specific RGB gamuts. And when they are gamut mapped, they are done so in those RGB spaces. For instance, HSL which represents the sRGB gamut in a cylindrical form will be gamut mapped in sRGB (though simple clipping may be done directly in HSL).</p> <p>There are a few color spaces/models that do not have a clearly defined gamuts. One such case is HPLuv, which is only defined as a cylindrical color space that represent only a subset of the sRGB color space. Additionally Okhsl and Okhsv are two cylindrical color spaces based on the perceptual Oklab color space that are meant to target the sRGB gamut, but are only a loose approximation which can actually slightly clip the sRGB gamut while simultaneously containing a few colors that exceed the sRGB gamut. ColorAide will not automatically associate these color spaces with an RGB gamut. In the case of HPLuv, there is no specifically defined RGB gamut, and in the case of Okhsl and Okhsv, sRGB is the closest, but does not precisely represent the colors in Okhsl and Okhsv.</p> <p>Gamut mapping in HPLuv usually provides fine results, but you may find that gamut mapping Okhsl may not provide the intended results. When gamut mapping such spaces, you may want to use the closest RGB gamut.</p> <pre><code>&gt;&gt;&gt; Steps([c.fit('okhsl', method='oklch-chroma') for c in Color.steps(['oklch(90% 0.4 0)', 'oklch(90% 0.4 360)'], steps=100, space='oklch', hue='longer')])\n[color(--oklch 0.9 0.03085 0 / 1), color(--oklch 0.9 0.03372 3.6364 / 1), color(--oklch 0.9 0.03428 7.2727 / 1), color(--oklch 0.9 0.03333 10.909 / 1), color(--oklch 0.9 0.03093 14.545 / 1), color(--oklch 0.9 0.02652 18.182 / 1), color(--oklch 0.9 0.01818 21.818 / 1), color(--oklch 0.9 0.00125 205.45 / 1), color(--oklch 0.9 0.08837 209.09 / 1), color(--oklch 0.9 0.00249 32.727 / 1), color(--oklch 0.9 0.01967 36.364 / 1), color(--oklch 0.9 0.02693 40 / 1), color(--oklch 0.9 0.03129 43.636 / 1), color(--oklch 0.9 0.03452 47.273 / 1), color(--oklch 0.9 0.03733 50.909 / 1), color(--oklch 0.9 0.04004 54.545 / 1), color(--oklch 0.9 0.04282 58.182 / 1), color(--oklch 0.9 0.04576 61.818 / 1), color(--oklch 0.9 0.04888 65.455 / 1), color(--oklch 0.9 0.05211 69.091 / 1), color(--oklch 0.9 0.05531 72.727 / 1), color(--oklch 0.9 0.0581 76.364 / 1), color(--oklch 0.9 0.05966 80 / 1), color(--oklch 0.9 0.05812 83.636 / 1), color(--oklch 0.9 0.04843 87.273 / 1), color(--oklch 0.9 0.01209 90.909 / 1), color(--oklch 0.9 0.15515 94.545 / 1), color(--oklch 0.9 0.1861 98.182 / 1), color(--oklch 0.9 0.18832 101.82 / 1), color(--oklch 0.9 0.19138 105.45 / 1), color(--oklch 0.9 0.01909 289.09 / 1), color(--oklch 0.9 0.03162 292.73 / 1), color(--oklch 0.9 0.02113 296.36 / 1), color(--oklch 0.9 0.03591 300 / 1), color(--oklch 0.9 0.22247 123.64 / 1), color(--oklch 0.9 0.23299 127.27 / 1), color(--oklch 0.9 0.2456 130.91 / 1), color(--oklch 0.9 0.24384 134.55 / 1), color(--oklch 0.9 0.22238 138.18 / 1), color(--oklch 0.9 0.20619 141.82 / 1), color(--oklch 0.9 0.19362 145.45 / 1), color(--oklch 0.9 0.03067 329.09 / 1), color(--oklch 0.9 0.00536 152.73 / 1), color(--oklch 0.9 0.0202 156.36 / 1), color(--oklch 0.9 0.02441 160 / 1), color(--oklch 0.9 0.02118 163.64 / 1), color(--oklch 0.9 0.01041 167.27 / 1), color(--oklch 0.9 0.01147 350.91 / 1), color(--oklch 0.9 0.05689 354.55 / 1), color(--oklch 0.9 0.15497 178.18 / 1), color(--oklch 0.9 0.1556 181.82 / 1), color(--oklch 0.9 0.15708 185.45 / 1), color(--oklch 0.9 0.15589 189.09 / 1), color(--oklch 0.9 0.15425 192.73 / 1), color(--oklch 0.9 0.15008 196.36 / 1), color(--oklch 0.9 0.12658 200 / 1), color(--oklch 0.9 0.10983 203.64 / 1), color(--oklch 0.9 0.01686 27.273 / 1), color(--oklch 0.9 0.0287 210.91 / 1), color(--oklch 0.9 0.04084 214.55 / 1), color(--oklch 0.9 0.04427 218.18 / 1), color(--oklch 0.9 0.04441 221.82 / 1), color(--oklch 0.9 0.0431 225.45 / 1), color(--oklch 0.9 0.04112 229.09 / 1), color(--oklch 0.9 0.03883 232.73 / 1), color(--oklch 0.9 0.03641 236.36 / 1), color(--oklch 0.9 0.03393 240 / 1), color(--oklch 0.9 0.03138 243.64 / 1), color(--oklch 0.9 0.02866 247.27 / 1), color(--oklch 0.9 0.02552 250.91 / 1), color(--oklch 0.9 0.0212 254.55 / 1), color(--oklch 0.9 0.01317 258.18 / 1), color(--oklch 0.9 0.01887 81.818 / 1), color(--oklch 0.9 0.04813 265.45 / 1), color(--oklch 0.9 0.04811 269.09 / 1), color(--oklch 0.9 0.0831 92.727 / 1), color(--oklch 0.9 0.00036 276.36 / 1), color(--oklch 0.9 0.01827 280 / 1), color(--oklch 0.9 0.02615 283.64 / 1), color(--oklch 0.9 0.03053 287.27 / 1), color(--oklch 0.9 0.0331 290.91 / 1), color(--oklch 0.9 0.03429 294.55 / 1), color(--oklch 0.9 0.03388 298.18 / 1), color(--oklch 0.9 0.03076 301.82 / 1), color(--oklch 0.9 0.02106 305.45 / 1), color(--oklch 0.9 0.01717 129.09 / 1), color(--oklch 0.9 0.06811 312.73 / 1), color(--oklch 0.9 0.07289 316.36 / 1), color(--oklch 0.9 0.07874 320 / 1), color(--oklch 0.9 0.08599 323.64 / 1), color(--oklch 0.9 0.09033 327.27 / 1), color(--oklch 0.9 0.08316 330.91 / 1), color(--oklch 0.9 0.07729 334.55 / 1), color(--oklch 0.9 0.07245 338.18 / 1), color(--oklch 0.9 0.06842 341.82 / 1), color(--oklch 0.9 0.06506 345.45 / 1), color(--oklch 0.9 0.0235 169.09 / 1), color(--oklch 0.9 0.00322 172.73 / 1), color(--oklch 0.9 0.02296 356.36 / 1), color(--oklch 0.9 0.03085 0 / 1)]\n&gt;&gt;&gt; Steps([c.fit('srgb', method='oklch-chroma') for c in Color.steps(['oklch(90% 0.4 0)', 'oklch(90% 0.4 360)'], steps=100, space='oklch', hue='longer')])\n[color(--oklch 0.88717 0.06673 355.33 / 1), color(--oklch 0.88718 0.06441 359.67 / 1), color(--oklch 0.88719 0.06255 4.0928 / 1), color(--oklch 0.88718 0.06113 8.5912 / 1), color(--oklch 0.88719 0.06011 13.152 / 1), color(--oklch 0.88715 0.05951 17.75 / 1), color(--oklch 0.88717 0.05925 22.369 / 1), color(--oklch 0.88713 0.05941 26.987 / 1), color(--oklch 0.88715 0.05991 31.574 / 1), color(--oklch 0.88713 0.06083 36.121 / 1), color(--oklch 0.88716 0.0621 40.588 / 1), color(--oklch 0.88717 0.06379 44.978 / 1), color(--oklch 0.88716 0.06593 49.278 / 1), color(--oklch 0.88715 0.06854 53.473 / 1), color(--oklch 0.88712 0.07167 57.565 / 1), color(--oklch 0.88715 0.07531 61.519 / 1), color(--oklch 0.88713 0.07964 65.378 / 1), color(--oklch 0.88712 0.08471 69.122 / 1), color(--oklch 0.88712 0.09063 72.748 / 1), color(--oklch 0.88713 0.09758 76.267 / 1), color(--oklch 0.88713 0.10584 79.694 / 1), color(--oklch 0.88717 0.11564 83.019 / 1), color(--oklch 0.88715 0.12763 86.283 / 1), color(--oklch 0.88719 0.14226 89.462 / 1), color(--oklch 0.88719 0.16071 92.59 / 1), color(--oklch 0.88726 0.18232 95.438 / 1), color(--oklch 0.89218 0.18372 96.494 / 1), color(--oklch 0.8987 0.18567 97.858 / 1), color(--oklch 0.90192 0.18793 100.67 / 1), color(--oklch 0.90192 0.19107 104.69 / 1), color(--oklch 0.90193 0.19529 108.7 / 1), color(--oklch 0.90192 0.20068 112.7 / 1), color(--oklch 0.90192 0.20737 116.68 / 1), color(--oklch 0.90193 0.21554 120.62 / 1), color(--oklch 0.90194 0.22539 124.54 / 1), color(--oklch 0.90194 0.23722 128.42 / 1), color(--oklch 0.90194 0.25142 132.26 / 1), color(--oklch 0.89219 0.26266 135.44 / 1), color(--oklch 0.88263 0.27371 138.18 / 1), color(--oklch 0.88175 0.25494 141.76 / 1), color(--oklch 0.88189 0.23689 145.66 / 1), color(--oklch 0.88209 0.22286 149.58 / 1), color(--oklch 0.88221 0.21214 153.5 / 1), color(--oklch 0.88229 0.20391 157.42 / 1), color(--oklch 0.88313 0.19644 161.07 / 1), color(--oklch 0.88558 0.18764 164.42 / 1), color(--oklch 0.88805 0.17994 167.95 / 1), color(--oklch 0.8905 0.17342 171.57 / 1), color(--oklch 0.89291 0.168 175.25 / 1), color(--oklch 0.8953 0.1636 178.96 / 1), color(--oklch 0.89767 0.16015 182.69 / 1), color(--oklch 0.90003 0.15756 186.42 / 1), color(--oklch 0.90238 0.15577 190.11 / 1), color(--oklch 0.90473 0.15472 193.75 / 1), color(--oklch 0.9054 0.15455 194.77 / 1), color(--oklch 0.90357 0.15414 195.17 / 1), color(--oklch 0.89711 0.15276 196.59 / 1), color(--oklch 0.89505 0.13708 199.31 / 1), color(--oklch 0.89504 0.12221 202.11 / 1), color(--oklch 0.89502 0.11028 204.96 / 1), color(--oklch 0.89502 0.10034 207.93 / 1), color(--oklch 0.895 0.09216 210.95 / 1), color(--oklch 0.89499 0.08517 214.1 / 1), color(--oklch 0.89499 0.07918 217.37 / 1), color(--oklch 0.89499 0.07401 220.78 / 1), color(--oklch 0.89499 0.06955 224.33 / 1), color(--oklch 0.89499 0.06569 228.03 / 1), color(--oklch 0.89498 0.06237 231.88 / 1), color(--oklch 0.89499 0.05949 235.92 / 1), color(--oklch 0.89497 0.05709 240.08 / 1), color(--oklch 0.89498 0.05504 244.48 / 1), color(--oklch 0.89498 0.05341 249.01 / 1), color(--oklch 0.89497 0.05215 253.7 / 1), color(--oklch 0.89497 0.05126 258.51 / 1), color(--oklch 0.89496 0.05075 263.44 / 1), color(--oklch 0.89495 0.05063 268.45 / 1), color(--oklch 0.89496 0.05088 273.51 / 1), color(--oklch 0.89495 0.05156 278.57 / 1), color(--oklch 0.89494 0.05266 283.61 / 1), color(--oklch 0.89494 0.0542 288.57 / 1), color(--oklch 0.89494 0.05623 293.44 / 1), color(--oklch 0.89493 0.0588 298.19 / 1), color(--oklch 0.89493 0.06192 302.78 / 1), color(--oklch 0.89492 0.0657 307.21 / 1), color(--oklch 0.89491 0.07022 311.49 / 1), color(--oklch 0.89492 0.07558 315.56 / 1), color(--oklch 0.8949 0.08201 319.49 / 1), color(--oklch 0.8949 0.0897 323.25 / 1), color(--oklch 0.89413 0.09833 326.36 / 1), color(--oklch 0.88972 0.10274 326.4 / 1), color(--oklch 0.88709 0.10539 326.42 / 1), color(--oklch 0.8866 0.10588 326.42 / 1), color(--oklch 0.8873 0.10102 328.09 / 1), color(--oklch 0.88727 0.09341 331.65 / 1), color(--oklch 0.88723 0.087 335.3 / 1), color(--oklch 0.88726 0.08147 339.1 / 1), color(--oklch 0.88723 0.07682 342.98 / 1), color(--oklch 0.88724 0.07284 347 / 1), color(--oklch 0.88718 0.06954 351.1 / 1), color(--oklch 0.88717 0.06673 355.33 / 1)]\n</code></pre> Gamut: srgb"},{"location":"gamut/#lch-chroma","title":"LCh Chroma","text":"<p>The <code>lch-chroma</code> gamut mapping is registered in <code>Color</code> by default</p> <p>LCh Chroma applies MINDE Chroma Reduction within the CIELCh color space and is currently the default approach in ColorAide.</p> <p>Note</p> <p>As most colors in ColorAide use a D65 white point by default, LCh D65 is used as the gamut mapping color space.</p> <p>CIELCh, is not necessarily the best perceptual color space available, but it is a generally well understood color space that has been available a long time. It does suffer from a purple shift when dealing with blue colors, but can generally handle colors in very wide gamuts reasonably due to its fairly consistent shape well past the spectral locus.</p> <p>CSS originally proposed MINDE Chroma Reduction with CIELCh, but has later changed to OkLCh. It is possible that the entire choice in algorithms could change as well in the future. We do offer an OkLCh variant, but we currently still use CIELCh due to its consistency even with colors far outside the gamut. If you are working within reasonable gamuts, OkLCh may be a better choice.</p> <p>LCh Chroma is the default gamut mapping algorithm unless otherwise changed, and can be performed by simply calling <code>fit()</code> or by calling <code>fit(method='lch-chroma')</code>.</p> <pre><code>&gt;&gt;&gt; c = Color('srgb', [2, -1, 0])\n&gt;&gt;&gt; c.fit(method='lch-chroma')\ncolor(srgb 1 0.39658 0.38511 / 1)\n</code></pre> Gamut: srgb <p>Additionally, the JND target can be controlled for tighter or looser gamut mapping via the <code>jnd</code> option. The default is <code>2</code>.</p> <pre><code>&gt;&gt;&gt; c = Color('srgb', [2, -1, 0])\n&gt;&gt;&gt; c.fit(method='lch-chroma', jnd=0.2)\ncolor(srgb 1 0.4342 0.41183 / 1)\n</code></pre> Gamut: srgb"},{"location":"gamut/#oklch-chroma","title":"OkLCh Chroma","text":"<p>The <code>lch-chroma</code> gamut mapping is registered in <code>Color</code> by default</p> <p>The CSS Color Level 4 specification currently recommends using the perceptually uniform OkLCh color space with the MINDE Chroma Reduction approach.</p> <p>OkLCh does a much better job holding hues constant. When combined with gamut mapping, it generally does a better job than CIELCh, but it does have limitations. When colors get near the edge of the visible spectrum, the shape of the color space distorts, and gamut mapping will not be as good. But if you are working within reasonable gamuts, it may be an excellent option.</p> <pre><code>&gt;&gt;&gt; c = Color('srgb', [2, -1, 0])\n&gt;&gt;&gt; c.fit(method='oklch-chroma')\ncolor(srgb 1 0.60354 0.66617 / 1)\n</code></pre> Gamut: srgb <p>Additionally, the JND target can be controlled for tighter or looser gamut mapping via the <code>jnd</code> option. The default is <code>0.02</code>.</p> <pre><code>&gt;&gt;&gt; c = Color('srgb', [2, -1, 0])\n&gt;&gt;&gt; c.fit(method='oklch-chroma', jnd=0.002)\ncolor(srgb 1 0.63219 0.68048 / 1)\n</code></pre> Gamut: srgb"},{"location":"gamut/#hct-chroma","title":"HCT Chroma","text":"<p>The <code>hct-chroma</code> gamut mapping is not registered in <code>Color</code> by default</p> <p>Warning</p> <p>This approach was specifically added to help produce tonal palettes, but with the recent addition of the ray trace approach to chroma reduction in any perceptual space, it is recommended that users apply that approach as it performs a tight chroma reduction much quicker, and it doesn't require a special \u2206E method.</p> <p>On occasions, MINDE approach can be slightly more accurate very close to white due to the way ray trace handles HCT's atypical achromatic response, but differences should be imperceptible to the eye at such lightness levels making the improved performance of the ray trace approach much more desirable.</p> <pre><code>&gt;&gt;&gt; c = Color('hct', [325, 24, 50])\n&gt;&gt;&gt; tones = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 95, 100]\n&gt;&gt;&gt; Steps([c.clone().set('tone', tone).convert('srgb').to_string(hex=True, fit={'method': 'raytrace', 'pspace': 'hct'}) for tone in tones])\n['#000000', '#29132e', '#3f2844', '#573e5b', '#705574', '#8a6d8d', '#a587a8', '#c1a1c3', '#debcdf', '#fbd7fc', '#ffebfd', '#ffffff']\n</code></pre> Gamut: srgb <p>If more accuracy in HCT's atypical achromatic region is desired, the MINDE approach is available.</p> <p>Much like the other LCh chroma reduction algorithms, HCT Chroma performs gamut mapping exactly like LCh Chroma with the exception that it uses the HCT color space as the working LCh color space.</p> <p>Google's Material Design uses a new color space called HCT. It uses the hue and chroma from CAM16 space and the tone/lightness from the CIELab space. HCT takes advantage of the good hue preservation of CAM16 and has the better lightness predictability of CIELab. Using these characteristics, the color space is adept at generating tonal palettes with predictable lightness. This makes it easier to construct UIs with decent contrast. But to do this well, you must work in HCT and gamut map in HCT. For this reason, the HCT Chroma gamut mapping method was added.</p> <p>HCT Chroma is computationally the most expensive gamut mapping method that is offered. Since the color space used is based on the already computationally expensive CAM16 color space, and is made more expensive by blending that color space with CIELab, it is not the most performant approach, but when used in conjunction with the HCT color space, it can allow creating good tonal palettes:</p> <pre><code>&gt;&gt;&gt; c = Color('hct', [325, 24, 50])\n&gt;&gt;&gt; tones = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 95, 100]\n&gt;&gt;&gt; Steps([c.clone().set('tone', tone).convert('srgb').to_string(hex=True, fit={'method': 'hct-chroma', 'jnd': 0.0}) for tone in tones])\n['#000000', '#29132e', '#3f2844', '#573e5b', '#705574', '#8a6d8d', '#a587a8', '#c1a1c3', '#debcdf', '#fbd7fc', '#ffebfd', '#ffffff']\n</code></pre> Gamut: srgb <p>As shown above, the JND target can be controlled for tighter or looser gamut mapping via the <code>jnd</code> option. The default is <code>2</code>, but to get tonal palette results comparable to Google Material, we are using <code>0.0</code>.</p> <p>To HCT Chroma plugin is not registered by default, but can be added by subclassing <code>Color</code>. You must register the \u2206E<sub>hct</sub> distancing algorithm and the HCT color space as well.</p> <pre><code>from coloraide import Color as Base\nfrom coloraide.gamut.fit_hct_chroma import HCTChroma\nfrom coloraide.distance.delta_e_hct import DEHCT\nfrom coloraide.spaces.hct import HCT\n\nclass Color(Base): ...\n\nColor.register([HCT(), DEHCT(), HCTChroma()])\n</code></pre>"},{"location":"gamut/#ray-tracing-chroma-reduction","title":"Ray Tracing Chroma Reduction","text":"<p>Experimental Gamut Mapping</p> <p>New in 4.0</p> <p>The default perceptual space is now OkLCh.</p> <p>Please see Gamut Mapping in Any Perceptual Space to learn how to use different perceptual spaces and how to set your own default.</p> <p>ColorAide has developed a chroma reduction technique that employs ray tracing. Its aim is to provide faster chrome reduction for gamut mapping using constant lightness. This approach specifically targets RGB gamuts, or spaces that can be represented with RGB gamuts. Additionally, if ColorAide can detect a linear version of the targeted RGB gamut, that version will be used automatically for best results. Currently ColorAide can gamut map all officially supported color spaces as they either have an RGB gamut or can be coerced into one.</p> <p>The ray trace approach works by taking a given color and converting it to a perceptual Lab-ish or LCh-ish color space (the default being OkLCh) and then calculates the achromatic version of the color (chroma set to zero) which will be our anchor point. Assuming our anchor point is within bounds, a ray is cast from the inside of the cube, from the anchor point to the current color. The intersection along this path with the RGB gamut surface is then found.  If the achromatic color exceeds the maximum or minimum lightness of the gamut, the respective maximum or minimum achromatic color is returned. </p> <p>Ray Trace Algorithm</p> <p>The ray trace algorithm is based on the slab method. The intersection that is selected is the first one encountered when following the ray from the origin point in the direction of the specified end point.</p> <p>The intersection of the line and the gamut surface represents an approximation of the most saturated color for that lightness and hue, but because the RGB space is not perceptual, the initial approximation is likely to be off because decreasing chroma and holding lightness and hue constant in a perceptual space will create a curved path through the RGB space. In order to converge on a point as close as possible to the actual most saturated color with the given hue and lightness, we must refine our result with a few additional iterations.</p> <p>In order to converge on the actual chroma reduced color we seek, we can take the first intersection we find and correct the color in the perceptual color space by projecting the point back onto the chroma reduction path, correcting the color's hue and lightness. The corrected color becomes our new current color and should be a much closer color on the reduced chroma line. We can repeat this process a few more times, each time finding a better, closer color on the path. After about three additional iterations (a combined total of four for the entire process), we will be close enough where we can stop. Finally, we can then clip off floating point math errors. With this, we will now have a more accurate approximation of the color we seek.</p> <p></p> <p>One final improvement is that during the correction step, where we adjust surface point back onto the chroma reduction path, if we find a point below the gamut surface, we can adjust our anchor to be this new point, closer to the gamut surface, which in some spaces will help to converge closer to our ideal color than they would without the adjustment.</p> <p></p> <p>The results are comparable to MINDE using a low JND, but resolves much faster and within more predictable, consistent time.</p> <pre><code>&gt;&gt;&gt; Color('oklch(90% 0.8 270)').fit('srgb', method='raytrace', pspace='lch-d65')\ncolor(--oklch 0.76773 0.15855 309.37 / 1)\n&gt;&gt;&gt; Color('oklch(90% 0.8 270)').fit('srgb', method='lch-chroma', jnd=0)\ncolor(--oklch 0.76773 0.15855 309.37 / 1)\n</code></pre> Gamut: srgb <p>As noted earlier, this method specifically targets RGB gamuts. This is because the ray tracing is performed on a simple RGB cube which is easy to calculate. ColorAide maps almost all colors to an RGB gamut, if they have one. And those gamuts are often associated with a linear RGB counterpart which is preferred when gamut mapping, but there are a few color spaces/models that do not map to an obvious RGB gamut.</p> <p>HPLuv, which is only defined as a cylindrical color space that represent only a subset of the sRGB color space, has no defined RGB gamut on which to operate on. Additionally Okhsl and Okhsv are two cylindrical color spaces, based on the perceptual Oklab color space, that are meant to target the sRGB gamut, but are only a loose approximation which actually can slightly clip the sRGB gamut while simultaneously containing a few colors that exceed the sRGB gamut. ColorAide will not automatically associate these color spaces with an RGB gamut as their is not one that precisely represent the colors in Okhsl and Okhsv.</p> <p>With that said, ColorAide will translate these spaces into a cube shape to apply gamut mapping on them if they are specifically used. In the case of HPLuv, results are usually fine, but you may find that gamut mapping Okhsl may not provide the intended results. It should be noted that the currently suggested CSS gamut mapping algorithm (<code>oklch-chroma</code>) does not do much better, so, for Okhsl and Okhsv, it is better to use the closest RGB gamut.</p> <pre><code>&gt;&gt;&gt; Steps([c.fit('okhsl', method='raytrace') for c in Color.steps(['oklch(90% 0.4 0)', 'oklch(90% 0.4 360)'], steps=100, space='oklch', hue='longer')])\n[color(--oklch 0.9 0.03085 0 / 1), color(--oklch 0.9 0.03372 3.6364 / 1), color(--oklch 0.9 0.03428 7.2727 / 1), color(--oklch 0.9 0.03333 10.909 / 1), color(--oklch 0.9 0.03093 14.545 / 1), color(--oklch 0.9 0.02652 18.182 / 1), color(--oklch 0.9 0.01818 21.818 / 1), color(--oklch 0.9 0.00125 205.45 / 1), color(--oklch 0.9 0.08837 209.09 / 1), color(--oklch 0.9 0.00249 32.727 / 1), color(--oklch 0.9 0.01967 36.364 / 1), color(--oklch 0.9 0.02693 40 / 1), color(--oklch 0.9 0.03129 43.636 / 1), color(--oklch 0.9 0.03452 47.273 / 1), color(--oklch 0.9 0.03733 50.909 / 1), color(--oklch 0.9 0.04004 54.545 / 1), color(--oklch 0.9 0.04282 58.182 / 1), color(--oklch 0.9 0.04576 61.818 / 1), color(--oklch 0.9 0.04888 65.455 / 1), color(--oklch 0.9 0.05211 69.091 / 1), color(--oklch 0.9 0.05531 72.727 / 1), color(--oklch 0.9 0.0581 76.364 / 1), color(--oklch 0.9 0.05966 80 / 1), color(--oklch 0.9 0.05812 83.636 / 1), color(--oklch 0.9 0.04843 87.273 / 1), color(--oklch 0.9 0.01209 90.909 / 1), color(--oklch 0.9 0.15515 94.545 / 1), color(--oklch 0.9 0.1861 98.182 / 1), color(--oklch 0.9 0.18832 101.82 / 1), color(--oklch 0.9 0.19138 105.45 / 1), color(--oklch 0.9 0.01909 289.09 / 1), color(--oklch 0.9 0.03162 292.73 / 1), color(--oklch 0.9 0.02113 296.36 / 1), color(--oklch 0.9 0.03591 300 / 1), color(--oklch 0.9 0.22247 123.64 / 1), color(--oklch 0.9 0.23299 127.27 / 1), color(--oklch 0.9 0.2456 130.91 / 1), color(--oklch 0.9 0.24384 134.55 / 1), color(--oklch 0.9 0.22238 138.18 / 1), color(--oklch 0.9 0.20619 141.82 / 1), color(--oklch 0.9 0.19362 145.45 / 1), color(--oklch 0.9 0.03067 329.09 / 1), color(--oklch 0.9 0.00536 152.73 / 1), color(--oklch 0.9 0.0202 156.36 / 1), color(--oklch 0.9 0.02441 160 / 1), color(--oklch 0.9 0.02118 163.64 / 1), color(--oklch 0.9 0.01041 167.27 / 1), color(--oklch 0.9 0.01147 350.91 / 1), color(--oklch 0.9 0.05689 354.55 / 1), color(--oklch 0.9 0.15497 178.18 / 1), color(--oklch 0.9 0.1556 181.82 / 1), color(--oklch 0.9 0.15708 185.45 / 1), color(--oklch 0.9 0.15589 189.09 / 1), color(--oklch 0.9 0.15425 192.73 / 1), color(--oklch 0.9 0.15008 196.36 / 1), color(--oklch 0.9 0.12658 200 / 1), color(--oklch 0.9 0.10983 203.64 / 1), color(--oklch 0.9 0.01686 27.273 / 1), color(--oklch 0.9 0.0287 210.91 / 1), color(--oklch 0.9 0.04084 214.55 / 1), color(--oklch 0.9 0.04427 218.18 / 1), color(--oklch 0.9 0.04441 221.82 / 1), color(--oklch 0.9 0.0431 225.45 / 1), color(--oklch 0.9 0.04112 229.09 / 1), color(--oklch 0.9 0.03883 232.73 / 1), color(--oklch 0.9 0.03641 236.36 / 1), color(--oklch 0.9 0.03393 240 / 1), color(--oklch 0.9 0.03138 243.64 / 1), color(--oklch 0.9 0.02866 247.27 / 1), color(--oklch 0.9 0.02552 250.91 / 1), color(--oklch 0.9 0.0212 254.55 / 1), color(--oklch 0.9 0.01317 258.18 / 1), color(--oklch 0.9 0.01887 81.818 / 1), color(--oklch 0.9 0.04813 265.45 / 1), color(--oklch 0.9 0.04811 269.09 / 1), color(--oklch 0.9 0.0831 92.727 / 1), color(--oklch 0.9 0.00036 276.36 / 1), color(--oklch 0.9 0.01827 280 / 1), color(--oklch 0.9 0.02615 283.64 / 1), color(--oklch 0.9 0.03053 287.27 / 1), color(--oklch 0.9 0.0331 290.91 / 1), color(--oklch 0.9 0.03429 294.55 / 1), color(--oklch 0.9 0.03388 298.18 / 1), color(--oklch 0.9 0.03076 301.82 / 1), color(--oklch 0.9 0.02106 305.45 / 1), color(--oklch 0.9 0.01717 129.09 / 1), color(--oklch 0.9 0.06811 312.73 / 1), color(--oklch 0.9 0.07289 316.36 / 1), color(--oklch 0.9 0.07874 320 / 1), color(--oklch 0.9 0.08599 323.64 / 1), color(--oklch 0.9 0.09033 327.27 / 1), color(--oklch 0.9 0.08316 330.91 / 1), color(--oklch 0.9 0.07729 334.55 / 1), color(--oklch 0.9 0.07245 338.18 / 1), color(--oklch 0.9 0.06842 341.82 / 1), color(--oklch 0.9 0.06506 345.45 / 1), color(--oklch 0.9 0.0235 169.09 / 1), color(--oklch 0.9 0.00322 172.73 / 1), color(--oklch 0.9 0.02296 356.36 / 1), color(--oklch 0.9 0.03085 0 / 1)]\n&gt;&gt;&gt; Steps([c.fit('okhsl', method='oklch-chroma') for c in Color.steps(['oklch(90% 0.4 0)', 'oklch(90% 0.4 360)'], steps=100, space='oklch', hue='longer')])\n[color(--oklch 0.9 0.03085 0 / 1), color(--oklch 0.9 0.03372 3.6364 / 1), color(--oklch 0.9 0.03428 7.2727 / 1), color(--oklch 0.9 0.03333 10.909 / 1), color(--oklch 0.9 0.03093 14.545 / 1), color(--oklch 0.9 0.02652 18.182 / 1), color(--oklch 0.9 0.01818 21.818 / 1), color(--oklch 0.9 0.00125 205.45 / 1), color(--oklch 0.9 0.08837 209.09 / 1), color(--oklch 0.9 0.00249 32.727 / 1), color(--oklch 0.9 0.01967 36.364 / 1), color(--oklch 0.9 0.02693 40 / 1), color(--oklch 0.9 0.03129 43.636 / 1), color(--oklch 0.9 0.03452 47.273 / 1), color(--oklch 0.9 0.03733 50.909 / 1), color(--oklch 0.9 0.04004 54.545 / 1), color(--oklch 0.9 0.04282 58.182 / 1), color(--oklch 0.9 0.04576 61.818 / 1), color(--oklch 0.9 0.04888 65.455 / 1), color(--oklch 0.9 0.05211 69.091 / 1), color(--oklch 0.9 0.05531 72.727 / 1), color(--oklch 0.9 0.0581 76.364 / 1), color(--oklch 0.9 0.05966 80 / 1), color(--oklch 0.9 0.05812 83.636 / 1), color(--oklch 0.9 0.04843 87.273 / 1), color(--oklch 0.9 0.01209 90.909 / 1), color(--oklch 0.9 0.15515 94.545 / 1), color(--oklch 0.9 0.1861 98.182 / 1), color(--oklch 0.9 0.18832 101.82 / 1), color(--oklch 0.9 0.19138 105.45 / 1), color(--oklch 0.9 0.01909 289.09 / 1), color(--oklch 0.9 0.03162 292.73 / 1), color(--oklch 0.9 0.02113 296.36 / 1), color(--oklch 0.9 0.03591 300 / 1), color(--oklch 0.9 0.22247 123.64 / 1), color(--oklch 0.9 0.23299 127.27 / 1), color(--oklch 0.9 0.2456 130.91 / 1), color(--oklch 0.9 0.24384 134.55 / 1), color(--oklch 0.9 0.22238 138.18 / 1), color(--oklch 0.9 0.20619 141.82 / 1), color(--oklch 0.9 0.19362 145.45 / 1), color(--oklch 0.9 0.03067 329.09 / 1), color(--oklch 0.9 0.00536 152.73 / 1), color(--oklch 0.9 0.0202 156.36 / 1), color(--oklch 0.9 0.02441 160 / 1), color(--oklch 0.9 0.02118 163.64 / 1), color(--oklch 0.9 0.01041 167.27 / 1), color(--oklch 0.9 0.01147 350.91 / 1), color(--oklch 0.9 0.05689 354.55 / 1), color(--oklch 0.9 0.15497 178.18 / 1), color(--oklch 0.9 0.1556 181.82 / 1), color(--oklch 0.9 0.15708 185.45 / 1), color(--oklch 0.9 0.15589 189.09 / 1), color(--oklch 0.9 0.15425 192.73 / 1), color(--oklch 0.9 0.15008 196.36 / 1), color(--oklch 0.9 0.12658 200 / 1), color(--oklch 0.9 0.10983 203.64 / 1), color(--oklch 0.9 0.01686 27.273 / 1), color(--oklch 0.9 0.0287 210.91 / 1), color(--oklch 0.9 0.04084 214.55 / 1), color(--oklch 0.9 0.04427 218.18 / 1), color(--oklch 0.9 0.04441 221.82 / 1), color(--oklch 0.9 0.0431 225.45 / 1), color(--oklch 0.9 0.04112 229.09 / 1), color(--oklch 0.9 0.03883 232.73 / 1), color(--oklch 0.9 0.03641 236.36 / 1), color(--oklch 0.9 0.03393 240 / 1), color(--oklch 0.9 0.03138 243.64 / 1), color(--oklch 0.9 0.02866 247.27 / 1), color(--oklch 0.9 0.02552 250.91 / 1), color(--oklch 0.9 0.0212 254.55 / 1), color(--oklch 0.9 0.01317 258.18 / 1), color(--oklch 0.9 0.01887 81.818 / 1), color(--oklch 0.9 0.04813 265.45 / 1), color(--oklch 0.9 0.04811 269.09 / 1), color(--oklch 0.9 0.0831 92.727 / 1), color(--oklch 0.9 0.00036 276.36 / 1), color(--oklch 0.9 0.01827 280 / 1), color(--oklch 0.9 0.02615 283.64 / 1), color(--oklch 0.9 0.03053 287.27 / 1), color(--oklch 0.9 0.0331 290.91 / 1), color(--oklch 0.9 0.03429 294.55 / 1), color(--oklch 0.9 0.03388 298.18 / 1), color(--oklch 0.9 0.03076 301.82 / 1), color(--oklch 0.9 0.02106 305.45 / 1), color(--oklch 0.9 0.01717 129.09 / 1), color(--oklch 0.9 0.06811 312.73 / 1), color(--oklch 0.9 0.07289 316.36 / 1), color(--oklch 0.9 0.07874 320 / 1), color(--oklch 0.9 0.08599 323.64 / 1), color(--oklch 0.9 0.09033 327.27 / 1), color(--oklch 0.9 0.08316 330.91 / 1), color(--oklch 0.9 0.07729 334.55 / 1), color(--oklch 0.9 0.07245 338.18 / 1), color(--oklch 0.9 0.06842 341.82 / 1), color(--oklch 0.9 0.06506 345.45 / 1), color(--oklch 0.9 0.0235 169.09 / 1), color(--oklch 0.9 0.00322 172.73 / 1), color(--oklch 0.9 0.02296 356.36 / 1), color(--oklch 0.9 0.03085 0 / 1)]\n&gt;&gt;&gt; Steps([c.fit('srgb', method='raytrace') for c in Color.steps(['oklch(90% 0.4 0)', 'oklch(90% 0.4 360)'], steps=100, space='oklch', hue='longer')])\n[color(--oklch 0.9 0.05626 0 / 1), color(--oklch 0.9 0.05492 3.6364 / 1), color(--oklch 0.9 0.05385 7.2727 / 1), color(--oklch 0.9 0.05303 10.909 / 1), color(--oklch 0.9 0.05244 14.545 / 1), color(--oklch 0.9 0.05207 18.182 / 1), color(--oklch 0.9 0.0519 21.818 / 1), color(--oklch 0.9 0.05195 25.455 / 1), color(--oklch 0.9 0.0522 29.091 / 1), color(--oklch 0.9 0.05266 32.727 / 1), color(--oklch 0.9 0.05334 36.364 / 1), color(--oklch 0.9 0.05426 40 / 1), color(--oklch 0.9 0.05543 43.636 / 1), color(--oklch 0.9 0.05688 47.273 / 1), color(--oklch 0.9 0.05865 50.909 / 1), color(--oklch 0.9 0.06078 54.546 / 1), color(--oklch 0.9 0.06333 58.182 / 1), color(--oklch 0.9 0.06636 61.819 / 1), color(--oklch 0.9 0.07 65.456 / 1), color(--oklch 0.9 0.07435 69.093 / 1), color(--oklch 0.9 0.0796 72.733 / 1), color(--oklch 0.9 0.08601 76.374 / 1), color(--oklch 0.9 0.09391 80.021 / 1), color(--oklch 0.9 0.10384 83.675 / 1), color(--oklch 0.9 0.1166 87.343 / 1), color(--oklch 0.9 0.13348 91.035 / 1), color(--oklch 0.9 0.15639 94.717 / 1), color(--oklch 0.9 0.1861 98.182 / 1), color(--oklch 0.9 0.18832 101.82 / 1), color(--oklch 0.9 0.19138 105.45 / 1), color(--oklch 0.9 0.19534 109.09 / 1), color(--oklch 0.9 0.20029 112.73 / 1), color(--oklch 0.9 0.20635 116.36 / 1), color(--oklch 0.9 0.21367 120 / 1), color(--oklch 0.9 0.22247 123.64 / 1), color(--oklch 0.9 0.23299 127.27 / 1), color(--oklch 0.9 0.2456 130.91 / 1), color(--oklch 0.9 0.24384 134.55 / 1), color(--oklch 0.9 0.22238 138.18 / 1), color(--oklch 0.9 0.20619 141.82 / 1), color(--oklch 0.9 0.19362 145.45 / 1), color(--oklch 0.9 0.1837 149.09 / 1), color(--oklch 0.9 0.17581 152.73 / 1), color(--oklch 0.9 0.16954 156.36 / 1), color(--oklch 0.9 0.16461 160 / 1), color(--oklch 0.9 0.16083 163.64 / 1), color(--oklch 0.9 0.15804 167.27 / 1), color(--oklch 0.9 0.15617 170.91 / 1), color(--oklch 0.9 0.15516 174.55 / 1), color(--oklch 0.9 0.15497 178.18 / 1), color(--oklch 0.9 0.1556 181.82 / 1), color(--oklch 0.9 0.15708 185.45 / 1), color(--oklch 0.9 0.15589 189.09 / 1), color(--oklch 0.9 0.15425 192.73 / 1), color(--oklch 0.9 0.15008 196.36 / 1), color(--oklch 0.9 0.12658 200 / 1), color(--oklch 0.9 0.10983 203.64 / 1), color(--oklch 0.9 0.09734 207.27 / 1), color(--oklch 0.9 0.08773 210.91 / 1), color(--oklch 0.9 0.08013 214.54 / 1), color(--oklch 0.9 0.07402 218.18 / 1), color(--oklch 0.9 0.06903 221.82 / 1), color(--oklch 0.9 0.06492 225.45 / 1), color(--oklch 0.9 0.06151 229.09 / 1), color(--oklch 0.9 0.05866 232.73 / 1), color(--oklch 0.9 0.05628 236.36 / 1), color(--oklch 0.9 0.0543 240 / 1), color(--oklch 0.9 0.05265 243.64 / 1), color(--oklch 0.9 0.0513 247.27 / 1), color(--oklch 0.9 0.05022 250.91 / 1), color(--oklch 0.9 0.04938 254.55 / 1), color(--oklch 0.9 0.04876 258.18 / 1), color(--oklch 0.9 0.04834 261.82 / 1), color(--oklch 0.9 0.04813 265.45 / 1), color(--oklch 0.9 0.04811 269.09 / 1), color(--oklch 0.9 0.04828 272.73 / 1), color(--oklch 0.9 0.04865 276.36 / 1), color(--oklch 0.9 0.04923 280 / 1), color(--oklch 0.9 0.05003 283.64 / 1), color(--oklch 0.9 0.05106 287.27 / 1), color(--oklch 0.9 0.05235 290.91 / 1), color(--oklch 0.9 0.05392 294.55 / 1), color(--oklch 0.9 0.05583 298.18 / 1), color(--oklch 0.9 0.05813 301.82 / 1), color(--oklch 0.9 0.06087 305.45 / 1), color(--oklch 0.9 0.06416 309.09 / 1), color(--oklch 0.9 0.06811 312.73 / 1), color(--oklch 0.9 0.07289 316.36 / 1), color(--oklch 0.9 0.07874 320 / 1), color(--oklch 0.9 0.08599 323.64 / 1), color(--oklch 0.9 0.09033 327.27 / 1), color(--oklch 0.9 0.08316 330.91 / 1), color(--oklch 0.9 0.07729 334.55 / 1), color(--oklch 0.9 0.07245 338.18 / 1), color(--oklch 0.9 0.06842 341.82 / 1), color(--oklch 0.9 0.06506 345.45 / 1), color(--oklch 0.9 0.06223 349.09 / 1), color(--oklch 0.9 0.05987 352.73 / 1), color(--oklch 0.9 0.05789 356.36 / 1), color(--oklch 0.9 0.05626 0 / 1)]\n</code></pre> Gamut: srgb"},{"location":"gamut/#gamut-mapping-in-any-perceptual-space","title":"Gamut Mapping in Any Perceptual Space","text":"<p>ColorAide provides a couple gamut mapping approaches and a few using different perceptual spaces to perform the operation, but th <code>minde-chroma</code> and the <code>raytrace</code> gamut mapping allow for using any perceptual space to perform the gamut mapping operation in. Any perceptual space in the LCh-ish or Lab-ish form can be specified via the <code>pspace</code> parameter.</p> <pre><code>&gt;&gt;&gt; Color('oklch(50% 0.4 270)').fit('srgb', method='raytrace', pspace='cam16-jmh')\ncolor(--oklch 0.48631 0.29467 277.07 / 1)\n&gt;&gt;&gt; Color('oklch(50% 0.4 270)').fit('srgb', method='raytrace', pspace='luv')\ncolor(--oklch 0.47398 0.29406 276.64 / 1)\n</code></pre> Gamut: srgb <p>For the MINDE chroma approach, you would need to specify and configure an appropriate \u2206E distancing approach and determine an appropriate JND limit for said distancing approach. Ideally, a \u2206E algorithm specific to the perceptual space is preferred to help prevent costly conversions to other color spaces. Performance of algorithm in different perceptual spaces is dependent on the \u2206E algorithm used, the JND selected, and how uniformly perceptual the color space is.</p> <p>As an example, <code>minde-chroma</code> method uses OkLCh and uses the \u2206E<sub>ok</sub> distancing algorithm with a JND of 0.02. The LCh variant uses CIELCh D65 and uses \u2206E<sub>2000</sub> with a JND of 2. We can manually perform both of these by setting the perceptual space with <code>psapce</code>, the \u2206E configuration via <code>de_options</code>, and the JND with <code>jnd</code>.</p> <pre><code>&gt;&gt;&gt; gma_lch = {'pspace': 'lch-d65', 'de_options': {'method': '2000'}, 'jnd': 2}\n&gt;&gt;&gt; gma_oklch = {'pspace': 'oklch', 'de_options': {'method': 'ok'}, 'jnd': 0.02}\n&gt;&gt;&gt; Steps([c.fit('srgb', **gma_lch) for c in Color.steps(['oklch(90% 0.4 0)', 'oklch(90% 0.4 360)'], steps=100, space='oklch', hue='longer')])\n[color(--oklch 0.84918 0.09121 357.15 / 1), color(--oklch 0.84901 0.0884 1.4712 / 1), color(--oklch 0.8489 0.08612 5.9235 / 1), color(--oklch 0.84886 0.08434 10.532 / 1), color(--oklch 0.84883 0.0831 15.333 / 1), color(--oklch 0.84898 0.08232 20.426 / 1), color(--oklch 0.84924 0.08213 25.959 / 1), color(--oklch 0.84978 0.08269 32.293 / 1), color(--oklch 0.85052 0.08518 41.028 / 1), color(--oklch 0.85133 0.0939 54.434 / 1), color(--oklch 0.85212 0.10289 62.615 / 1), color(--oklch 0.85303 0.1107 67.921 / 1), color(--oklch 0.85411 0.11725 71.661 / 1), color(--oklch 0.85537 0.12273 74.479 / 1), color(--oklch 0.85683 0.12732 76.714 / 1), color(--oklch 0.85848 0.13118 78.567 / 1), color(--oklch 0.8603 0.13454 80.176 / 1), color(--oklch 0.86231 0.13744 81.612 / 1), color(--oklch 0.86448 0.14009 82.942 / 1), color(--oklch 0.8668 0.1426 84.212 / 1), color(--oklch 0.86924 0.14512 85.452 / 1), color(--oklch 0.87184 0.14761 86.668 / 1), color(--oklch 0.87454 0.15033 87.899 / 1), color(--oklch 0.87736 0.15332 89.146 / 1), color(--oklch 0.88022 0.15699 90.455 / 1), color(--oklch 0.88312 0.16151 91.831 / 1), color(--oklch 0.88608 0.16715 93.284 / 1), color(--oklch 0.88896 0.17519 94.91 / 1), color(--oklch 0.89209 0.1837 96.476 / 1), color(--oklch 0.89662 0.18504 97.429 / 1), color(--oklch 0.90149 0.18653 98.428 / 1), color(--oklch 0.90666 0.18817 99.462 / 1), color(--oklch 0.91192 0.18997 100.6 / 1), color(--oklch 0.91436 0.19222 102.97 / 1), color(--oklch 0.91655 0.19511 105.67 / 1), color(--oklch 0.91839 0.19901 108.83 / 1), color(--oklch 0.91973 0.20459 112.66 / 1), color(--oklch 0.92028 0.21328 117.54 / 1), color(--oklch 0.91945 0.22858 124.11 / 1), color(--oklch 0.90154 0.25286 132.63 / 1), color(--oklch 0.89131 0.23503 140.47 / 1), color(--oklch 0.89656 0.19826 146.57 / 1), color(--oklch 0.90131 0.174 152.26 / 1), color(--oklch 0.90572 0.15674 157.52 / 1), color(--oklch 0.90948 0.14448 162.32 / 1), color(--oklch 0.9128 0.13538 166.67 / 1), color(--oklch 0.91541 0.12902 170.66 / 1), color(--oklch 0.9175 0.12451 174.36 / 1), color(--oklch 0.91897 0.12175 177.88 / 1), color(--oklch 0.91997 0.12035 181.28 / 1), color(--oklch 0.92027 0.12065 184.69 / 1), color(--oklch 0.91993 0.12264 188.17 / 1), color(--oklch 0.91905 0.12632 191.79 / 1), color(--oklch 0.90985 0.14607 194.89 / 1), color(--oklch 0.9054 0.15455 194.77 / 1), color(--oklch 0.92843 0.10387 196.86 / 1), color(--oklch 0.9285 0.08567 201.11 / 1), color(--oklch 0.9276 0.07299 205.88 / 1), color(--oklch 0.92601 0.06378 211.24 / 1), color(--oklch 0.92387 0.05713 217.12 / 1), color(--oklch 0.92131 0.05236 223.49 / 1), color(--oklch 0.91839 0.04909 230.23 / 1), color(--oklch 0.91519 0.04706 237.16 / 1), color(--oklch 0.91173 0.04615 243.97 / 1), color(--oklch 0.90805 0.04613 250.51 / 1), color(--oklch 0.9042 0.04686 256.64 / 1), color(--oklch 0.90027 0.04816 262.37 / 1), color(--oklch 0.89633 0.04993 267.75 / 1), color(--oklch 0.89248 0.05207 272.76 / 1), color(--oklch 0.88877 0.05452 277.36 / 1), color(--oklch 0.88519 0.05721 281.48 / 1), color(--oklch 0.88173 0.06008 285.14 / 1), color(--oklch 0.87843 0.06308 288.41 / 1), color(--oklch 0.8753 0.06617 291.35 / 1), color(--oklch 0.87237 0.0693 294.02 / 1), color(--oklch 0.86967 0.07247 296.49 / 1), color(--oklch 0.86721 0.07566 298.8 / 1), color(--oklch 0.86501 0.07887 300.99 / 1), color(--oklch 0.86308 0.08212 303.1 / 1), color(--oklch 0.86143 0.08543 305.17 / 1), color(--oklch 0.86006 0.08884 307.23 / 1), color(--oklch 0.85896 0.09241 309.3 / 1), color(--oklch 0.85815 0.09619 311.4 / 1), color(--oklch 0.85762 0.1003 313.57 / 1), color(--oklch 0.85736 0.10487 315.84 / 1), color(--oklch 0.85739 0.11002 318.19 / 1), color(--oklch 0.85769 0.11599 320.67 / 1), color(--oklch 0.8583 0.12303 323.27 / 1), color(--oklch 0.85923 0.13159 326.02 / 1), color(--oklch 0.85347 0.14015 326.72 / 1), color(--oklch 0.84964 0.14423 326.75 / 1), color(--oklch 0.85277 0.14008 326.96 / 1), color(--oklch 0.852 0.13069 330.27 / 1), color(--oklch 0.85131 0.12251 333.7 / 1), color(--oklch 0.85078 0.11526 337.28 / 1), color(--oklch 0.85031 0.10895 340.99 / 1), color(--oklch 0.84994 0.10344 344.85 / 1), color(--oklch 0.84962 0.0987 348.83 / 1), color(--oklch 0.84938 0.09464 352.93 / 1), color(--oklch 0.84918 0.09121 357.15 / 1)]\n&gt;&gt;&gt; Steps([c.fit('srgb', **gma_oklch) for c in Color.steps(['oklch(90% 0.4 0)', 'oklch(90% 0.4 360)'], steps=100, space='oklch', hue='longer')])\n[color(--oklch 0.88717 0.06673 355.33 / 1), color(--oklch 0.88718 0.06441 359.67 / 1), color(--oklch 0.88719 0.06255 4.0928 / 1), color(--oklch 0.88718 0.06113 8.5912 / 1), color(--oklch 0.88719 0.06011 13.152 / 1), color(--oklch 0.88715 0.05951 17.75 / 1), color(--oklch 0.88717 0.05925 22.369 / 1), color(--oklch 0.88713 0.05941 26.987 / 1), color(--oklch 0.88715 0.05991 31.574 / 1), color(--oklch 0.88713 0.06083 36.121 / 1), color(--oklch 0.88716 0.0621 40.588 / 1), color(--oklch 0.88717 0.06379 44.978 / 1), color(--oklch 0.88716 0.06593 49.278 / 1), color(--oklch 0.88715 0.06854 53.473 / 1), color(--oklch 0.88712 0.07167 57.565 / 1), color(--oklch 0.88715 0.07531 61.519 / 1), color(--oklch 0.88713 0.07964 65.378 / 1), color(--oklch 0.88712 0.08471 69.122 / 1), color(--oklch 0.88712 0.09063 72.748 / 1), color(--oklch 0.88713 0.09758 76.267 / 1), color(--oklch 0.88713 0.10584 79.694 / 1), color(--oklch 0.88717 0.11564 83.019 / 1), color(--oklch 0.88715 0.12763 86.283 / 1), color(--oklch 0.88719 0.14226 89.462 / 1), color(--oklch 0.88719 0.16071 92.59 / 1), color(--oklch 0.88726 0.18232 95.438 / 1), color(--oklch 0.89218 0.18372 96.494 / 1), color(--oklch 0.8987 0.18567 97.858 / 1), color(--oklch 0.90192 0.18793 100.67 / 1), color(--oklch 0.90192 0.19107 104.69 / 1), color(--oklch 0.90193 0.19529 108.7 / 1), color(--oklch 0.90192 0.20068 112.7 / 1), color(--oklch 0.90192 0.20737 116.68 / 1), color(--oklch 0.90193 0.21554 120.62 / 1), color(--oklch 0.90194 0.22539 124.54 / 1), color(--oklch 0.90194 0.23722 128.42 / 1), color(--oklch 0.90194 0.25142 132.26 / 1), color(--oklch 0.89219 0.26266 135.44 / 1), color(--oklch 0.88263 0.27371 138.18 / 1), color(--oklch 0.88175 0.25494 141.76 / 1), color(--oklch 0.88189 0.23689 145.66 / 1), color(--oklch 0.88209 0.22286 149.58 / 1), color(--oklch 0.88221 0.21214 153.5 / 1), color(--oklch 0.88229 0.20391 157.42 / 1), color(--oklch 0.88313 0.19644 161.07 / 1), color(--oklch 0.88558 0.18764 164.42 / 1), color(--oklch 0.88805 0.17994 167.95 / 1), color(--oklch 0.8905 0.17342 171.57 / 1), color(--oklch 0.89291 0.168 175.25 / 1), color(--oklch 0.8953 0.1636 178.96 / 1), color(--oklch 0.89767 0.16015 182.69 / 1), color(--oklch 0.90003 0.15756 186.42 / 1), color(--oklch 0.90238 0.15577 190.11 / 1), color(--oklch 0.90473 0.15472 193.75 / 1), color(--oklch 0.9054 0.15455 194.77 / 1), color(--oklch 0.90357 0.15414 195.17 / 1), color(--oklch 0.89711 0.15276 196.59 / 1), color(--oklch 0.89505 0.13708 199.31 / 1), color(--oklch 0.89504 0.12221 202.11 / 1), color(--oklch 0.89502 0.11028 204.96 / 1), color(--oklch 0.89502 0.10034 207.93 / 1), color(--oklch 0.895 0.09216 210.95 / 1), color(--oklch 0.89499 0.08517 214.1 / 1), color(--oklch 0.89499 0.07918 217.37 / 1), color(--oklch 0.89499 0.07401 220.78 / 1), color(--oklch 0.89499 0.06955 224.33 / 1), color(--oklch 0.89499 0.06569 228.03 / 1), color(--oklch 0.89498 0.06237 231.88 / 1), color(--oklch 0.89499 0.05949 235.92 / 1), color(--oklch 0.89497 0.05709 240.08 / 1), color(--oklch 0.89498 0.05504 244.48 / 1), color(--oklch 0.89498 0.05341 249.01 / 1), color(--oklch 0.89497 0.05215 253.7 / 1), color(--oklch 0.89497 0.05126 258.51 / 1), color(--oklch 0.89496 0.05075 263.44 / 1), color(--oklch 0.89495 0.05063 268.45 / 1), color(--oklch 0.89496 0.05088 273.51 / 1), color(--oklch 0.89495 0.05156 278.57 / 1), color(--oklch 0.89494 0.05266 283.61 / 1), color(--oklch 0.89494 0.0542 288.57 / 1), color(--oklch 0.89494 0.05623 293.44 / 1), color(--oklch 0.89493 0.0588 298.19 / 1), color(--oklch 0.89493 0.06192 302.78 / 1), color(--oklch 0.89492 0.0657 307.21 / 1), color(--oklch 0.89491 0.07022 311.49 / 1), color(--oklch 0.89492 0.07558 315.56 / 1), color(--oklch 0.8949 0.08201 319.49 / 1), color(--oklch 0.8949 0.0897 323.25 / 1), color(--oklch 0.89413 0.09833 326.36 / 1), color(--oklch 0.88972 0.10274 326.4 / 1), color(--oklch 0.88709 0.10539 326.42 / 1), color(--oklch 0.8866 0.10588 326.42 / 1), color(--oklch 0.8873 0.10102 328.09 / 1), color(--oklch 0.88727 0.09341 331.65 / 1), color(--oklch 0.88723 0.087 335.3 / 1), color(--oklch 0.88726 0.08147 339.1 / 1), color(--oklch 0.88723 0.07682 342.98 / 1), color(--oklch 0.88724 0.07284 347 / 1), color(--oklch 0.88718 0.06954 351.1 / 1), color(--oklch 0.88717 0.06673 355.33 / 1)]\n</code></pre> Gamut: srgb <p>It should be noted that gamut mapping will be limited by the capabilities of the perceptual space being used. Some color spaces can swing to varying degrees outside the visible spectrum and some perceptual models can tolerate this more than others. While the characteristics of the color space can affect gamut mapping results, this does not mean the gamut mapping approach does not work, only that some color models may work best under more constraints.</p> <p>Consider the example below. We take a very saturated yellow in Display P3 (<code>color(display-p3 1 1 0)</code>) and then we interpolate it's lightness between 0, masking off chroma so that we are only interpolating lightness. We do this interpolation in CIELCh, whose chroma can swing very far outside the visible spectrum when interpolating hues at more extreme lightness. Finally, we gamut map in various LCh models. What we can observe is some models will struggle to map some of these colors as the hue preservation can break down at extreme limits. In the cases below, this specifically happens due to negative XYZ values that are produced due to high chroma in lower lightness. Some models can tolerate this more than others.</p> <pre><code>&gt;&gt;&gt; yellow = Color('color(display-p3 1 1 0)')\n&gt;&gt;&gt; lightness_mask = Color('lch(0% none none)')\n&gt;&gt;&gt; Steps([c.fit('srgb', method='raytrace', pspace='oklch') for c in Color.steps([yellow, lightness_mask], steps=20, space='lch')])\n[color(--lch 97.252 94.474 99.968 / 1), color(--lch 92.116 90.244 100.33 / 1), color(--lch 86.981 86.019 100.72 / 1), color(--lch 81.848 81.8 101.15 / 1), color(--lch 76.716 77.587 101.63 / 1), color(--lch 71.583 73.375 102.14 / 1), color(--lch 66.446 69.159 102.67 / 1), color(--lch 61.303 64.934 103.2 / 1), color(--lch 56.155 60.694 103.7 / 1), color(--lch 50.999 56.432 104.17 / 1), color(--lch 45.834 52.143 104.56 / 1), color(--lch 40.663 47.836 104.91 / 1), color(--lch 35.631 43.818 106.43 / 1), color(--lch 30.421 39.374 106.27 / 1), color(--lch 25.124 34.439 105.77 / 1), color(--lch 19.731 28.372 105.2 / 1), color(--lch 14.159 21.103 104.22 / 1), color(--lch 8.1264 12.265 101.36 / 1), color(--lch 1.9671 2.9842 79.847 / 1), color(--lch 0 0 none / 1)]\n&gt;&gt;&gt; Steps([c.fit('srgb', method='raytrace', pspace='lch99o') for c in Color.steps([yellow, lightness_mask], steps=20, space='lch')])\n[color(--lch 97.038 22.96 96.153 / 1), color(--lch 92.214 89.989 97.362 / 1), color(--lch 87.091 85.717 97.183 / 1), color(--lch 81.969 81.446 96.949 / 1), color(--lch 76.847 77.184 96.878 / 1), color(--lch 71.724 72.924 96.861 / 1), color(--lch 66.6 68.664 96.843 / 1), color(--lch 61.473 64.401 96.827 / 1), color(--lch 56.343 60.137 96.818 / 1), color(--lch 51.21 55.869 96.823 / 1), color(--lch 46.071 51.599 96.852 / 1), color(--lch 40.924 47.323 96.92 / 1), color(--lch 35.767 43.039 97.053 / 1), color(--lch 30.594 38.745 97.292 / 1), color(--lch 25.396 34.033 97.641 / 1), color(--lch 20.157 28.339 98.228 / 1), color(--lch 14.844 21.718 99.385 / 1), color(--lch 9.3945 14.051 98.579 / 1), color(--lch 4.0615 6.0794 98.13 / 1), color(--lch 0 0 none / 1)]\n&gt;&gt;&gt; Steps([c.fit('srgb', method='raytrace', pspace='hct') for c in Color.steps([yellow, lightness_mask], steps=20, space='lch')])\n[color(--lch 97.316 94.474 99.598 / 1), color(--lch 92.189 90.239 99.889 / 1), color(--lch 87.062 86.008 100.21 / 1), color(--lch 81.937 81.782 100.56 / 1), color(--lch 76.813 77.56 100.95 / 1), color(--lch 71.688 73.334 101.34 / 1), color(--lch 66.563 69.099 101.69 / 1), color(--lch 61.437 64.832 101.85 / 1), color(--lch 56.31 60.536 101.82 / 1), color(--lch 51.178 56.255 101.94 / 1), color(--lch 46.042 51.962 102.01 / 1), color(--lch 40.898 47.651 101.99 / 1), color(--lch 35.745 43.318 101.81 / 1), color(--lch 30.577 38.956 101.39 / 1), color(--lch 25.384 34.191 100.69 / 1), color(--lch 20.152 28.407 99.637 / 1), color(--lch 14.849 21.647 97.546 / 1), color(--lch 9.4049 13.959 92.117 / 1), color(--lch 4.0759 6.2258 78.058 / 1), color(--lch 0 0 none / 1)]\n&gt;&gt;&gt; Steps([c.fit('srgb', method='raytrace', pspace='jzczhz') for c in Color.steps([yellow, lightness_mask], steps=20, space='lch')])\n[color(--lch 97.139 94.455 100.44 / 1), color(--lch 91.987 90.221 100.84 / 1), color(--lch 86.837 85.991 101.27 / 1), color(--lch 81.689 81.766 101.73 / 1), color(--lch 76.544 77.547 102.23 / 1), color(--lch 71.395 73.327 102.76 / 1), color(--lch 66.237 69.101 103.33 / 1), color(--lch 61.067 64.865 103.92 / 1), color(--lch 55.883 60.613 104.53 / 1), color(--lch 50.68 56.34 105.17 / 1), color(--lch 45.456 52.052 105.87 / 1), color(--lch 40.235 47.847 107.09 / 1), color(--lch 25.052 77.611 313.27 / 1), color(--lch 20.684 69.351 313.27 / 1), color(--lch 16.234 60.938 313.27 / 1), color(--lch 11.635 52.242 313.27 / 1), color(--lch 6.7735 42.632 313.1 / 1), color(--lch 2.6403 23.628 305.32 / 1), color(--lch 0 0 none / 1), color(--lch 0 0 none / 1)]\n&gt;&gt;&gt; Steps([c.fit('srgb', method='raytrace', pspace='lchuv') for c in Color.steps([yellow, lightness_mask], steps=20, space='lch')])\n[color(--lch 97.317 94.47 99.572 / 1), color(--lch 92.189 90.24 99.895 / 1), color(--lch 87.062 86.016 100.26 / 1), color(--lch 81.936 81.799 100.68 / 1), color(--lch 76.811 77.59 101.16 / 1), color(--lch 71.686 73.383 101.67 / 1), color(--lch 66.559 69.173 102.18 / 1), color(--lch 61.431 64.955 102.68 / 1), color(--lch 56.302 60.723 103.14 / 1), color(--lch 51.169 56.469 103.51 / 1), color(--lch 46.032 52.183 103.74 / 1), color(--lch 40.889 47.854 103.71 / 1), color(--lch 35.738 43.476 103.34 / 1), color(--lch 30.572 39.052 102.52 / 1), color(--lch 25.382 34.234 101.29 / 1), color(--lch 20.151 28.423 99.916 / 1), color(--lch 14.846 21.683 98.546 / 1), color(--lch 8.7143 33.663 285.14 / 1), color(--lch 3.7511 22.378 280.24 / 1), color(--lch 0 0 none / 1)]\n</code></pre> Gamut: srgb <p>Almost any perceptual model, if pushed far enough, can start to break down. Converting to and from these spaces before reducing chroma can introduce such disparities. Every color space has limitations, some spaces just have more agreeable ones.</p> <p>If you are working within reasonable gamuts, most will work fine. And if you want to do something like above, holding chroma really high for all lightness values, you will often find that it works best when you do it directly in the color space that is doing the gamut mapping as you will have to \"fit\" the color before converting to another color space.</p> <pre><code>&gt;&gt;&gt; yellow = Color('color(display-p3 1 1 0)')\n&gt;&gt;&gt; lightness_mask = Color('oklch(0% none none)')\n&gt;&gt;&gt; Steps([c.fit('srgb', method='raytrace', pspace='oklch') for c in Color.steps([yellow, lightness_mask], steps=20, space='oklch')])\n[color(--oklch 0.96476 0.21094 110.23 / 1), color(--oklch 0.91399 0.19984 110.23 / 1), color(--oklch 0.86321 0.18874 110.23 / 1), color(--oklch 0.81243 0.17763 110.23 / 1), color(--oklch 0.76166 0.16653 110.23 / 1), color(--oklch 0.71088 0.15543 110.23 / 1), color(--oklch 0.6601 0.14433 110.23 / 1), color(--oklch 0.60932 0.13323 110.23 / 1), color(--oklch 0.55855 0.12212 110.23 / 1), color(--oklch 0.50777 0.11102 110.23 / 1), color(--oklch 0.45699 0.09992 110.23 / 1), color(--oklch 0.40622 0.08882 110.23 / 1), color(--oklch 0.35544 0.07772 110.23 / 1), color(--oklch 0.30466 0.06661 110.23 / 1), color(--oklch 0.25389 0.05551 110.23 / 1), color(--oklch 0.20311 0.04441 110.23 / 1), color(--oklch 0.15233 0.03331 110.23 / 1), color(--oklch 0.10155 0.0222 110.23 / 1), color(--oklch 0.05078 0.0111 110.23 / 1), color(--oklch 0 0 none / 1)]\n&gt;&gt;&gt; yellow = Color('color(display-p3 1 1 0)')\n&gt;&gt;&gt; lightness_mask = Color('color(--lch99o 0% none none)')\n&gt;&gt;&gt; Steps([c.fit('srgb', method='raytrace', pspace='lch99o') for c in Color.steps([yellow, lightness_mask], steps=20, space='lch99o')])\n[color(--lch99o 97.304 20.716 98.051 / 1), color(--lch99o 92.182 43.933 97.877 / 1), color(--lch99o 87.061 42.844 97.877 / 1), color(--lch99o 81.94 41.72 97.877 / 1), color(--lch99o 76.819 40.558 97.877 / 1), color(--lch99o 71.697 39.356 97.877 / 1), color(--lch99o 66.576 38.109 97.877 / 1), color(--lch99o 61.455 36.813 97.877 / 1), color(--lch99o 56.334 35.464 97.877 / 1), color(--lch99o 51.212 34.055 97.877 / 1), color(--lch99o 46.091 32.58 97.877 / 1), color(--lch99o 40.97 31.031 97.877 / 1), color(--lch99o 35.849 29.399 97.877 / 1), color(--lch99o 30.727 27.581 97.877 / 1), color(--lch99o 25.606 25.272 97.877 / 1), color(--lch99o 20.485 22.368 97.877 / 1), color(--lch99o 15.364 18.721 97.877 / 1), color(--lch99o 10.242 14.071 97.877 / 1), color(--lch99o 5.1212 8.0424 97.877 / 1), color(--lch99o 0 0 none / 1)]\n&gt;&gt;&gt; yellow = Color('color(display-p3 1 1 0)')\n&gt;&gt;&gt; lightness_mask = Color('color(--hct none none 0%)')\n&gt;&gt;&gt; Steps([c.fit('srgb', method='raytrace', pspace='hct') for c in Color.steps([yellow, lightness_mask], steps=20, space='hct')])\n[color(--hct 111.07 75.366 96.849 / 1), color(--hct 111.07 72.594 91.752 / 1), color(--hct 111.07 69.788 86.655 / 1), color(--hct 111.07 66.946 81.557 / 1), color(--hct 111.07 64.066 76.46 / 1), color(--hct 111.07 61.147 71.363 / 1), color(--hct 111.07 58.186 66.265 / 1), color(--hct 111.07 55.18 61.168 / 1), color(--hct 111.07 52.127 56.071 / 1), color(--hct 111.07 49.024 50.973 / 1), color(--hct 111.07 45.866 45.876 / 1), color(--hct 111.07 42.649 40.779 / 1), color(--hct 111.07 39.368 35.681 / 1), color(--hct 111.07 36.015 30.584 / 1), color(--hct 111.07 32.581 25.487 / 1), color(--hct 111.07 29.056 20.389 / 1), color(--hct 111.07 25.424 15.292 / 1), color(--hct 111.07 21.666 10.195 / 1), color(--hct 111.07 17.402 5.0973 / 1), color(--hct none 0 0 / 1)]\n&gt;&gt;&gt; yellow = Color('color(display-p3 1 1 0)')\n&gt;&gt;&gt; lightness_mask = Color('jzczhz(0% none none)')\n&gt;&gt;&gt; Steps([c.fit('srgb', method='raytrace', pspace='jzczhz') for c in Color.steps([yellow, lightness_mask], steps=20, space='jzczhz')])\n[color(--jzczhz 0.2083 0.13765 102.74 / 1), color(--jzczhz 0.19734 0.13381 102.74 / 1), color(--jzczhz 0.18637 0.12977 102.74 / 1), color(--jzczhz 0.17541 0.12552 102.74 / 1), color(--jzczhz 0.16445 0.12103 102.74 / 1), color(--jzczhz 0.15348 0.1163 102.74 / 1), color(--jzczhz 0.14252 0.1113 102.74 / 1), color(--jzczhz 0.13156 0.10601 102.74 / 1), color(--jzczhz 0.12059 0.10039 102.74 / 1), color(--jzczhz 0.10963 0.09443 102.74 / 1), color(--jzczhz 0.09867 0.08808 102.74 / 1), color(--jzczhz 0.08771 0.0813 102.74 / 1), color(--jzczhz 0.07674 0.07405 102.74 / 1), color(--jzczhz 0.06578 0.06625 102.74 / 1), color(--jzczhz 0.05482 0.05785 102.74 / 1), color(--jzczhz 0.04385 0.04873 102.74 / 1), color(--jzczhz 0.03289 0.03876 102.74 / 1), color(--jzczhz 0.02193 0.02772 102.74 / 1), color(--jzczhz 0.01096 0.01523 102.74 / 1), color(--jzczhz 0 0 none / 1)]\n&gt;&gt;&gt; yellow = Color('color(display-p3 1 1 0)')\n&gt;&gt;&gt; lightness_mask = Color('color(--lchuv 0% none none)')\n&gt;&gt;&gt; Steps([c.fit('srgb', method='raytrace', pspace='lchuv') for c in Color.steps([yellow, lightness_mask], steps=20, space='lchuv')])\n[color(--lchuv 96.849 106.77 85.874 / 1), color(--lchuv 91.752 101.15 85.874 / 1), color(--lchuv 86.655 95.528 85.874 / 1), color(--lchuv 81.557 89.909 85.874 / 1), color(--lchuv 76.46 84.29 85.874 / 1), color(--lchuv 71.363 78.67 85.874 / 1), color(--lchuv 66.265 73.051 85.874 / 1), color(--lchuv 61.168 67.432 85.874 / 1), color(--lchuv 56.071 61.812 85.874 / 1), color(--lchuv 50.973 56.193 85.874 / 1), color(--lchuv 45.876 50.574 85.874 / 1), color(--lchuv 40.779 44.954 85.874 / 1), color(--lchuv 35.681 39.335 85.874 / 1), color(--lchuv 30.584 33.716 85.874 / 1), color(--lchuv 25.487 28.097 85.874 / 1), color(--lchuv 20.389 22.477 85.874 / 1), color(--lchuv 15.292 16.858 85.874 / 1), color(--lchuv 10.195 11.239 85.874 / 1), color(--lchuv 5.0973 5.6193 85.874 / 1), color(--lchuv 0 0 none / 1)]\n</code></pre> Gamut: srgb <p>Lastly, if we have a particular color space that we'd like to have as the default, we can derive a variant for our particular color space using our preferred method of gamut mapping. Generally it is recommended to use the base plugins <code>minde-chroma</code> or <code>raytrace</code> as the base.</p> Ray TraceMINDE Chroma <pre><code>&gt;&gt;&gt; from coloraide.gamut.fit_raytrace import RayTrace\n&gt;&gt;&gt; from coloraide.spaces.hct import HCT\n&gt;&gt;&gt; from coloraide import Color as Base\n&gt;&gt;&gt; class HCTRayTrace(RayTrace):\n...     \"\"\"Apply gamut mapping using ray tracing.\"\"\"\n... \n...     NAME = 'hct-raytrace'\n...     PSPACE = \"hct\"\n... \n&gt;&gt;&gt; class Color(Base): ...\n... \n&gt;&gt;&gt; Color.register([HCT(), HCTRayTrace()])\n&gt;&gt;&gt; c = Color('hct', [325, 24, 50])\n&gt;&gt;&gt; tones = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 95, 100]\n&gt;&gt;&gt; Steps([c.clone().set('tone', tone).convert('srgb').to_string(hex=True, fit='hct-raytrace') for tone in tones])\n['#000000', '#29132e', '#3f2844', '#573e5b', '#705574', '#8a6d8d', '#a587a8', '#c1a1c3', '#debcdf', '#fbd7fc', '#ffebfd', '#ffffff']\n</code></pre> Gamut: srgb <p>If we want to make ray tracing the default algorithm for all gamut mapping, we can simply set <code>FIT</code> to our method.</p> <pre><code>class Color(Base):\n    FIT = 'hct-raytrace'\n\nColor.register(HCTRayTrace(), overwrite=True)\n</code></pre> <pre><code>&gt;&gt;&gt; from coloraide import Color as Base\n&gt;&gt;&gt; from coloraide.spaces.hct import HCT\n&gt;&gt;&gt; from coloraide.distance.delta_e_hct import DEHCT\n&gt;&gt;&gt; from coloraide.gamut.fit_minde_chroma import MINDEChroma\n&gt;&gt;&gt; class HCTChroma(MINDEChroma):\n...     \"\"\"HCT chroma gamut mapping class.\"\"\"\n... \n...     NAME = \"hct-chroma\"\n...     JND = 2.0\n...     DE_OPTIONS = {\"method\": \"hct\"}\n...     PSPACE = \"hct\"\n... \n&gt;&gt;&gt; class Color(Base): ...\n... \n&gt;&gt;&gt; Color.register([HCT(), DEHCT(), HCTChroma()])\n&gt;&gt;&gt; c = Color('hct', [325, 24, 50])\n&gt;&gt;&gt; tones = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 95, 100]\n&gt;&gt;&gt; Steps([c.clone().set('tone', tone).convert('srgb').to_string(hex=True, fit='hct-chroma') for tone in tones])\n['#000000', '#29132e', '#3f2844', '#573e5b', '#705574', '#8a6d8d', '#a587a8', '#c1a1c3', '#debcdf', '#fbd7fc', '#ffe8ff', '#ffffff']\n</code></pre> Gamut: srgb <p>If we want to make ray tracing the default algorithm for all gamut mapping, we can simply set <code>FIT</code> to our method.</p> <pre><code>class Color(Base):\n    FIT = 'hct-chroma'\n\nColor.register(HCTChroma(), overwrite=True)\n</code></pre>"},{"location":"gamut/#adaptive-lightness","title":"Adaptive Lightness","text":"<p>Both MINDE chroma reduction and ray trace chroma reduction support adaptive lightness. This is an option to allow for a non-constant lightness chroma reduction. Adaptive lightness allows us to essentially choose a dynamic anchor point different than our constant lightness anchor. Choosing a different anchor point can allow us to preserve more chroma/colorfulness by sacrificing some lightness.</p> <p>Essentially, a lightness focal point is selected by which the chroma reduction will be biased towards by some factor \u0251. This is done by taking this focal lightness and using it as a reference by which a new, non-constant lightness anchor point is calculated relative to this focal point. The anchor point is biased more or less towards this focal lightness depending on how large or small the \u0251 value is respectively.</p> <p>Below shows examples of chroma reduction with a focal lightness of 50% and an \u0251 value of 0, 0.5, and 5 respectively.</p> Constant Lightness (\u0251 = 0)Adaptive Lightness (\u0251 = 0.5)Adaptive Lightness (\u0251 = 5) <p></p> <p></p> <p></p> <p>There are various ways in which adaptive lightness could be implemented, but we will talk about two basic approaches: hue independent and hue dependent.</p> <p>A hue independent approach will select some lightness focal point. This focal point can be anywhere, but it will be the same regardless of the hue. This focal point will be used to calculate new anchor points relative to the focal point based on the given \u0251 that will guide the chroma reduction.</p> <p>A hue dependent approach will select a lightness focal point for each hue. In such approaches, the lightness selected is often a lightness value that corresponds with the maximum chroma for the current hue in the target gamut, this lightness and chroma point being called the cusp. By biasing chroma reduction towards the lightness of the cusp, it better accounts for the geometry of the perceptual color space and ensures that the process is providing colors with more, not less, chroma in all situations.</p> Hue Independent (\u0251 = 0.5)Hue Dependent (\u0251 = 0.5) <p></p> <p></p> <p>Note</p> <p>The current algorithms we use to determine anchor points relative to a lightness focal point is described in the following article by the author of Oklab:</p> <ul> <li>Hue independent.</li> <li>Hue dependent.</li> </ul> <p>These algorithms are not specific to Oklab and are general functions that can be applied to any similar color space.</p> <p>Generally, the hue dependent approach is the more preferable approach, but it is more complex to calculate the cusp in every supported gamut for a every perceptual space in a performant, generic way. Conversely, the hue independent approach requires no specialized calculation as the lightness focal point is a single, arbitrary point with no relation to the perceptual hue or the gamut making it fast and easy to calculate the required anchor points, but its practical range will be more limited. If only a smaller factor is needed, the hue dependent approach could be a faster, and a more desirable approach.</p> <p>Currently, ColorAide only implements a hue independent approach as a generalized approach for any perceptual space and any target gamut is difficult, that's not to say that a more specialized, limited hue dependent approach can't be offered in the future, but none are currently offered at this time.</p> <p>To enable hue independent adaptive lightness, simply set the <code>adaptive</code> option in any MINDE chroma or ray trace gamut mapping method. A factor of 0 is equivalent to constant lightness and will disables adaptive lightness. Any other positive value will create a bias towards the focal point of 50% lightness. The biasing of the chroma reduction towards the focal point will increase as the provided factor increases. A practical range might be more in the ballpark of 0 - 0.5, maybe even lower, but higher values can be used if desired.</p> Ray TraceMINDE Chroma <pre><code>&gt;&gt;&gt; Steps(\n...     [\n...         c.fit('srgb', method='raytrace', pspace='oklch', adaptive=0.0)\n...         for c in Color.steps(['oklch(80% 0.4 0)', 'oklch(80% 0.4 360)'], space='oklch', steps=100, hue='longer')\n...     ]\n... )\n[color(--oklch 0.8 0.12455 360 / 1), color(--oklch 0.8 0.12152 3.6364 / 1), color(--oklch 0.8 0.11908 7.2727 / 1), color(--oklch 0.8 0.11718 10.909 / 1), color(--oklch 0.8 0.11577 14.545 / 1), color(--oklch 0.8 0.11484 18.182 / 1), color(--oklch 0.8 0.11437 21.818 / 1), color(--oklch 0.8 0.11434 25.455 / 1), color(--oklch 0.8 0.11476 29.091 / 1), color(--oklch 0.8 0.11563 32.727 / 1), color(--oklch 0.8 0.11697 36.364 / 1), color(--oklch 0.8 0.11881 40 / 1), color(--oklch 0.8 0.12119 43.636 / 1), color(--oklch 0.8 0.12416 47.273 / 1), color(--oklch 0.8 0.12778 50.909 / 1), color(--oklch 0.8 0.13214 54.546 / 1), color(--oklch 0.8 0.13735 58.185 / 1), color(--oklch 0.8 0.14357 61.826 / 1), color(--oklch 0.8 0.15099 65.476 / 1), color(--oklch 0.8 0.15982 69.118 / 1), color(--oklch 0.8 0.17031 72.727 / 1), color(--oklch 0.8 0.16779 76.364 / 1), color(--oklch 0.8 0.1657 80 / 1), color(--oklch 0.8 0.1643 83.636 / 1), color(--oklch 0.8 0.16359 87.273 / 1), color(--oklch 0.8 0.16353 90.909 / 1), color(--oklch 0.8 0.16414 94.545 / 1), color(--oklch 0.8 0.16542 98.182 / 1), color(--oklch 0.8 0.1674 101.82 / 1), color(--oklch 0.8 0.17012 105.45 / 1), color(--oklch 0.8 0.17364 109.09 / 1), color(--oklch 0.8 0.17804 112.73 / 1), color(--oklch 0.8 0.18342 116.36 / 1), color(--oklch 0.8 0.18993 120 / 1), color(--oklch 0.8 0.19775 123.64 / 1), color(--oklch 0.8 0.2071 127.27 / 1), color(--oklch 0.8 0.21831 130.91 / 1), color(--oklch 0.8 0.23178 134.55 / 1), color(--oklch 0.8 0.24809 138.18 / 1), color(--oklch 0.8 0.26802 141.82 / 1), color(--oklch 0.8 0.24828 145.45 / 1), color(--oklch 0.8 0.22524 149.09 / 1), color(--oklch 0.8 0.20717 152.73 / 1), color(--oklch 0.8 0.19271 156.36 / 1), color(--oklch 0.8 0.18097 160 / 1), color(--oklch 0.8 0.17135 163.64 / 1), color(--oklch 0.8 0.16341 167.27 / 1), color(--oklch 0.8 0.15685 170.91 / 1), color(--oklch 0.8 0.15144 174.55 / 1), color(--oklch 0.8 0.14702 178.18 / 1), color(--oklch 0.8 0.14346 181.82 / 1), color(--oklch 0.8 0.14067 185.45 / 1), color(--oklch 0.8 0.13857 189.09 / 1), color(--oklch 0.8 0.13711 192.73 / 1), color(--oklch 0.8 0.13626 196.36 / 1), color(--oklch 0.8 0.136 200 / 1), color(--oklch 0.8 0.13634 203.64 / 1), color(--oklch 0.8 0.13726 207.27 / 1), color(--oklch 0.8 0.1388 210.91 / 1), color(--oklch 0.8 0.141 214.55 / 1), color(--oklch 0.8 0.14391 218.18 / 1), color(--oklch 0.8 0.14309 221.82 / 1), color(--oklch 0.8 0.13463 225.45 / 1), color(--oklch 0.8 0.1276 229.09 / 1), color(--oklch 0.8 0.12174 232.73 / 1), color(--oklch 0.8 0.11684 236.36 / 1), color(--oklch 0.8 0.11276 240 / 1), color(--oklch 0.8 0.10938 243.64 / 1), color(--oklch 0.8 0.10661 247.27 / 1), color(--oklch 0.8 0.10439 250.91 / 1), color(--oklch 0.8 0.10267 254.55 / 1), color(--oklch 0.8 0.1014 258.18 / 1), color(--oklch 0.8 0.10057 261.82 / 1), color(--oklch 0.8 0.10015 265.45 / 1), color(--oklch 0.8 0.10013 269.09 / 1), color(--oklch 0.8 0.10052 272.73 / 1), color(--oklch 0.8 0.10132 276.36 / 1), color(--oklch 0.8 0.10255 280 / 1), color(--oklch 0.8 0.10424 283.64 / 1), color(--oklch 0.8 0.10642 287.27 / 1), color(--oklch 0.8 0.10914 290.91 / 1), color(--oklch 0.8 0.11247 294.55 / 1), color(--oklch 0.8 0.11649 298.18 / 1), color(--oklch 0.8 0.12132 301.82 / 1), color(--oklch 0.8 0.1271 305.45 / 1), color(--oklch 0.8 0.13402 309.09 / 1), color(--oklch 0.8 0.14236 312.73 / 1), color(--oklch 0.8 0.15245 316.36 / 1), color(--oklch 0.8 0.1648 320 / 1), color(--oklch 0.8 0.18012 323.64 / 1), color(--oklch 0.8 0.19909 327.27 / 1), color(--oklch 0.8 0.18377 330.91 / 1), color(--oklch 0.8 0.1711 334.55 / 1), color(--oklch 0.8 0.16053 338.18 / 1), color(--oklch 0.8 0.15168 341.82 / 1), color(--oklch 0.8 0.14423 345.45 / 1), color(--oklch 0.8 0.13796 349.09 / 1), color(--oklch 0.8 0.13268 352.73 / 1), color(--oklch 0.8 0.12824 356.36 / 1), color(--oklch 0.8 0.12455 360 / 1)]\n&gt;&gt;&gt; Steps(\n...     [\n...         c.fit('srgb', method='raytrace', pspace='oklch', adaptive=0.5)\n...         for c in Color.steps(['oklch(80% 0.4 0)', 'oklch(80% 0.4 360)'], space='oklch', steps=100, hue='longer')\n...     ]\n... )\n[color(--oklch 0.73529 0.17729 0 / 1), color(--oklch 0.73426 0.17375 3.6364 / 1), color(--oklch 0.73342 0.17086 7.2727 / 1), color(--oklch 0.73275 0.16857 10.909 / 1), color(--oklch 0.73225 0.16684 14.545 / 1), color(--oklch 0.7319 0.16565 18.182 / 1), color(--oklch 0.73171 0.16498 21.818 / 1), color(--oklch 0.73167 0.16483 25.455 / 1), color(--oklch 0.73177 0.1652 29.091 / 1), color(--oklch 0.73203 0.16608 32.727 / 1), color(--oklch 0.73244 0.16751 36.364 / 1), color(--oklch 0.73302 0.16949 40 / 1), color(--oklch 0.73377 0.17207 43.636 / 1), color(--oklch 0.7347 0.17528 47.273 / 1), color(--oklch 0.73584 0.17918 50.91 / 1), color(--oklch 0.73709 0.18351 54.546 / 1), color(--oklch 0.73478 0.17554 58.182 / 1), color(--oklch 0.73286 0.16893 61.818 / 1), color(--oklch 0.73128 0.16349 65.455 / 1), color(--oklch 0.72998 0.15904 69.091 / 1), color(--oklch 0.72895 0.15549 72.726 / 1), color(--oklch 0.72815 0.15273 76.357 / 1), color(--oklch 0.72757 0.1507 79.992 / 1), color(--oklch 0.72717 0.14935 83.633 / 1), color(--oklch 0.72697 0.14865 87.271 / 1), color(--oklch 0.72695 0.1486 90.909 / 1), color(--oklch 0.72712 0.14919 94.545 / 1), color(--oklch 0.72748 0.15042 98.182 / 1), color(--oklch 0.72804 0.15234 101.82 / 1), color(--oklch 0.7288 0.15498 105.45 / 1), color(--oklch 0.7298 0.1584 109.09 / 1), color(--oklch 0.73105 0.16269 112.73 / 1), color(--oklch 0.73258 0.16796 116.36 / 1), color(--oklch 0.73444 0.17437 120 / 1), color(--oklch 0.73669 0.1821 123.64 / 1), color(--oklch 0.73939 0.19141 127.27 / 1), color(--oklch 0.74266 0.20266 130.91 / 1), color(--oklch 0.74663 0.21632 134.55 / 1), color(--oklch 0.75149 0.23305 138.18 / 1), color(--oklch 0.75752 0.25379 141.82 / 1), color(--oklch 0.75155 0.23325 145.45 / 1), color(--oklch 0.74469 0.20967 149.09 / 1), color(--oklch 0.73941 0.19148 152.73 / 1), color(--oklch 0.73524 0.17711 156.36 / 1), color(--oklch 0.73188 0.16556 160 / 1), color(--oklch 0.72915 0.15617 163.64 / 1), color(--oklch 0.72692 0.14848 167.27 / 1), color(--oklch 0.72508 0.14216 170.91 / 1), color(--oklch 0.72357 0.13698 174.55 / 1), color(--oklch 0.72235 0.13275 178.18 / 1), color(--oklch 0.72136 0.12936 181.82 / 1), color(--oklch 0.72059 0.12671 185.45 / 1), color(--oklch 0.72001 0.12471 189.09 / 1), color(--oklch 0.71961 0.12333 192.73 / 1), color(--oklch 0.71938 0.12253 196.36 / 1), color(--oklch 0.7193 0.12229 200 / 1), color(--oklch 0.7194 0.1226 203.64 / 1), color(--oklch 0.71965 0.12347 207.27 / 1), color(--oklch 0.72008 0.12494 210.91 / 1), color(--oklch 0.72068 0.12702 214.55 / 1), color(--oklch 0.72149 0.12979 218.18 / 1), color(--oklch 0.72251 0.13332 221.82 / 1), color(--oklch 0.72379 0.13771 225.46 / 1), color(--oklch 0.72535 0.14311 229.09 / 1), color(--oklch 0.72727 0.14971 232.73 / 1), color(--oklch 0.72963 0.15781 236.36 / 1), color(--oklch 0.72931 0.15671 240 / 1), color(--oklch 0.72816 0.15276 243.64 / 1), color(--oklch 0.72721 0.1495 247.27 / 1), color(--oklch 0.72645 0.14687 250.91 / 1), color(--oklch 0.72585 0.14482 254.55 / 1), color(--oklch 0.72542 0.14332 258.18 / 1), color(--oklch 0.72513 0.14233 261.82 / 1), color(--oklch 0.72499 0.14184 265.45 / 1), color(--oklch 0.72499 0.14185 269.09 / 1), color(--oklch 0.72513 0.14235 272.73 / 1), color(--oklch 0.72542 0.14335 276.36 / 1), color(--oklch 0.72586 0.14486 280 / 1), color(--oklch 0.72646 0.14692 283.64 / 1), color(--oklch 0.72723 0.14955 287.27 / 1), color(--oklch 0.72818 0.15282 290.91 / 1), color(--oklch 0.72933 0.15678 294.55 / 1), color(--oklch 0.7307 0.16151 298.18 / 1), color(--oklch 0.73233 0.16712 301.82 / 1), color(--oklch 0.73425 0.17373 305.45 / 1), color(--oklch 0.73652 0.18152 309.09 / 1), color(--oklch 0.73918 0.1907 312.73 / 1), color(--oklch 0.74233 0.20154 316.36 / 1), color(--oklch 0.74608 0.21443 320 / 1), color(--oklch 0.75056 0.22985 323.64 / 1), color(--oklch 0.75598 0.24851 327.27 / 1), color(--oklch 0.75313 0.2387 330.91 / 1), color(--oklch 0.7496 0.22655 334.55 / 1), color(--oklch 0.74655 0.21605 338.18 / 1), color(--oklch 0.74391 0.20697 341.82 / 1), color(--oklch 0.74163 0.19911 345.45 / 1), color(--oklch 0.73966 0.19233 349.09 / 1), color(--oklch 0.73796 0.1865 352.73 / 1), color(--oklch 0.73651 0.18151 356.36 / 1), color(--oklch 0.73529 0.17729 0 / 1)]\n</code></pre> Gamut: srgb <pre><code>&gt;&gt;&gt; Steps(\n...     [\n...         c.fit('srgb', method='minde-chroma', pspace='oklch', adaptive=0.0, jnd=0)\n...         for c in Color.steps(['oklch(80% 0.4 0)', 'oklch(80% 0.4 360)'], space='oklch', steps=100, hue='longer')\n...     ]\n... )\n[color(--oklch 0.79997 0.12458 359.99 / 1), color(--oklch 0.79997 0.12155 3.6308 / 1), color(--oklch 0.79997 0.11911 7.2679 / 1), color(--oklch 0.79999 0.11718 10.908 / 1), color(--oklch 0.79997 0.11579 14.543 / 1), color(--oklch 0.8 0.11484 18.182 / 1), color(--oklch 0.79995 0.1144 21.818 / 1), color(--oklch 0.79999 0.11435 25.455 / 1), color(--oklch 0.79995 0.11479 29.094 / 1), color(--oklch 0.79994 0.11567 32.733 / 1), color(--oklch 0.79999 0.11698 36.365 / 1), color(--oklch 0.79998 0.11883 40.003 / 1), color(--oklch 0.79995 0.12124 43.647 / 1), color(--oklch 0.79997 0.12419 47.28 / 1), color(--oklch 0.79997 0.12781 50.916 / 1), color(--oklch 0.79995 0.13219 54.558 / 1), color(--oklch 0.79997 0.13738 58.189 / 1), color(--oklch 0.8 0.14355 61.818 / 1), color(--oklch 0.79998 0.15097 65.46 / 1), color(--oklch 0.79999 0.15976 69.093 / 1), color(--oklch 0.8 0.17031 72.728 / 1), color(--oklch 0.80001 0.1678 76.347 / 1), color(--oklch 0.8 0.1657 79.995 / 1), color(--oklch 0.80001 0.16431 83.627 / 1), color(--oklch 0.80001 0.16359 87.26 / 1), color(--oklch 0.8 0.16353 90.904 / 1), color(--oklch 0.8 0.16414 94.543 / 1), color(--oklch 0.8 0.16542 98.181 / 1), color(--oklch 0.80001 0.1674 101.81 / 1), color(--oklch 0.80001 0.17012 105.45 / 1), color(--oklch 0.80001 0.17364 109.09 / 1), color(--oklch 0.80001 0.17804 112.73 / 1), color(--oklch 0.80001 0.18343 116.36 / 1), color(--oklch 0.8 0.18993 120 / 1), color(--oklch 0.8 0.19775 123.64 / 1), color(--oklch 0.8 0.20711 127.27 / 1), color(--oklch 0.8 0.21832 130.91 / 1), color(--oklch 0.8 0.2318 134.55 / 1), color(--oklch 0.8 0.24811 138.19 / 1), color(--oklch 0.8 0.26804 141.82 / 1), color(--oklch 0.80001 0.24832 145.45 / 1), color(--oklch 0.80002 0.22527 149.09 / 1), color(--oklch 0.80002 0.2072 152.72 / 1), color(--oklch 0.80002 0.19274 156.36 / 1), color(--oklch 0.80003 0.18101 159.99 / 1), color(--oklch 0.80001 0.17136 163.63 / 1), color(--oklch 0.80003 0.16343 167.27 / 1), color(--oklch 0.80004 0.15687 170.9 / 1), color(--oklch 0.80001 0.15145 174.54 / 1), color(--oklch 0.80002 0.14703 178.18 / 1), color(--oklch 0.80004 0.14348 181.81 / 1), color(--oklch 0.80003 0.14067 185.45 / 1), color(--oklch 0.8 0.13857 189.09 / 1), color(--oklch 0.8 0.13711 192.73 / 1), color(--oklch 0.80003 0.13627 196.37 / 1), color(--oklch 0.80001 0.13601 200 / 1), color(--oklch 0.80004 0.13634 203.64 / 1), color(--oklch 0.80002 0.13727 207.28 / 1), color(--oklch 0.80003 0.13881 210.92 / 1), color(--oklch 0.80001 0.141 214.55 / 1), color(--oklch 0.80002 0.14392 218.19 / 1), color(--oklch 0.79998 0.14314 221.8 / 1), color(--oklch 0.79999 0.13465 225.44 / 1), color(--oklch 0.79999 0.12762 229.08 / 1), color(--oklch 0.79999 0.12176 232.72 / 1), color(--oklch 0.79999 0.11687 236.35 / 1), color(--oklch 0.79999 0.11277 239.99 / 1), color(--oklch 0.79998 0.10941 243.61 / 1), color(--oklch 0.79999 0.10662 247.27 / 1), color(--oklch 0.8 0.10439 250.91 / 1), color(--oklch 0.79998 0.10268 254.53 / 1), color(--oklch 0.79998 0.10141 258.17 / 1), color(--oklch 0.79999 0.10057 261.81 / 1), color(--oklch 0.79999 0.10015 265.45 / 1), color(--oklch 0.79998 0.10014 269.08 / 1), color(--oklch 0.79998 0.10053 272.72 / 1), color(--oklch 0.79999 0.10133 276.36 / 1), color(--oklch 0.79998 0.10256 280 / 1), color(--oklch 0.79998 0.10425 283.64 / 1), color(--oklch 0.79999 0.10642 287.27 / 1), color(--oklch 0.79999 0.10915 290.91 / 1), color(--oklch 0.79999 0.11247 294.55 / 1), color(--oklch 0.8 0.11649 298.18 / 1), color(--oklch 0.79998 0.12134 301.83 / 1), color(--oklch 0.79999 0.12712 305.46 / 1), color(--oklch 0.79999 0.13405 309.1 / 1), color(--oklch 0.79999 0.14237 312.73 / 1), color(--oklch 0.79998 0.1525 316.38 / 1), color(--oklch 0.79999 0.16483 320.01 / 1), color(--oklch 0.79999 0.18016 323.64 / 1), color(--oklch 0.79999 0.19912 327.27 / 1), color(--oklch 0.79999 0.18379 330.91 / 1), color(--oklch 0.79996 0.17117 334.54 / 1), color(--oklch 0.79999 0.16054 338.18 / 1), color(--oklch 0.79997 0.15173 341.81 / 1), color(--oklch 0.8 0.14424 345.45 / 1), color(--oklch 0.79999 0.13798 349.09 / 1), color(--oklch 0.79998 0.1327 352.72 / 1), color(--oklch 0.79996 0.12828 356.35 / 1), color(--oklch 0.79997 0.12458 359.99 / 1)]\n&gt;&gt;&gt; Steps(\n...     [\n...         c.fit('srgb', method='minde-chroma', pspace='oklch', adaptive=0.5, jnd=0)\n...         for c in Color.steps(['oklch(80% 0.4 0)', 'oklch(80% 0.4 360)'], space='oklch', steps=100, hue='longer')\n...     ]\n... )\n[color(--oklch 0.73528 0.17729 360 / 1), color(--oklch 0.73426 0.17375 3.6363 / 1), color(--oklch 0.73341 0.17087 7.2719 / 1), color(--oklch 0.73275 0.16857 10.908 / 1), color(--oklch 0.73225 0.16684 14.545 / 1), color(--oklch 0.7319 0.16565 18.182 / 1), color(--oklch 0.73171 0.16499 21.818 / 1), color(--oklch 0.73166 0.16484 25.455 / 1), color(--oklch 0.73177 0.1652 29.091 / 1), color(--oklch 0.73203 0.16609 32.727 / 1), color(--oklch 0.73243 0.16752 36.365 / 1), color(--oklch 0.73301 0.1695 40.001 / 1), color(--oklch 0.73377 0.17207 43.637 / 1), color(--oklch 0.7347 0.17529 47.274 / 1), color(--oklch 0.73583 0.17919 50.911 / 1), color(--oklch 0.7371 0.18351 54.543 / 1), color(--oklch 0.73479 0.17555 58.177 / 1), color(--oklch 0.73286 0.16894 61.815 / 1), color(--oklch 0.73128 0.16349 65.451 / 1), color(--oklch 0.72999 0.15905 69.087 / 1), color(--oklch 0.72895 0.15549 72.725 / 1), color(--oklch 0.72815 0.15272 76.361 / 1), color(--oklch 0.72756 0.15069 79.997 / 1), color(--oklch 0.72718 0.14935 83.633 / 1), color(--oklch 0.72697 0.14865 87.272 / 1), color(--oklch 0.72695 0.1486 90.908 / 1), color(--oklch 0.72712 0.14919 94.545 / 1), color(--oklch 0.72749 0.15043 98.18 / 1), color(--oklch 0.72804 0.15234 101.82 / 1), color(--oklch 0.72881 0.15498 105.45 / 1), color(--oklch 0.72981 0.1584 109.09 / 1), color(--oklch 0.73105 0.16269 112.73 / 1), color(--oklch 0.73258 0.16796 116.36 / 1), color(--oklch 0.73445 0.17437 120 / 1), color(--oklch 0.73669 0.1821 123.64 / 1), color(--oklch 0.7394 0.19142 127.27 / 1), color(--oklch 0.74266 0.20266 130.91 / 1), color(--oklch 0.74663 0.21632 134.55 / 1), color(--oklch 0.75149 0.23305 138.18 / 1), color(--oklch 0.75752 0.2538 141.82 / 1), color(--oklch 0.75155 0.23325 145.45 / 1), color(--oklch 0.7447 0.20967 149.09 / 1), color(--oklch 0.73942 0.19149 152.72 / 1), color(--oklch 0.73524 0.17712 156.36 / 1), color(--oklch 0.73189 0.16557 160 / 1), color(--oklch 0.72915 0.15617 163.64 / 1), color(--oklch 0.72692 0.14848 167.27 / 1), color(--oklch 0.72508 0.14216 170.91 / 1), color(--oklch 0.72358 0.13698 174.54 / 1), color(--oklch 0.72235 0.13276 178.18 / 1), color(--oklch 0.72137 0.12936 181.82 / 1), color(--oklch 0.72059 0.12671 185.45 / 1), color(--oklch 0.72002 0.12471 189.09 / 1), color(--oklch 0.71962 0.12333 192.73 / 1), color(--oklch 0.71938 0.12253 196.36 / 1), color(--oklch 0.71931 0.12229 200 / 1), color(--oklch 0.7194 0.1226 203.64 / 1), color(--oklch 0.71966 0.12348 207.27 / 1), color(--oklch 0.72009 0.12494 210.91 / 1), color(--oklch 0.72068 0.12702 214.55 / 1), color(--oklch 0.7215 0.12979 218.19 / 1), color(--oklch 0.72252 0.13332 221.82 / 1), color(--oklch 0.7238 0.13771 225.46 / 1), color(--oklch 0.72536 0.14311 229.09 / 1), color(--oklch 0.72729 0.14972 232.73 / 1), color(--oklch 0.72964 0.15783 236.37 / 1), color(--oklch 0.72931 0.15671 240 / 1), color(--oklch 0.72816 0.15276 243.64 / 1), color(--oklch 0.72721 0.1495 247.27 / 1), color(--oklch 0.72645 0.14687 250.91 / 1), color(--oklch 0.72585 0.14482 254.55 / 1), color(--oklch 0.72541 0.14332 258.18 / 1), color(--oklch 0.72513 0.14233 261.82 / 1), color(--oklch 0.72499 0.14184 265.45 / 1), color(--oklch 0.72499 0.14185 269.09 / 1), color(--oklch 0.72513 0.14235 272.73 / 1), color(--oklch 0.72542 0.14335 276.36 / 1), color(--oklch 0.72586 0.14486 280 / 1), color(--oklch 0.72646 0.14692 283.64 / 1), color(--oklch 0.72723 0.14955 287.27 / 1), color(--oklch 0.72818 0.15282 290.91 / 1), color(--oklch 0.72933 0.15678 294.55 / 1), color(--oklch 0.7307 0.16151 298.18 / 1), color(--oklch 0.73233 0.16712 301.82 / 1), color(--oklch 0.73425 0.17374 305.46 / 1), color(--oklch 0.73652 0.18153 309.09 / 1), color(--oklch 0.73918 0.1907 312.73 / 1), color(--oklch 0.74233 0.20155 316.37 / 1), color(--oklch 0.74608 0.21443 320 / 1), color(--oklch 0.75056 0.22986 323.64 / 1), color(--oklch 0.75598 0.24851 327.27 / 1), color(--oklch 0.75313 0.2387 330.91 / 1), color(--oklch 0.7496 0.22656 334.54 / 1), color(--oklch 0.74654 0.21606 338.18 / 1), color(--oklch 0.74391 0.20698 341.82 / 1), color(--oklch 0.74162 0.19912 345.45 / 1), color(--oklch 0.73966 0.19233 349.09 / 1), color(--oklch 0.73796 0.1865 352.73 / 1), color(--oklch 0.73651 0.18151 356.36 / 1), color(--oklch 0.73528 0.17729 360 / 1)]\n</code></pre> Gamut: srgb <p>Note</p> <p>Generally, adaptive lightness can be used within any perceptual space against any target gamut using the ray trace or MINDE chroma reduction approach. With that said, it should be noted that some spaces will not perform as well at high \u0251 values due to their geometry regardless of whether the ray trace or MINDE chroma reduction approach is used.</p> <p>The one exception to the above statement is the Luv/LCH<sub>uv</sub> color space which exhibited less accurate results in our testing when using the ray trace approach and high \u0251 values that strayed too far from constant lightness. The dark blue region of Luv/LCH<sub>uv</sub> created chroma reduction curves that pushed the ray trace algorithm too hard with adaptive lightness.</p> <p>While Luv/LCH<sub>uv</sub> is currently the only space provided by ColorAide that had trouble with high \u0251 values when using the ray trace algorithm, there may be others that have yet to be implemented. In these rare cases, it may be better to use MINDE chroma reduction which, while slower, has a straightforward algorithm that is less likely to have issues. For all others, ray trace will give the best performance with comparable results.</p> Ray TraceMINDE Chroma <pre><code>&gt;&gt;&gt; Steps(\n...     [\n...         c.fit('srgb', method='raytrace', pspace='lchuv', adaptive=0.0)\n...         for c in Color.steps(['color(--lchuv 10% 100 270)', 'color(--lchuv 90% 100 270)'], space='luv', steps=100)\n...     ]\n... )\n[color(--luv 10 0 -36.496 / 1), color(--luv 10.808 0 -39.445 / 1), color(--luv 11.616 0 -42.394 / 1), color(--luv 12.424 0 -45.343 / 1), color(--luv 13.232 0 -48.292 / 1), color(--luv 14.04 0 -51.241 / 1), color(--luv 14.848 0 -54.19 / 1), color(--luv 15.657 0 -57.14 / 1), color(--luv 16.465 0 -60.089 / 1), color(--luv 17.273 0 -63.038 / 1), color(--luv 18.081 0 -65.987 / 1), color(--luv 18.889 0 -68.936 / 1), color(--luv 19.697 0 -71.885 / 1), color(--luv 20.505 0 -74.834 / 1), color(--luv 21.313 0 -77.783 / 1), color(--luv 22.121 0 -80.733 / 1), color(--luv 22.929 0 -83.682 / 1), color(--luv 23.737 0 -86.631 / 1), color(--luv 24.545 0 -89.58 / 1), color(--luv 25.354 0 -92.529 / 1), color(--luv 26.162 0 -95.478 / 1), color(--luv 26.97 0 -98.427 / 1), color(--luv 27.778 0 -100 / 1), color(--luv 28.586 0 -100 / 1), color(--luv 29.394 0 -100 / 1), color(--luv 30.202 0 -100 / 1), color(--luv 31.01 0 -100 / 1), color(--luv 31.818 0 -100 / 1), color(--luv 32.626 0 -100 / 1), color(--luv 33.434 0 -100 / 1), color(--luv 34.242 0 -100 / 1), color(--luv 35.051 0 -100 / 1), color(--luv 35.859 0 -100 / 1), color(--luv 36.667 0 -100 / 1), color(--luv 37.475 0 -100 / 1), color(--luv 38.283 0 -100 / 1), color(--luv 39.091 0 -100 / 1), color(--luv 39.899 0 -100 / 1), color(--luv 40.707 0 -100 / 1), color(--luv 41.515 0 -100 / 1), color(--luv 42.323 0 -100 / 1), color(--luv 43.131 0 -100 / 1), color(--luv 43.939 0 -100 / 1), color(--luv 44.747 0 -100 / 1), color(--luv 45.556 0 -100 / 1), color(--luv 46.364 0 -100 / 1), color(--luv 47.172 0 -100 / 1), color(--luv 47.98 0 -100 / 1), color(--luv 48.788 0 -100 / 1), color(--luv 49.596 0 -100 / 1), color(--luv 50.404 0 -100 / 1), color(--luv 51.212 0 -100 / 1), color(--luv 52.02 0 -100 / 1), color(--luv 52.828 0 -100 / 1), color(--luv 53.636 0 -100 / 1), color(--luv 54.444 0 -100 / 1), color(--luv 55.253 0 -100 / 1), color(--luv 56.061 0 -100 / 1), color(--luv 56.869 0 -100 / 1), color(--luv 57.677 0 -100 / 1), color(--luv 58.485 0 -100 / 1), color(--luv 59.293 0 -100 / 1), color(--luv 60.101 0 -100 / 1), color(--luv 60.909 0 -100 / 1), color(--luv 61.717 0 -99.125 / 1), color(--luv 62.525 0 -97.155 / 1), color(--luv 63.333 0 -95.16 / 1), color(--luv 64.141 0 -93.143 / 1), color(--luv 64.949 0 -91.105 / 1), color(--luv 65.758 0 -89.049 / 1), color(--luv 66.566 0 -86.976 / 1), color(--luv 67.374 0 -84.888 / 1), color(--luv 68.182 0 -82.786 / 1), color(--luv 68.99 0 -80.672 / 1), color(--luv 69.798 0 -78.548 / 1), color(--luv 70.606 0 -76.414 / 1), color(--luv 71.414 0 -74.272 / 1), color(--luv 72.222 0 -72.124 / 1), color(--luv 73.03 0 -69.971 / 1), color(--luv 73.838 0 -67.813 / 1), color(--luv 74.646 0 -65.652 / 1), color(--luv 75.455 0 -63.488 / 1), color(--luv 76.263 0 -61.324 / 1), color(--luv 77.071 0 -59.159 / 1), color(--luv 77.879 0 -56.994 / 1), color(--luv 78.687 0 -54.831 / 1), color(--luv 79.495 0 -52.67 / 1), color(--luv 80.303 0 -50.511 / 1), color(--luv 81.111 0 -48.356 / 1), color(--luv 81.919 0 -46.205 / 1), color(--luv 82.727 0 -44.059 / 1), color(--luv 83.535 0 -41.918 / 1), color(--luv 84.343 0 -39.782 / 1), color(--luv 85.152 0 -37.652 / 1), color(--luv 85.96 0 -35.53 / 1), color(--luv 86.768 0 -33.414 / 1), color(--luv 87.576 0 -31.305 / 1), color(--luv 88.384 0 -29.204 / 1), color(--luv 89.192 0 -27.111 / 1), color(--luv 90 0 -25.027 / 1)]\n&gt;&gt;&gt; Steps(\n...     [\n...         c.fit('srgb', method='raytrace', pspace='lchuv', adaptive=0.5)\n...         for c in Color.steps(['color(--lchuv 10% 100 270)', 'color(--lchuv 90% 100 270)'], space='luv', steps=100)\n...     ]\n... )\n[color(--luv 17.611 0 -64.273 / 1), color(--luv 17.451 0 -63.689 / 1), color(--luv 17.753 0 -64.79 / 1), color(--luv 17.128 0 -62.511 / 1), color(--luv 19.3 0 -70.437 / 1), color(--luv 18.909 0 -69.008 / 1), color(--luv 20.223 0 -73.806 / 1), color(--luv 20.03 0 -73.099 / 1), color(--luv 35.778 0 -130.57 / 1), color(--luv 32.872 0 -119.97 / 1), color(--luv 30.938 0 -112.91 / 1), color(--luv 29.592 0 -108 / 1), color(--luv 28.638 0 -104.52 / 1), color(--luv 27.96 0 -102.04 / 1), color(--luv 26.531 0 -96.827 / 1), color(--luv 25.668 0 -93.677 / 1), color(--luv 25.499 0 -93.061 / 1), color(--luv 25.618 0 -93.493 / 1), color(--luv 25.886 0 -94.474 / 1), color(--luv 26.246 0 -95.788 / 1), color(--luv 26.669 0 -97.328 / 1), color(--luv 27.136 0 -99.035 / 1), color(--luv 27.778 0 -100 / 1), color(--luv 28.586 0 -100 / 1), color(--luv 29.394 0 -100 / 1), color(--luv 30.202 0 -100 / 1), color(--luv 31.01 0 -100 / 1), color(--luv 31.818 0 -100 / 1), color(--luv 32.626 0 -100 / 1), color(--luv 33.434 0 -100 / 1), color(--luv 34.242 0 -100 / 1), color(--luv 35.051 0 -100 / 1), color(--luv 35.859 0 -100 / 1), color(--luv 36.667 0 -100 / 1), color(--luv 37.475 0 -100 / 1), color(--luv 38.283 0 -100 / 1), color(--luv 39.091 0 -100 / 1), color(--luv 39.899 0 -100 / 1), color(--luv 40.707 0 -100 / 1), color(--luv 41.515 0 -100 / 1), color(--luv 42.323 0 -100 / 1), color(--luv 43.131 0 -100 / 1), color(--luv 43.939 0 -100 / 1), color(--luv 44.747 0 -100 / 1), color(--luv 45.556 0 -100 / 1), color(--luv 46.364 0 -100 / 1), color(--luv 47.172 0 -100 / 1), color(--luv 47.98 0 -100 / 1), color(--luv 48.788 0 -100 / 1), color(--luv 49.596 0 -100 / 1), color(--luv 50.404 0 -100 / 1), color(--luv 51.212 0 -100 / 1), color(--luv 52.02 0 -100 / 1), color(--luv 52.828 0 -100 / 1), color(--luv 53.636 0 -100 / 1), color(--luv 54.444 0 -100 / 1), color(--luv 55.253 0 -100 / 1), color(--luv 56.061 0 -100 / 1), color(--luv 56.869 0 -100 / 1), color(--luv 57.677 0 -100 / 1), color(--luv 58.485 0 -100 / 1), color(--luv 59.293 0 -100 / 1), color(--luv 60.101 0 -100 / 1), color(--luv 60.909 0 -100 / 1), color(--luv 61.67 0 -99.239 / 1), color(--luv 62.362 0 -97.554 / 1), color(--luv 63.041 0 -95.885 / 1), color(--luv 63.705 0 -94.235 / 1), color(--luv 64.356 0 -92.605 / 1), color(--luv 64.993 0 -90.996 / 1), color(--luv 65.616 0 -89.41 / 1), color(--luv 66.227 0 -87.847 / 1), color(--luv 66.825 0 -86.308 / 1), color(--luv 67.41 0 -84.794 / 1), color(--luv 67.983 0 -83.304 / 1), color(--luv 68.544 0 -81.84 / 1), color(--luv 69.093 0 -80.401 / 1), color(--luv 69.631 0 -78.987 / 1), color(--luv 70.157 0 -77.6 / 1), color(--luv 70.673 0 -76.237 / 1), color(--luv 71.178 0 -74.9 / 1), color(--luv 71.672 0 -73.588 / 1), color(--luv 72.156 0 -72.302 / 1), color(--luv 72.629 0 -71.04 / 1), color(--luv 73.093 0 -69.802 / 1), color(--luv 73.548 0 -68.589 / 1), color(--luv 73.993 0 -67.4 / 1), color(--luv 74.429 0 -66.235 / 1), color(--luv 74.855 0 -65.092 / 1), color(--luv 75.274 0 -63.973 / 1), color(--luv 75.683 0 -62.876 / 1), color(--luv 76.084 0 -61.801 / 1), color(--luv 76.478 0 -60.748 / 1), color(--luv 76.863 0 -59.716 / 1), color(--luv 77.24 0 -58.705 / 1), color(--luv 77.61 0 -57.715 / 1), color(--luv 77.972 0 -56.745 / 1), color(--luv 78.327 0 -55.794 / 1), color(--luv 78.675 0 -54.863 / 1), color(--luv 79.016 0 -53.951 / 1)]\n</code></pre> Gamut: srgb <pre><code>&gt;&gt;&gt; Steps(\n...     [\n...         c.fit('srgb', method='minde-chroma', pspace='lchuv', adaptive=0.0, jnd=0)\n...         for c in Color.steps(['color(--lchuv 10% 100 270)', 'color(--lchuv 90% 100 270)'], space='luv', steps=100)\n...     ]\n... )\n[color(--luv 10 -0.00001 -36.496 / 1), color(--luv 10.808 -0.00001 -39.445 / 1), color(--luv 11.616 -0.00001 -42.394 / 1), color(--luv 12.424 -0.00001 -45.343 / 1), color(--luv 13.232 -0.00001 -48.292 / 1), color(--luv 14.04 -0.00001 -51.241 / 1), color(--luv 14.849 -0.00001 -54.19 / 1), color(--luv 15.657 -0.00001 -57.14 / 1), color(--luv 16.465 -0.00001 -60.089 / 1), color(--luv 17.273 0 -63.038 / 1), color(--luv 18.081 0 -65.987 / 1), color(--luv 18.889 0 -68.936 / 1), color(--luv 19.697 0 -71.885 / 1), color(--luv 20.505 0 -74.834 / 1), color(--luv 21.313 -0.00001 -77.783 / 1), color(--luv 22.121 -0.00001 -80.733 / 1), color(--luv 22.929 -0.00001 -83.682 / 1), color(--luv 23.737 -0.00001 -86.631 / 1), color(--luv 24.545 -0.00001 -89.58 / 1), color(--luv 25.354 -0.00001 -92.529 / 1), color(--luv 26.162 -0.00001 -95.478 / 1), color(--luv 26.97 -0.00001 -98.427 / 1), color(--luv 27.778 0 -100 / 1), color(--luv 28.586 0 -100 / 1), color(--luv 29.394 0 -100 / 1), color(--luv 30.202 0 -100 / 1), color(--luv 31.01 0 -100 / 1), color(--luv 31.818 0 -100 / 1), color(--luv 32.626 0 -100 / 1), color(--luv 33.434 0 -100 / 1), color(--luv 34.242 0 -100 / 1), color(--luv 35.051 0 -100 / 1), color(--luv 35.859 0 -100 / 1), color(--luv 36.667 0 -100 / 1), color(--luv 37.475 0 -100 / 1), color(--luv 38.283 0 -100 / 1), color(--luv 39.091 0 -100 / 1), color(--luv 39.899 0 -100 / 1), color(--luv 40.707 0 -100 / 1), color(--luv 41.515 0 -100 / 1), color(--luv 42.323 0 -100 / 1), color(--luv 43.131 0 -100 / 1), color(--luv 43.939 0 -100 / 1), color(--luv 44.747 0 -100 / 1), color(--luv 45.556 0 -100 / 1), color(--luv 46.364 0 -100 / 1), color(--luv 47.172 0 -100 / 1), color(--luv 47.98 0 -100 / 1), color(--luv 48.788 0 -100 / 1), color(--luv 49.596 0 -100 / 1), color(--luv 50.404 0 -100 / 1), color(--luv 51.212 0 -100 / 1), color(--luv 52.02 0 -100 / 1), color(--luv 52.828 0 -100 / 1), color(--luv 53.636 0 -100 / 1), color(--luv 54.444 0 -100 / 1), color(--luv 55.253 0 -100 / 1), color(--luv 56.061 0 -100 / 1), color(--luv 56.869 0 -100 / 1), color(--luv 57.677 0 -100 / 1), color(--luv 58.485 0 -100 / 1), color(--luv 59.293 0 -100 / 1), color(--luv 60.101 0 -100 / 1), color(--luv 60.909 0 -100 / 1), color(--luv 61.717 0 -99.125 / 1), color(--luv 62.525 0 -97.155 / 1), color(--luv 63.333 0.00001 -95.16 / 1), color(--luv 64.141 0 -93.143 / 1), color(--luv 64.949 0.00001 -91.105 / 1), color(--luv 65.758 0 -89.049 / 1), color(--luv 66.566 0.00001 -86.976 / 1), color(--luv 67.374 0.00001 -84.888 / 1), color(--luv 68.182 0 -82.786 / 1), color(--luv 68.99 0.00001 -80.672 / 1), color(--luv 69.798 0.00001 -78.548 / 1), color(--luv 70.606 0.00001 -76.414 / 1), color(--luv 71.414 0.00001 -74.272 / 1), color(--luv 72.222 0 -72.124 / 1), color(--luv 73.03 0 -69.971 / 1), color(--luv 73.838 0.00001 -67.813 / 1), color(--luv 74.646 0 -65.652 / 1), color(--luv 75.455 0 -63.488 / 1), color(--luv 76.263 0 -61.324 / 1), color(--luv 77.071 0 -59.159 / 1), color(--luv 77.879 0 -56.994 / 1), color(--luv 78.687 0.00001 -54.831 / 1), color(--luv 79.495 0 -52.67 / 1), color(--luv 80.303 0 -50.511 / 1), color(--luv 81.111 0 -48.356 / 1), color(--luv 81.919 0 -46.205 / 1), color(--luv 82.727 0 -44.059 / 1), color(--luv 83.535 0.00001 -41.918 / 1), color(--luv 84.343 0 -39.782 / 1), color(--luv 85.152 0 -37.652 / 1), color(--luv 85.96 0.00001 -35.53 / 1), color(--luv 86.768 0 -33.414 / 1), color(--luv 87.576 0 -31.305 / 1), color(--luv 88.384 0 -29.204 / 1), color(--luv 89.192 0 -27.111 / 1), color(--luv 90 0 -25.027 / 1)]\n&gt;&gt;&gt; Steps(\n...     [\n...         c.fit('srgb', method='minde-chroma', pspace='lchuv', adaptive=0.5, jnd=0)\n...         for c in Color.steps(['color(--lchuv 10% 100 270)', 'color(--lchuv 90% 100 270)'], space='luv', steps=100)\n...     ]\n... )\n[color(--luv 18.099 -0.00091 -66.054 / 1), color(--luv 18.433 -0.00004 -67.273 / 1), color(--luv 18.778 -0.00146 -68.533 / 1), color(--luv 19.129 -0.00145 -69.815 / 1), color(--luv 19.489 -0.00153 -71.127 / 1), color(--luv 19.857 -0.00147 -72.47 / 1), color(--luv 20.233 -0.00106 -73.842 / 1), color(--luv 20.617 -0.00008 -75.244 / 1), color(--luv 21.014 -0.00154 -76.693 / 1), color(--luv 21.417 -0.00033 -78.162 / 1), color(--luv 21.832 -0.00103 -79.677 / 1), color(--luv 22.255 -0.00021 -81.22 / 1), color(--luv 22.689 -0.00076 -82.807 / 1), color(--luv 23.134 -0.00084 -84.431 / 1), color(--luv 23.589 -0.00022 -86.09 / 1), color(--luv 24.056 -0.00014 -87.793 / 1), color(--luv 24.534 -0.00031 -89.539 / 1), color(--luv 25.024 -0.00045 -91.327 / 1), color(--luv 25.526 -0.00027 -93.158 / 1), color(--luv 26.041 -0.00093 -95.039 / 1), color(--luv 26.568 -0.00071 -96.961 / 1), color(--luv 27.108 -0.00071 -98.933 / 1), color(--luv 27.778 0 -100 / 1), color(--luv 28.586 0 -100 / 1), color(--luv 29.394 0 -100 / 1), color(--luv 30.202 0 -100 / 1), color(--luv 31.01 0 -100 / 1), color(--luv 31.818 0 -100 / 1), color(--luv 32.626 0 -100 / 1), color(--luv 33.434 0 -100 / 1), color(--luv 34.242 0 -100 / 1), color(--luv 35.051 0 -100 / 1), color(--luv 35.859 0 -100 / 1), color(--luv 36.667 0 -100 / 1), color(--luv 37.475 0 -100 / 1), color(--luv 38.283 0 -100 / 1), color(--luv 39.091 0 -100 / 1), color(--luv 39.899 0 -100 / 1), color(--luv 40.707 0 -100 / 1), color(--luv 41.515 0 -100 / 1), color(--luv 42.323 0 -100 / 1), color(--luv 43.131 0 -100 / 1), color(--luv 43.939 0 -100 / 1), color(--luv 44.747 0 -100 / 1), color(--luv 45.556 0 -100 / 1), color(--luv 46.364 0 -100 / 1), color(--luv 47.172 0 -100 / 1), color(--luv 47.98 0 -100 / 1), color(--luv 48.788 0 -100 / 1), color(--luv 49.596 0 -100 / 1), color(--luv 50.404 0 -100 / 1), color(--luv 51.212 0 -100 / 1), color(--luv 52.02 0 -100 / 1), color(--luv 52.828 0 -100 / 1), color(--luv 53.636 0 -100 / 1), color(--luv 54.444 0 -100 / 1), color(--luv 55.253 0 -100 / 1), color(--luv 56.061 0 -100 / 1), color(--luv 56.869 0 -100 / 1), color(--luv 57.677 0 -100 / 1), color(--luv 58.485 0 -100 / 1), color(--luv 59.293 0 -100 / 1), color(--luv 60.101 0 -100 / 1), color(--luv 60.909 0 -100 / 1), color(--luv 61.67 0.00041 -99.239 / 1), color(--luv 62.362 0.00052 -97.554 / 1), color(--luv 63.041 0.00014 -95.885 / 1), color(--luv 63.705 0.00037 -94.235 / 1), color(--luv 64.356 0.00041 -92.605 / 1), color(--luv 64.993 0.00013 -90.996 / 1), color(--luv 65.616 0.00006 -89.41 / 1), color(--luv 66.227 0.0001 -87.847 / 1), color(--luv 66.825 0.0002 -86.308 / 1), color(--luv 67.41 0.00029 -84.793 / 1), color(--luv 67.983 0.00032 -83.304 / 1), color(--luv 68.544 0.00027 -81.839 / 1), color(--luv 69.093 0.00012 -80.4 / 1), color(--luv 69.631 0.0005 -78.986 / 1), color(--luv 70.158 0.0001 -77.599 / 1), color(--luv 70.673 0.00025 -76.236 / 1), color(--luv 71.178 0.00029 -74.899 / 1), color(--luv 71.672 0.00024 -73.587 / 1), color(--luv 72.156 0.00012 -72.301 / 1), color(--luv 72.63 0.00063 -71.038 / 1), color(--luv 73.094 0.00045 -69.801 / 1), color(--luv 73.548 0.00029 -68.588 / 1), color(--luv 73.993 0.00018 -67.399 / 1), color(--luv 74.429 0.00016 -66.234 / 1), color(--luv 74.856 0.00028 -65.091 / 1), color(--luv 75.274 0.00057 -63.971 / 1), color(--luv 75.684 0.00039 -62.874 / 1), color(--luv 76.085 0.00047 -61.799 / 1), color(--luv 76.478 0.00015 -60.747 / 1), color(--luv 76.863 0.00019 -59.715 / 1), color(--luv 77.241 0.00065 -58.702 / 1), color(--luv 77.61 0.00011 -57.714 / 1), color(--luv 77.972 0.00009 -56.743 / 1), color(--luv 78.328 0.00063 -55.791 / 1), color(--luv 78.676 0.00031 -54.861 / 1), color(--luv 79.017 0.00066 -53.947 / 1)]\n</code></pre> Gamut: srgb"},{"location":"gamut/#pointers-gamut","title":"Pointer's Gamut","text":"<p>New 2.4</p> <p>The Pointer\u2019s gamut is (an approximation of) the gamut of real surface colors as can be seen by the human eye, based on the research by Michael R. Pointer (1980). What this means is that every color that can be reflected by the surface of an object of any material should be is inside the Pointer\u2019s gamut. This does not include, however, those that do not occur naturally, such as neon lights, etc.</p> <p></p> <p>While in the above image, it may appear that most of sRGB is in the gamut, it is important to note that the image is showing the maximum range of the gamut. The actual boundary will be different at different luminance levels.</p> <p></p> <p>The gamuts previously discussed are bound by a color space's limits, but the Pointer's gamut applies to colors more generally and was created from observed data via research. Because it doesn't quite fit with the color space gamut API, ColorAide exposes two special functions to test if a color is in the Pointer's gamut and to fit a color to the gamut.</p> <p>To test if a color is within the gamut, simply call <code>in_pointer_gamut()</code>:</p> <pre><code>&gt;&gt;&gt; Color('red').in_pointer_gamut()\nFalse\n&gt;&gt;&gt; Color('orange').in_pointer_gamut()\nTrue\n</code></pre> Gamut: srgb <p>ColorAide also provides a way to fit a color to the Pointer's gamut. The original gamut's data is described in LCh using illuminant C. Using this color space, we can estimate the chroma limit for any color based on it's lightness and hue. We can then reduce the chroma, preserving the lightness and hue. The image below shows the out of Pointer's gamut color <code>red</code> (indicated by the <code>x</code>) which is clamped to the Pointer's gamut by reducing the chroma (indicated by the dot).</p> <p></p> <p>ColorAide provides the <code>fit_pointer_gamut()</code> method to perform this \"fitting\" of the color.</p> <pre><code>&gt;&gt;&gt; color = Color('red')\n&gt;&gt;&gt; color\ncolor(srgb 1 0 0 / 1)\n&gt;&gt;&gt; color.in_pointer_gamut()\nFalse\n&gt;&gt;&gt; color.fit_pointer_gamut()\ncolor(srgb 0.95687 0.18251 0.09074 / 1)\n&gt;&gt;&gt; color.in_pointer_gamut()\nTrue\n</code></pre> Gamut: srgb <p>Tip</p> <p>Much like <code>in_gamut()</code>, <code>in_pointer_gamut()</code> allows adjusting tolerance as well via the <code>tolerance</code> parameter.</p>"},{"location":"harmonies/","title":"Color Harmonies","text":"<p>Isaac Newton, based on his observations of light interacting with prisms, constructed the first known color wheel. From there, many others built upon this work, sometimes with opposing ideas, but his original work is where color harmony got its start.</p> <p>The original color wheel, while inspired by what was observed by light, was created based on experiments with pigments as well. In paints, red, yellow, and blue are often taught to be primary colors. This idea originates from Newton's work as through his experiments, he came to the conclusions that all colors could be made from red, yellow, and blue, and assumed this was true for light as well. While this isn't exactly true, his work was very important in reshaping how people viewed color.</p> <p>Over time, the color wheel was refined. The traditional model, which we will call an RYB color model, defined 12 colors that made up the wheel: the primary colors, the secondary colors, and the tertiary colors. The secondary colors are created by evenly mixing the primary colors, and the tertiary colors are created by evenly mixing those primary colors with the secondary colors.</p> <pre><code>&gt;&gt;&gt; Wheel(Color('ryb', [1, 0, 0]).harmony('wheel', space='ryb'))\n[color(--ryb 1 0 0 / 1), color(--ryb 1 0.5 0 / 1), color(--ryb 1 1 0 / 1), color(--ryb 0.5 1 0 / 1), color(--ryb 0 1 0 / 1), color(--ryb 0 1 0.5 / 1), color(--ryb 0 1 1 / 1), color(--ryb 0 0.5 1 / 1), color(--ryb 0 0 1 / 1), color(--ryb 0.5 0 1 / 1), color(--ryb 1 0 1 / 1), color(--ryb 1 0 0.5 / 1)]\n</code></pre> Gamut: srgb <p>The concept of color harmonies was formulated on the idea that colors, based on specific, relative position on the wheel, can form more pleasing color combinations.</p>"},{"location":"harmonies/#which-color-space-is-best-for-color-harmonies","title":"Which Color Space is Best for Color Harmonies?","text":"<p>These days, there are many color spaces and models out there: subtractive models, additive models, perceptually uniform models, high dynamic range models, etc. But which space/model is the best for color harmonies?</p> <p>The concept of primary colors stems from the idea that there are a set of pure colors from which all colors can be made from. The primary colors of electronic screens use red, green, and blue light to display its full gamut of color. Interestingly, electronic screens were modeled after the human eye that have three cones, each sensitive to wavelengths close to red, green, and blue. From what the three cones in the eye detect, our brain perceive all the various colors.</p> <p>Paints and inks on the other hand can alter the light that comes back to our eye depending on the medium's light absorption and scattering properties. These physical properties of the medium can alter what light is reflected back to our eyes causing how our eyes perceive the mixing of colors in paint. This mixing behavior in pigments can seem different when compared to how pure light mixes.</p> <p>The work that helped create the first color wheel was done with the limited paints that were available at the time, and influenced by the light scattering and absorption properties of those paints. Because of this, the original color wheel is built on the RYB color model which uses red, yellow, and blue as the primary colors. The question though, is would our theories on color harmony be different today if early theorists had a better understanding of light and color?</p> <p>In reality, we can create a color wheel from any of the various color spaces out there and end up with different results based on how color is spaced and oriented within those spaces. As an example, we could create one directly from the sRGB color space. The sRGB space is an additive color space that was modeled on light behavior, so its primary colors are red, green, and blue. We can simply select the most red, green, and blue colors in its gamut, and transform them into a polar space such as HSL. Here, these colors are evenly spaced and if we mixed these colors evenly, and those colors evenly, we will get 12 colors whose hues are evenly spaced at 30\u02da.</p> <pre><code>&gt;&gt;&gt; Steps([Color('hsl', [x, 1, 0.5]) for x in range(0, 360, 30)])\n[color(--hsl 0 1 0.5 / 1), color(--hsl 30 1 0.5 / 1), color(--hsl 60 1 0.5 / 1), color(--hsl 90 1 0.5 / 1), color(--hsl 120 1 0.5 / 1), color(--hsl 150 1 0.5 / 1), color(--hsl 180 1 0.5 / 1), color(--hsl 210 1 0.5 / 1), color(--hsl 240 1 0.5 / 1), color(--hsl 270 1 0.5 / 1), color(--hsl 300 1 0.5 / 1), color(--hsl 330 1 0.5 / 1)]\n</code></pre> Gamut: srgb <p>From this we can construct an sRGB color wheel.</p> <pre><code>&gt;&gt;&gt; Wheel(Color('red').harmony('wheel', space='srgb'))\n[color(srgb 1 0 0 / 1), color(srgb 1 0.5 0 / 1), color(srgb 1 1 0 / 1), color(srgb 0.5 1 0 / 1), color(srgb 0 1 0 / 1), color(srgb 0 1 0.5 / 1), color(srgb 0 1 1 / 1), color(srgb 0 0.5 1 / 1), color(srgb 0 0 1 / 1), color(srgb 0.5 0 1 / 1), color(srgb 1 0 1 / 1), color(srgb 1 0 0.5 / 1)]\n</code></pre> Gamut: srgb <p>These results are different from the RYB color wheel we showed earlier, but are used to display all the colors you see on your screen right now. This is how light works when not scattered and absorbed by pigments, but does that mean that this color wheel yields better color harmonies?</p> <p>We can transform the RGB color model into a subtractive color space, something similar to what printers use when applying ink to paper. Printers use something closer to an RYB model and use magenta, yellow, and cyan.</p> <pre><code>&gt;&gt;&gt; Wheel(Color('magenta').harmony('wheel', space='cmy'))\n[color(--cmy 0 1 0 / 1), color(--cmy 0 1 0.5 / 1), color(--cmy 0 1 1 / 1), color(--cmy 0 0.5 1 / 1), color(--cmy 0 0 1 / 1), color(--cmy 0.5 0 1 / 1), color(--cmy 1 0 1 / 1), color(--cmy 1 0 0.5 / 1), color(--cmy 1 0 0 / 1), color(--cmy 1 0.5 0 / 1), color(--cmy 1 1 0 / 1), color(--cmy 0.5 1 0 / 1)]\n</code></pre> Gamut: srgb <p>If we were to select the perceptually uniform OkLCh color space, and seed it with red's lightness and chroma, we'd once again get very different results in the color wheel. The results are more similar to when we used sRGB, but the exact hues may be different and lightness is kept more uniform when we construct the wheel. But does that mean this model is better?</p> <pre><code>&gt;&gt;&gt; Wheel(Color('red').harmony('wheel', space='oklch'))\n[color(--oklch 0.62796 0.25768 29.234 / 1), color(--oklch 0.62796 0.25768 59.234 / 1), color(--oklch 0.62796 0.25768 89.234 / 1), color(--oklch 0.62796 0.25768 119.23 / 1), color(--oklch 0.62796 0.25768 149.23 / 1), color(--oklch 0.62796 0.25768 179.23 / 1), color(--oklch 0.62796 0.25768 209.23 / 1), color(--oklch 0.62796 0.25768 239.23 / 1), color(--oklch 0.62796 0.25768 269.23 / 1), color(--oklch 0.62796 0.25768 299.23 / 1), color(--oklch 0.62796 0.25768 329.23 / 1), color(--oklch 0.62796 0.25768 359.23 / 1)]\n</code></pre> Gamut: srgb <p>The truth is that what is better or even harmonious can be largely subjective.</p> <p>Many artists swear by the limited, classical RYB color wheel, and others are fine with using the sRGB color wheel as it is easy to work with in CSS via the HSL color space, and models closer to how the eye works. Additionally, there may be some that prefer a perceptually uniform approach that aims for more consistent hues and predictable lightness.</p> <p>As far as ColorAide is concerned, we've chosen to use OkLCh as the color space in which we work in. This is based mainly on the fact that it keeps hue more consistent than some other options, and it allows us to support a wider gamut than options like HSL.</p> <pre><code>&gt;&gt;&gt; Steps(Color.steps(['black', 'blue', 'white'], steps=11, space='oklch'))\n[color(--oklch 0 0 264.05 / 1), color(--oklch 0.0904 0.06264 264.05 / 1), color(--oklch 0.18081 0.12529 264.05 / 1), color(--oklch 0.27121 0.18793 264.05 / 1), color(--oklch 0.36161 0.25057 264.05 / 1), color(--oklch 0.45201 0.31321 264.05 / 1), color(--oklch 0.56161 0.25057 264.05 / 1), color(--oklch 0.67121 0.18793 264.05 / 1), color(--oklch 0.78081 0.12529 264.05 / 1), color(--oklch 0.8904 0.06264 264.05 / 1), color(--oklch 1 0 264.05 / 1)]\n&gt;&gt;&gt; Steps(Color.steps(['black', 'blue', 'white'], steps=11, space='hsl'))\n[color(--hsl 240 0 0 / 1), color(--hsl 240 0.2 0.1 / 1), color(--hsl 240 0.4 0.2 / 1), color(--hsl 240 0.6 0.3 / 1), color(--hsl 240 0.8 0.4 / 1), color(--hsl 240 1 0.5 / 1), color(--hsl 240 0.8 0.6 / 1), color(--hsl 240 0.6 0.7 / 1), color(--hsl 240 0.4 0.8 / 1), color(--hsl 240 0.2 0.9 / 1), color(--hsl 240 0 1 / 1)]\n&gt;&gt;&gt; Steps(Color.steps(['black', 'blue', 'white'], steps=11, space='lch'))\n[color(--lch 0 0 301.36 / 1), color(--lch 5.9137 26.24 301.36 / 1), color(--lch 11.827 52.481 301.36 / 1), color(--lch 17.741 78.721 301.36 / 1), color(--lch 23.655 104.96 301.36 / 1), color(--lch 29.568 131.2 301.36 / 1), color(--lch 43.655 104.96 301.36 / 1), color(--lch 57.741 78.721 301.36 / 1), color(--lch 71.827 52.481 301.36 / 1), color(--lch 85.914 26.24 301.36 / 1), color(--lch 100 0 301.36 / 1)]\n</code></pre> Gamut: srgb <p>While OkLCh is the default, we make no assertions that this is better than using any other color space. If you are from the world of paint, you may strongly dislike this default and prefer a classical RYB approach, or maybe you just want to use the familiar sRGB approach. We understand that there are many reasons to use other spaces, so use what you like, we won't judge . If you are a color theory purist, you can use the classical RYB model.</p> <pre><code>&gt;&gt;&gt; Steps(Color('red').harmony('complement'))\n[color(--oklch 0.62796 0.25768 29.234 / 1), color(--oklch 0.62796 0.25768 209.23 / 1)]\n&gt;&gt;&gt; Steps(Color('ryb', [1, 0, 0]).harmony('complement', space='ryb'))\n[color(--ryb 1 0 0 / 1), color(--ryb 0 1 1 / 1)]\n</code></pre> Gamut: srgb <p>RYB Model</p> <p>The RYB model has a more limited color gamut than sRGB as the red, yellow and blue primaries cannot make all colors. Additionally, the red, yellow, and blue primaries are not the same as the ones in sRGB, so when using RYB to generate harmonies, make sure you are working directly within RYB to ensure you are not out of gamut.</p> <p>Tip</p> <p>Regardless of what color space <code>harmony()</code> operates in, it can output the results in any color space you need by setting <code>out_space</code>.</p> <pre><code>&gt;&gt;&gt; Steps(Color('red').harmony('complement', out_space='srgb'))\n[color(srgb 1 0 0 / 1), color(srgb -0.56631 0.66342 0.85808 / 1)]\n</code></pre> Gamut: srgb"},{"location":"harmonies/#supported-harmonies","title":"Supported Harmonies","text":"<p>ColorAide currently supports 7 theorized color harmonies: monochromatic, complementary, split complementary, analogous, triadic, square, and rectangular. By default, all color harmonies are calculated with the perceptually uniform OkLCh color space, but other color spaces can be used if desired.</p> <p></p>"},{"location":"harmonies/#monochromatic","title":"Monochromatic","text":"<p>The monochromatic harmony pairs various tints and shades by mixing white and black respectively with the target color to create pleasing color schemes. The number of tints and shades that are created is determined by color distance between white and black via \u2206E<sub>2000</sub>.</p> <p>Then number of colors returned by the monochromatic harmony can be controlled via the <code>count</code> parameter, 5 being the default.</p> <p></p> <pre><code>&gt;&gt;&gt; Steps(Color('red').harmony('mono'))\n[color(--oklch 0.20932 0.08589 29.234 / 1), color(--oklch 0.41864 0.17179 29.234 / 1), color(--oklch 0.62796 0.25768 29.234 / 1), color(--oklch 0.75197 0.17179 29.234 / 1), color(--oklch 0.87599 0.08589 29.234 / 1)]\n&gt;&gt;&gt; Steps(Color('red').harmony('mono', count=8))\n[color(--oklch 0.12559 0.05154 29.234 / 1), color(--oklch 0.25118 0.10307 29.234 / 1), color(--oklch 0.37677 0.15461 29.234 / 1), color(--oklch 0.50236 0.20615 29.234 / 1), color(--oklch 0.62796 0.25768 29.234 / 1), color(--oklch 0.72097 0.19326 29.234 / 1), color(--oklch 0.81398 0.12884 29.234 / 1), color(--oklch 0.90699 0.06442 29.234 / 1)]\n</code></pre> Gamut: srgb <p>Achromatic Colors</p> <p>Pure <code>white</code> and <code>black</code> will not be included in a monochromatic color harmony unless the color is achromatic.</p> <p>New 3.3</p> <p>The <code>count</code> parameter is new in 3.3.</p>"},{"location":"harmonies/#complementary","title":"Complementary","text":"<p>Complementary harmonies use a dyad of colors at opposite ends of the color wheel.</p> <p></p> <pre><code>&gt;&gt;&gt; Steps(Color('red').harmony('complement'))\n[color(--oklch 0.62796 0.25768 29.234 / 1), color(--oklch 0.62796 0.25768 209.23 / 1)]\n</code></pre> Gamut: srgb"},{"location":"harmonies/#split-complementary","title":"Split Complementary","text":"<p>Split Complementary is similar to complementary, but actually uses a triad of colors. Instead of just choosing one complement, it splits and chooses two colors on the opposite side that are close, but not adjacent.</p> <p></p> <pre><code>&gt;&gt;&gt; Steps(Color('red').harmony('split'))\n[color(--oklch 0.62796 0.25768 29.234 / 1), color(--oklch 0.62796 0.25768 239.23 / 1), color(--oklch 0.62796 0.25768 -180.77 / 1)]\n</code></pre> Gamut: srgb"},{"location":"harmonies/#analogous","title":"Analogous","text":"<p>Analogous harmonies consists of 3 adjacent colors.</p> <p></p> <pre><code>&gt;&gt;&gt; Steps(Color('red').harmony('analogous'))\n[color(--oklch 0.62796 0.25768 29.234 / 1), color(--oklch 0.62796 0.25768 59.234 / 1), color(--oklch 0.62796 0.25768 -0.76612 / 1)]\n</code></pre> Gamut: srgb"},{"location":"harmonies/#triadic","title":"Triadic","text":"<p>Triadic draws an equilateral triangle between 3 colors on the color wheel. For instance, the primary colors have triadic harmony.</p> <p></p> <pre><code>&gt;&gt;&gt; Steps(Color('red').harmony('triad'))\n[color(--oklch 0.62796 0.25768 29.234 / 1), color(--oklch 0.62796 0.25768 149.23 / 1), color(--oklch 0.62796 0.25768 269.23 / 1)]\n</code></pre> Gamut: srgb"},{"location":"harmonies/#tetradic-square","title":"Tetradic Square","text":"<p>Tetradic color harmonies refer to a group of four colors. One tetradic color harmony can be found by drawing a square between four colors on the color wheel.</p> <p></p> <pre><code>&gt;&gt;&gt; Steps(Color('red').harmony('square'))\n[color(--oklch 0.62796 0.25768 29.234 / 1), color(--oklch 0.62796 0.25768 119.23 / 1), color(--oklch 0.62796 0.25768 209.23 / 1), color(--oklch 0.62796 0.25768 299.23 / 1)]\n</code></pre> Gamut: srgb"},{"location":"harmonies/#tetradic-rectangular","title":"Tetradic Rectangular","text":"<p>The rectangular tetradic harmony is very similar to the square tetradic harmony except that it draws a rectangle between four colors instead of a square.</p> <p></p> <pre><code>&gt;&gt;&gt; Steps(Color('red').harmony('rectangle'))\n[color(--oklch 0.62796 0.25768 29.234 / 1), color(--oklch 0.62796 0.25768 59.234 / 1), color(--oklch 0.62796 0.25768 209.23 / 1), color(--oklch 0.62796 0.25768 239.23 / 1)]\n</code></pre> Gamut: srgb"},{"location":"harmonies/#others","title":"Others","text":"<p>If you have a particular configuration that you are after that is not covered with the default harmonies, you can use <code>harmony</code> to calculate your own via <code>wheel</code>. The <code>wheel</code> harmony that can generate a wheel of evenly spaced colors of any size. From this, additional harmonies could be calculated. Simply use a color to seed the wheel, specify the space in which to generate the wheel, and optionally, provide the desired number of colors in the color wheel via the <code>count</code> argument. With this, we can generate a wheel of any size for any color.</p> <pre><code>&gt;&gt;&gt; Wheel(Color('ryb', [1, 0, 0]).harmony('wheel', space='ryb', count=48))\n[color(--ryb 1 0 0 / 1), color(--ryb 1 0.125 0 / 1), color(--ryb 1 0.25 0 / 1), color(--ryb 1 0.375 0 / 1), color(--ryb 1 0.5 0 / 1), color(--ryb 1 0.625 0 / 1), color(--ryb 1 0.75 0 / 1), color(--ryb 1 0.875 0 / 1), color(--ryb 1 1 0 / 1), color(--ryb 0.875 1 0 / 1), color(--ryb 0.75 1 0 / 1), color(--ryb 0.625 1 0 / 1), color(--ryb 0.5 1 0 / 1), color(--ryb 0.375 1 0 / 1), color(--ryb 0.25 1 0 / 1), color(--ryb 0.125 1 0 / 1), color(--ryb 0 1 0 / 1), color(--ryb 0 1 0.125 / 1), color(--ryb 0 1 0.25 / 1), color(--ryb 0 1 0.375 / 1), color(--ryb 0 1 0.5 / 1), color(--ryb 0 1 0.625 / 1), color(--ryb 0 1 0.75 / 1), color(--ryb 0 1 0.875 / 1), color(--ryb 0 1 1 / 1), color(--ryb 0 0.875 1 / 1), color(--ryb 0 0.75 1 / 1), color(--ryb 0 0.625 1 / 1), color(--ryb 0 0.5 1 / 1), color(--ryb 0 0.375 1 / 1), color(--ryb 0 0.25 1 / 1), color(--ryb 0 0.125 1 / 1), color(--ryb 0 0 1 / 1), color(--ryb 0.125 0 1 / 1), color(--ryb 0.25 0 1 / 1), color(--ryb 0.375 0 1 / 1), color(--ryb 0.5 0 1 / 1), color(--ryb 0.625 0 1 / 1), color(--ryb 0.75 0 1 / 1), color(--ryb 0.875 0 1 / 1), color(--ryb 1 0 1 / 1), color(--ryb 1 0 0.875 / 1), color(--ryb 1 0 0.75 / 1), color(--ryb 1 0 0.625 / 1), color(--ryb 1 0 0.5 / 1), color(--ryb 1 0 0.375 / 1), color(--ryb 1 0 0.25 / 1), color(--ryb 1 0 0.125 / 1)]\n&gt;&gt;&gt; Steps(Color('ryb', [1, 0, 0]).harmony('wheel', space='ryb', count=48))\n[color(--ryb 1 0 0 / 1), color(--ryb 1 0.125 0 / 1), color(--ryb 1 0.25 0 / 1), color(--ryb 1 0.375 0 / 1), color(--ryb 1 0.5 0 / 1), color(--ryb 1 0.625 0 / 1), color(--ryb 1 0.75 0 / 1), color(--ryb 1 0.875 0 / 1), color(--ryb 1 1 0 / 1), color(--ryb 0.875 1 0 / 1), color(--ryb 0.75 1 0 / 1), color(--ryb 0.625 1 0 / 1), color(--ryb 0.5 1 0 / 1), color(--ryb 0.375 1 0 / 1), color(--ryb 0.25 1 0 / 1), color(--ryb 0.125 1 0 / 1), color(--ryb 0 1 0 / 1), color(--ryb 0 1 0.125 / 1), color(--ryb 0 1 0.25 / 1), color(--ryb 0 1 0.375 / 1), color(--ryb 0 1 0.5 / 1), color(--ryb 0 1 0.625 / 1), color(--ryb 0 1 0.75 / 1), color(--ryb 0 1 0.875 / 1), color(--ryb 0 1 1 / 1), color(--ryb 0 0.875 1 / 1), color(--ryb 0 0.75 1 / 1), color(--ryb 0 0.625 1 / 1), color(--ryb 0 0.5 1 / 1), color(--ryb 0 0.375 1 / 1), color(--ryb 0 0.25 1 / 1), color(--ryb 0 0.125 1 / 1), color(--ryb 0 0 1 / 1), color(--ryb 0.125 0 1 / 1), color(--ryb 0.25 0 1 / 1), color(--ryb 0.375 0 1 / 1), color(--ryb 0.5 0 1 / 1), color(--ryb 0.625 0 1 / 1), color(--ryb 0.75 0 1 / 1), color(--ryb 0.875 0 1 / 1), color(--ryb 1 0 1 / 1), color(--ryb 1 0 0.875 / 1), color(--ryb 1 0 0.75 / 1), color(--ryb 1 0 0.625 / 1), color(--ryb 1 0 0.5 / 1), color(--ryb 1 0 0.375 / 1), color(--ryb 1 0 0.25 / 1), color(--ryb 1 0 0.125 / 1)]\n</code></pre> Gamut: srgb"},{"location":"harmonies/#changing-the-default-harmony-color-space","title":"Changing the Default Harmony Color Space","text":"<p>New 2.7</p> <p>Non-cylindrical space support was added in 2.7.</p> <p>If you'd like to change the <code>Color()</code> class's default harmony color space, it can be done with class override. Simply derive a new <code>Color()</code> class from the original and override the <code>HARMONY</code> property with the name of a suitable color space. Color spaces must be a registered color space of either a cylindrical space, a Lab-like color space, or what we will call a regular, rectangular space. By \"regular\" we mean a normal 3 channel color space usually with a range of [0, 1] (think RGB). Afterwards, all color harmony calculations will use the specified color space unless overridden via the method's <code>space</code> parameter.</p> <pre><code>&gt;&gt;&gt; class Custom(Color):\n...     HARMONY = 'ryb'\n... \n&gt;&gt;&gt; Steps(Custom('red').harmony('split'))\n[color(--ryb 1 0 0 / 1), color(--ryb 0 0.5 1 / 1), color(--ryb 0 1 0.5 / 1)]\n</code></pre> Gamut: srgb <p>Warning</p> <p>Remember that every color space is different. Some may rotate hues in a different direction and some may just not be very compatible for extracting harmonies from.</p> <p>Additionally, a color space may not handle colors beyond its gamut well, for such color spaces, it is important to work within that spaces gamut opposed to picking colors outside of the gamut and relying on gamut mapping.</p>"},{"location":"interpolation/","title":"Color Interpolation","text":"<p>Interpolation is a type of estimation that finds new data points based on the range of a discrete set of known data points. When used in the context of color, it is finding one or more colors that reside between any two given colors. This is often used to simulate mixing colors, creating gradients, or even create color palettes.</p> <p>ColorAide provides a number of useful utilities based on interpolation.</p>"},{"location":"interpolation/#linear-interpolation","title":"Linear Interpolation","text":"<p>Linear interpolation is registered in <code>Color</code> by Default</p> <p>One of the most common, and easiest ways to interpolate data between two points is to use linear interpolation. An easy way of thinking about this concept is to imagine drawing a straight line that connects two colors within a color space. We could then navigate along that line and return colors at different points to simulate mixing colors at various percentages or return the whole range and create a continuous, smooth gradient.</p> <p>To further illustrate this point, the example below shows a slice of the Oklab color space at a lightness of 70%. On this 2D plane, we select two colors: <code>oklab(0.7 0.15 0.1)</code> and <code>oklab(0.7 -0.03 -0.12)</code>. We then connect these two colors with a line. We can then select any point on the line to simulate the mixing of these colors. 0% would yield the first color, 100% would yield the second color, and 50% would yield a new color: <code>oklab(0.7 0.06 -0.01)</code>.</p> <p></p> <p>Figure 1. Interpolation performed at 50%</p> <p>The <code>interpolate</code> method allows a user to create a linear interpolation function using two or more colors. By default, a returned interpolation function accepts numerical input in the domain of [0, 1] and will cause a new color between the specified colors to be returned.</p> <p>By default, colors are interpolated in the perceptually uniform Oklab color space, though any supported color space can be used instead. This also applies to all methods that use interpolation, such as <code>discrete</code>, <code>steps</code>, <code>mix</code>, etc.</p> <p>As an example, below we create an interpolation between <code>rebeccapurple</code> and <code>lch(85% 100 85)</code>. We then step through values of <code>0.0</code>, <code>0.1</code>, <code>0.2</code>, etc. This returns colors at various positions on the line that connects the two colors, <code>0</code> returning <code>rebeccapurple</code> and <code>1</code> returning <code>lch(85% 100 85)</code>.</p> <pre><code>&gt;&gt;&gt; i = Color.interpolate([\"rebeccapurple\", \"lch(85% 100 85)\"], space='lch')\n&gt;&gt;&gt; [i(x / 10).to_string() for x in range(10 + 1)]\n['lch(32.393 61.244 308.86)', 'lch(37.653 65.119 322.47)', 'lch(42.914 68.995 336.09)', 'lch(48.175 72.87 349.7)', 'lch(53.436 76.746 3.3143)', 'lch(58.696 80.622 16.929)', 'lch(63.957 84.497 30.543)', 'lch(69.218 88.373 44.157)', 'lch(74.479 92.249 57.771)', 'lch(79.739 96.124 71.386)', 'lch(85 100 85)']\n</code></pre> Gamut: srgb <p>If we create enough steps, we can create a gradient.</p> <pre><code>&gt;&gt;&gt; i = Color.interpolate(\n...     [\"rebeccapurple\", \"lch(85% 100 85)\"],\n...     space='lch'\n... )\n</code></pre> Gamut: srgb"},{"location":"interpolation/#css-linear-interpolation","title":"CSS Linear Interpolation","text":"<p>New 2.11</p> <p>CSS linear interpolation is registered in <code>Color</code> by Default</p> <p>While ColorAide supports CSS color syntax, it's goal is not to necessarily mirror CSS in all aspects, though often we do provide ways to emulate the behavior.</p> <p>The default linear interpolation that ColorAide uses by default deviates from how CSS handles interpolation. More specifically, it deviates in how undefined hues are resolved during the interpolation steps which directly affects achromatic interpolation results. The difference in handling is subtle, but becomes quite observable when using the <code>longer</code> hue fix-up.</p> <p>Hue Interpolation</p> <p>Hue interpolation, along with fix-ups, is more generally covered in Hue Interpolation.</p> <p>Normally, two colors with defined hues will have a shorter and longer arc length between the two hue angles.</p> ShorterLonger <p></p> <pre><code>&gt;&gt;&gt; Color.interpolate(['red', 'blue'], space='hsl', hue='shorter')\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x7f465481ec60&gt;\n</code></pre> Gamut: srgb <p></p> <pre><code>&gt;&gt;&gt; Color.interpolate(['red', 'blue'], space='hsl', hue='longer')\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x7f465481e8a0&gt;\n</code></pre> Gamut: srgb <p>ColorAide and CSS apply hue fix-ups to ensure proper interpolation occurs along a given hue arc in the desired way. ColorAide's default linear interpolation waits until after hue fix-ups are applied when resolve undefined hues while CSS resolves undefined hues before hue fix-ups are applied.</p> <p>In ColorAide's approach, if only one hue is defined, an arc length does not exist between the undefined hue and the defined hue. This means that during interpolation, the undefined hue will simply inherit the hue from the defined hue during the interpolation calculation.</p> <p>CSS, on the other hand, resolves the undefined hue before hue fix-ups are applied which forces the hue to be defined before during hue fix-ups and creates a pseudo arc length between the undefined and defined hue. This subtle difference makes a large impact when evaluating <code>longer</code> hue interpolations. Instead of interpolating an undefined hue and a defined hue, CSS actually interpolates between either a <code>shorter</code> angel difference of 0\u02da or a <code>longer</code> angle difference of 360\u02da.</p> CSS LongerColorAide Longer <p></p> <pre><code>&gt;&gt;&gt; Color.interpolate(['hsl(0 75 50)', 'hsl(none 0 50)'], space='hsl', method='css-linear', hue='longer')\n&lt;coloraide.interpolate.css_linear.InterpolatorCSSLinear object at 0x7f46549f12b0&gt;\n</code></pre> Gamut: srgb <p></p> <pre><code>&gt;&gt;&gt; Color.interpolate(['hsl(0 75 50)', 'hsl(none 0 50)'], space='hsl', method='linear', hue='longer')\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x7f465481e8a0&gt;\n</code></pre> Gamut: srgb <p>There may be arguments as to why some feel CSS's approach is more or less appropriate, but our desire is only to clarify the differences and make known why our default is the way it is. If a CSS compatible linear interpolation is needed, then <code>css-linear</code> can be specified as the interpolation <code>method</code>. If <code>css-linear</code> is desired as the default approach, the <code>Color</code> object can be subclassed and configured to do so.</p> <pre><code>&gt;&gt;&gt; from coloraide import Color as Base\n&gt;&gt;&gt; class Color(Base):\n...     INTERPOLATOR = 'css-linear'\n... \n&gt;&gt;&gt; Color.interpolate(['red', 'transparent', 'blue'], space='hsl', hue='longer')\n&lt;coloraide.interpolate.css_linear.InterpolatorCSSLinear object at 0x7f46548816d0&gt;\n</code></pre> Gamut: srgb"},{"location":"interpolation/#piecewise-interpolation","title":"Piecewise Interpolation","text":"<p>Piecewise interpolation takes the idea of linear interpolation and then applies it to multiple colors. As drawing a straight line through a series of points greater than two can be difficult to achieve, piecewise interpolation creates straight lines between each color in a chain of colors.</p> <p></p> <p>When the <code>interpolate</code> method receives more that two colors, the interpolation will utilize piecewise interpolation and interpolation will be broken up between each pair of colors. The function, just like when interpolating between two colors, still operates by default in the domain of [0, 1], only it will now apply to the entire range of colors.</p> <p>Piecewise interpolation simply breaks up a series of data points into segments in order to apply interpolation individually on each segment.</p> <pre><code>&gt;&gt;&gt; Color.interpolate(['black', 'red', 'white'])\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x7f465481ed50&gt;\n</code></pre> Gamut: srgb <p>This approach generally works well, but since the placement of colors may not be in a straight line, you will often have pivot points and the transition may not be quite as smooth at these locations.</p>"},{"location":"interpolation/#continuous-interpolation","title":"Continuous Interpolation","text":"<p>Continuous interpolation is registered in <code>Color</code> by Default</p> <p>In this document, we use the term \"continuous\" in two ways when talking about interpolation: continuous vs discrete  and the interpolation method whose literal name is <code>continuous</code>.</p> <p>The <code>continuous</code> interpolation approach, is simply a piecewise, linear interpolation method that interpolates defined channels continuously across two or more segments with undefined channels, essentially taking into account all the segments in the piecewise chain when processing undefined channels. This differs from the default CSS piecewise interpolation approach which only takes into context two segments at any given time. What this means is that if you have multiple colors, and one or more of the colors have the same channel undefined, the colors with that channel defined will be interpolated across the undefined gaps spanning one or more segments in the chain.</p> <p>In this example, we have 3 colors. The end colors both define lightness, but the middle color is undefined. We can see that when we use normal, linear piecewise interpolation that we get a discontinuity. But with <code>continuous</code> interpolation, we get a smooth interpolation of the lightness through the undefined channel.</p> <pre><code>&gt;&gt;&gt; colors = [\n...     Color('oklab', [0, 0, 0]),\n...     Color('oklab', [NaN, -0.03246, -0.31153]),\n...     Color('oklab', [1, 0, 0])\n... ]\n&gt;&gt;&gt; Color.interpolate(colors, space='oklab', method='linear')\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x7f465481e8a0&gt;\n&gt;&gt;&gt; Color.interpolate(colors, space='oklab', method='continuous')\n&lt;coloraide.interpolate.continuous.InterpolatorContinuous object at 0x7f46549f12b0&gt;\n</code></pre> Gamut: srgb <p>Now, if have colors on the side that are not between two defined colors, all those colors will adopt the defined value of the first color on either the right or left that is defined. In the example below, we have a single color with all components defined, but all the colors to the left are missing the lightness. Again, in the normal <code>linear</code> approach, we see a discontinuity, but with the <code>continous</code> approach, all colors with the undefined lightness will assume the lightness of the defined color.</p> <pre><code>&gt;&gt;&gt; colors = [\n...     Color('oklab', [NaN, 0.22486, 0.12585]),\n...     Color('oklab', [NaN, -0.1403, 0.10768]),\n...     Color('oklab', [0.45201, -0.03246, -0.31153])\n... ]\n&gt;&gt;&gt; Color.interpolate(colors, space='oklab', method='linear')\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x7f465481ed50&gt;\n&gt;&gt;&gt; Color.interpolate(colors, space='oklab', method='continuous')\n&lt;coloraide.interpolate.continuous.InterpolatorContinuous object at 0x7f4654882fd0&gt;\n</code></pre> Gamut: srgb <p>This approach is useful for more natural, multi-color interpolations and is used as foundation for our spline interpolation approaches which often require the context of at least four colors when applying their logic.</p>"},{"location":"interpolation/#cubic-spline-interpolation","title":"Cubic Spline Interpolation","text":"<p>Linear interpolation is nice because it is easy to implement, and due to its straight forward nature, pretty fast. With that said, it doesn't always have the smoothest transitions. It turns out that there are other piecewise ways to interpolate that can yield smoother results.</p> <p>Inspired by some efforts seen on the web and in the great JavaScript library Culori, ColorAide implements a number of spline based interpolation methods.</p> <p>Because splines require taking into account more than two colors at a time, all spline based interpolation methods are built off of the <code>continuous</code> interpolation approach of handling undefined values.</p>"},{"location":"interpolation/#b-spline","title":"B-Spline","text":"<p>B-Spline interpolation is registered in <code>Color</code> by Default</p> <p></p> <p>B-spline is a piecewise spline similar to Bezier curves. It utilizes \"control points\" that help shape the interpolation path through a series of colors. Like Bezier Curves, the path does not pass through the control points, but it is clamped at the start and end. Essentially, the interpolation path passes through both end colors and bends that path along the way towards the other colors being used as control points.</p> <p>It can be used by specifying <code>bspline</code> as the interpolation method.</p> <pre><code>&gt;&gt;&gt; Color.interpolate(['red', 'green', 'blue', 'orange'], method='bspline')\n&lt;coloraide.interpolate.bspline.InterpolatorBSpline object at 0x7f46549f12b0&gt;\n</code></pre> Gamut: srgb"},{"location":"interpolation/#natural","title":"Natural","text":"<p>Natural interpolation is registered in <code>Color</code> by Default</p> <p></p> <p>The \"natural\" spline is the same as the B-spline approach except an algorithm is applied that uses the colors as data points and calculates new control points such that the interpolation passes through all the data points. This means that the path will pass through all the colors. The resultant spline has the continuity and properties of a natural spline, hence the name.</p> <p>One down side is that it can overshoot or undershoot a bit, and can occasionally cause the interpolation path to pass out of gamut if interpolating on an edge.</p> <p>It can be used by specifying <code>natural</code> as the interpolation method.</p> <pre><code>&gt;&gt;&gt; Color.interpolate(['red', 'green', 'blue', 'orange'], method='natural')\n&lt;coloraide.interpolate.bspline_natural.InterpolatorNaturalBSpline object at 0x7f46549f12b0&gt;\n</code></pre> Gamut: srgb"},{"location":"interpolation/#monotone","title":"Monotone","text":"<p>Monotone interpolation is registered in <code>Color</code> by Default</p> <p></p> <p>The \"monotone\" spline is a piecewise interpolation spline that passes through all its data points and helps to preserve monotonicity. As far as we are concerned, the important thing to note is that it greatly reduces any overshoot or undershoot in the interpolation.</p> <pre><code>&gt;&gt;&gt; Color.interpolate(['red', 'green', 'blue', 'orange'], method='monotone')\n&lt;coloraide.interpolate.monotone.InterpolatorMonotone object at 0x7f46549f12b0&gt;\n</code></pre> Gamut: srgb"},{"location":"interpolation/#catmull-rom","title":"Catmull-Rom","text":"<p>Catmull-Rom interpolation is not registered in <code>Color</code> by Default</p> <p></p> <p>Lastly, the Catmull-Rom spline is another \"interpolating\" spline that passes through all of its data points, similar to the \"natural\" spline, but it but does not share the same continuity and properties of a \"natural\" spline.</p> <p>Much like the \"natural\" spline, it can overshoot or undershoot.</p> <p>Catmull-Rom is not registered by default, but can be registered as shown below and then used by specifying <code>catrom</code> as the interpolation method.</p> <pre><code>&gt;&gt;&gt; from coloraide import Color\n&gt;&gt;&gt; from coloraide.interpolate.catmull_rom import CatmullRom\n&gt;&gt;&gt; class Custom(Color): ...\n... \n&gt;&gt;&gt; Custom.register(CatmullRom())\n&gt;&gt;&gt; Custom.interpolate(['red', 'green', 'blue', 'orange'], method='catrom')\n&lt;coloraide.interpolate.catmull_rom.InterpolatorCatmullRom object at 0x7f46549f12b0&gt;\n</code></pre> Gamut: srgb"},{"location":"interpolation/#discrete-interpolation","title":"Discrete Interpolation","text":"<p>New 2.5</p> <p>So far, we've only shown examples of continuous interpolation methods. To clarify, we are using \"continuous\" in a slightly different way than we discussed earlier. When we say \"continuous\" here, we simply mean that the colors in the interpolation smoothly transition from one color to the other. But when creating charts or graphs, some times you'd like to categorize data such that a range of values correspond to a specific color. For this, we can use <code>discrete</code>, which like <code>intrpolate</code>, returns an interpolation object, but the ranges will be discrete.</p> <p>By default, ranges are calculated directly form the input colors. So if you had three colors, the interpolation would be broken up into 3 ranges. Compare this with the \"continuous\" interpolation we methods we showed earlier.</p> <pre><code>&gt;&gt;&gt; Color.discrete(['red', 'green', 'blue'])\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x7f465481ec60&gt;\n&gt;&gt;&gt; Color.interpolate(['red', 'green', 'blue'])\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x7f465481e8a0&gt;\n</code></pre> Gamut: srgb <p>If we specify <code>step</code>, we can create a larger or smaller color scale using the input colors to interpolate the new color scale. And we can use any of the aforementioned interpolation methods to help generate this new discrete scale.</p> <pre><code>&gt;&gt;&gt; Color.discrete(['red', 'green', 'blue'], steps=5, method='catrom')\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x7f465481ec60&gt;\n</code></pre> Gamut: srgb <p>What makes this really useful is if you combine it with custom domains to process data. By default, the domain is <code>[0, 1]</code>, but we can change this to directly correlate the data with our quantized color samples. For instance, let's use a series of discrete colors to represent temperature. Additionally, let's use <code>domain</code> to associate a temperature ranges with the given colors. Now when we input a temperature value, it will align with our discrete color scale.</p> <pre><code>&gt;&gt;&gt; i = Color.discrete(['blue', 'green', 'yellow', 'orange', 'red'], domain=[-32, 32, 60, 85, 95])\n&gt;&gt;&gt; i(-32)\ncolor(--oklab 0.45201 -0.03246 -0.31153 / 1)\n&gt;&gt;&gt; i(40)\ncolor(--oklab 0.51975 -0.1403 0.10768 / 1)\n&gt;&gt;&gt; i(87)\ncolor(--oklab 0.79269 0.05661 0.16138 / 1)\n&gt;&gt;&gt; i(100)\ncolor(--oklab 0.62796 0.22486 0.12585 / 1)\n&gt;&gt;&gt; i\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x7f465481e8a0&gt;\n</code></pre> Gamut: srgb <p>Additionally, color scales can be limited using the <code>padding</code> parameter.</p> <pre><code>&gt;&gt;&gt; Color.discrete(['blue', 'green', 'yellow', 'orange', 'red'])\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x7f465481ed50&gt;\n&gt;&gt;&gt; Color.discrete(['blue', 'green', 'yellow', 'orange', 'red'], padding=[0.25, 0])\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x7f465481ec60&gt;\n</code></pre> Gamut: srgb <p>As <code>discrete()</code> is built on <code>steps()</code>, it can take all the same arguments. Check out <code>steps()</code> to learn more.</p>"},{"location":"interpolation/#hue-interpolation","title":"Hue Interpolation","text":"<p>In interpolation, hues are handled special allowing us to control the way in which hues are evaluated. By default, the shortest angle between two hues is targeted for interpolation, but the <code>hue</code> option allows us to redefine this behavior in a number of interesting ways: <code>shorter</code>, <code>longer</code>, <code>increasing</code>, <code>decreasing</code>, and <code>specified</code>. These hue \"fix-ups\" identify all possible ways in which we can interpolate a hue and come from the CSS level 4 specification.</p> <p>Specified</p> <p>The <code>specified</code> fix-up was at one time specified in the CSS Color Level 4 specification, but is no longer mentioned there. While CSS no longer supports this hue fix-up, we still do. <code>specified</code> simply does not apply any hue fix-up and will use hues as specified, hence the name.</p> <p>To help visualize the different hue methods, consider the following evaluation between <code>hsl(270 50 40)</code> and <code>hsl(780 100 40)</code>. Below we will demonstrate each of the different hue evaluations and explain what it is that they do.</p> shorterlongerincreasingdecreasingspecified <p><code>shorter</code> interpolates along the shortest arc length after normalizing the hues.</p> <p></p> <pre><code>&gt;&gt;&gt; Color.interpolate(\n...     [\"hsl(270 50 40)\", \"hsl(780 100 40)\"],\n...     space='hsl',\n...     hue=\"shorter\"\n... )\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x7f465481e8a0&gt;\n</code></pre> Gamut: srgb <p><code>longer</code> interpolates along the longest arc length after normalizing the hues.</p> <p></p> <pre><code>&gt;&gt;&gt; Color.interpolate(\n...     [\"hsl(270 50 40)\", \"hsl(780 100 40)\"],\n...     space='hsl',\n...     hue=\"longer\"\n... )\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x7f465481e8a0&gt;\n</code></pre> Gamut: srgb <p><code>increasing</code> interpolates counter clockwise (after normalizing the hues), such that the hues are increasing.</p> <p></p> <pre><code>&gt;&gt;&gt; Color.interpolate(\n...     [\"hsl(270 50 40)\", \"hsl(780 100 40)\"],\n...     space='hsl',\n...     hue=\"increasing\"\n... )\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x7f465481e8a0&gt;\n</code></pre> Gamut: srgb <p><code>decreasing</code> interpolates clockwise (after normalizing the hues), such that the hues are decreasing.</p> <p></p> <pre><code>&gt;&gt;&gt; Color.interpolate(\n...     [\"hsl(270 50 40)\", \"hsl(780 100 40)\"],\n...     space='hsl',\n...     hue=\"decreasing\"\n... )\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x7f465481e8a0&gt;\n</code></pre> Gamut: srgb <p><code>specified</code> interpolates from the first color to the second color without applying any hue fix-ups.</p> <p></p> <pre><code>&gt;&gt;&gt; Color.interpolate(\n...     [\"hsl(270 50 40)\", \"hsl(780 100 40)\"],\n...     space='hsl',\n...     hue=\"specified\"\n... )\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x7f465481e8a0&gt;\n</code></pre> Gamut: srgb <p>In general, achromatic colors cannot have an arc length between them and other color. When applying linear interpolation between an achromatic color (or a color which simply does not define the hue), the applied hue fix-up will have little effect. With that said, when using CSS linear interpolation, the algorithm is a little different and it essentially creates pseudo arcs between color pairs with undefined hues and defined hues. Only with the <code>longer</code> hue fix-up does this become apparent. Below we compare CSS linear interpolation to our default linear interpolation.</p> CSS Longer InterpolationDefault Longer Interpolation <p></p> <pre><code>&gt;&gt;&gt; Color.interpolate(['hsl(0 75 50)', 'hsl(none 0 50)'], space='hsl', method='css-linear', hue='longer')\n&lt;coloraide.interpolate.css_linear.InterpolatorCSSLinear object at 0x7f4656ddcf50&gt;\n</code></pre> Gamut: srgb <p></p> <pre><code>&gt;&gt;&gt; Color.interpolate(['hsl(0 75 50)', 'hsl(none 0 50)'], space='hsl', method='linear', hue='longer')\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x7f465481ed50&gt;\n</code></pre> Gamut: srgb"},{"location":"interpolation/#interpolating-with-alpha","title":"Interpolating with Alpha","text":"<p>Interpolating color channels is pretty straight forward and uses traditional linear interpolation logic, but when introducing transparency to a color, interpolation uses a concept known as premultiplication which alters the normal interpolation process.</p> <p>Premultiplication is a technique that tends to produce better results when two colors have differing transparency. It essentially accounts for the transparency and uses it to weight how may a given color channel will contribute to the interpolation. A more transparent color's channels will naturally contribute less.</p> <p>Consider the following example. Normally, when transitioning to a \"transparent\" color, the colors will be more gray during the transition. This is because <code>transparent</code> is actually black. But when using premultiplication, the transition looks just as one would expect as the transparent color's channels are weighted less due to the high transparency.</p> <pre><code>&gt;&gt;&gt; Color.interpolate(['white', 'transparent'], space='srgb', premultiplied=False)\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x7f465481e8a0&gt;\n&gt;&gt;&gt; Color.interpolate(['white', 'transparent'], space='srgb')\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x7f465481e7b0&gt;\n</code></pre> Gamut: srgb <p>As a final example, below we have an opaque orange and a blue that is quite transparent. Logically, the blue shouldn't have as big an affect on the overall color as it is so faint, and yet, in the un-premultiplied example, when mixing the colors equally, we see that the resultant color is also equally influenced by the hue of both colors. In the premultiplied example, we see that orange is still quite dominant at 50% as it is fully opaque.</p> <pre><code>&gt;&gt;&gt; Color('orange').mix(Color('blue').set('alpha', 0.25), space='srgb', premultiplied=False)\ncolor(srgb 0.5 0.32353 0.5 / 0.625)\n&gt;&gt;&gt; Color('orange').mix(Color('blue').set('alpha', 0.25), space='srgb')\ncolor(srgb 0.8 0.51765 0.2 / 0.625)\n</code></pre> Gamut: srgb <p>If we interpolate it, we can see the difference in transition.</p> <pre><code>&gt;&gt;&gt; Color.interpolate(['orange', Color('blue').set('alpha', 0.25)], space='srgb', premultiplied=False)\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x7f465481e8a0&gt;\n&gt;&gt;&gt; Color.interpolate(['orange', Color('blue').set('alpha', 0.25)], space='srgb')\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x7f465481ed50&gt;\n</code></pre> Gamut: srgb <p>There may be some cases where it is desired to use no premultiplication in alpha blending. One could simply be that you need to mimic the same behavior of a system that does not use premultiplied interpolation. If so, simply set <code>premultiplied</code> to <code>False</code> as shown above.</p>"},{"location":"interpolation/#mixing","title":"Mixing","text":"<p>Interpolation Options</p> <p>Any options not consumed by <code>mix</code> will be passed to the underlying <code>interpolation</code> function. This includes options like <code>hue</code>, <code>progress</code>, etc.</p> <p>The <code>mix</code> function is built on top of the <code>interpolate</code> function and provides a simple, quick, and intuitive simple mixing of two colors. Just pass in a color to mix with the base color, and you'll get an equal mix of the two.</p> <pre><code>&gt;&gt;&gt; Color(\"red\").mix(Color(\"blue\"))\ncolor(--oklab 0.53998 0.0962 -0.09284 / 1)\n</code></pre> Gamut: srgb <p>By default, colors are mixed at 50%, but the percentage can be controlled. Here we mix the color <code>blue</code> into the color <code>red</code> at 20%. With <code>blue</code> at 20% and <code>red</code> at 80%, this gives us a more reddish color.</p> <pre><code>&gt;&gt;&gt; Color(\"red\").mix(Color(\"blue\"), 0.2)\ncolor(--oklab 0.59277 0.1734 0.03837 / 1)\n</code></pre> Gamut: srgb <p>As with all interpolation based functions, if needed, a different color space can be specified with the <code>space</code> parameter or even a different interpolation method via <code>method</code>. <code>mix</code> accepts all the same parameters used in <code>interpolate</code>, though concepts like stops and hints are not allowed with mixing.</p> <pre><code>&gt;&gt;&gt; Color(\"red\").mix(Color(\"blue\"), space=\"hsl\", method='bspline')\ncolor(--hsl -60 1 0.5 / 1)\n</code></pre> Gamut: srgb <p>Mix can also accept a string and will create the color for us which is great if we don't need to work with the second color afterwards.</p> <pre><code>&gt;&gt;&gt; Color(\"red\").mix(\"blue\", 0.2)\ncolor(--oklab 0.59277 0.1734 0.03837 / 1)\n</code></pre> Gamut: srgb <p>Mixing will always return a new color unless <code>in_place</code> is set <code>True</code>.</p>"},{"location":"interpolation/#steps","title":"Steps","text":"<p>Interpolation Options</p> <p>Any options not consumed by <code>mix</code> will be passed to the underlying <code>interpolation</code> function. This includes options like <code>hue</code>, <code>progress</code>, etc.</p> <p>The <code>steps</code> method provides an intuitive interface to create lists of discrete colors. Like mixing, it is also built on <code>interpolate</code>. Just provide two or more colors, and specify how many <code>steps</code> are wanted.</p> <pre><code>&gt;&gt;&gt; Color.steps([\"red\", \"blue\"], steps=10)\n[color(--oklab 0.62796 0.22486 0.12585 / 1), color(--oklab 0.60841 0.19627 0.07725 / 1), color(--oklab 0.58886 0.16768 0.02865 / 1), color(--oklab 0.56931 0.13909 -0.01995 / 1), color(--oklab 0.54976 0.1105 -0.06854 / 1), color(--oklab 0.53021 0.08191 -0.11714 / 1), color(--oklab 0.51066 0.05332 -0.16574 / 1), color(--oklab 0.49111 0.02473 -0.21433 / 1), color(--oklab 0.47156 -0.00387 -0.26293 / 1), color(--oklab 0.45201 -0.03246 -0.31153 / 1)]\n</code></pre> Gamut: srgb <p>If desired, multiple colors can be provided, and steps will be returned for all the interpolated segments. When interpolating multiple colors, piecewise interpolation is used (which is covered in more detail later).</p> <pre><code>&gt;&gt;&gt; Color.steps([\"red\", \"orange\", \"yellow\", \"green\"], steps=10)\n[color(--oklab 0.62796 0.22486 0.12585 / 1), color(--oklab 0.68287 0.16878 0.13769 / 1), color(--oklab 0.73778 0.1127 0.14954 / 1), color(--oklab 0.79269 0.05661 0.16138 / 1), color(--oklab 0.85112 0.01395 0.17378 / 1), color(--oklab 0.90955 -0.02871 0.18617 / 1), color(--oklab 0.96798 -0.07137 0.19857 / 1), color(--oklab 0.81857 -0.09435 0.16827 / 1), color(--oklab 0.66916 -0.11732 0.13797 / 1), color(--oklab 0.51975 -0.1403 0.10768 / 1)]\n</code></pre> Gamut: srgb <p>Steps can also be configured to return colors based on a maximum Delta E distance. This means you can ensure the distance between all colors is no greater than a certain value.</p> <p>In this example, we specify the color <code>color(display-p3 0 1 0)</code> and interpolate steps between <code>red</code>. The result gives us an array of colors, where the distance between any two colors should be no greater than the Delta E result of 10.</p> <pre><code>&gt;&gt;&gt; Color.steps(\n...     [Color(\"display-p3\", [0, 1, 0]), \"red\"],\n...     space=\"lch\",\n...     out_space=\"srgb\",\n...     max_delta_e=10\n... )\n[color(srgb -0.5116 1.0183 -0.31067 / 1), color(srgb -0.4504 0.99903 -0.32673 / 1), color(srgb -0.37655 0.97943 -0.33694 / 1), color(srgb -0.27847 0.95946 -0.34286 / 1), color(srgb -0.09291 0.9391 -0.34554 / 1), color(srgb 0.23528 0.91833 -0.34574 / 1), color(srgb 0.34809 0.89715 -0.34401 / 1), color(srgb 0.42823 0.87552 -0.34098 / 1), color(srgb 0.49308 0.85343 -0.33745 / 1), color(srgb 0.54849 0.83088 -0.33349 / 1), color(srgb 0.59727 0.80784 -0.32909 / 1), color(srgb 0.64097 0.7843 -0.32423 / 1), color(srgb 0.6806 0.76025 -0.3189 / 1), color(srgb 0.71679 0.73568 -0.3131 / 1), color(srgb 0.74999 0.71057 -0.30681 / 1), color(srgb 0.78053 0.6849 -0.30002 / 1), color(srgb 0.80865 0.65865 -0.29271 / 1), color(srgb 0.83451 0.6318 -0.28486 / 1), color(srgb 0.85826 0.60433 -0.27644 / 1), color(srgb 0.87999 0.57619 -0.26744 / 1), color(srgb 0.89978 0.54736 -0.25782 / 1), color(srgb 0.9177 0.51777 -0.24752 / 1), color(srgb 0.9338 0.48735 -0.2365 / 1), color(srgb 0.9481 0.456 -0.22467 / 1), color(srgb 0.96064 0.4236 -0.21195 / 1), color(srgb 0.97145 0.38994 -0.19821 / 1), color(srgb 0.98055 0.35476 -0.18326 / 1), color(srgb 0.98796 0.31761 -0.16684 / 1), color(srgb 0.99369 0.27779 -0.14854 / 1), color(srgb 0.99777 0.23405 -0.12767 / 1), color(srgb 1.0002 0.18378 -0.10158 / 1), color(srgb 1.0009 0.11978 -0.06417 / 1), color(srgb 1 0 0 / 1)]\n</code></pre> Gamut: srgb <p><code>max_steps</code> can be used to limit the results of <code>max_delta_e</code> in case result balloons to an unexpected size. Obviously, this affects the Delta E between the colors inversely. It should be noted that steps are injected equally between every color when satisfying a max Delta E limit in order to avoid shifting the midpoint. In some cases, in order to satisfy both the <code>max_delta_e</code> and the <code>max_steps</code> requirement, the number of steps may even be clipped such that they are less than the <code>max_steps</code> limit. <code>max_steps</code> is set to <code>1000</code> by default, but can be set to <code>None</code> if no limit is desired.</p> <pre><code>&gt;&gt;&gt; Color.steps(\n...     [Color(\"display-p3\", [0, 1, 0]), \"red\"],\n...     space=\"lch\",\n...     out_space=\"srgb\",\n...     max_delta_e=10,\n...     max_steps=10\n... )\n[color(srgb -0.5116 1.0183 -0.31067 / 1), color(srgb -0.09291 0.9391 -0.34554 / 1), color(srgb 0.49308 0.85343 -0.33745 / 1), color(srgb 0.6806 0.76025 -0.3189 / 1), color(srgb 0.80865 0.65865 -0.29271 / 1), color(srgb 0.89978 0.54736 -0.25782 / 1), color(srgb 0.96064 0.4236 -0.21195 / 1), color(srgb 0.99369 0.27779 -0.14854 / 1), color(srgb 1 0 0 / 1)]\n</code></pre> Gamut: srgb <p>When specifying a <code>max_delta_e</code>, <code>steps</code> will function as a minimum required steps and will push the delta even smaller if the required steps is greater than the calculated steps via the maximum Delta E limit.</p> <pre><code>&gt;&gt;&gt; Color.steps(\n...     [Color(\"display-p3\", [0, 1, 0]), \"red\"],\n...     space=\"lch\",\n...     out_space=\"srgb\",\n...     max_delta_e=10,\n...     steps=50\n... )\n[color(srgb -0.5116 1.0183 -0.31067 / 1), color(srgb -0.47276 1.0057 -0.32192 / 1), color(srgb -0.42946 0.99307 -0.33039 / 1), color(srgb -0.37992 0.98024 -0.33661 / 1), color(srgb -0.32082 0.96725 -0.341 / 1), color(srgb -0.24447 0.9541 -0.34385 / 1), color(srgb -0.1198 0.94078 -0.34542 / 1), color(srgb 0.15996 0.92729 -0.34592 / 1), color(srgb 0.26558 0.91362 -0.3455 / 1), color(srgb 0.33665 0.89976 -0.34431 / 1), color(srgb 0.3931 0.88572 -0.34248 / 1), color(srgb 0.44104 0.8715 -0.34036 / 1), color(srgb 0.48324 0.85707 -0.33806 / 1), color(srgb 0.52118 0.84244 -0.33557 / 1), color(srgb 0.55582 0.82761 -0.33289 / 1), color(srgb 0.58776 0.81258 -0.33002 / 1), color(srgb 0.61745 0.79733 -0.32696 / 1), color(srgb 0.64519 0.78187 -0.32371 / 1), color(srgb 0.67123 0.76619 -0.32025 / 1), color(srgb 0.69575 0.75029 -0.31659 / 1), color(srgb 0.7189 0.73416 -0.31273 / 1), color(srgb 0.74079 0.7178 -0.30866 / 1), color(srgb 0.76151 0.7012 -0.30437 / 1), color(srgb 0.78113 0.68437 -0.29987 / 1), color(srgb 0.79972 0.66729 -0.29515 / 1), color(srgb 0.81733 0.64995 -0.2902 / 1), color(srgb 0.834 0.63236 -0.28502 / 1), color(srgb 0.84977 0.6145 -0.2796 / 1), color(srgb 0.86467 0.59636 -0.27393 / 1), color(srgb 0.87872 0.57794 -0.26801 / 1), color(srgb 0.89194 0.55922 -0.26182 / 1), color(srgb 0.90434 0.54018 -0.25536 / 1), color(srgb 0.91596 0.52082 -0.2486 / 1), color(srgb 0.92679 0.50111 -0.24154 / 1), color(srgb 0.93686 0.48103 -0.23415 / 1), color(srgb 0.94616 0.46054 -0.22641 / 1), color(srgb 0.95471 0.43961 -0.2183 / 1), color(srgb 0.96252 0.41819 -0.20979 / 1), color(srgb 0.96959 0.39623 -0.20082 / 1), color(srgb 0.97593 0.37364 -0.19136 / 1), color(srgb 0.98155 0.35032 -0.18134 / 1), color(srgb 0.98644 0.32615 -0.17067 / 1), color(srgb 0.99062 0.30093 -0.15926 / 1), color(srgb 0.99409 0.27439 -0.14694 / 1), color(srgb 0.99685 0.24615 -0.13353 / 1), color(srgb 0.99891 0.21556 -0.11841 / 1), color(srgb 1.0002 0.18152 -0.10034 / 1), color(srgb 1.0009 0.14177 -0.07755 / 1), color(srgb 1.0008 0.09013 -0.04535 / 1), color(srgb 1 0 0 / 1)]\n</code></pre> Gamut: srgb <p><code>steps</code> uses the color class's default \u2206E method to calculate max \u2206E, the current default \u2206E being \u2206E<sup>*</sup><sub>ab</sub>. While using something like \u2206E<sup>*</sup><sub>00</sub> is far more accurate, it is a much more expensive operation. If desired, the class's default \u2206E can be changed via subclassing the color object and changing <code>DELTA_E</code> class variable or by manually specifying the method via the <code>delta_e</code> parameter.</p> \u2206E<sup>*</sup><sub>ab</sub>.\u2206E<sup>*</sup><sub>00</sub> <pre><code>&gt;&gt;&gt; Color.steps(\n...     [Color(\"display-p3\", [0, 1, 0]), \"red\"],\n...     space=\"lch\",\n...     out_space=\"srgb\",\n...     max_delta_e=10,\n...     delta_e=\"76\"\n... )\n[color(srgb -0.5116 1.0183 -0.31067 / 1), color(srgb -0.4504 0.99903 -0.32673 / 1), color(srgb -0.37655 0.97943 -0.33694 / 1), color(srgb -0.27847 0.95946 -0.34286 / 1), color(srgb -0.09291 0.9391 -0.34554 / 1), color(srgb 0.23528 0.91833 -0.34574 / 1), color(srgb 0.34809 0.89715 -0.34401 / 1), color(srgb 0.42823 0.87552 -0.34098 / 1), color(srgb 0.49308 0.85343 -0.33745 / 1), color(srgb 0.54849 0.83088 -0.33349 / 1), color(srgb 0.59727 0.80784 -0.32909 / 1), color(srgb 0.64097 0.7843 -0.32423 / 1), color(srgb 0.6806 0.76025 -0.3189 / 1), color(srgb 0.71679 0.73568 -0.3131 / 1), color(srgb 0.74999 0.71057 -0.30681 / 1), color(srgb 0.78053 0.6849 -0.30002 / 1), color(srgb 0.80865 0.65865 -0.29271 / 1), color(srgb 0.83451 0.6318 -0.28486 / 1), color(srgb 0.85826 0.60433 -0.27644 / 1), color(srgb 0.87999 0.57619 -0.26744 / 1), color(srgb 0.89978 0.54736 -0.25782 / 1), color(srgb 0.9177 0.51777 -0.24752 / 1), color(srgb 0.9338 0.48735 -0.2365 / 1), color(srgb 0.9481 0.456 -0.22467 / 1), color(srgb 0.96064 0.4236 -0.21195 / 1), color(srgb 0.97145 0.38994 -0.19821 / 1), color(srgb 0.98055 0.35476 -0.18326 / 1), color(srgb 0.98796 0.31761 -0.16684 / 1), color(srgb 0.99369 0.27779 -0.14854 / 1), color(srgb 0.99777 0.23405 -0.12767 / 1), color(srgb 1.0002 0.18378 -0.10158 / 1), color(srgb 1.0009 0.11978 -0.06417 / 1), color(srgb 1 0 0 / 1)]\n</code></pre> Gamut: srgb <pre><code>&gt;&gt;&gt; Color.steps(\n...     [Color(\"display-p3\", [0, 1, 0]), \"red\"],\n...     space=\"lch\",\n...     out_space=\"srgb\",\n...     max_delta_e=10,\n...     delta_e=\"2000\"\n... )\n[color(srgb -0.5116 1.0183 -0.31067 / 1), color(srgb -0.37655 0.97943 -0.33694 / 1), color(srgb -0.09291 0.9391 -0.34554 / 1), color(srgb 0.34809 0.89715 -0.34401 / 1), color(srgb 0.49308 0.85343 -0.33745 / 1), color(srgb 0.59727 0.80784 -0.32909 / 1), color(srgb 0.6806 0.76025 -0.3189 / 1), color(srgb 0.74999 0.71057 -0.30681 / 1), color(srgb 0.80865 0.65865 -0.29271 / 1), color(srgb 0.85826 0.60433 -0.27644 / 1), color(srgb 0.89978 0.54736 -0.25782 / 1), color(srgb 0.9338 0.48735 -0.2365 / 1), color(srgb 0.96064 0.4236 -0.21195 / 1), color(srgb 0.98055 0.35476 -0.18326 / 1), color(srgb 0.99369 0.27779 -0.14854 / 1), color(srgb 1.0002 0.18378 -0.10158 / 1), color(srgb 1 0 0 / 1)]\n</code></pre> Gamut: srgb <p>And much like <code>interpolate</code>, we can use <code>stops</code> and <code>hints</code> and any of the other supported <code>interpolate</code> features as well.</p> <pre><code>&gt;&gt;&gt; Color.steps(['orange', stop('purple', 0.25), 'green'], method='bspline', steps=10)\n[color(--oklab 0.79269 0.05661 0.16138 / 1), color(--oklab 0.63434 0.09861 0.05147 / 1), color(--oklab 0.51731 0.10434 -0.01701 / 1), color(--oklab 0.48698 0.08246 -0.02298 / 1), color(--oklab 0.47842 0.05764 -0.01527 / 1), color(--oklab 0.4775 0.02611 0.00011 / 1), color(--oklab 0.48271 -0.01079 0.02163 / 1), color(--oklab 0.49251 -0.05172 0.04775 / 1), color(--oklab 0.50536 -0.09534 0.07695 / 1), color(--oklab 0.51975 -0.1403 0.10768 / 1)]\n</code></pre> Gamut: srgb"},{"location":"interpolation/#masking","title":"Masking","text":"<p>If desired, we can mask off specific channels that we do not wish to interpolate. Masking works by cloning the color and setting the specified channels as undefined (internally set to <code>NaN</code>). When interpolating, if one color's channel has a <code>NaN</code>, the other color's channel will be used as the result, keeping that channel at a constant value. If both colors have a <code>NaN</code> for the same channel, then <code>NaN</code> will be returned.</p> <p>Magic Behind NaN</p> <p>There are times when <code>NaN</code> values can happen naturally, such as with achromatic colors with hues. To learn more, check out Undefined Handling/NaN Handling.</p> <p>In the following example, we have a base color of <code>lch(52% 58.1 22.7)</code> which we then interpolate with <code>lch(56% 49.1 257.1)</code>. We then mask off the second color's channels except for <code>hue</code>. Applying this logic, we will end up with a range of colors that maintains the same lightness and chroma as the first color, but with different hues. We can see as we step through the colors that only the hue is interpolated.</p> <pre><code>&gt;&gt;&gt; i = Color.interpolate(\n...     [\"lch(52% 58.1 22.7)\", Color(\"lch(56% 49.1 257.1)\").mask(['lightness', 'chroma', 'alpha'])],\n...     space=\"lch\"\n... )\n&gt;&gt;&gt; [i(x/10).to_string() for x in range(10)]\n['lch(52 58.1 22.7)', 'lch(52 58.1 10.14)', 'lch(52 58.1 357.58)', 'lch(52 58.1 345.02)', 'lch(52 58.1 332.46)', 'lch(52 58.1 319.9)', 'lch(52 58.1 307.34)', 'lch(52 58.1 294.78)', 'lch(52 58.1 282.22)', 'lch(52 58.1 269.66)']\n</code></pre> Gamut: srgb <p>You can also create inverted masks. An inverted mask will mask all except the specified channel.</p> <pre><code>&gt;&gt;&gt; i = Color.interpolate(\n...     [\"lch(52% 58.1 22.7)\", Color(\"lch(56% 49.1 257.1)\").mask('hue', invert=True)],\n...     space=\"lch\"\n... )\n&gt;&gt;&gt; [i(x/10).to_string() for x in range(10)]\n['lch(52 58.1 22.7)', 'lch(52 58.1 10.14)', 'lch(52 58.1 357.58)', 'lch(52 58.1 345.02)', 'lch(52 58.1 332.46)', 'lch(52 58.1 319.9)', 'lch(52 58.1 307.34)', 'lch(52 58.1 294.78)', 'lch(52 58.1 282.22)', 'lch(52 58.1 269.66)']\n</code></pre> Gamut: srgb"},{"location":"interpolation/#easing-functions","title":"Easing Functions","text":"<p>When interpolating, whether using linear interpolation or something like B-Spline interpolation, the transitioning between colors is always linear in time, even if the path to those colors is not. For example, if you are interpolating between 2 colors and you request a <code>0.5</code> point on that line, it will always be in the middle. This is because, no matter how crooked the path, the rate of change on that path is always linear.</p> <p>By default, ColorAide uses linear transitions when interpolating, but there are times that a different, more dynamic transition may be desired. This can be achieved by using the <code>progress</code> parameter on any of the interpolation related functions provided by ColorAide.</p> <p><code>progress</code> accepts an easing function that takes a single <code>time</code> input and returns a new <code>time</code> input. This allows for a user to augment the rate of change when transitioning from one color to another. Inputs are almost always between 0 - 1 unless <code>extrapolate</code> is enabled and the user has manually input a range beyond 0 - 1. Even a change in domain will not affect the range as once the domain is accounted for, internally the domain [0, 1] is used.</p> <p>ColorAide provides 5 basic easing functions out of the box along with <code>cubic_bezier</code> which is used to create all of the aforementioned easing function except <code>linear</code>, which simply returns what is given as an input.</p> <p>Create Your Own Cubic Bezier Easings Online: https://cubic-bezier.com</p> More Common Cubic Bezier Easings <p>The following were all acquired from https://matthewlein.com/tools/ceaser.js.</p> <pre><code>ease_in_quad = cubic_bezier(0.550, 0.085, 0.680, 0.530)\nease_in_cubic = cubic_bezier(0.550, 0.055, 0.675, 0.190)\nease_in_quart = cubic_bezier(0.895, 0.030, 0.685, 0.220)\nease_in_quint = cubic_bezier(0.755, 0.050, 0.855, 0.060)\nease_in_sine = cubic_bezier(0.470, 0.000, 0.745, 0.715)\nease_in_expo = cubic_bezier(0.950, 0.050, 0.795, 0.035)\nease_in_circ = cubic_bezier(0.600, 0.040, 0.980, 0.335)\nease_in_back = cubic_bezier(0.600, -0.280, 0.735, 0.045)\n\nease_out_quad = cubic_bezier(0.250, 0.460, 0.450, 0.940)\nease_out_cubic = cubic_bezier(0.215, 0.610, 0.355, 1.000)\nease_out_quart = cubic_bezier(0.165, 0.840, 0.440, 1.000)\nease_out_quint = cubic_bezier(0.230, 1.000, 0.320, 1.000)\nease_out_sine = cubic_bezier(0.390, 0.575, 0.565, 1.000)\nease_out_expo = cubic_bezier(0.190, 1.000, 0.220, 1.000)\nease_out_circ = cubic_bezier(0.075, 0.820, 0.165, 1.000)\nease_out_back = cubic_bezier(0.175, 0.885, 0.320, 1.275)\n\nease_in_out_quad = cubic_bezier(0.455, 0.030, 0.515, 0.955)\nease_in_out_cubic = cubic_bezier(0.645, 0.045, 0.355, 1.000)\nease_in_out_quart = cubic_bezier(0.770, 0.000, 0.175, 1.000)\nease_in_out_quint = cubic_bezier(0.860, 0.000, 0.070, 1.000)\nease_in_out_sine = cubic_bezier(0.445, 0.050, 0.550, 0.950)\nease_in_out_expo = cubic_bezier(1.000, 0.000, 0.000, 1.000)\nease_in_out_circ = cubic_bezier(0.785, 0.135, 0.150, 0.860)\nease_in_out_back = cubic_bezier(0.680, -0.550, 0.265, 1.550)\n</code></pre> LinearEaseEase InEase OutEase In/OutCubic Bezier <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p>Here, we are using the default \"ease in\" and \"ease out\" easing functions provided by ColorAide.</p> <pre><code>&gt;&gt;&gt; from coloraide import ease_in, ease_out\n&gt;&gt;&gt; Color.interpolate(\n...     [\"green\", \"blue\"],\n...     progress=ease_in\n... )\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x7f465481fb60&gt;\n&gt;&gt;&gt; Color.interpolate(\n...     [\"green\", \"blue\"]\n... )\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x7f465481f890&gt;\n&gt;&gt;&gt; Color.interpolate(\n...     [\"green\", \"blue\"],\n...     progress=ease_out\n... )\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x7f465481e8a0&gt;\n</code></pre> Gamut: srgb <p>Additionally, easing functions can be injected inline which allows a user to control how easing is performed between specific sub-interpolations within piecewise interpolation.</p> <pre><code>&gt;&gt;&gt; Color.interpolate([\"red\", \"green\", ease_out, \"blue\"])\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x7f465481e8a0&gt;\n</code></pre> Gamut: srgb <p>ColorAide even lets you apply easing functions to specific channels, though they can only be done this way for the entire operation. This can be done to one or more channels at a time. Below, we apply an exponential \"ease in\" to <code>alpha</code> while allowing all other channels to interpolate normally.</p> <pre><code>&gt;&gt;&gt; ease_in_expo = cubic_bezier(0.950, 0.050, 0.795, 0.035)\n&gt;&gt;&gt; Color.interpolate(\n...     [\"lch(50% 50 0)\", \"lch(90% 50 260 / 0.5)\"],\n...     progress={\n...         'alpha': ease_in_expo\n...     }\n... )\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x7f465481e8a0&gt;\n</code></pre> Gamut: srgb <p>We can also set all the channels to an easing function via <code>all</code> and then override specific channels. In this case, we exponentially \"ease out\" on all channels except the red channel, which we then force to be linear.</p> <pre><code>&gt;&gt;&gt; ease_out_expo = cubic_bezier(0.190, 1.000, 0.220, 1.000)\n&gt;&gt;&gt; Color.interpolate(\n...     [\"color(srgb 0 1 1)\", \"color(srgb 1 0 0)\"],\n...     progress={\n...         'all': ease_out_expo,\n...         'r': linear\n...     },\n...     space='srgb'\n... )\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x7f465481f890&gt;\n</code></pre> Gamut: srgb"},{"location":"interpolation/#color-stops-and-hints","title":"Color Stops and Hints","text":"<p>Color stops are the position where the transition to and from a color starts and ends. By default, color stops are evenly distributed within the domain of [0, 1], but if desired, these color stops can be shifted.</p> <p>To specify color stops, simply wrap a color in a <code>coloraide.stop</code> object and specify the stop position. Stop positions will then cause the transition of the targeted color to be moved.</p> <pre><code>&gt;&gt;&gt; from coloraide import stop\n&gt;&gt;&gt; Color.interpolate(['orange', 'purple', 'green'])\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x7f465481e8a0&gt;\n&gt;&gt;&gt; Color.interpolate(['orange', stop('purple', 0.25), 'green'])\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x7f465481f890&gt;\n</code></pre> Gamut: srgb <p>Color stops follow the rules as laid out in the CSS spec.</p> <p>CSS gradients also have a concept of \"hints\". Hints essentially define the midpoint between two colors. Instead of reinventing the wheel, and further complicating the interface, we've decided to just demonstrate color hints with easing functions. The logic comes directly from the CSS spec.</p> <p>Using the <code>hint</code> function, we can generate a midpoint easing method that moves the middle of the interpolation transition to the specified point which is relative to the two color stops it is between.</p> <pre><code>&gt;&gt;&gt; from coloraide import hint\n&gt;&gt;&gt; Color.interpolate(['orange', 'purple', 'green'])\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x7f465481fb60&gt;\n&gt;&gt;&gt; Color.interpolate(['orange', hint(0.75), 'purple', 'green'])\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x7f465481e8a0&gt;\n</code></pre> Gamut: srgb"},{"location":"interpolation/#padding","title":"Padding","text":"<p>New 2.6</p> <p>Particularly when interpolating a color scale, it can be useful to \"resize\" the area of the color scale being evaluated. This can generally be done using the <code>padding</code> parameter. Consider the following example using the ColorBrewer scale <code>OrRd</code>.</p> <pre><code>&gt;&gt;&gt; scale = ['#fff7ec', '#fee8c8', '#fdd49e', '#fdbb84', '#fc8d59', '#ef6548', '#d7301f', '#b30000', '#7f0000']\n&gt;&gt;&gt; Color.interpolate(scale, space='srgb')\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x7f465481e6c0&gt;\n&gt;&gt;&gt; Color.discrete(scale, space='srgb', steps=5)\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x7f465481e030&gt;\n&gt;&gt;&gt; Color.interpolate(scale, space='srgb', padding=0.25)\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x7f465481fb60&gt;\n&gt;&gt;&gt; Color.discrete(scale, space='srgb', steps=5, padding=0.25)\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x7f465481e4e0&gt;\n</code></pre> Gamut: srgb <p>Padding can be applied to both sides by specifying a single number, or it can be controlled per side by sending in a sequence of two values.</p> <pre><code>&gt;&gt;&gt; scale = ['#fff7ec', '#fee8c8', '#fdd49e', '#fdbb84', '#fc8d59', '#ef6548', '#d7301f', '#b30000', '#7f0000']\n&gt;&gt;&gt; Color.discrete(scale, space='srgb', steps=5, padding=[0.25, 0])\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x7f465481fb60&gt;\n</code></pre> Gamut: srgb <p>Negative padding is allowed as well.</p> <pre><code>&gt;&gt;&gt; scale = ['#fff7ec', '#fee8c8', '#fdd49e', '#fdbb84', '#fc8d59', '#ef6548', '#d7301f', '#b30000', '#7f0000']\n&gt;&gt;&gt; Color.discrete(scale, space='srgb', steps=5, padding=[-0.25, 0])\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x7f465481e4e0&gt;\n</code></pre> Gamut: srgb <p>If the result extends past the limits, <code>extrapolate</code> needs to be enabled or the values will be clamped to the ends.</p> <pre><code>&gt;&gt;&gt; scale = ['#fff7ec', '#fee8c8', '#fdd49e', '#fdbb84', '#fc8d59', '#ef6548', '#d7301f', '#b30000', '#7f0000']\n&gt;&gt;&gt; Color.discrete(scale, space='srgb', steps=5, padding=[1, 1])\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x7f465481e030&gt;\n&gt;&gt;&gt; Color.discrete(scale, space='srgb', steps=5, padding=[1, 1], extrapolate=True)\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x7f465481e6c0&gt;\n</code></pre> Gamut: srgb"},{"location":"interpolation/#domains","title":"Domains","text":"<p>By default, interpolation has an input domain of [0, 1]. This domain applies to an entire interpolation, even ones that span multiple colors. Generally, this is sufficient and can be used to generate color scales, mixes, and steps in any way that a user needs. When generating colors that should align with data, custom domains can be quite helpful.</p> <p>For instance, associating colors with temperature.</p> <pre><code>&gt;&gt;&gt; i = Color.interpolate(\n...     ['blue', 'green', 'yellow', 'orange', 'red'],\n...     domain=[-32, 32, 60, 85, 95]\n... )\n&gt;&gt;&gt; i(-32)\ncolor(--oklab 0.45201 -0.03246 -0.31153 / 1)\n&gt;&gt;&gt; i(47)\ncolor(--oklab 0.75988 -0.10337 0.15637 / 1)\n&gt;&gt;&gt; i(89)\ncolor(--oklab 0.7268 0.12391 0.14717 / 1)\n&gt;&gt;&gt; i\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x7f465481e6c0&gt;\n</code></pre> Gamut: srgb <p>It should be noted that you are not constrained to provide the exact same amount of domain values as you have colors and can have differing amounts, but if you want to align specific colors to certain data points, then it helps.</p> <pre><code>&gt;&gt;&gt; Color.interpolate(\n...     ['blue', 'green', 'yellow', 'orange', 'red'],\n...     domain=[-32, 32, 60, 85, 95]\n... )\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x7f465481e030&gt;\n&gt;&gt;&gt; Color.interpolate(\n...     ['blue', 'green', 'yellow', 'orange', 'red'],\n...     domain=[-32, 95]\n... )\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x7f465481fb60&gt;\n</code></pre> Gamut: srgb <p>Lastly, domains must be specified in ascending order of values. If a value decreases in magnitude, it will assume the value that comes right before it. This means you cannot put a domain in reverse. If you need to reverse the order, just flip the color order and setup the domain accordingly.</p> <pre><code>&gt;&gt;&gt; i = Color.interpolate(\n...     ['blue', 'green', 'yellow', 'orange', 'red'],\n...     domain=[-32, 32, 60, 20, 95]\n... )\n&gt;&gt;&gt; i.domain\n&lt;bound method Interpolator.domain of &lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x7f465481fb60&gt;&gt;\n&gt;&gt;&gt; i\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x7f465481fb60&gt;\n</code></pre> Gamut: srgb <p>Custom domains are most useful when working with <code>discrete</code> or <code>interpolate</code> directly, but you can use it in other methods like <code>steps</code> as well. As <code>steps</code> does not take data point inputs like <code>interpolate</code>, we do not need to use the temperature data as an input except to set the domain, but the steps will be generated with the same alignment relative to the domain range.</p> <pre><code>&gt;&gt;&gt; Color.interpolate(\n...     ['blue', 'green', 'yellow', 'orange', 'red'],\n...     domain=[-32, 32, 60, 85, 95]\n... )\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x7f465481fb60&gt;\n&gt;&gt;&gt; Color.discrete(\n...     ['blue', 'green', 'yellow', 'orange', 'red'],\n...     domain=[-32, 32, 60, 85, 95]\n... )\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x7f465481e4e0&gt;\n&gt;&gt;&gt; Color.steps(\n...     ['blue', 'green', 'yellow', 'orange', 'red'],\n...     steps=11,\n...     domain=[-32, 32, 60, 85, 95]\n... )\n[color(--oklab 0.45201 -0.03246 -0.31153 / 1), color(--oklab 0.46546 -0.05386 -0.22834 / 1), color(--oklab 0.4789 -0.07526 -0.14516 / 1), color(--oklab 0.49234 -0.09666 -0.06197 / 1), color(--oklab 0.50578 -0.11806 0.02122 / 1), color(--oklab 0.51922 -0.13946 0.1044 / 1), color(--oklab 0.71505 -0.11027 0.14728 / 1), color(--oklab 0.91836 -0.079 0.18851 / 1), color(--oklab 0.90067 -0.02222 0.18429 / 1), color(--oklab 0.81162 0.04279 0.1654 / 1), color(--oklab 0.62796 0.22486 0.12585 / 1)]\n</code></pre> Gamut: srgb <p>Wile you can technically feed <code>domain</code> into <code>mix</code>, it is probably not as useful. It will respect the domain alignment, but mix always accepts a percentage of [0, 1], regardless of the underlying domain.</p>"},{"location":"interpolation/#extrapolation","title":"Extrapolation","text":"<p>By default, ColorAide clamps the entire progress of an interpolation to always be within the domain ([0, 1] by default). In most cases, this is more what most user expects and why this is the default. It should be noted that this does not affect easing functions, as the clamping is done prior to any easing function calls.</p> <p>If it is desired to extrapolate past 0 and 1, <code>extrapolate</code> can set to <code>True</code> on all interpolation methods.</p> <pre><code>&gt;&gt;&gt; Color('red').mix('blue', 0.5)\ncolor(--oklab 0.53998 0.0962 -0.09284 / 1)\n&gt;&gt;&gt; Color('red').mix('blue', -0.5, extrapolate=True)\ncolor(--oklab 0.71593 0.35352 0.34453 / 1)\n</code></pre> Gamut: srgb <p>As a larger example, we can purposely interpolate over a range with values beyond 0 and 1. Here we extended the range to -0.5 and 1.5.</p> <pre><code>&gt;&gt;&gt; offset, factor = 0.25, 1.5\n&gt;&gt;&gt; i = Color.interpolate(['red', 'blue'])\n&gt;&gt;&gt; Ramp([i((r * factor / 100) - offset) for r in range(101)])\n[color(--oklab 0.62796 0.22486 0.12585 / 1), color(--oklab 0.62796 0.22486 0.12585 / 1), color(--oklab 0.62796 0.22486 0.12585 / 1), color(--oklab 0.62796 0.22486 0.12585 / 1), color(--oklab 0.62796 0.22486 0.12585 / 1), color(--oklab 0.62796 0.22486 0.12585 / 1), color(--oklab 0.62796 0.22486 0.12585 / 1), color(--oklab 0.62796 0.22486 0.12585 / 1), color(--oklab 0.62796 0.22486 0.12585 / 1), color(--oklab 0.62796 0.22486 0.12585 / 1), color(--oklab 0.62796 0.22486 0.12585 / 1), color(--oklab 0.62796 0.22486 0.12585 / 1), color(--oklab 0.62796 0.22486 0.12585 / 1), color(--oklab 0.62796 0.22486 0.12585 / 1), color(--oklab 0.62796 0.22486 0.12585 / 1), color(--oklab 0.62796 0.22486 0.12585 / 1), color(--oklab 0.62796 0.22486 0.12585 / 1), color(--oklab 0.62708 0.22358 0.12366 / 1), color(--oklab 0.62444 0.21972 0.1171 / 1), color(--oklab 0.6218 0.21586 0.11054 / 1), color(--oklab 0.61916 0.212 0.10398 / 1), color(--oklab 0.61652 0.20814 0.09742 / 1), color(--oklab 0.61388 0.20428 0.09086 / 1), color(--oklab 0.61124 0.20042 0.0843 / 1), color(--oklab 0.6086 0.19656 0.07774 / 1), color(--oklab 0.60596 0.1927 0.07117 / 1), color(--oklab 0.60332 0.18884 0.06461 / 1), color(--oklab 0.60068 0.18498 0.05805 / 1), color(--oklab 0.59805 0.18112 0.05149 / 1), color(--oklab 0.59541 0.17726 0.04493 / 1), color(--oklab 0.59277 0.1734 0.03837 / 1), color(--oklab 0.59013 0.16954 0.03181 / 1), color(--oklab 0.58749 0.16568 0.02525 / 1), color(--oklab 0.58485 0.16182 0.01869 / 1), color(--oklab 0.58221 0.15796 0.01213 / 1), color(--oklab 0.57957 0.1541 0.00557 / 1), color(--oklab 0.57693 0.15024 -0.00099 / 1), color(--oklab 0.57429 0.14638 -0.00755 / 1), color(--oklab 0.57165 0.14252 -0.01411 / 1), color(--oklab 0.56901 0.13866 -0.02067 / 1), color(--oklab 0.56638 0.1348 -0.02723 / 1), color(--oklab 0.56374 0.13094 -0.0338 / 1), color(--oklab 0.5611 0.12708 -0.04036 / 1), color(--oklab 0.55846 0.12322 -0.04692 / 1), color(--oklab 0.55582 0.11936 -0.05348 / 1), color(--oklab 0.55318 0.1155 -0.06004 / 1), color(--oklab 0.55054 0.11164 -0.0666 / 1), color(--oklab 0.5479 0.10778 -0.07316 / 1), color(--oklab 0.54526 0.10392 -0.07972 / 1), color(--oklab 0.54262 0.10006 -0.08628 / 1), color(--oklab 0.53998 0.0962 -0.09284 / 1), color(--oklab 0.53735 0.09234 -0.0994 / 1), color(--oklab 0.53471 0.08848 -0.10596 / 1), color(--oklab 0.53207 0.08462 -0.11252 / 1), color(--oklab 0.52943 0.08076 -0.11908 / 1), color(--oklab 0.52679 0.0769 -0.12564 / 1), color(--oklab 0.52415 0.07304 -0.1322 / 1), color(--oklab 0.52151 0.06918 -0.13877 / 1), color(--oklab 0.51887 0.06532 -0.14533 / 1), color(--oklab 0.51623 0.06146 -0.15189 / 1), color(--oklab 0.51359 0.05761 -0.15845 / 1), color(--oklab 0.51095 0.05375 -0.16501 / 1), color(--oklab 0.50832 0.04989 -0.17157 / 1), color(--oklab 0.50568 0.04603 -0.17813 / 1), color(--oklab 0.50304 0.04217 -0.18469 / 1), color(--oklab 0.5004 0.03831 -0.19125 / 1), color(--oklab 0.49776 0.03445 -0.19781 / 1), color(--oklab 0.49512 0.03059 -0.20437 / 1), color(--oklab 0.49248 0.02673 -0.21093 / 1), color(--oklab 0.48984 0.02287 -0.21749 / 1), color(--oklab 0.4872 0.01901 -0.22405 / 1), color(--oklab 0.48456 0.01515 -0.23061 / 1), color(--oklab 0.48192 0.01129 -0.23717 / 1), color(--oklab 0.47928 0.00743 -0.24374 / 1), color(--oklab 0.47665 0.00357 -0.2503 / 1), color(--oklab 0.47401 -0.00029 -0.25686 / 1), color(--oklab 0.47137 -0.00415 -0.26342 / 1), color(--oklab 0.46873 -0.00801 -0.26998 / 1), color(--oklab 0.46609 -0.01187 -0.27654 / 1), color(--oklab 0.46345 -0.01573 -0.2831 / 1), color(--oklab 0.46081 -0.01959 -0.28966 / 1), color(--oklab 0.45817 -0.02345 -0.29622 / 1), color(--oklab 0.45553 -0.02731 -0.30278 / 1), color(--oklab 0.45289 -0.03117 -0.30934 / 1), color(--oklab 0.45201 -0.03246 -0.31153 / 1), color(--oklab 0.45201 -0.03246 -0.31153 / 1), color(--oklab 0.45201 -0.03246 -0.31153 / 1), color(--oklab 0.45201 -0.03246 -0.31153 / 1), color(--oklab 0.45201 -0.03246 -0.31153 / 1), color(--oklab 0.45201 -0.03246 -0.31153 / 1), color(--oklab 0.45201 -0.03246 -0.31153 / 1), color(--oklab 0.45201 -0.03246 -0.31153 / 1), color(--oklab 0.45201 -0.03246 -0.31153 / 1), color(--oklab 0.45201 -0.03246 -0.31153 / 1), color(--oklab 0.45201 -0.03246 -0.31153 / 1), color(--oklab 0.45201 -0.03246 -0.31153 / 1), color(--oklab 0.45201 -0.03246 -0.31153 / 1), color(--oklab 0.45201 -0.03246 -0.31153 / 1), color(--oklab 0.45201 -0.03246 -0.31153 / 1), color(--oklab 0.45201 -0.03246 -0.31153 / 1), color(--oklab 0.45201 -0.03246 -0.31153 / 1)]\n&gt;&gt;&gt; i = Color.interpolate(['red', 'blue'], extrapolate=True)\n&gt;&gt;&gt; Ramp([i((r * factor / 100) - offset) for r in range(101)])\n[color(--oklab 0.67194 0.28919 0.23519 / 1), color(--oklab 0.6693 0.28533 0.22863 / 1), color(--oklab 0.66666 0.28147 0.22207 / 1), color(--oklab 0.66402 0.27761 0.21551 / 1), color(--oklab 0.66138 0.27375 0.20895 / 1), color(--oklab 0.65875 0.26989 0.20239 / 1), color(--oklab 0.65611 0.26603 0.19583 / 1), color(--oklab 0.65347 0.26217 0.18927 / 1), color(--oklab 0.65083 0.25831 0.1827 / 1), color(--oklab 0.64819 0.25445 0.17614 / 1), color(--oklab 0.64555 0.2506 0.16958 / 1), color(--oklab 0.64291 0.24674 0.16302 / 1), color(--oklab 0.64027 0.24288 0.15646 / 1), color(--oklab 0.63763 0.23902 0.1499 / 1), color(--oklab 0.63499 0.23516 0.14334 / 1), color(--oklab 0.63235 0.2313 0.13678 / 1), color(--oklab 0.62971 0.22744 0.13022 / 1), color(--oklab 0.62708 0.22358 0.12366 / 1), color(--oklab 0.62444 0.21972 0.1171 / 1), color(--oklab 0.6218 0.21586 0.11054 / 1), color(--oklab 0.61916 0.212 0.10398 / 1), color(--oklab 0.61652 0.20814 0.09742 / 1), color(--oklab 0.61388 0.20428 0.09086 / 1), color(--oklab 0.61124 0.20042 0.0843 / 1), color(--oklab 0.6086 0.19656 0.07774 / 1), color(--oklab 0.60596 0.1927 0.07117 / 1), color(--oklab 0.60332 0.18884 0.06461 / 1), color(--oklab 0.60068 0.18498 0.05805 / 1), color(--oklab 0.59805 0.18112 0.05149 / 1), color(--oklab 0.59541 0.17726 0.04493 / 1), color(--oklab 0.59277 0.1734 0.03837 / 1), color(--oklab 0.59013 0.16954 0.03181 / 1), color(--oklab 0.58749 0.16568 0.02525 / 1), color(--oklab 0.58485 0.16182 0.01869 / 1), color(--oklab 0.58221 0.15796 0.01213 / 1), color(--oklab 0.57957 0.1541 0.00557 / 1), color(--oklab 0.57693 0.15024 -0.00099 / 1), color(--oklab 0.57429 0.14638 -0.00755 / 1), color(--oklab 0.57165 0.14252 -0.01411 / 1), color(--oklab 0.56901 0.13866 -0.02067 / 1), color(--oklab 0.56638 0.1348 -0.02723 / 1), color(--oklab 0.56374 0.13094 -0.0338 / 1), color(--oklab 0.5611 0.12708 -0.04036 / 1), color(--oklab 0.55846 0.12322 -0.04692 / 1), color(--oklab 0.55582 0.11936 -0.05348 / 1), color(--oklab 0.55318 0.1155 -0.06004 / 1), color(--oklab 0.55054 0.11164 -0.0666 / 1), color(--oklab 0.5479 0.10778 -0.07316 / 1), color(--oklab 0.54526 0.10392 -0.07972 / 1), color(--oklab 0.54262 0.10006 -0.08628 / 1), color(--oklab 0.53998 0.0962 -0.09284 / 1), color(--oklab 0.53735 0.09234 -0.0994 / 1), color(--oklab 0.53471 0.08848 -0.10596 / 1), color(--oklab 0.53207 0.08462 -0.11252 / 1), color(--oklab 0.52943 0.08076 -0.11908 / 1), color(--oklab 0.52679 0.0769 -0.12564 / 1), color(--oklab 0.52415 0.07304 -0.1322 / 1), color(--oklab 0.52151 0.06918 -0.13877 / 1), color(--oklab 0.51887 0.06532 -0.14533 / 1), color(--oklab 0.51623 0.06146 -0.15189 / 1), color(--oklab 0.51359 0.05761 -0.15845 / 1), color(--oklab 0.51095 0.05375 -0.16501 / 1), color(--oklab 0.50832 0.04989 -0.17157 / 1), color(--oklab 0.50568 0.04603 -0.17813 / 1), color(--oklab 0.50304 0.04217 -0.18469 / 1), color(--oklab 0.5004 0.03831 -0.19125 / 1), color(--oklab 0.49776 0.03445 -0.19781 / 1), color(--oklab 0.49512 0.03059 -0.20437 / 1), color(--oklab 0.49248 0.02673 -0.21093 / 1), color(--oklab 0.48984 0.02287 -0.21749 / 1), color(--oklab 0.4872 0.01901 -0.22405 / 1), color(--oklab 0.48456 0.01515 -0.23061 / 1), color(--oklab 0.48192 0.01129 -0.23717 / 1), color(--oklab 0.47928 0.00743 -0.24374 / 1), color(--oklab 0.47665 0.00357 -0.2503 / 1), color(--oklab 0.47401 -0.00029 -0.25686 / 1), color(--oklab 0.47137 -0.00415 -0.26342 / 1), color(--oklab 0.46873 -0.00801 -0.26998 / 1), color(--oklab 0.46609 -0.01187 -0.27654 / 1), color(--oklab 0.46345 -0.01573 -0.2831 / 1), color(--oklab 0.46081 -0.01959 -0.28966 / 1), color(--oklab 0.45817 -0.02345 -0.29622 / 1), color(--oklab 0.45553 -0.02731 -0.30278 / 1), color(--oklab 0.45289 -0.03117 -0.30934 / 1), color(--oklab 0.45025 -0.03503 -0.3159 / 1), color(--oklab 0.44762 -0.03889 -0.32246 / 1), color(--oklab 0.44498 -0.04275 -0.32902 / 1), color(--oklab 0.44234 -0.04661 -0.33558 / 1), color(--oklab 0.4397 -0.05047 -0.34214 / 1), color(--oklab 0.43706 -0.05433 -0.3487 / 1), color(--oklab 0.43442 -0.05819 -0.35527 / 1), color(--oklab 0.43178 -0.06205 -0.36183 / 1), color(--oklab 0.42914 -0.06591 -0.36839 / 1), color(--oklab 0.4265 -0.06977 -0.37495 / 1), color(--oklab 0.42386 -0.07363 -0.38151 / 1), color(--oklab 0.42122 -0.07749 -0.38807 / 1), color(--oklab 0.41858 -0.08135 -0.39463 / 1), color(--oklab 0.41595 -0.08521 -0.40119 / 1), color(--oklab 0.41331 -0.08907 -0.40775 / 1), color(--oklab 0.41067 -0.09293 -0.41431 / 1), color(--oklab 0.40803 -0.09679 -0.42087 / 1)]\n</code></pre> Gamut: srgb <p>Lastly, it is important to note that this affects stops as well, mainly stops applied to interpolation endpoints. When an endpoint is moved inwards via a color stop, the end range of the interpolation is clamped, extending the star and end color. But when extrapolation is enabled, a color stop on an endpoint essentially moves the start and end interpolation. And since there are no other colors on either end to interpolate with, extrapolation occurs.</p> <pre><code>&gt;&gt;&gt; Color.interpolate([stop('red', 0.25), stop('blue', 0.75)])\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x7f465481e6c0&gt;\n&gt;&gt;&gt; Color.interpolate([stop('red', 0.25), stop('blue', 0.75)], extrapolate=True)\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x7f465481fb60&gt;\n</code></pre> Gamut: srgb"},{"location":"interpolation/#null-handling","title":"Undefined/NaN Handling","text":"<p>Color spaces that have hue coordinates often have rules about when the hue is considered relevant. For instance, in the HSL color space, if saturation is zero, the hue is essentially powerless. This is because the color is \"without color\" or achromatic; therefore, the hue can have no affect on the actual color.</p> <p>ColorAide will generally respect the values a user provides, so if an achromatic HSL color is given a hue of 270 degrees, ColorAide will accept it, but the hue will not affect the color in any meaningful way.</p> <p>During conversions, such context is lost, and if an achromatic color is converted to the color space like HSL, the resultant color will have a hue that is noted as undefined. This is simply because there is no good hue for achromatic colors as they play no part in the color. Any hue is actually incorrect as achromatic colors have no real hue. Instead, colors will be returned with a value that represents that the hue is missing or undefined, or maybe better worded, could not be defined.</p> <p>Many libraries, like d3-color, chroma.js, and color.js, represent null hues with <code>NaN</code> (not a number). This is usually done to make color interpolation easier. Some, like d3-color, are a bit more liberal with <code>NaN</code> and will target special cases that are above and beyond the normal rules to help ensure good interpolation. For instance, they not only mark hue undefined on HSL colors when saturation is zero, but they'll mark saturation as <code>NaN</code> when lightness indicates \"black\" or \"white\".</p> <p>ColorAide also uses <code>NaN</code>, or in Python <code>float('nan')</code>, to represent undefined channels. In certain situations, when a hue is deemed undefined, the hue value will be set to <code>coloraide.NaN</code>, which is just a constant containing <code>float('nan')</code>.</p> <p>When performing linear interpolation, where only two color's channels are ever being evaluated together at a given time, if one color's channel has a <code>NaN</code>, the other color's channel will be used as the result. If both colors have a <code>NaN</code> for the same channel, then <code>NaN</code> will be returned.</p> <p>Continuous NaN Handling</p> <p><code>NaN</code> handling is a bit different for the Continuous and Cubic Spline interpolation approaches. Linear only evaluates colors at a given time, while the others will take into consideration more than two colors. Because the context is much wider and more complicated, <code>NaN</code> values will often get context from both sides.</p> <p>Notice that in this example, because white's saturation is zero, the hue is undefined. Because the hue is undefined, when the color is mixed with a second color (<code>green</code>), the hue of the second color is used.</p> <pre><code>&gt;&gt;&gt; color = Color('white').convert('hsl')\n&gt;&gt;&gt; color[:-1]\n[nan, 0.0, 1.0]\n&gt;&gt;&gt; color2 = Color('green').convert('hsl')\n&gt;&gt;&gt; color2[:-1]\n[120.0, 1.0, 0.25098039215686274]\n&gt;&gt;&gt; color.mix(color2, space=\"hsl\")\ncolor(--hsl 120 0.5 0.62549 / 1)\n</code></pre> Gamut: srgb <p>But if we manually set the hue to <code>0</code> instead of <code>NaN</code>, we can see that the mixing goes quite differently.</p> <pre><code>&gt;&gt;&gt; color = Color('white').convert('hsl').set('hue', 0)\n&gt;&gt;&gt; color[:-1]\n[0.0, 0.0, 1.0]\n&gt;&gt;&gt; color2 = Color('green').convert('hsl')\n&gt;&gt;&gt; color2[:-1]\n[120.0, 1.0, 0.25098039215686274]\n&gt;&gt;&gt; color.mix(color2, space=\"hsl\")\ncolor(--hsl 60 0.5 0.62549 / 1)\n</code></pre> Gamut: srgb <p>Technically, any channel can be set to <code>NaN</code>. And there are various ways to do this. The Color Manipulation documentation goes into the details of how these <code>NaN</code> values naturally occur and the various ways a user and manipulate them.</p>"},{"location":"interpolation/#carrying-forward","title":"Carrying-Forward","text":"<p>Experimental</p> <p>This feature is provided to give parity with CSS behavior. As the spec is still in flux, behavior is subject to change or feature could be removed entirely. Use at your own risk.</p> <p>CSS introduces the concept of carrying-forward undefined channels of like color spaces during conversion to the interpolating color space. The idea is to provide a sane handling to users who specified undefined channels for interpolation, but did not account for the conversion to the interpolating color space.</p> <p>If a color has undefined channels, and is converting to a like color space, after conversion the new color will have the same undefined channels, assuming the channels support carrying-forward. The example below demonstrates the concept.</p> <pre><code>&gt;&gt;&gt; rgb = Color('srgb', [0.5, NaN, 0.8])\n&gt;&gt;&gt; p3 = rgb.convert('display-p3').set('green', NaN)\n&gt;&gt;&gt; rgb, p3\n(color(srgb 0.5 none 0.8 / 1), color(display-p3 0.45659 none 0.76952 / 1))\n</code></pre> Gamut: srgb <p>ColorAide, by default, expects the user to be aware that undefined values are lost if conversion is required for interpolation. This is mainly because the intent of the color can be changed during this process, but some users may find the automatic carrying-forward more convenient. For this reason, ColorAide has implemented carrying-forward as an optional feature via the <code>carryforward</code> option.</p> <p>In this example, interpolating without carrying-forward results in an interpolation between a purplish color and white. Using carrying-forward, we get a purplish color with an undefined green channel. The green channel takes on the white's green channel giving us an interpolation between a more greenish color and white.</p> <pre><code>&gt;&gt;&gt; Color.interpolate(['color(srgb 0.5 none 0.8)', 'white'], space='display-p3')\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x7f465481e4e0&gt;\n&gt;&gt;&gt; Color.interpolate(['color(srgb 0.5 none 0.8)', 'white'], space='display-p3', carryforward=True)\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x7f465481e030&gt;\n</code></pre> Gamut: srgb <p>Depending on the color space, carrying-forward may have better or worse results.</p> <p>The following table shows channel components supported for <code>carryforward</code>. Spaces may use different names for their channels, but if they are derived from the related space classes, their channels are supported. For instance, <code>xyz</code> is derived from <code>RGBish</code>, so <code>x</code>, <code>y</code>, and <code>z</code> is treated like super saturated <code>r</code>, <code>g</code>, and <code>b</code>.</p> Space\u00a0Type Channel\u00a0Equivalents <code>RGBish</code> <code>r</code>, <code>g</code>, <code>b</code> <code>LABish</code> <code>l</code> <code>LCHish</code> <code>l</code>, <code>c</code>, <code>h</code> <code>HSLish</code> <code>h</code>, <code>s</code>, <code>l</code> <code>HSVish</code> <code>h</code>, <code>s</code>, <code>v</code> <code>Cylindrical</code> <code>h</code> <p>Carrying-forward is applied within categories.</p> Category Components Reds <code>r</code> Greens <code>g</code> Blues <code>b</code> Lightness <code>l</code> Colorfulness <code>c</code>, <code>s</code> Hue <code>h</code> Opponent a <code>a</code> Opponent b <code>b</code> Value <code>v</code>"},{"location":"interpolation/#powerless-hues","title":"Powerless Hues","text":"<p>Experimental</p> <p>This feature is provided to give parity with CSS behavior. As the spec is still in flux, behavior is subject to change or feature could be removed entirely. Use at your own risk.</p> <p>Normally, ColorAide respects the user's explicitly defined hues. This gives the user power to do things like masking off all channels but the hue in order to interpolate only the hue channel.</p> <pre><code>&gt;&gt;&gt; Color.interpolate(['oklch(none none 0)', 'oklch(0.75 0.2 360)'], space='oklch', hue='specified')\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x7f465481e4e0&gt;\n</code></pre> Gamut: srgb <p>But when doing this, a user must explicitly define the hue as achromatic if they want the hue to be ignored. Conversions of achromatic colors to a cylindrical space will, in most cases, have the hue automatically set to undefined.</p> <pre><code>&gt;&gt;&gt; Color.interpolate(['oklch(1 0 0)', 'oklch(0.75 0.2 180)'], space='oklch')\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x7f465481e030&gt;\n&gt;&gt;&gt; Color.interpolate(['oklch(1 0 None)', 'oklch(0.75 0.2 180)'], space='oklch')\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x7f465481e6c0&gt;\n</code></pre> Gamut: srgb <p>CSS has the concept of powerless hues which causes explicitly defined hues to be powerless (or act as undefined) when a color is considered achromatic. This means a user never has to think about achromatic hues, so even if they erroneously define a hue, the hue will automatically be treated as undefined when interpolating. ColorAide implements this behavior via the <code>powerless</code> option.</p> <pre><code>&gt;&gt;&gt; Color.interpolate(['oklch(1 0 0)', 'oklch(0.75 0.2 180)'], space='oklch', powerless=True)\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x7f465481e030&gt;\n&gt;&gt;&gt; Color.interpolate(['oklch(1 0 None)', 'oklch(0.75 0.2 180)'], space='oklch', powerless=True)\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x7f465481e4e0&gt;\n</code></pre> Gamut: srgb <p>The one downside is that control over the hue will be diminished to some degree as ColorAide will no longer respect a user's explicit hue if the color is determined to be achromatic.</p> <pre><code>&gt;&gt;&gt; Color.interpolate(['oklch(none none 0)', 'oklch(0.75 0.2 360)'], space='oklch', hue='specified')\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x7f465481e030&gt;\n&gt;&gt;&gt; Color.interpolate(['oklch(none none 0)', 'oklch(0.75 0.2 360)'], space='oklch', hue='specified', powerless=True)\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x7f465481e4e0&gt;\n</code></pre> Gamut: srgb"},{"location":"manipulation/","title":"Manipulating Colors","text":"<p>Once a <code>Color</code> object is created, you have access to all the color channels. Color channels can be read individually or extracted all at once. Getting and setting color channels is flexible and easy, allowing for intuitive access.</p>"},{"location":"manipulation/#accessing-coordinates","title":"Accessing Coordinates","text":"<p>There are various ways to get and set the current values of color coordinates. Colors can be accessed by channel name or numerical index directly. We can also manipulate colors within different color spaces.</p>"},{"location":"manipulation/#access-by-channel-name","title":"Access By Channel Name","text":"<p>One of the more intuitive ways to access color values is by channel name. Each color space defines the name of each of the available channels. <code>alpha</code> is the one channel name that is always constant no matter the color space.</p> <pre><code>&gt;&gt;&gt; color = Color(\"orange\")\n&gt;&gt;&gt; color\ncolor(srgb 1 0.64706 0 / 1)\n&gt;&gt;&gt; color['r']\n1.0\n&gt;&gt;&gt; color['g']\n0.6470588235294118\n&gt;&gt;&gt; color['b']\n0.0\n&gt;&gt;&gt; color['alpha']\n1.0\n</code></pre> Gamut: srgb <p>Some channels may be also be recognized using an alias. Check the color space's documentation to learn the recognized channel names and aliases.</p> <pre><code>&gt;&gt;&gt; color = Color(\"orange\")\n&gt;&gt;&gt; color\ncolor(srgb 1 0.64706 0 / 1)\n&gt;&gt;&gt; color['red'] = 0\n&gt;&gt;&gt; color['green'] = 0\n&gt;&gt;&gt; color['blue'] = 1\n&gt;&gt;&gt; color\ncolor(srgb 0 0 1 / 1)\n</code></pre> Gamut: srgb"},{"location":"manipulation/#access-by-index","title":"Access By Index","text":"<p>Color channels can also be read or set by index. Channels are always in logical order. This means, for instance, an RGB color space will have its channel in the order of <code>r</code>, <code>g</code>, <code>b</code>, and <code>alpha</code>. The<code>alpha</code> channel always being the last channel in any color space. Check out the color space's documentation to learn more about available channels and the order in which they are stored.</p> <pre><code>&gt;&gt;&gt; color = Color(\"orange\")\n&gt;&gt;&gt; color\ncolor(srgb 1 0.64706 0 / 1)\n&gt;&gt;&gt; color[0]\n1.0\n&gt;&gt;&gt; color[1]\n0.6470588235294118\n&gt;&gt;&gt; color[2]\n0.0\n&gt;&gt;&gt; color[3]\n1.0\n</code></pre> Gamut: srgb <p>Because a Color object essentially operates similar to a list, negative values are also allowed.</p> <pre><code>&gt;&gt;&gt; color = Color(\"orange\")\n&gt;&gt;&gt; color\ncolor(srgb 1 0.64706 0 / 1)\n&gt;&gt;&gt; color[-1] = 0.5\n&gt;&gt;&gt; color\ncolor(srgb 1 0.64706 0 / 0.5)\n</code></pre> Gamut: srgb"},{"location":"manipulation/#access-by-iteration","title":"Access By Iteration","text":"<p>Color objects can also be treated as an iterable object. This allows us to simply loop through the values.</p> <pre><code>&gt;&gt;&gt; color = Color(\"orange\")\n&gt;&gt;&gt; color\ncolor(srgb 1 0.64706 0 / 1)\n&gt;&gt;&gt; [c for c in color]\n[1.0, 0.6470588235294118, 0.0, 1.0]\n</code></pre> Gamut: srgb"},{"location":"manipulation/#access-by-slicing","title":"Access By Slicing","text":"<p>As previously mentioned, Color objects operate very similar to lists, and as such, can also be read or set via slicing.</p> <pre><code>&gt;&gt;&gt; color = Color(\"orange\")\n&gt;&gt;&gt; color\ncolor(srgb 1 0.64706 0 / 1)\n&gt;&gt;&gt; color[:-1]\n[1.0, 0.6470588235294118, 0.0]\n&gt;&gt;&gt; color[:-1] = [0, 0, 1]\n&gt;&gt;&gt; color\ncolor(srgb 0 0 1 / 1)\n</code></pre> Gamut: srgb"},{"location":"manipulation/#access-by-type","title":"Access by Type","text":"<p>New 2.0</p> <p>When dealing with colors, you have two types of channels: color channels and an alpha channel. These values can be accessed and separated by slicing as mentioned earlier, but some convenience functions have been added to make this easier. <code>coords()</code> and <code>alpha()</code> will retrieve the color channels and the alpha channel respectively.</p> <pre><code>&gt;&gt;&gt; color = Color(\"srgb\", [1, 0, 1], 0.5)\n&gt;&gt;&gt; color\ncolor(srgb 1 0 1 / 0.5)\n&gt;&gt;&gt; color.alpha()\n0.5\n&gt;&gt;&gt; color.coords()\n[1.0, 0.0, 1.0]\n</code></pre> Gamut: srgb <p>In addition, both of these functions offer a special parameter <code>nans</code> that controls whether undefined values are returned as specified or whether they are resolved to defined values.</p> <pre><code>&gt;&gt;&gt; color = Color(\"hsl\", [NaN, 0, 0.75], 0.5)\n&gt;&gt;&gt; color\ncolor(--hsl none 0 0.75 / 0.5)\n&gt;&gt;&gt; color.coords()\n[nan, 0.0, 0.75]\n&gt;&gt;&gt; color.coords(nans=False)\n[0.0, 0.0, 0.75]\n</code></pre> Gamut: srgb <p>Lastly, you can control the precision of your output values with the <code>precision</code> parameter in either <code>coords()</code> or <code>alpha()</code>. For more information or to learn more about more advanced controls of precision, see the sections on precision and rounding which applies to both serialization and coordinate retrieval.</p> <pre><code>&gt;&gt;&gt; color = Color(\"hsl\", [NaN, 0, 0.7534848], 0.523456)\n&gt;&gt;&gt; color\ncolor(--hsl none 0 0.75348 / 0.52346)\n&gt;&gt;&gt; color.coords(precision=2)\n[nan, 0.0, 0.75]\n&gt;&gt;&gt; color.alpha(precision=1)\n0.5\n</code></pre> Gamut: srgb <p>If per channel precision control is desired for <code>coords()</code> a list can be provided where each index in the list corresponds to the given channel at that index.</p> <pre><code>&gt;&gt;&gt; color = Color(\"purple\")\n&gt;&gt;&gt; color\ncolor(srgb 0.50196 0 0.50196 / 1)\n&gt;&gt;&gt; color.coords(precision=[2, 3, 5])\n[0.5, 0.0, 0.50196]\n</code></pre> Gamut: srgb <p>New in 4.0: Precision Output Control</p>"},{"location":"manipulation/#access-by-functions","title":"Access By Functions","text":"<p>Colors can also be accessed and modified in more advanced ways with special access functions <code>get()</code> and <code>set()</code>.</p> <p><code>get()</code> provides access to any channel via the channel name for a given color space, but what sets it apart from other channel access methods is that it can indirectly access channels in other color spaces as well.</p> <pre><code>&gt;&gt;&gt; color = Color(\"pink\")\n&gt;&gt;&gt; color\ncolor(srgb 1 0.75294 0.79608 / 1)\n&gt;&gt;&gt; color.get('red')\n1.0\n&gt;&gt;&gt; color.get('oklch.hue')\n7.085489349755127\n</code></pre> Gamut: srgb <p>Numerical values for channels can be used as well, but the input should still be a string.</p> <pre><code>&gt;&gt;&gt; color = Color(\"pink\")\n&gt;&gt;&gt; color\ncolor(srgb 1 0.75294 0.79608 / 1)\n&gt;&gt;&gt; color.get('0')\n1.0\n&gt;&gt;&gt; color.get('oklch.0')\n0.8677384508411227\n</code></pre> Gamut: srgb <p>New in 2.14</p> <p>Parsing numerical representations of channels is new in 2.14</p> <p>Like <code>get()</code>, <code>set()</code> is a method that allows for the setting of any color channel via the color channel names. The value can be set via numerical values or functions with more complex logic.</p> <pre><code>&gt;&gt;&gt; color = Color(\"pink\")\n&gt;&gt;&gt; color\ncolor(srgb 1 0.75294 0.79608 / 1)\n&gt;&gt;&gt; color.set('blue', 0.5)\ncolor(srgb 1 0.75294 0.5 / 1)\n&gt;&gt;&gt; color.set('green', lambda g: g * 1.3)\ncolor(srgb 1 0.97882 0.5 / 1)\n&gt;&gt;&gt; color.set('2', 0.0)\ncolor(srgb 1 0.97882 0 / 1)\n</code></pre> Gamut: srgb <p>Since <code>set()</code> returns a reference to the current color object, we can also chain multiple <code>set()</code> operations.</p> <pre><code>&gt;&gt;&gt; color = Color('black')\n&gt;&gt;&gt; color\ncolor(srgb 0 0 0 / 1)\n&gt;&gt;&gt; color.set('red', 1).set('green', 1)\ncolor(srgb 1 1 0 / 1)\n</code></pre> Gamut: srgb <p>Even more interesting is that, like <code>get()</code>, you can modify a channel in another color space indirectly.</p> <pre><code>&gt;&gt;&gt; color = Color(\"orange\")\n&gt;&gt;&gt; color\ncolor(srgb 1 0.64706 0 / 1)\n&gt;&gt;&gt; color.set('oklab.lightness', 0.50)\ncolor(srgb 0.61518 0.28886 -0.22143 / 1)\n&gt;&gt;&gt; color.set('oklab.0', 0.2)\ncolor(srgb 0.24502 -0.06492 -0.05538 / 1)\n</code></pre> Gamut: srgb <p>When getting/setting a color channel in a different color space than the current color space, the underlying color must be converted to the target color space in order to access the channel. When doing this to get/set multiple channels, this can be a bit inefficient. In order to make such operations more efficient, both <code>get()</code> and <code>set()</code> allow for bulk operations. When performing bulk channel operations, the channels operations are performed in the order they are specified; therefore, it is important to group together channels of the same color space to ensure they are accessed with a single conversion.</p> <p>To get multiple channels, simply provide a list of channels.</p> <pre><code>&gt;&gt;&gt; color = Color('orange')\n&gt;&gt;&gt; color\ncolor(srgb 1 0.64706 0 / 1)\n&gt;&gt;&gt; color.get(['oklch.lightness', 'oklch.hue', 'alpha'])\n[0.7926884361521512, 70.66991620195026, 1.0]\n</code></pre> Gamut: srgb <p>To set multiple channels, pass a single dictionary containing the channel names and values.</p> <pre><code>&gt;&gt;&gt; color = Color('orange')\n&gt;&gt;&gt; color\ncolor(srgb 1 0.64706 0 / 1)\n&gt;&gt;&gt; color.set(\n...     {\n...         'oklch.lightness': lambda l: l - l * 0.25,\n...         'oklch.hue': 270\n...     }\n... )\ncolor(srgb 0.34573 0.45438 0.89059 / 1)\n</code></pre> Gamut: srgb <p>Lastly, you can control the precision of your output values with the <code>precision</code> parameter. For more information or to learn more about more advanced controls of precision, see the sections on precision and rounding which applies to both serialization and coordinate retrieval.</p> <pre><code>&gt;&gt;&gt; color = Color(\"hsl\", [NaN, 0, 0.7534848], 0.523456)\n&gt;&gt;&gt; color\ncolor(--hsl none 0 0.75348 / 0.52346)\n&gt;&gt;&gt; color.get('lightness', precision=2)\n0.75\n&gt;&gt;&gt; color.get('alpha', precision=1)\n0.5\n</code></pre> Gamut: srgb <p>Channels can be requested with per channel precision control by providing a list of precision. Each index in the precision list corresponds to input index of each channel in the order they passed in.</p> <pre><code>&gt;&gt;&gt; color = Color('orange')\n&gt;&gt;&gt; color\ncolor(srgb 1 0.64706 0 / 1)\n&gt;&gt;&gt; color.get(['alpha', 'oklch.lightness', 'oklch.hue'], precision=[5, 3, 0])\n[1.0, 0.793, 71.0]\n</code></pre> Gamut: srgb <p>Indirect Channel Modifications</p> <p>Indirect channel modification is very useful, but keep in mind that it may give you access to color spaces that are incompatible due to gamut size. Additionally, the feature converts the color to the target color space, modifies it, and then converts it back making it susceptible to any possible round trip errors.</p> <p>New in 1.5: Getting/Setting Multiple Channels</p> <p>New in 4.0: Precision Output Control</p>"},{"location":"manipulation/#undefined-values","title":"Undefined Values","text":"<p>Colors can sometimes have undefined channels. This can actually happen in a number of ways. In almost all cases, undefined values are generated or manually inserted in order to help out with interpolation.</p> <ol> <li> <p>Hues can naturally become undefined if the color is achromatic.</p> <pre><code>&gt;&gt;&gt; color = Color('white').convert('hsl')\n&gt;&gt;&gt; color[:]\n[nan, 0.0, 1.0, 1.0]\n</code></pre> Gamut: srgb </li> <li> <p>When specifying raw data, channels can be explicitly set to undefined, and when an insufficient amount of channel    data is provided, the missing channels will be assumed as undefined, the exception is the <code>alpha</code> channel which is    assumed to be <code>1</code> unless explicitly defined or explicitly set as undefined.</p> <pre><code>&gt;&gt;&gt; Color('srgb', [1])[:]\n[1.0, nan, nan, 1.0]\n&gt;&gt;&gt; Color('srgb', [1, 0, 0], NaN)[:]\n[1.0, 0.0, 0.0, nan]\n</code></pre> Gamut: srgb </li> <li> <p>Undefined values can also occur when a user specifies a channel with the <code>none</code> keyword in CSS syntax.</p> <pre><code>&gt;&gt;&gt; from coloraide import NaN\n&gt;&gt;&gt; color = Color(\"srgb\", [0.3, NaN, 0.4])\n&gt;&gt;&gt; color[:]\n[0.3, nan, 0.4, 1.0]\n&gt;&gt;&gt; color = Color('rgb(30% none 40%)')\n&gt;&gt;&gt; color[:]\n[0.3, nan, 0.4, 1.0]\n</code></pre> Gamut: srgb </li> <li> <p>Lastly, a user can use the <code>mask</code> method which is a quick way to set one or multiple channels as undefined.    Additionally, it returns a clone leaving the original untouched by default.</p> <pre><code>&gt;&gt;&gt; Color('white')[:]\n[1.0, 1.0, 1.0, 1.0]\n&gt;&gt;&gt; Color('white').mask(['red', 'green'])[:]\n[nan, nan, 1.0, 1.0]\n</code></pre> Gamut: srgb <p>The <code>alpha</code> channel can also be masked:</p> <pre><code>&gt;&gt;&gt; Color('white').mask('alpha')[-1]\nnan\n</code></pre> Gamut: srgb <p>You can also do inverse masks, or masks that apply to every channel not specified.</p> <pre><code>&gt;&gt;&gt; c = Color('white').mask('blue', invert=True)\n&gt;&gt;&gt; c[:]\n[nan, nan, 1.0, nan]\n</code></pre> Gamut: srgb </li> </ol>"},{"location":"manipulation/#checking-for-undefined-values","title":"Checking for Undefined Values","text":"<p>As previously mentioned, a color channel can be undefined for a number of reasons. And in cases such as interpolation, undefined values can even be useful. On the other hand, sometimes knowing there is an undefined value or being able to ignore it can be useful.</p> <p>Undefined values are represented as the float value <code>NaN</code>. And since <code>NaN</code> values are not numbers \u2013 hence the name \"not a number\" \u2013 they don't quite work the same as normal numbers. They don't contribute to math operations like add, multiply, and divide. Any math operation performed with a <code>NaN</code> will simply yield <code>NaN</code>. <code>NaN</code> values are essentially infectious.</p> <p>At first glance, the behavior of <code>NaN</code> values can seem confusing, but it is actually pretty intuitive. If we define a color with an undefined channel, and try to add to that value, what should we get? In reality, if the value is undefined, how could we possibly add to it? The only sane answer is to return <code>NaN</code> again.</p> <pre><code>&gt;&gt;&gt; color = Color('color(srgb 1 none 1)')\n&gt;&gt;&gt; color['green'] + 0.5\nnan\n</code></pre> Gamut: srgb <p>Because a <code>NaN</code> (or undefined value) may cause surprising results, it can be useful to check if a hue (or any channel) is undefined before applying certain operations where such a value may be undesirable, especially if the color potentially came from an unknown source. To make checking for undefined values easy, the convenience function <code>is_nan</code> has been made available. You can simply give <code>is_nan</code> the property you wish to check, and it will return either <code>True</code> or <code>False</code>.</p> <pre><code>&gt;&gt;&gt; Color('hsl(none 0% 100%)').is_nan('hue')\nTrue\n</code></pre> Gamut: srgb <p>This is equivalent to using the <code>math</code> library and comparing the value directly:</p> <pre><code>&gt;&gt;&gt; import math\n&gt;&gt;&gt; math.isnan(Color('hsl(none 0% 100%)')['hue'])\nTrue\n</code></pre> Gamut: srgb"},{"location":"manipulation/#forcing-defined-values","title":"Forcing Defined Values","text":"<p>Another way to deal with <code>NaN</code> values is to just ignore them. <code>get()</code>, <code>set()</code>, <code>coords()</code>, and <code>alpha()</code> all can use the <code>nans</code> option to ensure read operations return a defined value.</p> <pre><code>&gt;&gt;&gt; c = Color('srgb', [])\n&gt;&gt;&gt; c\ncolor(srgb none none none / 1)\n&gt;&gt;&gt; c.get('red', nans=False)\n0.0\n&gt;&gt;&gt; c.set('green', lambda x: x + 3, nans=False)\ncolor(srgb none 3 none / 1)\n</code></pre> Gamut: srgb <p><code>set()</code></p> <p>In the context of <code>set()</code>, <code>nans</code> specifically ensures that when a callback function is provided that the input value is transformed into a real value opposed to an undefined value.</p> <p>We can also use <code>normalize()</code> to just set all channels to defined values, but keep mind, when an achromatic color has a real hue, they will then influence interpolation results if interpolating in that same color space.</p> <pre><code>&gt;&gt;&gt; c = Color('srgb', [])\n&gt;&gt;&gt; c.normalize(nans=False)\ncolor(srgb 0 0 0 / 1)\n</code></pre> Gamut: srgb"},{"location":"manipulation/#how-are-undefined-values-resolved","title":"How are Undefined Values Resolved?","text":"<p>ColorAide will resolve undefined values when necessary. Resolving undefined values may be needed to compute color distance, convert a color, serialize a color, or various other reasons.</p> <p>Normally, an undefined value defaults to <code>0</code> when forced to be defined, but there are a few cases where this may not always be true.</p> <ol> <li> <p>When a color is achromatic the hue becomes meaningless in most cylindrical color spaces. This makes sense as     achromatic colors have no hues, but this is also because the algorithms usually work out this way. When chroma is     small enough, it usually makes the hue mathematically insignificant. In these cases, when a hue must be defined, we     will generally assume <code>0</code> as an arbitrary default, but there are some color spaces who have algorithms where the hue     actually becomes more important for precise conversions.</p> <p>The color spaces CAM16 JMh and HCT are color models that allow you to set the viewing environment. One of the options determines whether the eye is adapted to the illuminant or not. If not adapted, which is our default for both CAM16 JMh and HCT, you can get an achromatic response where grayscale colors lean heavily into one specific hue. Additionally, achromatic chroma may grow to a value much greater than <code>0</code> as lightness increases. If we were to use <code>0</code> as a default for chroma and/or hue, we'd actually not convert back to a real achromatic color.</p> <p>We can see in the example below that using <code>0</code> for an undefined hue in CAM16 JMh will not convert <code>gray</code> back to sRGB properly, but using the one calculated for the color space gets us much closer.</p> <pre><code>&gt;&gt;&gt; srgb = Color('gray')\n&gt;&gt;&gt; srgb\ncolor(srgb 0.50196 0.50196 0.50196 / 1)\n&gt;&gt;&gt; jmh = srgb.convert('cam16-jmh')\n&gt;&gt;&gt; jmh.coords(nans=False)\n[43.042092459543426, 1.4670107518796203, 209.53509858059104]\n&gt;&gt;&gt; jmh.convert('srgb')\ncolor(srgb 0.50196 0.50196 0.50196 / 1)\n&gt;&gt;&gt; jmh.set('hue', 0).convert('srgb')\ncolor(srgb 0.51857 0.49597 0.49766 / 1)\n</code></pre> Gamut: srgb <p>Some color spaces, due to things like adapting luminance and background luminance, will have their own achromatic response, meaning that achromatic colors are neutral, but may not be pure white, gray, etc.</p> </li> <li> <p>Most of the time, if you set all color channels to undefined, when resolved, the color will be black (or white in     the case of CMYK). Unfortunately, using <code>0</code> for undefined channels in some color spaces can create colors outside     the viewable gamut. One such example is ACEScct (a logarithmic encoding of ACES) which has a greater value than zero     for black. In this case, setting undefined channels to zero will cause nonsense colors. In this specific case, we     use ACEScct's value for black instead of <code>0</code> for more a more practical default.</p> <pre><code>&gt;&gt;&gt; aces = Color('black').convert('acescct')\n&gt;&gt;&gt; aces\ncolor(--acescct 0.07291 0.07291 0.07291 / 1)\n&gt;&gt;&gt; aces.mask(['alpha'], invert=True, in_place=True)\ncolor(--acescct none none none / 1)\n&gt;&gt;&gt; aces.coords(nans=False)\n[0.0729055341958355, 0.0729055341958355, 0.0729055341958355]\n&gt;&gt;&gt; aces.in_gamut()\nTrue\n&gt;&gt;&gt; aces[:] = [0] * 3\n&gt;&gt;&gt; aces.in_gamut()\nFalse\n</code></pre> Gamut: srgb <p>New 2.3</p> <p>ACEScc, another color space that performs a logarithmic encoding of ACES, will also resolve undefined channels to a non-zero value, not because zero is out of gamut, but to ensure consistency across all ACES color spaces which resolve to zero or non-zero equivalent values.</p> </li> </ol>"},{"location":"manipulation/#achromatic-colors","title":"Achromatic Colors","text":"<p>An achromatic color is a color without any real hue. Essentially, it is devoid of color leaving only shades of gray. Different color spaces represent achromatic colors in different ways.</p> <p>ColorAide has some special handling of achromatic colors and a few ways to test if a color is achromatic.</p>"},{"location":"manipulation/#checking-for-achromatic-colors","title":"Checking For Achromatic Colors","text":"<p>New 2.0</p> <p>ColorAide generally respects an input color's defined channels, but during conversion, or if <code>normalize()</code> is called, cylindrical color spaces will have their hue set to undefined if the color is achromatic (or very close to achromatic). One easy way to check for achromatic colors is simply to check if the hue is undefined with <code>is_nan()</code>.</p> <pre><code>&gt;&gt;&gt; c = Color('gray').convert('hsl')\n&gt;&gt;&gt; c.is_nan('hue')\nTrue\n</code></pre> Gamut: srgb <p>Unfortunately, this assumes that the <code>hue</code> has not been manually altered and this doesn't work with non cylindrical colors. Luckily, ColorAide has a universal way to check if any color is achromatic by using <code>is_achromatic()</code>.</p> <pre><code>&gt;&gt;&gt; color1 = Color('orange')\n&gt;&gt;&gt; color1\ncolor(srgb 1 0.64706 0 / 1)\n&gt;&gt;&gt; color1.is_achromatic()\nFalse\n&gt;&gt;&gt; color2 = Color('gray').convert('lab')\n&gt;&gt;&gt; color2\ncolor(--lab 53.585 0 0 / 1)\n&gt;&gt;&gt; color2.is_achromatic()\nTrue\n&gt;&gt;&gt; color3 = Color('darkgray').convert('hsl').set('hue', 270)\n&gt;&gt;&gt; color3\ncolor(--hsl 270 0 0.66275 / 1)\n&gt;&gt;&gt; color3.is_achromatic()\nTrue\n</code></pre> Gamut: srgb <p><code>is_achromatic()</code> tries to use a reasonable threshold to determine achromatic colors. The method used is usually specific to the color space as it is fastest to test in the color space being evaluated.</p>"},{"location":"manipulation/#normalizing-achromatic-colors","title":"Normalizing Achromatic Colors","text":"<p>When ColorAide converts to a cylindrical color, if the color is achromatic, the hue will get set as undefined. This is mainly because when a color gets very close to achromatic, the hues can become nonsensical. Many cylindrical spaces, as chroma (or saturation) approaches zero, the color approaches being achromatic. And as chroma gets smaller, the impact of the hue becomes smaller and smaller. In these cases, when we get very close to achromatic, we don't care what the hue is, so it gets set as undefined. Additionally, having hue set to undefined allows us to interpolate achromatic colors in a sane way, see Interpolation for more info.</p> <p>There are times that a color can be defined such that it is not in this normalized achromatic state. We can manually define a color not in this state, and we can also force a color out of this state.</p> <p>Here we can disable the normalization when converting. We can do this with <code>convert()</code> and <code>update()</code></p> <pre><code>&gt;&gt;&gt; Color('white').convert('lch')\ncolor(--lch 100 0 none / 1)\n&gt;&gt;&gt; Color('white').convert('lch', norm=False)\ncolor(--lch 100 0 0 / 1)\n</code></pre> Gamut: srgb <p>We can also remove the normalization by setting <code>nans</code> to <code>False</code> when using <code>normalize()</code>.</p> <pre><code>&gt;&gt;&gt; Color('white').convert('lch').normalize(nans=False)\ncolor(--lch 100 0 0 / 1)\n</code></pre> Gamut: srgb <p>If we want to force a color back into this normalized state, we can just call <code>normalize()</code> without any parameters. Normalize will remove any existing undefined channels and set achromatic hues to undefined.</p> <pre><code>&gt;&gt;&gt; c = Color('lch', [1, 0, 0])\n&gt;&gt;&gt; c\ncolor(--lch 1 0 0 / 1)\n&gt;&gt;&gt; c.normalize()\ncolor(--lch 1 0 none / 1)\n</code></pre> Gamut: srgb"},{"location":"playground/","title":"Playground","text":"Notebook"},{"location":"strings/","title":"String Output","text":"<p>ColorAide supports serializing colors in the same formats that it accepts as inputs. This includes all CSS formats for the associated color spaces, and if a color space is not supported in CSS, the <code>color(space ...)</code> format. ColorAide exposes various options to allow users to serialize in the form they most prefer.</p>"},{"location":"strings/#convert-to-strings","title":"Convert to Strings","text":"<p>Colors can be serialized to strings by using the <code>to_string</code> method. The color class will convert the current color into one of the many of CSS formats supported for the given color space.</p> <pre><code>&gt;&gt;&gt; Color(\"srgb\", [0.5, 0, 1], 0.3).to_string()\n'rgb(127.5 0 255 / 0.3)'\n</code></pre> Gamut: srgb <p>There are a number of options that are common among all color spaces, but there are also some color space specific options. We will only cover the color spaces shipped with ColorAide. It is possible to write a color space plugin that uses very different options.</p>"},{"location":"strings/#common-options","title":"Common Options","text":"<p>All color spaces support the following parameters.</p>"},{"location":"strings/#alpha","title":"Alpha","text":"<p><code>alpha</code> is set to <code>None</code> by default and controls whether the alpha channel is shown in the serialized output. When in the default state, <code>alpha</code> will only be shown if the alpha channel has a value less than 100%, but if set to <code>True</code>, alpha will always be shown. Setting to <code>False</code> will cause alpha to be ignored in the output.</p>"},{"location":"strings/#rounding","title":"Rounding","text":"<p>New in 4.6</p> <p>Note</p> <p>Rounding is done with \"half up\" logic to match CSS recommendations with their color syntax. Internally, as with most programming languages, all calculations use \"half even\" logic, or bankers rounding, to minimize floating point error. \"Half up\" is only used when serializing or explicitly requesting rounded coordinates through the API.</p> <p>There are various ways to approach rounding of data. ColorAide implements a few approaches in an attempt accommodate most needs. The following modes can be selected via the <code>rounding</code> parameter:</p> <ol> <li> <p><code>sigfig</code> is a rounding approach that ensures a specific number of significant figures, the default being 5.     Significant figures are non-leading zero digits.</p> <pre><code>&gt;&gt;&gt; Color(\"rgb(30.34567543% 0.0234567% 100%)\").to_string(rounding='sigfig', percent=True)\n'rgb(30.346% 0.023457% 100%)'\n</code></pre> Gamut: srgb <p>The number of significant figures is controlled via the <code>precision</code> parameter. Generally, values should be between [1, 17] with 17 being the largest precision that is supported by double-precision floating point numbers (15 is the largest stable precision). For convenience, <code>0</code> can be used as a shortcut for rounding whole integers. Any values that exceed this specification are ignored and full precision (<code>17</code>) is used.</p> <p>This is similar to how floating point numbers actually work, the difference being that the number of significant figures can be controlled. Since this will emphasize very small values, which may be well below the resolution that a color space can guarantee accuracy for, this isn't always recommended unless you want to get the exact values stored in a color.</p> <pre><code>&gt;&gt;&gt; c = Color('srgb', [2e-203] * 3)\n&gt;&gt;&gt; c.to_string(color=True, rounding='sigfig', precision=17)\n'color(srgb 0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020000000000000001 0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020000000000000001 0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020000000000000001)'\n&gt;&gt;&gt; c.coords(rounding='sigfig', precision=17)\n[2e-203, 2e-203, 2e-203]\n</code></pre> Gamut: srgb </li> <li> <p><code>decimal</code> is a rounding approach that ensures rounding to a specific decimal position, the default being 5.</p> <pre><code>&gt;&gt;&gt; Color(\"rgb(30.34567543% 0.0234567% 100%)\").to_string(rounding='decimal', percent=True)\n'rgb(30.34568% 0.02346% 100%)'\n</code></pre> Gamut: srgb <p>Decimal places can be positive or negative. Positive values will round to fractional positions (after the decimal), while negative values will round to integer positions (before the decimal).</p> <p>This can be good for being precise about how many decimals of precision a current color space may be accurate to, but it doesn't scale very very well as a default for various color spaces which may have reference ranges that differ by orders of magnitude. For this reason, it is recommended to use this if you are working in a specific color space and which to control the rounding to an exact precision.</p> <p>If negative values are used, the color will be rounded to the integer decimal place, <code>-1</code> representing the ones place, <code>-2</code> the tens place, etc.</p> <pre><code>&gt;&gt;&gt; Color(\"rgb(35.34567543% 0.0234567% 100%)\").to_string(rounding='decimal', precision=-1, percent=True)\n'rgb(40% 0% 100%)'\n</code></pre> Gamut: srgb </li> <li> <p><code>digits</code> is a rounding approach that combines <code>sigfig</code> and <code>decimal</code> where the lowest precision of the two     wins. When applied in this way, rounding will try to round to the specified number digits. This is the default mode     that ColorAide operates in with a default number of digits of 5.</p> <pre><code>&gt;&gt;&gt; Color(\"rgb(30.34567543% 0.0234567% 100%)\").to_string(rounding='digits', percent=True)\n'rgb(30.346% 0.02346% 100%)'\n</code></pre> Gamut: srgb <p>Like <code>sigfig</code>, values should be greater than 0 with 17 being the largest precision that is supported by double-precision floating point numbers (15 being the largest stable precision). For convenience, <code>0</code> can be used as a shortcut for rounding whole integers, and if a negative value is provided, the precision will just default to <code>17</code>.</p> <p>Because this is a marriage between <code>sigfig</code> and <code>decimal</code>, it scales better as a default. Color spaces with reference ranges of smaller magnitude have more decimals of precision than color spaces with reference ranges of larger magnitudes.</p> </li> </ol>"},{"location":"strings/#precision","title":"Precision","text":"<p><code>precision</code> is used to configure the precision of the currently selected <code>rounding</code> mode. ColorAide, by default, uses a value of <code>5</code> regardless of the rounding mode. How the number is handled is purely dependent on the rounding mode.</p> <p><code>precision</code> adjusts the significant figures to which the numbers are rounded. Significant figures are non-leading zero digits. So <code>100.003</code> has 6 significant figures and <code>0.000345</code> has 3 significant figures.</p> <code>digits</code><code>sigfig</code><code>decimal</code> <pre><code>&gt;&gt;&gt; Color(\"rgb(30.34567543% 0.0234567% 100%)\").to_string(precision=5, percent=True)\n'rgb(30.346% 0.02346% 100%)'\n&gt;&gt;&gt; Color(\"rgb(30.34567543% 0.0234567% 100%)\").to_string(precision=4, percent=True)\n'rgb(30.35% 0.0235% 100%)'\n&gt;&gt;&gt; Color(\"rgb(30.34567543% 0.0234567% 100%)\").to_string(precision=3, percent=True)\n'rgb(30.3% 0.023% 100%)'\n&gt;&gt;&gt; Color(\"rgb(30.34567543% 0.0234567% 100%)\").to_string(precision=2, percent=True)\n'rgb(30% 0.02% 100%)'\n&gt;&gt;&gt; Color(\"rgb(30.34567543% 0.0234567% 100%)\").to_string(precision=1, percent=True)\n'rgb(30% 0% 100%)'\n</code></pre> Gamut: srgb <pre><code>&gt;&gt;&gt; Color(\"rgb(30.34567543% 0.0234567% 100%)\").to_string(precision=5, rounding='sigfig', percent=True)\n'rgb(30.346% 0.023457% 100%)'\n&gt;&gt;&gt; Color(\"rgb(30.34567543% 0.0234567% 100%)\").to_string(precision=4, rounding='sigfig', percent=True)\n'rgb(30.35% 0.02346% 100%)'\n&gt;&gt;&gt; Color(\"rgb(30.34567543% 0.0234567% 100%)\").to_string(precision=3, rounding='sigfig', percent=True)\n'rgb(30.3% 0.0235% 100%)'\n&gt;&gt;&gt; Color(\"rgb(30.34567543% 0.0234567% 100%)\").to_string(precision=2, rounding='sigfig', percent=True)\n'rgb(30% 0.023% 100%)'\n&gt;&gt;&gt; Color(\"rgb(30.34567543% 0.0234567% 100%)\").to_string(precision=1, rounding='sigfig', percent=True)\n'rgb(30% 0.02% 100%)'\n</code></pre> Gamut: srgb <pre><code>&gt;&gt;&gt; Color(\"rgb(30.34567543% 0.0234567% 100%)\").to_string(precision=5, rounding='decimal', percent=True)\n'rgb(30.34568% 0.02346% 100%)'\n&gt;&gt;&gt; Color(\"rgb(30.34567543% 0.0234567% 100%)\").to_string(precision=4, rounding='decimal', percent=True)\n'rgb(30.3457% 0.0235% 100%)'\n&gt;&gt;&gt; Color(\"rgb(30.34567543% 0.0234567% 100%)\").to_string(precision=3, rounding='decimal', percent=True)\n'rgb(30.346% 0.023% 100%)'\n&gt;&gt;&gt; Color(\"rgb(30.34567543% 0.0234567% 100%)\").to_string(precision=2, rounding='decimal', percent=True)\n'rgb(30.35% 0.02% 100%)'\n&gt;&gt;&gt; Color(\"rgb(30.34567543% 0.0234567% 100%)\").to_string(precision=1, rounding='decimal', percent=True)\n'rgb(30.3% 0% 100%)'\n</code></pre> Gamut: srgb <p>Lastly, there are some times where the channel coordinates need to have different precision. If needed, ColorAide will allow a list of values for <code>precision</code> where each index in the list will correspond to a different color coordinate.</p> <p>As an example, let's say we are outputting sRGB colors in the CSS <code>rgb()</code> format and we want to round the color components to whole integers. We can do this by just setting <code>precision</code> to <code>0</code> which will force integer rounding, but when we do this, it will round the alpha channel to 0 and 1 which is undesirable.</p> <pre><code>&gt;&gt;&gt; Color(\"rgb(30.3456% 75% 100% / 0.75)\").to_string(precision=0)\n'rgb(77 191 255 / 1)'\n</code></pre> Gamut: srgb <p>If we provide a list of precision we can control each channel individually.</p> <pre><code>&gt;&gt;&gt; Color(\"rgb(30.3456% 75% 100% / 0.75)\").to_string(precision=[0, 0, 0, 3])\n'rgb(77 191 255 / 0.75)'\n</code></pre> Gamut: srgb <p>If a channel is omitted, the current default precision is assumed for that channel.</p> <pre><code>&gt;&gt;&gt; Color(\"rgb(30.3456% 75% 100% / 0.75)\").to_string(precision=[0, 0, 0])\n'rgb(77 191 255 / 0.75)'\n</code></pre> Gamut: srgb <p>New in 4.0: Per Channel Precision Control</p>"},{"location":"strings/#fit","title":"Fit","text":"<p><code>fit</code> is set to <code>True</code> by default and controls whether colors are fit to their gamut or not. Some color spaces are technically unbounded, so no fitting may occur in those color spaces. Additionally, some color formats, like sRGB hex, are always fitted (regardless of this setting) as they must fit into the gamut or they cannot be translated.</p> <pre><code>&gt;&gt;&gt; Color(\"rgb(30% 105% 0%)\").to_string()\n'rgb(107.26 255 58.5)'\n&gt;&gt;&gt; Color(\"rgb(30% 105% 0%)\").to_string(fit=False)\n'rgb(76.5 267.75 0)'\n</code></pre> Gamut: srgb <p>Additionally, we can choose a different fitting method by passing <code>fit</code> the name of the method we would like.</p> <pre><code>&gt;&gt;&gt; Color(\"rgb(30% 105% 0%)\").to_string()\n'rgb(107.26 255 58.5)'\n&gt;&gt;&gt; Color(\"rgb(30% 105% 0%)\").to_string(fit='clip')\n'rgb(76.5 255 0)'\n</code></pre> Gamut: srgb <p>Some gamut mapping plugins may expose more options. To set these options, you can use a dictionary. Specify the method via the <code>method</code> and any other options by their name.</p> <pre><code>&gt;&gt;&gt; Color(\"rgb(30% 105% 0%)\").to_string(fit={'method': 'oklch-chroma', 'jnd': 0.002})\n'rgb(144.58 255 123.58)'\n</code></pre> Gamut: srgb"},{"location":"strings/#color","title":"Color","text":"<p><code>color</code>, for some color spaces, is the default output, but for others this format can be explicitly requested by setting <code>color</code> to <code>True</code>. If set to <code>True</code>, this will take priority over other format options.</p> <pre><code>&gt;&gt;&gt; Color(\"rebeccapurple\").to_string(color=True)\n'color(srgb 0.4 0.2 0.6)'\n</code></pre> Gamut: srgb"},{"location":"strings/#none","title":"None","text":"<p>Colors that have undefined channels are internally represented with <code>NaN</code>. On output, these can be displayed as <code>none</code> per the most recent CSS spec. These are very new, so most browsers do not support them. This is disabled by default until a time when this behavior is common enough. <code>NaN</code> values will not survive fitting unless a color channel is naturally undefined. An example would be a hue when the color has saturation or chroma set to zero.</p> <pre><code>&gt;&gt;&gt; Color('hsl(none 0% 30%)').to_string(none=True)\n'hsl(none 0% 30%)'\n</code></pre> Gamut: srgb <p>The one exception is that legacy <code>rgb()</code>, <code>rgba()</code>, <code>hsl()</code>, and <code>hsla()</code> forms (comma separated) do not support <code>none</code> per the CSS spec.</p>"},{"location":"strings/#percent","title":"Percent","text":"<p>Color formats can serialize channels with percents by using <code>percent</code>.</p> <pre><code>&gt;&gt;&gt; Color(\"rebeccapurple\").to_string(percent=True)\n'rgb(40% 20% 60%)'\n&gt;&gt;&gt; Color(\"rebeccapurple\").convert('lab').to_string(percent=True)\n'lab(32.393% 30.738% -38.153%)'\n</code></pre> Gamut: srgb <p>By default, only HSL and HWB output channels with percents by default to match browser expectations which do not yet support colors with non-percent output for their non-hue channels. This is specifically only true for the named color function formats: <code>hsl()</code> and <code>hwb()</code>.</p> <pre><code>&gt;&gt;&gt; Color(\"rebeccapurple\").convert('hsl').to_string()\n'hsl(270 50% 40%)'\n&gt;&gt;&gt; Color(\"rebeccapurple\").convert('hsl').to_string(percent=False)\n'hsl(270 50 40)'\n</code></pre> Gamut: srgb <p>If serializing with the CSS legacy format (comma format), percentage will be forced for saturation and lightness when serializing HSL.</p> <pre><code>&gt;&gt;&gt; Color(\"rebeccapurple\").convert('hsl').to_string(comma=True)\n'hsl(270, 50%, 40%)'\n&gt;&gt;&gt; Color(\"rebeccapurple\").convert('hsl').to_string(comma=True, percent=False)\n'hsl(270, 50%, 40%)'\n</code></pre> Gamut: srgb <p>Percent output is supported for the <code>color()</code> function output as well.</p> <pre><code>&gt;&gt;&gt; Color(\"rebeccapurple\").convert('srgb').to_string(color=True, percent=True)\n'color(srgb 40% 20% 60%)'\n</code></pre> Gamut: srgb <p>If it is desired, explicit control over each channel can be achieved by passing in a sequence containing booleans.</p> <pre><code>&gt;&gt;&gt; Color('rebeccapurple').convert('lab').to_string(alpha=True, percent=[True, False, False, True])\n'lab(32.393% 38.423 -47.691 / 100%)'\n</code></pre> Gamut: srgb <p>Any omitted list values will be assumed <code>False</code>.</p> <pre><code>&gt;&gt;&gt; Color('rebeccapurple').convert('lab').to_string(alpha=True, percent=[True])\n'lab(32.393% 38.423 -47.691 / 1)'\n</code></pre> Gamut: srgb <p>New 2.12</p> <p>Boolean sequence support for <code>percent</code> added in 2.12.</p>"},{"location":"strings/#format-specific-options","title":"Format Specific Options","text":"<p>These options may occur in various color spaces depending on the CSS output format.</p>"},{"location":"strings/#comma","title":"Comma","text":"<p>In CSS, there are a few color spaces that allow a comma format: <code>srgb</code> and <code>hsl</code>. ColorAide allows these to be read in and to be output in their legacy comma format. These are the only formats that ship with comma support.</p> <p>If we want commas, we can force the comma syntax by setting <code>comma</code> to <code>True</code>. This can alter some color space output in other subtle ways. As the comma format is the old legacy approach, when sRGB has commas enabled, it will use <code>rgba</code> instead of <code>rgb</code>. If using the non-comma syntax, <code>rgb</code> is always used, even when the color has transparency.</p> <pre><code>&gt;&gt;&gt; Color(\"rgb(30 75 100 / 20%)\").to_string(comma=True)\n'rgba(30, 75, 100, 0.2)'\n</code></pre> Gamut: srgb"},{"location":"strings/#srgb-specific-options","title":"sRGB Specific Options","text":"<p>These options are currently specific to the sRGB color space.</p>"},{"location":"strings/#hex","title":"Hex","text":"<p>sRGB can output colors to a hex format which is unique compared to HSL and others. Simply enable <code>hex</code>.</p> <pre><code>&gt;&gt;&gt; Color(\"rebeccapurple\").to_string(hex=True)\n'#663399'\n</code></pre> Gamut: srgb"},{"location":"strings/#upper","title":"Upper","text":"<p>You can force hex to output in uppercase.</p> <pre><code>&gt;&gt;&gt; Color(\"red\").to_string(hex=True)\n'#ff0000'\n&gt;&gt;&gt; Color(\"red\").to_string(hex=True, upper=True)\n'#FF0000'\n</code></pre> Gamut: srgb"},{"location":"strings/#compress","title":"Compress","text":"<p>When converting to the hex color format, a color can be compressed in certain cases. Enabling <code>compress</code> will compress a hex color if possible.</p> <pre><code>&gt;&gt;&gt; Color(\"#11223388\").to_string(hex=True)\n'#11223388'\n&gt;&gt;&gt; Color(\"#11223388\").to_string(hex=True, compress=True)\n'#1238'\n</code></pre> Gamut: srgb"},{"location":"strings/#names","title":"Names","text":"<p>sRGB can also output color names. If a color evaluates to a hex code which also evaluates to a color name in the internal CSS color name mapping, then a color name will be returned. If the color does not match a color name, it will fallback to whatever the other options dictate.</p> <pre><code>&gt;&gt;&gt; Color(\"#663399\").to_string(names=True)\n'rebeccapurple'\n</code></pre> Gamut: srgb"},{"location":"temperature/","title":"Correlated Color Temperature","text":"<p>New 2.4</p> <p>Correlated color temperature (CCT) is a measurement of the average hue of light as it appears to the eye. It is expressed as the temperature (in Kelvins) something would need to be heated to glow at approximately the same color.</p> <p>This response can be modeled with a Planckian or black body locus/curve and is often shown in chromaticity diagrams.</p> <p></p> <p>Figure 1. 1960 Chromaticity Diagram with black body curve in the range of 1,000K - 100,000K</p> <p>In order to calculate the Planckian locus, color matching functions (CMFs) are needed. The CMFs are obtained from a series of experiments in which subjects set the intensities of three colors required to match a series of monochromatic (single wavelength) lights of equal energy that traverse the visible spectrum. CMFs contain the required data from such experiments and can be used to calculate a number of things, including the Planckian locus.</p> <p>CMFs</p> <p>It should be noted that there isn't one set of CMFs. Over the years there have been multiple attempts to come up with the best CMFs and often done at both 2\u02da and 10\u02da viewing angles. ColorAide only provides CMFS provided by the CIE via <code>coloraide.cmfs</code>, the CIE 1931 2 Degree Standard Observer being the default as it is still the common approach even though better CMFs have been provided.</p> CMFS <code>coloraide.cmfs.CIE_1931_2DEG</code> <code>coloraide.cmfs.CIE_1964_10DEG</code> <code>coloraide.cmfs.CIE_2015_2DEG</code> <code>coloraide.cmfs.CIE_2015_10DEG</code> <p>External CMFs could be used as long as they are in the appropriate format and not at increments less than 1nm.</p>"},{"location":"temperature/#cct","title":"CCT","text":"<p>When anything gets warm enough it will start to give off light, and the hotter it gets, the more energetic the light is. As an object increases in temperature, it will shift from the red end of the spectrum to the blue end.</p> <p>ColorAide provides the <code>blackbody()</code> method to generate colors along the black body curve. Simply give it a color space in which the color should be generated and a temperature in Kelvin and ColorAide will return an approximate color along the black body locus.</p> <pre><code>&gt;&gt;&gt; Steps([Color.blackbody('srgb', t) for t in range(1000, 15000, 50)])\n[color(srgb 1 0.18142 0 / 1), color(srgb 1 0.22157 0 / 1), color(srgb 1 0.25489 0 / 1), color(srgb 1 0.28375 0 / 1), color(srgb 1 0.3093 0 / 1), color(srgb 1 0.33241 0 / 1), color(srgb 1 0.35347 0 / 1), color(srgb 1 0.3729 0 / 1), color(srgb 1 0.39084 0 / 1), color(srgb 1 0.40753 0 / 1), color(srgb 1 0.42314 0 / 1), color(srgb 1 0.43781 0 / 1), color(srgb 1 0.45159 0 / 1), color(srgb 1 0.46445 0 / 1), color(srgb 1 0.47663 0 / 1), color(srgb 1 0.48821 0 / 1), color(srgb 1 0.49913 0 / 1), color(srgb 1 0.50946 0 / 1), color(srgb 1 0.5194 0.00025 / 1), color(srgb 1 0.53171 0.05099 / 1), color(srgb 1 0.54362 0.08665 / 1), color(srgb 1 0.55508 0.11675 / 1), color(srgb 1 0.56621 0.14078 / 1), color(srgb 1 0.57692 0.16381 / 1), color(srgb 1 0.58734 0.18409 / 1), color(srgb 1 0.59742 0.20351 / 1), color(srgb 1 0.60722 0.22203 / 1), color(srgb 1 0.6168 0.23892 / 1), color(srgb 1 0.62597 0.25645 / 1), color(srgb 1 0.63495 0.27277 / 1), color(srgb 1 0.64376 0.28801 / 1), color(srgb 1 0.65219 0.30409 / 1), color(srgb 1 0.66048 0.3192 / 1), color(srgb 1 0.66862 0.33348 / 1), color(srgb 1 0.67644 0.34807 / 1), color(srgb 1 0.68406 0.36243 / 1), color(srgb 1 0.69155 0.37611 / 1), color(srgb 1 0.69892 0.38918 / 1), color(srgb 1 0.70597 0.40288 / 1), color(srgb 1 0.71288 0.41619 / 1), color(srgb 1 0.71969 0.42897 / 1), color(srgb 1 0.7264 0.44127 / 1), color(srgb 1 0.73289 0.45367 / 1), color(srgb 1 0.73912 0.46623 / 1), color(srgb 1 0.74528 0.47835 / 1), color(srgb 1 0.75136 0.49007 / 1), color(srgb 1 0.75737 0.50143 / 1), color(srgb 1 0.7632 0.51278 / 1), color(srgb 1 0.76876 0.52444 / 1), color(srgb 1 0.77426 0.53576 / 1), color(srgb 1 0.7797 0.54675 / 1), color(srgb 1 0.78508 0.55745 / 1), color(srgb 1 0.79039 0.56787 / 1), color(srgb 1 0.79556 0.57824 / 1), color(srgb 1 0.80043 0.58891 / 1), color(srgb 1 0.80525 0.59931 / 1), color(srgb 1 0.81002 0.60946 / 1), color(srgb 1 0.81474 0.61937 / 1), color(srgb 1 0.81941 0.62905 / 1), color(srgb 1 0.82404 0.63852 / 1), color(srgb 1 0.82862 0.64778 / 1), color(srgb 1 0.83282 0.65746 / 1), color(srgb 1 0.83698 0.66693 / 1), color(srgb 1 0.8411 0.6762 / 1), color(srgb 1 0.84518 0.68528 / 1), color(srgb 1 0.84923 0.69418 / 1), color(srgb 1 0.85323 0.7029 / 1), color(srgb 1 0.8572 0.71145 / 1), color(srgb 1 0.86113 0.71985 / 1), color(srgb 1 0.86499 0.72814 / 1), color(srgb 1 0.86851 0.73667 / 1), color(srgb 1 0.87201 0.74505 / 1), color(srgb 1 0.87547 0.75327 / 1), color(srgb 1 0.8789 0.76134 / 1), color(srgb 1 0.88231 0.76927 / 1), color(srgb 1 0.88568 0.77707 / 1), color(srgb 1 0.88902 0.78474 / 1), color(srgb 1 0.89233 0.79228 / 1), color(srgb 1 0.89561 0.7997 / 1), color(srgb 1 0.89887 0.80701 / 1), color(srgb 1 0.9021 0.8142 / 1), color(srgb 1 0.90496 0.82155 / 1), color(srgb 1 0.9078 0.82879 / 1), color(srgb 1 0.91062 0.83591 / 1), color(srgb 1 0.91341 0.84293 / 1), color(srgb 1 0.91618 0.84983 / 1), color(srgb 1 0.91892 0.85664 / 1), color(srgb 1 0.92165 0.86334 / 1), color(srgb 1 0.92435 0.86995 / 1), color(srgb 1 0.92702 0.87646 / 1), color(srgb 1 0.92968 0.88288 / 1), color(srgb 1 0.93231 0.88921 / 1), color(srgb 1 0.93492 0.89545 / 1), color(srgb 1 0.93751 0.90161 / 1), color(srgb 1 0.94008 0.90769 / 1), color(srgb 1 0.94242 0.91377 / 1), color(srgb 1 0.94464 0.9198 / 1), color(srgb 1 0.94685 0.92575 / 1), color(srgb 1 0.94904 0.93162 / 1), color(srgb 1 0.95121 0.9374 / 1), color(srgb 1 0.95337 0.94312 / 1), color(srgb 1 0.9555 0.94876 / 1), color(srgb 1 0.95762 0.95432 / 1), color(srgb 1 0.95973 0.95982 / 1), color(srgb 1 0.96181 0.96525 / 1), color(srgb 1 0.96388 0.97061 / 1), color(srgb 1 0.96594 0.97591 / 1), color(srgb 1 0.96798 0.98114 / 1), color(srgb 1 0.97 0.98631 / 1), color(srgb 1 0.972 0.99142 / 1), color(srgb 1 0.974 0.99646 / 1), color(srgb 0.99855 0.97455 1 / 1), color(srgb 0.99365 0.97172 1 / 1), color(srgb 0.98885 0.96895 1 / 1), color(srgb 0.98416 0.96606 1 / 1), color(srgb 0.97956 0.96315 1 / 1), color(srgb 0.97506 0.96031 1 / 1), color(srgb 0.97065 0.95752 1 / 1), color(srgb 0.96632 0.9548 1 / 1), color(srgb 0.96208 0.95214 1 / 1), color(srgb 0.95793 0.94954 1 / 1), color(srgb 0.95385 0.94699 1 / 1), color(srgb 0.94985 0.94449 1 / 1), color(srgb 0.94593 0.94205 1 / 1), color(srgb 0.94207 0.93966 1 / 1), color(srgb 0.93829 0.93731 1 / 1), color(srgb 0.93458 0.93502 1 / 1), color(srgb 0.93094 0.93277 1 / 1), color(srgb 0.92735 0.93056 1 / 1), color(srgb 0.92384 0.9284 1 / 1), color(srgb 0.92038 0.92627 1 / 1), color(srgb 0.91698 0.92419 1 / 1), color(srgb 0.91364 0.92215 1 / 1), color(srgb 0.91036 0.92015 1 / 1), color(srgb 0.90713 0.91818 1 / 1), color(srgb 0.90395 0.91625 1 / 1), color(srgb 0.90083 0.91435 1 / 1), color(srgb 0.89776 0.91249 1 / 1), color(srgb 0.89474 0.91066 1 / 1), color(srgb 0.89176 0.90887 1 / 1), color(srgb 0.88883 0.9071 1 / 1), color(srgb 0.88604 0.90525 1 / 1), color(srgb 0.88329 0.90342 1 / 1), color(srgb 0.88058 0.90163 1 / 1), color(srgb 0.87791 0.89987 1 / 1), color(srgb 0.87529 0.89814 1 / 1), color(srgb 0.8727 0.89644 1 / 1), color(srgb 0.87016 0.89476 1 / 1), color(srgb 0.86765 0.89312 1 / 1), color(srgb 0.86518 0.8915 1 / 1), color(srgb 0.86274 0.8899 1 / 1), color(srgb 0.86035 0.88833 1 / 1), color(srgb 0.85798 0.88679 1 / 1), color(srgb 0.85565 0.88527 1 / 1), color(srgb 0.85336 0.88377 1 / 1), color(srgb 0.8511 0.8823 1 / 1), color(srgb 0.84886 0.88085 1 / 1), color(srgb 0.84666 0.87942 1 / 1), color(srgb 0.84449 0.87802 1 / 1), color(srgb 0.84235 0.87663 1 / 1), color(srgb 0.84024 0.87527 1 / 1), color(srgb 0.83816 0.87392 1 / 1), color(srgb 0.83611 0.8726 1 / 1), color(srgb 0.83408 0.87129 1 / 1), color(srgb 0.83208 0.87 1 / 1), color(srgb 0.8301 0.86873 1 / 1), color(srgb 0.82816 0.86748 1 / 1), color(srgb 0.82623 0.86625 1 / 1), color(srgb 0.82433 0.86504 1 / 1), color(srgb 0.82246 0.86384 1 / 1), color(srgb 0.82061 0.86265 1 / 1), color(srgb 0.81878 0.86149 1 / 1), color(srgb 0.81698 0.86034 1 / 1), color(srgb 0.8152 0.8592 1 / 1), color(srgb 0.81343 0.85808 1 / 1), color(srgb 0.8117 0.85698 1 / 1), color(srgb 0.80998 0.85589 1 / 1), color(srgb 0.80828 0.85481 1 / 1), color(srgb 0.8066 0.85375 1 / 1), color(srgb 0.80495 0.8527 1 / 1), color(srgb 0.80331 0.85167 1 / 1), color(srgb 0.80176 0.85062 1 / 1), color(srgb 0.80022 0.84959 1 / 1), color(srgb 0.79871 0.84857 1 / 1), color(srgb 0.79721 0.84756 1 / 1), color(srgb 0.79573 0.84656 1 / 1), color(srgb 0.79426 0.84558 1 / 1), color(srgb 0.79282 0.84461 1 / 1), color(srgb 0.79139 0.84365 1 / 1), color(srgb 0.78997 0.8427 1 / 1), color(srgb 0.78857 0.84177 1 / 1), color(srgb 0.78719 0.84084 1 / 1), color(srgb 0.78582 0.83993 1 / 1), color(srgb 0.78447 0.83902 1 / 1), color(srgb 0.78313 0.83813 1 / 1), color(srgb 0.7818 0.83725 1 / 1), color(srgb 0.78049 0.83638 1 / 1), color(srgb 0.7792 0.83552 1 / 1), color(srgb 0.77792 0.83466 1 / 1), color(srgb 0.77665 0.83382 1 / 1), color(srgb 0.77539 0.83299 1 / 1), color(srgb 0.77415 0.83217 1 / 1), color(srgb 0.77292 0.83135 1 / 1), color(srgb 0.77174 0.83054 1 / 1), color(srgb 0.77057 0.82974 1 / 1), color(srgb 0.76941 0.82894 1 / 1), color(srgb 0.76827 0.82816 1 / 1), color(srgb 0.76714 0.82738 1 / 1), color(srgb 0.76602 0.82661 1 / 1), color(srgb 0.76491 0.82585 1 / 1), color(srgb 0.76381 0.8251 1 / 1), color(srgb 0.76272 0.82435 1 / 1), color(srgb 0.76165 0.82362 1 / 1), color(srgb 0.76058 0.82289 1 / 1), color(srgb 0.75953 0.82217 1 / 1), color(srgb 0.75848 0.82145 1 / 1), color(srgb 0.75745 0.82075 1 / 1), color(srgb 0.75642 0.82005 1 / 1), color(srgb 0.75541 0.81935 1 / 1), color(srgb 0.7544 0.81867 1 / 1), color(srgb 0.75341 0.81799 1 / 1), color(srgb 0.75242 0.81732 1 / 1), color(srgb 0.75144 0.81666 1 / 1), color(srgb 0.75048 0.816 1 / 1), color(srgb 0.74952 0.81535 1 / 1), color(srgb 0.74857 0.8147 1 / 1), color(srgb 0.74763 0.81406 1 / 1), color(srgb 0.74669 0.81343 1 / 1), color(srgb 0.74577 0.81281 1 / 1), color(srgb 0.74485 0.81219 1 / 1), color(srgb 0.74395 0.81157 1 / 1), color(srgb 0.74308 0.81096 1 / 1), color(srgb 0.74222 0.81036 1 / 1), color(srgb 0.74137 0.80977 1 / 1), color(srgb 0.74052 0.80918 1 / 1), color(srgb 0.73968 0.80859 1 / 1), color(srgb 0.73886 0.80801 1 / 1), color(srgb 0.73803 0.80744 1 / 1), color(srgb 0.73722 0.80687 1 / 1), color(srgb 0.73641 0.80631 1 / 1), color(srgb 0.73561 0.80575 1 / 1), color(srgb 0.73481 0.80519 1 / 1), color(srgb 0.73403 0.80465 1 / 1), color(srgb 0.73325 0.8041 1 / 1), color(srgb 0.73247 0.80357 1 / 1), color(srgb 0.7317 0.80303 1 / 1), color(srgb 0.73094 0.8025 1 / 1), color(srgb 0.73019 0.80198 1 / 1), color(srgb 0.72944 0.80146 1 / 1), color(srgb 0.7287 0.80094 1 / 1), color(srgb 0.72796 0.80043 1 / 1), color(srgb 0.72723 0.79993 1 / 1), color(srgb 0.72651 0.79943 1 / 1), color(srgb 0.72579 0.79893 1 / 1), color(srgb 0.72508 0.79844 1 / 1), color(srgb 0.72437 0.79795 1 / 1), color(srgb 0.72367 0.79746 1 / 1), color(srgb 0.72297 0.79698 1 / 1), color(srgb 0.72228 0.79651 1 / 1), color(srgb 0.7216 0.79603 1 / 1), color(srgb 0.72092 0.79557 1 / 1), color(srgb 0.72025 0.7951 1 / 1), color(srgb 0.71958 0.79464 1 / 1), color(srgb 0.71892 0.79418 1 / 1), color(srgb 0.71826 0.79373 1 / 1), color(srgb 0.71761 0.79328 1 / 1), color(srgb 0.71697 0.79284 1 / 1), color(srgb 0.71635 0.7924 1 / 1), color(srgb 0.71574 0.79196 1 / 1), color(srgb 0.71514 0.79153 1 / 1), color(srgb 0.71454 0.7911 1 / 1), color(srgb 0.71394 0.79068 1 / 1), color(srgb 0.71335 0.79025 1 / 1), color(srgb 0.71276 0.78984 1 / 1), color(srgb 0.71218 0.78942 1 / 1), color(srgb 0.7116 0.78901 1 / 1), color(srgb 0.71103 0.7886 1 / 1), color(srgb 0.71046 0.78819 1 / 1), color(srgb 0.7099 0.78779 1 / 1), color(srgb 0.70933 0.78739 1 / 1)]\n</code></pre> Gamut: srgb <p>ColorAide also provides a method <code>cct()</code> which allows you to get an associated temperature and \u2206<sub>uv</sub> from a given color. \u2206<sub>uv</sub> will be discussed later.</p> <pre><code>&gt;&gt;&gt; color = Color.blackbody('srgb', 2000)\n&gt;&gt;&gt; color\ncolor(srgb 1 0.54362 0.08665 / 1)\n&gt;&gt;&gt; color.cct()\n[1999.9999999999993, -5.5295962522242654e-17]\n</code></pre> Gamut: srgb"},{"location":"temperature/#duv","title":"D<sub>uv</sub>","text":"<p>In addition to CCT, there is also the concept of D<sub>uv</sub> or \u2206<sub>uv</sub>. In the following image, we've now drawn perpendicular lines that intersect the black body curve. These lines are called isotherms. An isotherm is simply a line connecting points having the same temperature at a given time or on average over a given period. In the case of colors, they connect a number of colors that are close to the locus with the same temperature. \u2206<sub>uv</sub> describes the distance a given uv point is away from the associated uv point on the black body curve, positive being above the curve and negative being below the curve</p> <p></p> <p>Figure 2. 1960 Chromaticity Diagram with black body curve and isotherms indicating \u00b1 0.03 \u2206<sub>uv</sub>.</p> <p>We can calculate a color's associated temperature and its \u2206<sub>uv</sub> along the associated isotherm.</p> <pre><code>&gt;&gt;&gt; 'CCT: {}K Duv: {}'.format(*Color('yellow').cct())\n'CCT: 3934.7189746569234K Duv: 0.04024818555895665'\n</code></pre> Gamut: srgb <p>CCT and \u2206<sub>uv</sub> can also be used together to get a specific color that satisfies those requirements.</p> <pre><code>&gt;&gt;&gt; Color.blackbody('srgb-linear', *Color('yellow').cct())\ncolor(srgb-linear 1 1 0 / 1)\n</code></pre> Gamut: srgb"},{"location":"temperature/#limitations","title":"Limitations","text":"<p>All algorithms to calculate to and from CCT have some limitations and are only approximations, some being more accurate than others. Many algorithms are only accurate up to a certain temperature range. Additionally, it is recommend that colors that exhibit a \u2206<sub>uv</sub> larger than |5e-2| should be considered inaccurate, and some algorithm's may not do as well out to even this limit.</p>"},{"location":"temperature/#out-of-gamut-temperatures","title":"Out of Gamut Temperatures","text":"<p>It should be noted that <code>blackbody()</code> normalizes/scales the returned colors by default as the colors are often much too bright initially, all having a max luminance. This scaling is usually done under a linear RGB color space, Linear Rec2020 being the default as it encompasses the entire curve.</p> <p>Keep in mind that if the color is not in the display gamut it will need to be gamut mapped, and the gamut mapped value will not exhibit the same temperature. How far off it is will be depends on the disparity of the gamut sizes and how the color was gamut mapped.</p> <p></p> <p>Figure 3. CCT of 1200K in relation to the sRGB gamut.</p> <p>Colors that are outside the traditional RGB gamut (0 - 1) will be scaled to be within that range. If the color is beyond the gamut of the scaling color space, it will not convert back to the same temperature.</p> <pre><code>&gt;&gt;&gt; c = Color.blackbody('srgb', 1200)\n&gt;&gt;&gt; c\ncolor(srgb 1 0.3093 0 / 1)\n&gt;&gt;&gt; c.cct()\n[1305.4626114185926, -0.0053568532479511925]\n</code></pre> Gamut: srgb <p>Using a larger gamut, such as Linear Rec. 2020 that encompasses the entire black body curve, can allow for more accurate results throughout the entire range, but this may be impractical if you need to work in a smaller gamut.</p> <p>The desired RGB color space to scale within can be specified via <code>scale_space</code>. And if no scaling is desired, it can be turned off by setting <code>scale</code> to <code>False</code>.</p> <pre><code>&gt;&gt;&gt; c1 = Color.blackbody('display-p3', 1200, scale_space='display-p3-linear')\n&gt;&gt;&gt; c1\ncolor(display-p3 1 0.36021 0.0172 / 1)\n&gt;&gt;&gt; c1.cct()\n[1200.0000066930043, -1.093052476567441e-12]\n&gt;&gt;&gt; c2 = Color.blackbody('display-p3', 1200, scale=False)\n&gt;&gt;&gt; c2\ncolor(display-p3 1.6804 0.62798 0.05495 / 1)\n&gt;&gt;&gt; c2.cct()\n[1200.000006693005, -1.0930524765675185e-12]\n</code></pre> Gamut: srgb"},{"location":"temperature/#algorithms","title":"Algorithms","text":"<p>There are quite a few approaches to calculating to and from CCT, each with their strengths and weaknesses. ColorAide currently only supports a few approaches, specifically those that support the concept of CCT and \u2206<sub>uv</sub>. Each approach is implemented as a CCT plugin.</p> Algorithm Key Description Robertson\u00a01968 <code>robertson-1968</code> Uses the CIE 2\u02da Standard Observer and can handle a range of 1000K - \u221e. Ohno\u00a02013 <code>ohno-2013</code> Utilizes a combined approach of a triangular and parabolic solver. Current implementation allows for a range of 1000K - 100000K. <p>Robertson 1968 is the current default CCT approach, but any approach can be selected via the <code>method</code> parameter in <code>blackbody()</code> or <code>cct()</code>.</p> <pre><code>&gt;&gt;&gt; Color.blackbody('srgb-linear', 2500, method='ohno-2013').cct(method='ohno-2013')\n[2500.011703361377, 2.3130833455749082e-07]\n&gt;&gt;&gt; Color.blackbody('srgb-linear', 2500, method='robertson-1968').cct(method='robertson-1968')\n[2499.999999999999, 0.0]\n</code></pre> Gamut: srgb"},{"location":"temperature/#robertson-1968","title":"Robertson 1968","text":"<p>The Robertson 1968 CCT algorithm is registered in <code>Color</code> by default</p> <p>The \"Robertson 1968\" approach was created by A. R. Robertson and is based on the CIE 2\u02da Standard Observer with a range of 1667K - \u221e. This approach uses a look up table containing 31 precalculated points along the black body curve and is used to approximate temperatures in between.</p> <p>Robertson's approach is a reasonably fast approximation, but can exhibit moderate errors at times. The margin of error gets increasingly larger at very high temperatures approaching infinity.</p> <p>ColorAide implements the Robertson 1968 approach by faithfully calculating the original 31 points (with later corrections), but it also uses the same approach to extend the lower range from 1667K to 1000K by calculating 16 additional points.  There is no change in behavior from 1667K to \u221e, but it will now properly resolve values as low as 1000K as well.</p> <p>Practical Range</p> <p>While Robertson's technically supports a range out to infinity, it becomes increasingly less practical after 100000K due to increasingly less accurate results. Even some results below 100000K may already have fairly sizeable errors.</p> <pre><code>&gt;&gt;&gt; color = Color.blackbody('srgb-linear', 5000, duv=0.02)\n&gt;&gt;&gt; color\ncolor(srgb-linear 0.94158 1 0.49098 / 1)\n&gt;&gt;&gt; color.cct()\n[5000.000000000003, 0.020000000000000025]\n</code></pre> Gamut: srgb <p>Because the calculation logic is built into the plugin, you can actually use the plugin to generate a higher resolution table or even generate one using a different set of CMFs. When registering the plugin, you can configure the CMFs and a few other options to customize the look up table.</p> Parameters Description <code>cmfs</code> Valid CMFs at a resolution greater than or equal to 1nm. <code>white</code> A white point as xy chromaticity coordinates. <code>mired</code> The mired value points to generate in the table (1e6 / T<sub>kelvin</sub> = mired). Values should not be at a resolution lower than 1 mired as it can give the algorithm issues. 0 is acceptable though. <code>sigfig</code> Significant figures to round to. This is required to faithfully generate the values as documented in the papers and is set to <code>5</code> by default. If set to <code>0</code>, no rounding will be done. <code>planck_step</code> This controls the resolution at which the wavelengths in the CMFs are used to calculate the points along the Planckian locus. The original values are calculated with a 1nm resolution, so the default is set to <code>1</code>. If a given table has a lower resolution, such as 5nm, this value can be adjusted to properly work with that table. <p>To use a different set of CMFS, such as the CIE 1964 10\u02da Standard Observer, we could override the default plugin.</p> <pre><code>&gt;&gt;&gt; from coloraide.temperature import robertson_1968\n&gt;&gt;&gt; from coloraide import cmfs\n&gt;&gt;&gt; from coloraide import cat\n&gt;&gt;&gt; mired_points = tuple(range(0, 100, 10)) + tuple(range(100, 601, 25)) + tuple(range(625, 1001, 25))\n&gt;&gt;&gt; class Custom(Color):\n...     ...\n... \n&gt;&gt;&gt; Custom.register(\n...     robertson_1968.Robertson1968(cmfs.CIE_1964_10DEG, cat.WHITES['10deg']['D65'], mired_points, 0),\n...     overwrite=True\n... )\n&gt;&gt;&gt; Steps([Color.blackbody('srgb', t) for t in range(1000, 15000, 50)])\n[color(srgb 1 0.18142 0 / 1), color(srgb 1 0.22157 0 / 1), color(srgb 1 0.25489 0 / 1), color(srgb 1 0.28375 0 / 1), color(srgb 1 0.3093 0 / 1), color(srgb 1 0.33241 0 / 1), color(srgb 1 0.35347 0 / 1), color(srgb 1 0.3729 0 / 1), color(srgb 1 0.39084 0 / 1), color(srgb 1 0.40753 0 / 1), color(srgb 1 0.42314 0 / 1), color(srgb 1 0.43781 0 / 1), color(srgb 1 0.45159 0 / 1), color(srgb 1 0.46445 0 / 1), color(srgb 1 0.47663 0 / 1), color(srgb 1 0.48821 0 / 1), color(srgb 1 0.49913 0 / 1), color(srgb 1 0.50946 0 / 1), color(srgb 1 0.5194 0.00025 / 1), color(srgb 1 0.53171 0.05099 / 1), color(srgb 1 0.54362 0.08665 / 1), color(srgb 1 0.55508 0.11675 / 1), color(srgb 1 0.56621 0.14078 / 1), color(srgb 1 0.57692 0.16381 / 1), color(srgb 1 0.58734 0.18409 / 1), color(srgb 1 0.59742 0.20351 / 1), color(srgb 1 0.60722 0.22203 / 1), color(srgb 1 0.6168 0.23892 / 1), color(srgb 1 0.62597 0.25645 / 1), color(srgb 1 0.63495 0.27277 / 1), color(srgb 1 0.64376 0.28801 / 1), color(srgb 1 0.65219 0.30409 / 1), color(srgb 1 0.66048 0.3192 / 1), color(srgb 1 0.66862 0.33348 / 1), color(srgb 1 0.67644 0.34807 / 1), color(srgb 1 0.68406 0.36243 / 1), color(srgb 1 0.69155 0.37611 / 1), color(srgb 1 0.69892 0.38918 / 1), color(srgb 1 0.70597 0.40288 / 1), color(srgb 1 0.71288 0.41619 / 1), color(srgb 1 0.71969 0.42897 / 1), color(srgb 1 0.7264 0.44127 / 1), color(srgb 1 0.73289 0.45367 / 1), color(srgb 1 0.73912 0.46623 / 1), color(srgb 1 0.74528 0.47835 / 1), color(srgb 1 0.75136 0.49007 / 1), color(srgb 1 0.75737 0.50143 / 1), color(srgb 1 0.7632 0.51278 / 1), color(srgb 1 0.76876 0.52444 / 1), color(srgb 1 0.77426 0.53576 / 1), color(srgb 1 0.7797 0.54675 / 1), color(srgb 1 0.78508 0.55745 / 1), color(srgb 1 0.79039 0.56787 / 1), color(srgb 1 0.79556 0.57824 / 1), color(srgb 1 0.80043 0.58891 / 1), color(srgb 1 0.80525 0.59931 / 1), color(srgb 1 0.81002 0.60946 / 1), color(srgb 1 0.81474 0.61937 / 1), color(srgb 1 0.81941 0.62905 / 1), color(srgb 1 0.82404 0.63852 / 1), color(srgb 1 0.82862 0.64778 / 1), color(srgb 1 0.83282 0.65746 / 1), color(srgb 1 0.83698 0.66693 / 1), color(srgb 1 0.8411 0.6762 / 1), color(srgb 1 0.84518 0.68528 / 1), color(srgb 1 0.84923 0.69418 / 1), color(srgb 1 0.85323 0.7029 / 1), color(srgb 1 0.8572 0.71145 / 1), color(srgb 1 0.86113 0.71985 / 1), color(srgb 1 0.86499 0.72814 / 1), color(srgb 1 0.86851 0.73667 / 1), color(srgb 1 0.87201 0.74505 / 1), color(srgb 1 0.87547 0.75327 / 1), color(srgb 1 0.8789 0.76134 / 1), color(srgb 1 0.88231 0.76927 / 1), color(srgb 1 0.88568 0.77707 / 1), color(srgb 1 0.88902 0.78474 / 1), color(srgb 1 0.89233 0.79228 / 1), color(srgb 1 0.89561 0.7997 / 1), color(srgb 1 0.89887 0.80701 / 1), color(srgb 1 0.9021 0.8142 / 1), color(srgb 1 0.90496 0.82155 / 1), color(srgb 1 0.9078 0.82879 / 1), color(srgb 1 0.91062 0.83591 / 1), color(srgb 1 0.91341 0.84293 / 1), color(srgb 1 0.91618 0.84983 / 1), color(srgb 1 0.91892 0.85664 / 1), color(srgb 1 0.92165 0.86334 / 1), color(srgb 1 0.92435 0.86995 / 1), color(srgb 1 0.92702 0.87646 / 1), color(srgb 1 0.92968 0.88288 / 1), color(srgb 1 0.93231 0.88921 / 1), color(srgb 1 0.93492 0.89545 / 1), color(srgb 1 0.93751 0.90161 / 1), color(srgb 1 0.94008 0.90769 / 1), color(srgb 1 0.94242 0.91377 / 1), color(srgb 1 0.94464 0.9198 / 1), color(srgb 1 0.94685 0.92575 / 1), color(srgb 1 0.94904 0.93162 / 1), color(srgb 1 0.95121 0.9374 / 1), color(srgb 1 0.95337 0.94312 / 1), color(srgb 1 0.9555 0.94876 / 1), color(srgb 1 0.95762 0.95432 / 1), color(srgb 1 0.95973 0.95982 / 1), color(srgb 1 0.96181 0.96525 / 1), color(srgb 1 0.96388 0.97061 / 1), color(srgb 1 0.96594 0.97591 / 1), color(srgb 1 0.96798 0.98114 / 1), color(srgb 1 0.97 0.98631 / 1), color(srgb 1 0.972 0.99142 / 1), color(srgb 1 0.974 0.99646 / 1), color(srgb 0.99855 0.97455 1 / 1), color(srgb 0.99365 0.97172 1 / 1), color(srgb 0.98885 0.96895 1 / 1), color(srgb 0.98416 0.96606 1 / 1), color(srgb 0.97956 0.96315 1 / 1), color(srgb 0.97506 0.96031 1 / 1), color(srgb 0.97065 0.95752 1 / 1), color(srgb 0.96632 0.9548 1 / 1), color(srgb 0.96208 0.95214 1 / 1), color(srgb 0.95793 0.94954 1 / 1), color(srgb 0.95385 0.94699 1 / 1), color(srgb 0.94985 0.94449 1 / 1), color(srgb 0.94593 0.94205 1 / 1), color(srgb 0.94207 0.93966 1 / 1), color(srgb 0.93829 0.93731 1 / 1), color(srgb 0.93458 0.93502 1 / 1), color(srgb 0.93094 0.93277 1 / 1), color(srgb 0.92735 0.93056 1 / 1), color(srgb 0.92384 0.9284 1 / 1), color(srgb 0.92038 0.92627 1 / 1), color(srgb 0.91698 0.92419 1 / 1), color(srgb 0.91364 0.92215 1 / 1), color(srgb 0.91036 0.92015 1 / 1), color(srgb 0.90713 0.91818 1 / 1), color(srgb 0.90395 0.91625 1 / 1), color(srgb 0.90083 0.91435 1 / 1), color(srgb 0.89776 0.91249 1 / 1), color(srgb 0.89474 0.91066 1 / 1), color(srgb 0.89176 0.90887 1 / 1), color(srgb 0.88883 0.9071 1 / 1), color(srgb 0.88604 0.90525 1 / 1), color(srgb 0.88329 0.90342 1 / 1), color(srgb 0.88058 0.90163 1 / 1), color(srgb 0.87791 0.89987 1 / 1), color(srgb 0.87529 0.89814 1 / 1), color(srgb 0.8727 0.89644 1 / 1), color(srgb 0.87016 0.89476 1 / 1), color(srgb 0.86765 0.89312 1 / 1), color(srgb 0.86518 0.8915 1 / 1), color(srgb 0.86274 0.8899 1 / 1), color(srgb 0.86035 0.88833 1 / 1), color(srgb 0.85798 0.88679 1 / 1), color(srgb 0.85565 0.88527 1 / 1), color(srgb 0.85336 0.88377 1 / 1), color(srgb 0.8511 0.8823 1 / 1), color(srgb 0.84886 0.88085 1 / 1), color(srgb 0.84666 0.87942 1 / 1), color(srgb 0.84449 0.87802 1 / 1), color(srgb 0.84235 0.87663 1 / 1), color(srgb 0.84024 0.87527 1 / 1), color(srgb 0.83816 0.87392 1 / 1), color(srgb 0.83611 0.8726 1 / 1), color(srgb 0.83408 0.87129 1 / 1), color(srgb 0.83208 0.87 1 / 1), color(srgb 0.8301 0.86873 1 / 1), color(srgb 0.82816 0.86748 1 / 1), color(srgb 0.82623 0.86625 1 / 1), color(srgb 0.82433 0.86504 1 / 1), color(srgb 0.82246 0.86384 1 / 1), color(srgb 0.82061 0.86265 1 / 1), color(srgb 0.81878 0.86149 1 / 1), color(srgb 0.81698 0.86034 1 / 1), color(srgb 0.8152 0.8592 1 / 1), color(srgb 0.81343 0.85808 1 / 1), color(srgb 0.8117 0.85698 1 / 1), color(srgb 0.80998 0.85589 1 / 1), color(srgb 0.80828 0.85481 1 / 1), color(srgb 0.8066 0.85375 1 / 1), color(srgb 0.80495 0.8527 1 / 1), color(srgb 0.80331 0.85167 1 / 1), color(srgb 0.80176 0.85062 1 / 1), color(srgb 0.80022 0.84959 1 / 1), color(srgb 0.79871 0.84857 1 / 1), color(srgb 0.79721 0.84756 1 / 1), color(srgb 0.79573 0.84656 1 / 1), color(srgb 0.79426 0.84558 1 / 1), color(srgb 0.79282 0.84461 1 / 1), color(srgb 0.79139 0.84365 1 / 1), color(srgb 0.78997 0.8427 1 / 1), color(srgb 0.78857 0.84177 1 / 1), color(srgb 0.78719 0.84084 1 / 1), color(srgb 0.78582 0.83993 1 / 1), color(srgb 0.78447 0.83902 1 / 1), color(srgb 0.78313 0.83813 1 / 1), color(srgb 0.7818 0.83725 1 / 1), color(srgb 0.78049 0.83638 1 / 1), color(srgb 0.7792 0.83552 1 / 1), color(srgb 0.77792 0.83466 1 / 1), color(srgb 0.77665 0.83382 1 / 1), color(srgb 0.77539 0.83299 1 / 1), color(srgb 0.77415 0.83217 1 / 1), color(srgb 0.77292 0.83135 1 / 1), color(srgb 0.77174 0.83054 1 / 1), color(srgb 0.77057 0.82974 1 / 1), color(srgb 0.76941 0.82894 1 / 1), color(srgb 0.76827 0.82816 1 / 1), color(srgb 0.76714 0.82738 1 / 1), color(srgb 0.76602 0.82661 1 / 1), color(srgb 0.76491 0.82585 1 / 1), color(srgb 0.76381 0.8251 1 / 1), color(srgb 0.76272 0.82435 1 / 1), color(srgb 0.76165 0.82362 1 / 1), color(srgb 0.76058 0.82289 1 / 1), color(srgb 0.75953 0.82217 1 / 1), color(srgb 0.75848 0.82145 1 / 1), color(srgb 0.75745 0.82075 1 / 1), color(srgb 0.75642 0.82005 1 / 1), color(srgb 0.75541 0.81935 1 / 1), color(srgb 0.7544 0.81867 1 / 1), color(srgb 0.75341 0.81799 1 / 1), color(srgb 0.75242 0.81732 1 / 1), color(srgb 0.75144 0.81666 1 / 1), color(srgb 0.75048 0.816 1 / 1), color(srgb 0.74952 0.81535 1 / 1), color(srgb 0.74857 0.8147 1 / 1), color(srgb 0.74763 0.81406 1 / 1), color(srgb 0.74669 0.81343 1 / 1), color(srgb 0.74577 0.81281 1 / 1), color(srgb 0.74485 0.81219 1 / 1), color(srgb 0.74395 0.81157 1 / 1), color(srgb 0.74308 0.81096 1 / 1), color(srgb 0.74222 0.81036 1 / 1), color(srgb 0.74137 0.80977 1 / 1), color(srgb 0.74052 0.80918 1 / 1), color(srgb 0.73968 0.80859 1 / 1), color(srgb 0.73886 0.80801 1 / 1), color(srgb 0.73803 0.80744 1 / 1), color(srgb 0.73722 0.80687 1 / 1), color(srgb 0.73641 0.80631 1 / 1), color(srgb 0.73561 0.80575 1 / 1), color(srgb 0.73481 0.80519 1 / 1), color(srgb 0.73403 0.80465 1 / 1), color(srgb 0.73325 0.8041 1 / 1), color(srgb 0.73247 0.80357 1 / 1), color(srgb 0.7317 0.80303 1 / 1), color(srgb 0.73094 0.8025 1 / 1), color(srgb 0.73019 0.80198 1 / 1), color(srgb 0.72944 0.80146 1 / 1), color(srgb 0.7287 0.80094 1 / 1), color(srgb 0.72796 0.80043 1 / 1), color(srgb 0.72723 0.79993 1 / 1), color(srgb 0.72651 0.79943 1 / 1), color(srgb 0.72579 0.79893 1 / 1), color(srgb 0.72508 0.79844 1 / 1), color(srgb 0.72437 0.79795 1 / 1), color(srgb 0.72367 0.79746 1 / 1), color(srgb 0.72297 0.79698 1 / 1), color(srgb 0.72228 0.79651 1 / 1), color(srgb 0.7216 0.79603 1 / 1), color(srgb 0.72092 0.79557 1 / 1), color(srgb 0.72025 0.7951 1 / 1), color(srgb 0.71958 0.79464 1 / 1), color(srgb 0.71892 0.79418 1 / 1), color(srgb 0.71826 0.79373 1 / 1), color(srgb 0.71761 0.79328 1 / 1), color(srgb 0.71697 0.79284 1 / 1), color(srgb 0.71635 0.7924 1 / 1), color(srgb 0.71574 0.79196 1 / 1), color(srgb 0.71514 0.79153 1 / 1), color(srgb 0.71454 0.7911 1 / 1), color(srgb 0.71394 0.79068 1 / 1), color(srgb 0.71335 0.79025 1 / 1), color(srgb 0.71276 0.78984 1 / 1), color(srgb 0.71218 0.78942 1 / 1), color(srgb 0.7116 0.78901 1 / 1), color(srgb 0.71103 0.7886 1 / 1), color(srgb 0.71046 0.78819 1 / 1), color(srgb 0.7099 0.78779 1 / 1), color(srgb 0.70933 0.78739 1 / 1)]\n</code></pre> Gamut: srgb"},{"location":"temperature/#ohno-2013","title":"Ohno 2013","text":"<p>The Ohno 2013 CCT algorithm is registered in <code>Color</code> by default</p> <p>This is an approach researched by Yoshi Ohno and aims to provide better accuracy. It uses a look up table similar to the Robertson method and employs a combined approach of a triangular solver and a parabolic solver. This can lead to high accuracy if the table is large enough.</p> <p>Additionally, an \"automatic expansion\" technique can be used that starts with a small table and expands the table on smaller intervals based on the first solution. This can allow for a high accuracy without having to keep a large table in memory.</p> <p>For good accuracy throughout the range of 1000K - 100000K, as ColorAide supports, a very large table would be needed. If the \"automatic expansion\" technique was used, without caching the data which would cause the table to balloon in memory, the process is much slower.</p> <p>To mitigate the downside of storing a massive table in memory and to reduce the performance issues when using \"automatic expansion\", ColorAide uses a moderately sized table and creates a spline to interpolate points in between. The expansion technique is then used to get close to the target using the spline as the data table. Once points sufficiently close are found via the automatic expansion, more accurate values are calculated at those locations and are used in the triangular and parabolic solver. This allows us to use a smaller table while mitigating the performance issues associated with the expansion technique, all while maintaining good accuracy. The technique is still slower than the Robertson approach, but it is a more accurate approach.</p> <pre><code>&gt;&gt;&gt; color = Color.blackbody('srgb-linear', 5000, duv=0.02, method='ohno-2013')\n&gt;&gt;&gt; color\ncolor(srgb-linear 0.94166 1 0.49106 / 1)\n&gt;&gt;&gt; color.cct()\n[5000.015474747112, 0.019993847505661237]\n</code></pre> Gamut: srgb <p>ColorAide exposes some of the knobs to control the automatic expansion.</p> Parameter Description <code>start</code> Used to control the starting range for the search. Default is <code>1000</code>. For accuracy, the start should not be set lower than <code>1000</code>. <code>end</code> Used to control the ending range for the search. Default is <code>100000</code>. For accuracy, the end should not be set higher than <code>100000</code>. <code>samples</code> Number of sample points to use on each iteration of \"automatic expansion\". The default is <code>10</code>. <code>iterations</code> Number of iterations to perform when converging close to the temperature. The default is <code>6</code> as experimentation seemed indicate it yields the best results with a sample size of <code>10</code> and a range of 1000K - 100000K. <code>exact</code> Controls whether the spline approximation is used. When set to <code>True</code>, all values are directly calculated, bypassing the spline. Calculations will be slower when enabled. The default is <code>False</code> and will utilize the spline providing a performance boost. <p>By default, the entire range of 1000K to 100000K is explored when resolving CCT, but a smaller range can be used. This can be useful if you have an idea of the range, but not the specific value. Using a smaller range may allow for less iterations to achieve the same or better accuracy.</p> <pre><code>&gt;&gt;&gt; Color('orange').cct(method='ohno-2013')\n[2424.1146637385255, 0.008069417642630583]\n&gt;&gt;&gt; Color('orange').cct(start=2000, end=3000, iterations=3, method='ohno-2013')\n[2424.117026379762, 0.008069404687598869]\n</code></pre> Gamut: srgb <p>If a more pure approach is desired, <code>exact</code> can be used to directly use the \"automatic expansion\" without using the spline. The values for the table will be explicitly calculated on the fly. Performance will be affected with minimal to no increase in accuracy.</p> <pre><code>&gt;&gt;&gt; Color.blackbody('srgb-linear', 5000, duv=0.02).cct(method='ohno-2013')\n[4999.987927661827, 0.020006162744118677]\n&gt;&gt;&gt; Color.blackbody('srgb-linear', 5000, duv=0.02).cct(method='ohno-2013', exact=True)\n[4999.987927661827, 0.020006162744118677]\n</code></pre> Gamut: srgb <p>Lastly, the Ohno 2013 method can be used with other CMFs if desired. To do this, the plugin must be instantiated with different CMFs. The plugin supports a few initialization parameters to controls this.</p> Parameters Description <code>cmfs</code> Valid CMFs at a resolution greater than or equal to 1nm. <code>white</code> A white point as xy chromaticity coordinates. <code>planck_step</code> This controls the resolution at which the wavelengths in the CMFs are used to calculate the points along the Planckian locus. <code>5</code> (5nm) is used as the default as it provides decent performance vs accuracy. <p>To use an different CMFs, such as the CIE 10\u02da Standard Observer, we can add the plugin with our desired configuration, overwriting the defaults.</p> <pre><code>&gt;&gt;&gt; from coloraide import cmfs\n&gt;&gt;&gt; from coloraide import cat\n&gt;&gt;&gt; from coloraide.temperature.ohno_2013 import Ohno2013\n&gt;&gt;&gt; class Custom(Color):\n...     ...\n... \n&gt;&gt;&gt; Custom.register(\n...     Ohno2013(cmfs.CIE_1964_10DEG, cat.WHITES['10deg']['D65']),\n...     overwrite=True\n... )\n&gt;&gt;&gt; Steps([Custom.blackbody('srgb-linear', t, method='ohno-2013') for t in range(1000, 15000, 50)])\n[color(srgb-linear 1 0.04002 0 / 1), color(srgb-linear 1 0.05154 0 / 1), color(srgb-linear 1 0.06305 0 / 1), color(srgb-linear 1 0.07453 0 / 1), color(srgb-linear 1 0.08593 0 / 1), color(srgb-linear 1 0.09724 0 / 1), color(srgb-linear 1 0.10842 0 / 1), color(srgb-linear 1 0.11944 0 / 1), color(srgb-linear 1 0.1303 0 / 1), color(srgb-linear 1 0.14097 0 / 1), color(srgb-linear 1 0.15144 0 / 1), color(srgb-linear 1 0.16171 0 / 1), color(srgb-linear 1 0.17175 0 / 1), color(srgb-linear 1 0.18157 0 / 1), color(srgb-linear 1 0.19116 0 / 1), color(srgb-linear 1 0.20052 0 / 1), color(srgb-linear 1 0.20965 0 / 1), color(srgb-linear 1 0.21854 0 / 1), color(srgb-linear 1 0.22719 0 / 1), color(srgb-linear 1 0.2371 0.00195 / 1), color(srgb-linear 1 0.2484 0.00608 / 1), color(srgb-linear 1 0.25963 0.01052 / 1), color(srgb-linear 1 0.27081 0.01528 / 1), color(srgb-linear 1 0.28192 0.02035 / 1), color(srgb-linear 1 0.29296 0.02572 / 1), color(srgb-linear 1 0.30393 0.03139 / 1), color(srgb-linear 1 0.31483 0.03735 / 1), color(srgb-linear 1 0.32565 0.04361 / 1), color(srgb-linear 1 0.33639 0.05015 / 1), color(srgb-linear 1 0.34706 0.05696 / 1), color(srgb-linear 1 0.35764 0.06405 / 1), color(srgb-linear 1 0.36814 0.07141 / 1), color(srgb-linear 1 0.37856 0.07902 / 1), color(srgb-linear 1 0.3889 0.08688 / 1), color(srgb-linear 1 0.39915 0.09499 / 1), color(srgb-linear 1 0.40932 0.10333 / 1), color(srgb-linear 1 0.4194 0.1119 / 1), color(srgb-linear 1 0.4294 0.1207 / 1), color(srgb-linear 1 0.43931 0.12971 / 1), color(srgb-linear 1 0.44913 0.13893 / 1), color(srgb-linear 1 0.45886 0.14835 / 1), color(srgb-linear 1 0.46851 0.15796 / 1), color(srgb-linear 1 0.47807 0.16776 / 1), color(srgb-linear 1 0.48754 0.17774 / 1), color(srgb-linear 1 0.49693 0.1879 / 1), color(srgb-linear 1 0.50622 0.19821 / 1), color(srgb-linear 1 0.51543 0.20869 / 1), color(srgb-linear 1 0.52455 0.21932 / 1), color(srgb-linear 1 0.53358 0.23009 / 1), color(srgb-linear 1 0.54253 0.241 / 1), color(srgb-linear 1 0.55139 0.25204 / 1), color(srgb-linear 1 0.56016 0.26321 / 1), color(srgb-linear 1 0.56885 0.2745 / 1), color(srgb-linear 1 0.57745 0.2859 / 1), color(srgb-linear 1 0.58597 0.29741 / 1), color(srgb-linear 1 0.5944 0.30903 / 1), color(srgb-linear 1 0.60274 0.32073 / 1), color(srgb-linear 1 0.611 0.33253 / 1), color(srgb-linear 1 0.61918 0.34442 / 1), color(srgb-linear 1 0.62728 0.35638 / 1), color(srgb-linear 1 0.63529 0.36842 / 1), color(srgb-linear 1 0.64322 0.38053 / 1), color(srgb-linear 1 0.65107 0.3927 / 1), color(srgb-linear 1 0.65884 0.40493 / 1), color(srgb-linear 1 0.66652 0.41722 / 1), color(srgb-linear 1 0.67413 0.42956 / 1), color(srgb-linear 1 0.68166 0.44195 / 1), color(srgb-linear 1 0.68911 0.45438 / 1), color(srgb-linear 1 0.69648 0.46684 / 1), color(srgb-linear 1 0.70377 0.47934 / 1), color(srgb-linear 1 0.71099 0.49187 / 1), color(srgb-linear 1 0.71813 0.50443 / 1), color(srgb-linear 1 0.72519 0.51701 / 1), color(srgb-linear 1 0.73218 0.52961 / 1), color(srgb-linear 1 0.7391 0.54222 / 1), color(srgb-linear 1 0.74594 0.55485 / 1), color(srgb-linear 1 0.75271 0.56748 / 1), color(srgb-linear 1 0.75941 0.58012 / 1), color(srgb-linear 1 0.76604 0.59277 / 1), color(srgb-linear 1 0.77259 0.60541 / 1), color(srgb-linear 1 0.77908 0.61805 / 1), color(srgb-linear 1 0.78549 0.63068 / 1), color(srgb-linear 1 0.79184 0.64331 / 1), color(srgb-linear 1 0.79812 0.65592 / 1), color(srgb-linear 1 0.80433 0.66853 / 1), color(srgb-linear 1 0.81047 0.68111 / 1), color(srgb-linear 1 0.81655 0.69368 / 1), color(srgb-linear 1 0.82256 0.70623 / 1), color(srgb-linear 1 0.82851 0.71875 / 1), color(srgb-linear 1 0.8344 0.73125 / 1), color(srgb-linear 1 0.84022 0.74373 / 1), color(srgb-linear 1 0.84598 0.75617 / 1), color(srgb-linear 1 0.85167 0.76859 / 1), color(srgb-linear 1 0.85731 0.78097 / 1), color(srgb-linear 1 0.86288 0.79332 / 1), color(srgb-linear 1 0.8684 0.80564 / 1), color(srgb-linear 1 0.87385 0.81792 / 1), color(srgb-linear 1 0.87925 0.83016 / 1), color(srgb-linear 1 0.88459 0.84236 / 1), color(srgb-linear 1 0.88987 0.85452 / 1), color(srgb-linear 1 0.89509 0.86664 / 1), color(srgb-linear 1 0.90026 0.87872 / 1), color(srgb-linear 1 0.90538 0.89075 / 1), color(srgb-linear 1 0.91044 0.90273 / 1), color(srgb-linear 1 0.91544 0.91467 / 1), color(srgb-linear 1 0.92039 0.92656 / 1), color(srgb-linear 1 0.92529 0.93841 / 1), color(srgb-linear 1 0.93014 0.9502 / 1), color(srgb-linear 1 0.93493 0.96195 / 1), color(srgb-linear 1 0.93967 0.97364 / 1), color(srgb-linear 1 0.94437 0.98528 / 1), color(srgb-linear 1 0.94901 0.99687 / 1), color(srgb-linear 0.99167 0.94566 1 / 1), color(srgb-linear 0.9805 0.93947 1 / 1), color(srgb-linear 0.96964 0.93342 1 / 1), color(srgb-linear 0.95906 0.92751 1 / 1), color(srgb-linear 0.94877 0.92173 1 / 1), color(srgb-linear 0.93874 0.91607 1 / 1), color(srgb-linear 0.92897 0.91054 1 / 1), color(srgb-linear 0.91944 0.90513 1 / 1), color(srgb-linear 0.91016 0.89984 1 / 1), color(srgb-linear 0.90111 0.89465 1 / 1), color(srgb-linear 0.89229 0.88958 1 / 1), color(srgb-linear 0.88368 0.88461 1 / 1), color(srgb-linear 0.87528 0.87975 1 / 1), color(srgb-linear 0.86709 0.87499 1 / 1), color(srgb-linear 0.85909 0.87032 1 / 1), color(srgb-linear 0.85127 0.86574 1 / 1), color(srgb-linear 0.84364 0.86126 1 / 1), color(srgb-linear 0.83619 0.85687 1 / 1), color(srgb-linear 0.82891 0.85256 1 / 1), color(srgb-linear 0.8218 0.84833 1 / 1), color(srgb-linear 0.81484 0.84419 1 / 1), color(srgb-linear 0.80804 0.84013 1 / 1), color(srgb-linear 0.8014 0.83614 1 / 1), color(srgb-linear 0.7949 0.83223 1 / 1), color(srgb-linear 0.78854 0.82839 1 / 1), color(srgb-linear 0.78231 0.82463 1 / 1), color(srgb-linear 0.77622 0.82093 1 / 1), color(srgb-linear 0.77027 0.8173 1 / 1), color(srgb-linear 0.76443 0.81374 1 / 1), color(srgb-linear 0.75872 0.81024 1 / 1), color(srgb-linear 0.75313 0.8068 1 / 1), color(srgb-linear 0.74765 0.80342 1 / 1), color(srgb-linear 0.74228 0.80011 1 / 1), color(srgb-linear 0.73702 0.79685 1 / 1), color(srgb-linear 0.73187 0.79364 1 / 1), color(srgb-linear 0.72682 0.79049 1 / 1), color(srgb-linear 0.72187 0.7874 1 / 1), color(srgb-linear 0.71702 0.78436 1 / 1), color(srgb-linear 0.71226 0.78137 1 / 1), color(srgb-linear 0.70759 0.77843 1 / 1), color(srgb-linear 0.70301 0.77553 1 / 1), color(srgb-linear 0.69852 0.77269 1 / 1), color(srgb-linear 0.69412 0.76989 1 / 1), color(srgb-linear 0.68979 0.76714 1 / 1), color(srgb-linear 0.68555 0.76443 1 / 1), color(srgb-linear 0.68138 0.76176 1 / 1), color(srgb-linear 0.67729 0.75914 1 / 1), color(srgb-linear 0.67328 0.75656 1 / 1), color(srgb-linear 0.66934 0.75402 1 / 1), color(srgb-linear 0.66547 0.75152 1 / 1), color(srgb-linear 0.66166 0.74906 1 / 1), color(srgb-linear 0.65793 0.74663 1 / 1), color(srgb-linear 0.65426 0.74424 1 / 1), color(srgb-linear 0.65065 0.74189 1 / 1), color(srgb-linear 0.64711 0.73958 1 / 1), color(srgb-linear 0.64362 0.73729 1 / 1), color(srgb-linear 0.6402 0.73505 1 / 1), color(srgb-linear 0.63683 0.73283 1 / 1), color(srgb-linear 0.63352 0.73065 1 / 1), color(srgb-linear 0.63027 0.7285 1 / 1), color(srgb-linear 0.62707 0.72638 1 / 1), color(srgb-linear 0.62392 0.7243 1 / 1), color(srgb-linear 0.62082 0.72224 1 / 1), color(srgb-linear 0.61778 0.72021 1 / 1), color(srgb-linear 0.61478 0.71821 1 / 1), color(srgb-linear 0.61183 0.71624 1 / 1), color(srgb-linear 0.60893 0.71429 1 / 1), color(srgb-linear 0.60607 0.71238 1 / 1), color(srgb-linear 0.60326 0.71048 1 / 1), color(srgb-linear 0.60049 0.70862 1 / 1), color(srgb-linear 0.59777 0.70678 1 / 1), color(srgb-linear 0.59509 0.70497 1 / 1), color(srgb-linear 0.59245 0.70318 1 / 1), color(srgb-linear 0.58984 0.70141 1 / 1), color(srgb-linear 0.58728 0.69967 1 / 1), color(srgb-linear 0.58476 0.69795 1 / 1), color(srgb-linear 0.58227 0.69625 1 / 1), color(srgb-linear 0.57982 0.69458 1 / 1), color(srgb-linear 0.57741 0.69293 1 / 1), color(srgb-linear 0.57503 0.6913 1 / 1), color(srgb-linear 0.57269 0.68969 1 / 1), color(srgb-linear 0.57038 0.6881 1 / 1), color(srgb-linear 0.56811 0.68653 1 / 1), color(srgb-linear 0.56586 0.68498 1 / 1), color(srgb-linear 0.56365 0.68345 1 / 1), color(srgb-linear 0.56147 0.68194 1 / 1), color(srgb-linear 0.55933 0.68045 1 / 1), color(srgb-linear 0.55721 0.67898 1 / 1), color(srgb-linear 0.55512 0.67752 1 / 1), color(srgb-linear 0.55306 0.67609 1 / 1), color(srgb-linear 0.55102 0.67467 1 / 1), color(srgb-linear 0.54902 0.67327 1 / 1), color(srgb-linear 0.54704 0.67188 1 / 1), color(srgb-linear 0.54509 0.67051 1 / 1), color(srgb-linear 0.54317 0.66916 1 / 1), color(srgb-linear 0.54127 0.66782 1 / 1), color(srgb-linear 0.53939 0.6665 1 / 1), color(srgb-linear 0.53754 0.6652 1 / 1), color(srgb-linear 0.53572 0.66391 1 / 1), color(srgb-linear 0.53392 0.66264 1 / 1), color(srgb-linear 0.53214 0.66138 1 / 1), color(srgb-linear 0.53039 0.66013 1 / 1), color(srgb-linear 0.52866 0.6589 1 / 1), color(srgb-linear 0.52695 0.65769 1 / 1), color(srgb-linear 0.52526 0.65648 1 / 1), color(srgb-linear 0.52359 0.6553 1 / 1), color(srgb-linear 0.52195 0.65412 1 / 1), color(srgb-linear 0.52032 0.65296 1 / 1), color(srgb-linear 0.51871 0.65181 1 / 1), color(srgb-linear 0.51713 0.65067 1 / 1), color(srgb-linear 0.51556 0.64955 1 / 1), color(srgb-linear 0.51402 0.64844 1 / 1), color(srgb-linear 0.51249 0.64734 1 / 1), color(srgb-linear 0.51098 0.64625 1 / 1), color(srgb-linear 0.50949 0.64517 1 / 1), color(srgb-linear 0.50802 0.64411 1 / 1), color(srgb-linear 0.50656 0.64306 1 / 1), color(srgb-linear 0.50512 0.64202 1 / 1), color(srgb-linear 0.5037 0.64099 1 / 1), color(srgb-linear 0.5023 0.63997 1 / 1), color(srgb-linear 0.50091 0.63896 1 / 1), color(srgb-linear 0.49954 0.63796 1 / 1), color(srgb-linear 0.49818 0.63697 1 / 1), color(srgb-linear 0.49684 0.63599 1 / 1), color(srgb-linear 0.49552 0.63503 1 / 1), color(srgb-linear 0.4942 0.63407 1 / 1), color(srgb-linear 0.49291 0.63312 1 / 1), color(srgb-linear 0.49163 0.63219 1 / 1), color(srgb-linear 0.49036 0.63126 1 / 1), color(srgb-linear 0.48911 0.63034 1 / 1), color(srgb-linear 0.48787 0.62943 1 / 1), color(srgb-linear 0.48665 0.62853 1 / 1), color(srgb-linear 0.48544 0.62764 1 / 1), color(srgb-linear 0.48424 0.62675 1 / 1), color(srgb-linear 0.48306 0.62588 1 / 1), color(srgb-linear 0.48188 0.62502 1 / 1), color(srgb-linear 0.48072 0.62416 1 / 1), color(srgb-linear 0.47958 0.62331 1 / 1), color(srgb-linear 0.47844 0.62247 1 / 1), color(srgb-linear 0.47732 0.62164 1 / 1), color(srgb-linear 0.47621 0.62081 1 / 1), color(srgb-linear 0.47511 0.62 1 / 1), color(srgb-linear 0.47403 0.61919 1 / 1), color(srgb-linear 0.47295 0.61839 1 / 1), color(srgb-linear 0.47189 0.6176 1 / 1), color(srgb-linear 0.47083 0.61681 1 / 1), color(srgb-linear 0.46979 0.61603 1 / 1), color(srgb-linear 0.46876 0.61526 1 / 1), color(srgb-linear 0.46774 0.6145 1 / 1), color(srgb-linear 0.46673 0.61374 1 / 1), color(srgb-linear 0.46573 0.61299 1 / 1), color(srgb-linear 0.46474 0.61225 1 / 1), color(srgb-linear 0.46376 0.61151 1 / 1), color(srgb-linear 0.46279 0.61079 1 / 1), color(srgb-linear 0.46182 0.61006 1 / 1), color(srgb-linear 0.46087 0.60935 1 / 1), color(srgb-linear 0.45993 0.60864 1 / 1), color(srgb-linear 0.459 0.60793 1 / 1), color(srgb-linear 0.45808 0.60724 1 / 1), color(srgb-linear 0.45716 0.60655 1 / 1), color(srgb-linear 0.45626 0.60586 1 / 1), color(srgb-linear 0.45536 0.60519 1 / 1), color(srgb-linear 0.45447 0.60451 1 / 1), color(srgb-linear 0.45359 0.60385 1 / 1), color(srgb-linear 0.45272 0.60319 1 / 1), color(srgb-linear 0.45186 0.60253 1 / 1), color(srgb-linear 0.451 0.60188 1 / 1), color(srgb-linear 0.45015 0.60124 1 / 1)]\n</code></pre> Gamut: srgb"},{"location":"about/acknowledgments/","title":"Acknowledgments","text":"<p>All projects gain help and inspiration from somewhere, and we wanted to document the places in which we gathered knowledge, ideas, and help.</p>"},{"location":"about/acknowledgments/#projects","title":"Projects","text":""},{"location":"about/acknowledgments/#colorjs","title":"Color.js","text":"<p>When we began writing ColorAide, we wanted a simple interface to deal with different colors. We also wanted to support CSS colors which a lot of people are familiar with. We had a number of questions about the CSS spec and stumbled on Color.js, a JavaScript library developed and maintained by the co-authors of the CSS spec. We found Color.js and its authors helped clarify a number of confusing points. Additionally, their library did end up heavily inspiring many aspects of our own API as its approach very much aligned with the direction we had already started down.</p>"},{"location":"about/acknowledgments/#culori","title":"Culori","text":"<p>The Colorio library helped inspire the use of cubic splines as interpolation methods.</p>"},{"location":"about/acknowledgments/#colour-science","title":"Colour Science","text":"<p>The Colour Science project is a fantastic library that was used a great reference for comparing color behavior against. It's a fast, advanced library aimed at the more technical.</p>"},{"location":"about/acknowledgments/#references","title":"References","text":"<p>When researching color vision deficiencies, aside from the usual scientific papers, a couple of sites were found to be quite helpful.</p> <ul> <li>daltonlens.org was particularly helpful. As it comes from the perspective of an actual     Protan, it provided reviews on various algorithm's and explained in great depth some approaches and why they were     preferred over others.</li> <li>ixora.io was another useful site     that went into great details specifically about the Vi\u00e9not approach.</li> </ul>"},{"location":"about/changelog/","title":"Changelog","text":""},{"location":"about/changelog/#46","title":"4.6","text":"<ul> <li>NEW: Add new <code>rounding</code> option to control rounding modes in <code>to_string()</code>, <code>to_dict()</code>, <code>coords()</code>, <code>alpha()</code>,     and <code>get()</code>. New rounding modes are: <code>sigfig</code> and <code>decimal</code> which are in addition to the default <code>digits</code> mode.</li> <li>FIX: Fix typing for inherited colors.</li> </ul>"},{"location":"about/changelog/#451","title":"4.5.1","text":"<ul> <li>FIX: Ensure Jzazbz, JzCzhz, and ICtCp actually use <code>--jzazbz</code>, <code>--jzczhz</code>, and <code>--ictcp</code> by default when     serialized in the <code>color()</code> format.</li> </ul>"},{"location":"about/changelog/#45","title":"4.5","text":"<ul> <li>NEW: Support change in CSS HDR spec that now specifies Jzazbz, JzCzhz, and ICtCp serialization as using the     respective named color functions: <code>jzazbz()</code>, <code>jzczhz()</code>, and <code>ictcp()</code>. The <code>color()</code> format also use the custom     hyphenated names <code>--jzazbz</code>, <code>--jzczhz</code>, and <code>--ictcp</code> respectively by default. The non-hyphenated names are still     supported in the <code>color()</code> form for backwards compatibility, but usage is discouraged as at some future time     support for non-hyphenated names will be dropped as CSS has moved away from this as a supported convention.</li> <li>NEW: Reference ranges for Jzazbz, JzCzhz, and ICtCp, now match the latest CSS HDR spec.</li> <li>FIX: Fix order of magnitude calculation.</li> </ul>"},{"location":"about/changelog/#441","title":"4.4.1","text":"<ul> <li>FIX: Fix XYB transform.</li> </ul>"},{"location":"about/changelog/#44","title":"4.4","text":"<ul> <li>NEW: Add support for the CAM02 color model and add the CAM02 JMh, CAM02 UCS, CAM02 SCD, and CAM02 LCD color     spaces.</li> <li>NEW: Add the Hellwig corrections to CAM16 under a new color model variant called Hellwig which adds two new     color spaces: Hellwig JMh and Hellwig H-k JMh. The H-K variant add additional changes that adjusts lightness for the     Helmholtz\u2013Kohlrausch effect.</li> <li>NEW: Deprecate submodule name <code>cam16_jmh</code> and <code>zcam_jmh</code> in favor of the more generic <code>cam16</code> and <code>zcam</code> names.     Legacy submodule names are still accessible but will now raise a deprecation warning.</li> <li>FIX: Scale achromatic threshold depending on order of magnitude of component scaling. This ensures colors that     are scaled roughly between 0 - 1 are not considered achromatic earlier than a space scaled roughly between 0 - 100.</li> <li>FIX: Optimized matrix math operations should handle column vectors.</li> <li>FIX: Fix some issues with RYB Biased.</li> </ul>"},{"location":"about/changelog/#43","title":"4.3","text":"<ul> <li>NEW: Interpolate plugins now define a <code>get_space</code> hook allowing them to validate and return an appropriate     default space if the normal default cannot be supported.</li> <li>NEW: Drop Python 3.8 support as it is \"end of life\".</li> <li>NEW: Solve cubic Bezier curves algebraically for faster more predictable results.</li> <li>FIX: Typing fixes.</li> </ul>"},{"location":"about/changelog/#422","title":"4.2.2","text":"<ul> <li>FIX: More precise inverse of RYB Biased.</li> <li>FIX: Speed up solving of cubic Bezier for easing functions.</li> <li>FIX: Protect against possible divide by zero in HCT reverse transform.</li> </ul>"},{"location":"about/changelog/#421","title":"4.2.1","text":"<ul> <li>FIX: Hex output should force gamut mapping even if it is requested to disable it as output will be invalid     otherwise.</li> </ul>"},{"location":"about/changelog/#42","title":"4.2","text":"<ul> <li>NEW: Provide new color spaces Okl<sub>r</sub>ab/OkL<sub>r</sub>Ch which use a modified lightness prediction.</li> <li>NEW: Add new matrix math functions that are specifically optimized for matrices and vectors of length 3 and     leverage it in all appropriate places for a performance boost.</li> <li>NEW: Combine logic of <code>algebra</code> optimized vectorize functions and deprecate unnecessary function.</li> <li>NEW: Some typing fixes and adjustments.</li> </ul>"},{"location":"about/changelog/#41","title":"4.1","text":"<ul> <li>NEW: The <code>powerless</code> parameter is deprecated in <code>average()</code> as it is required to be always on for proper polar     space averaging.</li> <li>FIX: Polar space averaging was not setting hues to undefined when colors are evenly distributed. This is     required as circular means cannot be found in these cases.</li> <li>FIX: When averaging within a polar space, if the result hue is determined to be undefined at the end of     averaging, the color will be treated as if achromatic, setting saturation/chroma as necessary. This is needed to     prevent serialization of achromatic colors to a non-achromatic color when undefined values are resolved.</li> <li>FIX: Fully transparent colors should only contribute alpha in color averaging, regardless of <code>premultiply</code>     setting. This prevents fully transparent color channels, which provide no meaningful data, from distorting averages.</li> <li>FIX: When averaging in a polar space, if a color is considered achromatic but does not have an undefined hue,     the hue will be treated as undefined. Essentially the <code>powerless</code> parameter is now always <code>True</code>. This ensures that     achromatic colors properly contribute to the average without distorting the hue.</li> </ul>"},{"location":"about/changelog/#401","title":"4.0.1","text":"<ul> <li>FIX: Fix issue with <code>continuous</code> interpolation (and any that are derived from it, e.g., cubic spline     interpolations) that can cause bad hue fixup calculations.</li> <li>FIX: Fix issue with <code>continuous</code> interpolation (and any that are derived from it, e.g., cubic spline     interpolations) that can cause premultiplication to be applied to a color twice.</li> </ul>"},{"location":"about/changelog/#40","title":"4.0","text":"<ul> <li>NEW: Officially support Python 3.13.</li> <li>NEW: Define HTML output representation for Jupyter via <code>_repr_html_</code>.</li> <li>NEW: <code>get()</code>, <code>coords()</code>, <code>alpha()</code>, <code>to_dict()</code> can now return channel values with a specified precision via     the new <code>precision</code> parameter. Per channel precision can be controlled if a list of precision is given.</li> <li>NEW: <code>to_string()</code> support for per channel precision was added and <code>precision</code> can now accept a list of     precision.</li> <li>NEW: Remove deprecated <code>model</code> parameter from <code>cam16</code> \u2206E method. Space should be used instead.</li> <li>NEW: Remove deprecated <code>algebra.npow</code> function. <code>algebra.spow</code> should be used instead.</li> <li>NEW: New generic <code>minde-chroma</code> gamut mapping method that allows specifying any Lab-ish or LCh-ish space to     operate in. <code>oklch-chroma</code>, <code>lch-chroma</code>, and <code>hct-chroma</code> are now derived from <code>minde-chroma</code> and just default to     using the specified color space to provide backwards compatibility. <code>minde-chroma</code> defaults to using OkLCh by     default. <code>lch-chroma</code> is still ColorAide's default gamut mapping currently.</li> <li>NEW: All MINDE chroma reduction methods now skip distance checks if a JND of zero is specified. A JND of zero     essentially disables the MINDE behavior and will reduce chroma as close to the gamut boundary as possible faster     than it would previously.</li> <li>NEW: MINDE chroma reduction plugins now dynamically figures out lightness range instead of requiring it to be     specified as a class attribute.</li> <li>NEW: MINDE chroma reduction gamut mapping and ray trace gamut mapping now allow for specifying an <code>adaptive</code>     option which will bias the chroma reduction by the specified factor in a hue independent way relative to a midpoint     of L = 50%.</li> <li>NEW: Remove deprecated <code>lab</code> parameter from experimental <code>raytrace</code> gamut mapping method. Users should use     <code>pspace</code> instead to specify the perceptual space to use.</li> <li>NEW: Class method <code>layer()</code> added to replace <code>compose()</code> with a multi-color handling similar to other API     methods such as <code>interpolate()</code>, etc.</li> <li>NEW: <code>compose()</code> has been deprecated in favor of the new <code>layer()</code> method and will be removed at some future     time but is available to help with transition.</li> <li>NEW: Improve experimental <code>raytrace</code> gamut mapping approach when performed in certain perceptual spaces.</li> <li>NEW: The experimental <code>raytrace</code> gamut mapping method now uses OkLCh by default instead of CIELCh (D65). Results     may vary.</li> <li>BREAK: Pre-configured <code>oklch-raytrace</code> and <code>lch-raytrace</code> variants of the experimental <code>raytrace</code> gamut mapping     method have been removed to reduce included plugins. OkLCh is the default now and users can still specify CIELCh and     other perceptual spaces if desired via the <code>pspace</code> parameter. Additionally, documentation has been added so users     can easily recreate the aforementioned pre-configured methods themselves or their own desired variants.</li> <li>BREAK: MINDE chroma reductions plugin combines the <code>DE</code> and <code>DE_OPTIONS</code> class attributes under <code>DE_OPTIONS</code>.     Users who have a derived gamut mapping class must combined these two options under <code>DE_OPTIONS</code>.</li> <li>BREAK: MINDE chroma reduction plugin now specifies the perceptual space via the <code>PSPACE</code> attribute instead of     <code>SPACE</code>. Users who have a derived, personal gamut mapping plugin need to update the name accordingly.</li> <li>BREAK: MINDE chroma reduction plugins now specify the JND under the <code>JND</code> class attribute instead of <code>LIMIT</code>.     Users who have a derived, personal gamut mapping plugin need to update the name accordingly.</li> <li>BREAK: Interpolation plugin renamed the parameter <code>create</code> to <code>color_cls</code> which is a more descriptive and less     confusing name. If a user interpolation plugin is derived and overrides the <code>__init__</code> method, it should update to     use <code>color_cls</code> instead of <code>create</code>.</li> <li>FIX: HWB and HSV cannot normalize hue and saturation the same way as HSL when saturation is negative.</li> <li>FIX: Fix corner case in ZCAM that could throw a domain error.</li> <li>FIX: <code>Color.new()</code> was documented as a class method but was internally still an instance method. Ensure it is a     class method.</li> </ul>"},{"location":"about/changelog/#331","title":"3.3.1","text":"<ul> <li>FIX: Ray trace gamut mapping algorithm will better handle perceptual spaces like CAM16 and HCT which have     atypical achromatic responses. This prevents unexpected cutoff close to white.</li> <li>FIX: Fix some documentation examples regarding gamut mapping in HCT.</li> </ul>"},{"location":"about/changelog/#33","title":"3.3","text":"<ul> <li>NEW: Extend the <code>Cylindrical</code> mixin class to expose <code>radial_name()</code> and <code>radial_index()</code> on the color space to     return the default name or default index of the radial coordinate in polar color spaces. It also exposes     <code>is_polar()</code> as a simple check to see if the space uses polar coordinates.</li> <li>NEW: Euclidean distance algorithm will now handle cylindrical color spaces by converting the polar coordinates     to rectangular coordinates in order to return sensible results.</li> <li>NEW: Allow specifying number of colors to return for monochromatic harmony. When fewer are specified, allow them     to be spaced further apart for better contrast.</li> <li>FIX: Handle unexpected undefined values in Euclidean distance.</li> </ul>"},{"location":"about/changelog/#32","title":"3.2","text":"<ul> <li>NEW: Add <code>zcam-jmh</code> color model.</li> <li>NEW: Previously, color spaces such as <code>cam16-jmh</code>, <code>cam16-ucs</code>, <code>jzczhz</code>, etc. would handle achromatic values     absolutely, based on XYZ with the specified white point which could result in values with non-zero chroma. Now they     will be handled relative to the space, meaning colors will be considered achromatic when they are close to zero     chroma. What is considered achromatic is affected by the adapting luminance and other environmental settings.     This simplifies logic making it faster and also easier for users to subclass with their own environmental settings.</li> <li>NEW: Normalize how color spaces with special viewing conditions are configured. Document configuring viewing     conditions of color models where applicable.</li> <li>NEW: Add new <code>space</code> parameter in <code>cam16</code> \u2206E method to replace the now deprecate <code>model</code> parameter. <code>space</code> is     more flexible as users can now create CAM16 UCS spaces with different lighting environments and specify them     instead.</li> <li>NEW: Remove previously deprecated CAM16 Jab implementation. Use <code>cam16-ucs</code> instead.</li> <li>NEW: Interpolation will now gracefully handle a list of a single color causing the interpolation to just return     the single color.</li> <li>NEW: More helpful interpolation errors will raise for an empty list.</li> <li>NEW: Generic ray trace gamut mapping now has a new <code>pspace</code> parameter that can be used to specify a perceptual     space in either LCh-ish or Lab-ish form. <code>lch</code> parameter is now deprecated, but currently still present, but     <code>pspace</code> will take priority if both are defined.</li> <li>NEW: Rename <code>algebra.npow</code> to <code>algebra.spow</code> (signed power). <code>algebra.npow</code> is now deprecated and will be     removed at some future time.</li> <li>FIX: Don't force space to clamp negative XYZ when they are absolutizing them in some spaces.</li> <li>FIX: Ensure ST2084 EOTF implements the <code>max</code> step as specified in the spec.</li> </ul>"},{"location":"about/changelog/#312","title":"3.1.2","text":"<ul> <li>ENHANCE: Further improvements to both speed and accuracy of ray trace gamut mapping.</li> <li>FIX: Handle gamut mapping HDR spaces via ray trace more sanely.</li> </ul>"},{"location":"about/changelog/#311","title":"3.1.1","text":"<ul> <li>ENHANCE: Improved performance of ray tracing gamut mapping algorithm.</li> <li>FIX: Fix corner cases for detecting ray trace hits on gamut.</li> </ul>"},{"location":"about/changelog/#31","title":"3.1","text":"<ul> <li>NEW: Increase accuracy of the experimental ray tracing gamut mapping algorithm.</li> <li>NEW: Add generic gamut mapping algorithm that employs ray tracing method that can be used with any LCh     perceptual space.</li> <li>NEW: Ray tracing gamut mapping algorithm parameter <code>traces</code> will no longer do anything as the approach no longer     has variable passes after new accuracy enhancements.</li> <li>FIX: Jzazbz bug was fixed that would result in a divide by zero failure.</li> </ul>"},{"location":"about/changelog/#301","title":"3.0.1","text":"<ul> <li>FIX: Don't cache coercion of non-RGB space to RGB space in ray tracing gamut mapping algorithm as the underlying     color object could change underneath.</li> </ul>"},{"location":"about/changelog/#30","title":"3.0","text":"<ul> <li>BREAK: The CSS HDR spec now defines the polar spaces such as JzCzhz <code>color()</code> with hue channels that support     traditional hue syntax instead of percentages. Updated all polar spaces that are represented in the <code>color()</code> format     to support this change. This is likely low impact as using percentages for hues is fairly uncommon.</li> <li>BREAK: Remove previously deprecated functions: <code>algebra.apply</code>, <code>algebra.no_nans</code>, <code>algebra.no_nan</code>,     <code>algebra.is_nan</code>, <code>Labish.labish_names</code>, <code>Labish.labish_indexes</code>, <code>LChish.lchish_names</code>, and     <code>LCHish.lchish_indexes</code>. These were mainly used internally, so breakage is likely low.</li> <li>NEW: <code>jzazbz</code>, <code>jzczhz</code>, <code>ictcp</code>, <code>rec2100-pq</code>, and <code>rec2100-hlg</code> are now formally recognized, and by default     serialized, without the <code>--</code> prefix as all the spaces are now part of the official HDR specification in CSS.     Previously, the spec was unofficial. <code>--</code> prefixed names will still be recognized, but at some future time <code>--</code>     support will be removed for these spaces. Additionally, these spaces are now registered by default.</li> <li>NEW: \u2206E methods <code>z</code> and <code>itp</code> are now registered by default as their associated color spaces are now registered     by default as well.</li> <li>NEW: Color space channel flags <code>FLG_PERCENT</code> and <code>FLG_OPT_PERCENT</code> are deprecated and no longer used. They are     still present, but will be removed in the future.</li> <li>NEW: Update CSS percentage input/output ranges for <code>jzazbz</code>, <code>jzczhz</code>, and <code>ictcp</code> to match the CSS HDR spec.</li> <li>NEW: Ray tracing gamut mapping algorithms have been added: <code>oklch-raytrace</code> and <code>lch-raytrace</code>.</li> <li>NEW: RGB spaces now expose a <code>linear()</code> function on the underlying class to specify if they have a linear     equivalent.</li> <li>NEW: Adjust inheritance order of RGB spaces. Previously, many inherited from <code>sRGB</code>, now they inherit from     <code>sRGBLinear</code>.</li> <li>NEW: Add <code>rec2100-linear</code>, essentially and alias for <code>rec2020-linear</code>, that is specified in the CSS HDR     specification.</li> <li>FIX: Ensure that when using discrete interpolation that spline based interpolations are truly discrete.</li> </ul>"},{"location":"about/changelog/#216","title":"2.16","text":"<ul> <li>NEW: Gamut mapping plugins now must accept a <code>space</code> parameter and the color will not already be in the desired     gamut color space. This change was specifically made in order to fix a bug with HCT gamut mapping.</li> <li>FIX: Fix corner cases in HCT gamut mapping that would struggle with colors with high chroma and low lightness.</li> </ul>"},{"location":"about/changelog/#2151","title":"2.15.1","text":"<ul> <li>FIX: Small regression related to indirectly gamut mapping in another space other than its own.</li> </ul>"},{"location":"about/changelog/#215","title":"2.15","text":"<ul> <li>BREAK: \u2206E HCT used an extremely small JND by default to yield tonal palettes that were comparable to Google's     Material. This was not inline with other gamut mapping function defaults. The default is now a more appropriate     value of <code>2</code>. Users that relied on \u2206E HCT to help generate tonal pallets with HCT should now use the <code>jnd</code> parameter     to set the JND to <code>0.02</code> in order to generate tonal pallets more like Google.</li> <li>NEW: <code>fit()</code> now accepts a <code>jnd</code> option to control the JND limit when gamut mapping with <code>lch-chroma</code>,     <code>oklch-chroma</code>, and <code>hct-chroma</code>.</li> <li>NEW: <code>to_string()</code> can now accept a dictionary of arguments to control gamut mapping via the <code>fit</code> argument.</li> <li>FIX: Update <code>lch-chroma</code> epsilon to be consistent with other gamut mapping plugin conventions.</li> </ul>"},{"location":"about/changelog/#2141","title":"2.14.1","text":"<ul> <li>FIX: More precision for HCT conversion for better round trip conversions.</li> </ul>"},{"location":"about/changelog/#214","title":"2.14","text":"<ul> <li>NEW: <code>normalize()</code> will now also normalize a cylindrical color model with negative chroma/saturation to its     positive chroma/saturation form, assuming one exists.</li> <li>NEW: Gamut clipping is performed on a cylindrical color's normalized form ensuring that a color which is in     gamut but has a negative chroma/saturation will be mapped more correctly.</li> <li>NEW: Do not clamp user input of lightness and chroma in various spaces. Clamping will only occur during     conversion if the algorithm requires it.</li> <li>NEW: Channels can be accessed by <code>get</code> and <code>set</code> using their numerical value (as a string input).</li> <li>NEW: Color space plugins that specify the gamut space via <code>GAMUT_CHECK</code> must use that color space as a     reference when gamut mapping or clipping by default.</li> <li>NEW: New color space plugin attribute <code>CLIP_SPACE</code> added which will override the space specified by     <code>GAMUT_CHECK</code> to force clipping in the origin space even if a gamut mapping space is defined. This is only used when     it is advantageous to clip in the origin space, e.g. when faster and still practical.</li> <li>NEW: Deprecate non-standard CAM16 (Jab) space. People should use the standard CAM16 JMh or the CAM16 UCS, SCD,     or LCD Jab spaces. The non-standard Jab is still available via <code>coloraide.spaces.cam16.CAM16</code>, but it is no longer     available in <code>coloraide.everything</code> and will be removed at a future time.</li> <li>NEW: Add new channel aliases: <code>j</code> for <code>jz</code> in Jzazbz and JzCzhz. Also add <code>c</code> for <code>cz</code> and <code>h</code> for <code>hz</code> in     JzCzhz.</li> <li>NEW: HSL will now always return positive saturation for wide gamut colors via its conversion.</li> <li>FIX: Fix a an issue with the CAM16 model's transformation that prevented good round trip with negative     lightness.</li> <li>FIX: Ensure that when <code>harmony</code> auto creates a cylindrical space from a rectangular space that it checks     achromatic status in the original color space.</li> <li>FIX: \u2206E HCT should use colorfulness, not chroma, in the calculation.</li> <li>FIX: Don't return scientific notation when serializing colors.</li> <li>FIX: Small fix for Rec. 2100 PQ conversion algorithm.</li> <li>FIX: The oRGB color space should be gamut mapped in <code>srgb</code> as it is a transform of the sRGB space.</li> <li>FIX: Because Okhsl and Okhsv have a rough sRGB approximation and not precise, they are instead gamut mapped to     their own gamut by default.</li> <li>FIX: Much more accurate ICtCp matrices.</li> <li>FIX: Fix typing of deeply nested arrays in <code>algebra</code>.</li> <li>FIX: Fix issue with HCT undefined channel resolver.</li> <li>FIX: Proper handling of negative lightness for DIN99o.</li> <li>FIX: Circular mean should return positive values.</li> </ul>"},{"location":"about/changelog/#2131","title":"2.13.1","text":"<ul> <li>FIX: Minor typing regressions and fixes.</li> </ul>"},{"location":"about/changelog/#213","title":"2.13","text":"<ul> <li>NEW: Performance related enhancements in high traffic calculations.</li> <li>NEW: Use <code>matmul</code> instead of <code>dot</code> in calculations to not confuse math savvy people.</li> <li>FIX: Some typing fixes/improvements.</li> <li>FIX: Minor fixes to <code>algebra</code> library.</li> </ul>"},{"location":"about/changelog/#212","title":"2.12","text":"<ul> <li>NEW: When serializing, <code>percent</code> can now take a sequence of booleans to indicate which channels are desired to     be represented as a percentage, alpha included.</li> <li>NEW: <code>color()</code> serializing now supports string output with <code>percent</code>.</li> <li>FIX: When serializing, the alpha channel is no longer handled special with a minimum value of <code>5</code>. Precision is     equally applied to all channels.</li> </ul>"},{"location":"about/changelog/#211","title":"2.11","text":"<ul> <li>NEW: Add new <code>css-linear</code> interpolator that provides compatibility with the CSS specification. This deviates     from the default linear interpolator in how undefined hues are resolved for interpolation, particularly noticeable     with <code>longer</code> hue resolution.</li> <li>NEW: Add new <code>INTERPOLATOR</code> class option to change the default interpolator that is used.</li> </ul>"},{"location":"about/changelog/#210","title":"2.10","text":"<ul> <li>NEW: Declare official support for Python 3.12.</li> <li>NEW: <code>Color.steps</code> and <code>Color.discrete</code> now accept <code>delta_e_args</code> to allow configuring the underlying distance     algorithm when using the <code>delta_e</code> option.</li> <li>NEW: CIE Lab, both D50 and D65, are now derived from a <code>CIELab</code> class. CIE LCh, both D50 and D65, are also     now derived from a <code>CIELCh</code> class. This makes it easy to determine a CIE Lab or CIE LCh space from other Lab-like     spaces.</li> <li>NEW: \u2206E<sup>*</sup><sub>76</sub>, \u2206E<sup>*</sup><sub>94</sub>, \u2206E<sup>*</sup><sub>00</sub>, and \u2206E<sup>*</sup><sub>cmc</sub> all accept a new parameter called <code>space</code> which allows     the user to specify a registered Lab color space name (one that is derived from the <code>CIELab</code> class) to use as the     distancing color space. This allows a user to use D50 Lab (or any other variant) for distancing if required.</li> <li>FIX: For consistency, \u2206E<sup>*</sup><sub>94</sub> and \u2206E<sup>*</sup><sub>cmc</sub> now use Lab D65 by default just like \u2206E<sup>*</sup><sub>76</sub> and     \u2206E<sup>*</sup><sub>00</sub>. This fixes an issue where the docs indicated that they use D65, but in actuality they were using D50.</li> </ul>"},{"location":"about/changelog/#291post1","title":"2.9.1.post1","text":"<ul> <li>FIX: Fix incorrect changelog mention of recent fix being for HSL instead of HWB.</li> </ul>"},{"location":"about/changelog/#291","title":"2.9.1","text":"<ul> <li>FIX: Average should allow controlling <code>powerless</code> be disabled by default for backwards compatibility.</li> <li>FIX: HWB should use the algorithm defined in CSS that allows for round tripping even in the negative lightness     direction. Previously we were converting directly from HSV.</li> </ul>"},{"location":"about/changelog/#29","title":"2.9","text":"<ul> <li>NEW: Add <code>HWBish</code> mixin class.</li> <li>NEW: Deprecate <code>algebra.no_nan()</code>, <code>algebra.no_nans()</code>, and <code>algebra.is_nan()</code>.</li> <li>NEW: When averaging in a cylindrical space, always treat achromatic hues as powerless for better results.</li> <li>NEW: Add experimental support for CSS \"powerless\" hue handling and carrying-forward in interpolation, both     disabled by default.</li> <li>FIX: Fix RLAB conversion.</li> <li>FIX: Fix clipping of hues.</li> <li>ENHANCE: Tweaks to some matrix calculations.</li> <li>ENHANCE: Various performance related tweaks.</li> </ul>"},{"location":"about/changelog/#28","title":"2.8","text":"<ul> <li>NEW: Add Cubehelix color space.</li> <li>NEW: When precision is set to <code>-1</code> for string output, double precision (<code>17</code>) will be assumed.</li> <li>ENHANCE: More robust and generally better matrix inverse. Related inverse matrices have been regenerated for     consistency.</li> </ul>"},{"location":"about/changelog/#272","title":"2.7.2","text":"<ul> <li>FIX: More accurate easing logic.</li> </ul>"},{"location":"about/changelog/#271","title":"2.7.1","text":"<ul> <li>FIX: Fix issue where <code>harmony</code> would convert some colors to cylindrical spaces and not properly consider order     of channels.</li> <li>FIX: XYB, while Lab like in its default configuration, has such a large disparity in the non-lightness     components that the ranges for them should not be the same when using percentages.</li> <li>FIX: Lab like space mixins should not try and order <code>a</code> and <code>b</code> like coordinates when calling <code>indexes()</code>, but     should return them in there current order with lightness first. The meaning of these components can be different     enough for a given color space to make normalizing their ordered configuration meaningless and alter inherit hue     direction when processing for <code>harmony</code>.</li> </ul>"},{"location":"about/changelog/#27","title":"2.7","text":"<ul> <li>NEW: Add new RYB color space.</li> <li>NEW: Add <code>Regular</code> mixin class for normal, 3 channel color spaces (sRGB, CMY, RYB, etc.).</li> <li>NEW: <code>harmony()</code> can now accept and transform <code>Labish</code> and <code>Regular</code> color spaces to cylindrical spaces.</li> </ul>"},{"location":"about/changelog/#26","title":"2.6","text":"<ul> <li>NEW: Add <code>padding</code> parameter to limit color scales when interpolating.</li> </ul>"},{"location":"about/changelog/#25","title":"2.5","text":"<ul> <li>NEW: Add new <code>discrete()</code> function that creates a discrete interpolation object.</li> <li>NEW: Deprecate <code>coloraide.algebra.apply</code> function in favor of new vectorize functions.</li> <li>FIX: Fix small typing issue.</li> <li>FIX: Tweaks to Oklab 64 bit matrix precision.</li> <li>FIX: Fix <code>prismatic</code> and <code>cmyk</code> achromatic check logic.</li> <li>FIX: Ensure IPT uses the exact white point as documented in the paper.</li> <li>FIX: Fix various corner cases of algebraic functions and implement some performance improvements.</li> </ul>"},{"location":"about/changelog/#24","title":"2.4","text":"<ul> <li>NEW: Add Rec. 709 RGB color space.</li> <li>NEW: Add the 1960 UCS color space.</li> <li>NEW: Add correlated color temperature support with new <code>cct()</code> and <code>blackbody()</code> API.</li> <li>NEW: Add support for Robertson 1968 and Ohno 2013 CCT plugins.</li> <li>NEW: Add support for determining if a color is in the Pointer Gamut and provide a way to clamp a color to the     gamut.</li> <li>NEW: Include CMFS: CIE 1931 2 Degree Standard Observer, CIE 1964 10 Degree Standard Observer, CIE 2015 2 Degree     Standard Observer, and CIE 2015 10 Degree Standard Observer.</li> <li>NEW: Add <code>split_chromaticity()</code> method which will split a color into its chromaticity and luminance parts.</li> <li>NEW: Add <code>chromaticity()</code> which will create a new color from a given set of chromaticity coordinates.</li> <li>NEW: Relax <code>chromatic_adaptation()</code> type requirement of white point chromaticity inputs.</li> <li>NEW: <code>luminance()</code>, <code>xy()</code>, and <code>uv()</code> all now accept an optional white point via the <code>white</code> parameter to     control the white point in which the returned values are relative to. <code>luminance()</code> still defaults to D65 but will     use the current color's white point, like <code>xy()</code> and <code>uv()</code> if <code>white</code> is set to <code>None</code>.</li> <li>NEW: <code>white()</code> now accepts a positional parameter allowing it to output the white point of the current color     as various chromaticity coordinates in addition to the default XYZ coordinates.</li> <li>FIX: Fix case where deregistering all plugins with <code>*</code> was not deregistering <code>Filter</code> plugins.</li> </ul>"},{"location":"about/changelog/#23","title":"2.3","text":"<ul> <li>NEW ACEScc will now resolve undefined color channels (non-alpha) with a non-zero default that represents black     for consistency with other ACES color spaces.</li> <li>ENHANCE: Streamline averaging algorithm to increase performance.</li> <li>FIX: Ensure that HCT consistently clamps negative lightness and chroma to zero.</li> </ul>"},{"location":"about/changelog/#222","title":"2.2.2","text":"<ul> <li>FIX: Improve HCT round trip conversion speed and improve conversion in some weak areas.</li> </ul>"},{"location":"about/changelog/#221","title":"2.2.1","text":"<ul> <li>FIX: Averaging of a channel set with only undefined values should return an undefined value.</li> <li>FIX: Averaging should be done in linear light by default for a sane default. Default is now <code>srgb-linear</code>.</li> </ul>"},{"location":"about/changelog/#22","title":"2.2","text":"<ul> <li>NEW: Add XYB color space.</li> <li>ENHANCE: More efficient averaging.</li> <li>FIX: Fix issue where if all colors have the same channel undefined that a divide by zero can occur.</li> </ul>"},{"location":"about/changelog/#21","title":"2.1","text":"<ul> <li>NEW: Add new color averaging method.</li> <li>FIX: Interpolation should not modify any input colors.</li> </ul>"},{"location":"about/changelog/#202","title":"2.0.2","text":"<ul> <li>FIX: Consistent normalization of HWB hue.</li> <li>FIX: Consistent normalization of color in harmony monochromatic.</li> </ul>"},{"location":"about/changelog/#201","title":"2.0.1","text":"<ul> <li>FIX:  Incorrect result when interpolating from a cylindrical space to a rectangular space and using <code>out_space</code>.</li> </ul>"},{"location":"about/changelog/#20","title":"2.0","text":"<ul> <li> <p>BREAK: <code>interpolate</code>, <code>steps</code>, <code>mix</code>, <code>filter</code>, <code>compose</code>, and <code>harmony</code> will no longer base the output color on     the first input color. Colors will be evaluated in the specified color space and be output in that space unless     <code>out_space</code> is used to specify a specific output color space. For migration, specify the desired <code>out_space</code> if the     working <code>space</code> does not match the desired output.</p> </li> <li> <p>BREAK: Achromatic and undefined color channel handling has been rewritten. Color space objects no longer utilize     the <code>normalize()</code> or <code>achromatic_hue()</code> method and instead now use a new <code>is_achromatic()</code> and <code>resolve_channel()</code>     methods.</p> </li> <li> <p>NEW: Expose the new <code>Color.is_achromatic()</code> method to tell if colors, even non-cylindrical colors, are     achromatic or reasonably close to achromatic.</p> </li> <li> <p>NEW: Color channel definitions can specify a non-zero default for an undefined channel. Use <code>resolve_channel()</code>     for more advanced handling.</p> </li> <li> <p>NEW: CAM16, CAM16 UCS, CAM16 SCD, CAM15 LCD, CAM16 JMh, HCT, Jzazbz, JzCzhz, and IPT all currently require a     dynamic approach to detect achromatic colors. Undefined LCh chroma and hue channels and Lab a and b channels can now     resolve to non-zero values when undefined for better achromatic interpolation.</p> </li> <li> <p>NEW: ACEScct will now resolve undefined color channels (non-alpha) with a non-zero default that represents black     as zero is actually out of gamut for that space.</p> </li> <li> <p>NEW: <code>filter</code>, <code>compose</code>, and <code>harmony</code> all now support the <code>out_space</code> parameter.</p> </li> <li> <p>NEW: All <code>&lt;space&gt;ish</code> mixin classes now give access to normalized names and indexes as <code>names()</code> and <code>indexes()</code>     opposed to <code>&lt;space&gt;ish_names()</code> etc. Old methods are still available but are deprecated.</p> </li> <li> <p>NEW: All RGB, HSL, and HSV color spaces are now created with a respective <code>RGBish</code>, <code>HSLish</code>, and <code>HSVish</code> mixin     class.</p> </li> <li> <p>NEW: Separable blend modes will now be evaluated in whatever RGB-ish color space is provided.</p> </li> <li> <p>NEW: <code>compose</code> will throw an error if a non-RGB-ish color space is provided.</p> </li> <li> <p>NEW: <code>Color.normalize()</code> added a new <code>nans</code> parameter that when set to <code>False</code> will prevent achromatic hue     normalization and will just force all channels to be defined.</p> </li> <li> <p>NEW: <code>Color.coords()</code> and <code>Color.alpha()</code>, which used to be available during the alpha/beta period have been     re-added. <code>coords()</code> accesses just the color channels (no alpha channel) while <code>alpha()</code> gets the alpha channel.</p> </li> <li> <p>NEW: Coordinate access functions: <code>get()</code>, <code>set()</code>, <code>coords()</code>, and <code>alpha()</code> functions now have a <code>nans</code>     parameter that when set to <code>False</code> will ensure the component(s) is returned as a real number instead of NaN. Set     operations only apply this when passing the current value to a callback for relative modification.</p> </li> <li> <p>NEW: A <code>norm</code> parameter is now added to <code>convert</code> and <code>update</code>. When set to <code>False</code>, it will prevent achromatic     normalization of hues during conversion. If no conversion is needed, the color is returned as is.</p> </li> <li> <p>NEW: ColorAide used to gamut map colors such as HSL, HSV, and HWB when interpolating into those spaces. This is     no longer done. It is possible to gamut map wider gamuts with these color spaces, so it will be up to the user to     apply gamut mapping when it is determined they need it.</p> </li> <li> <p>NEW: <code>EXTENDED_RANGE</code> is no longer needed and is removed from current color space classes.</p> </li> <li> <p>NEW: Improved accuracy for Oklab, OkLCh, Okhsl, and Okhsv.</p> </li> <li> <p>NEW: New \"continuous\" interpolation method.</p> </li> <li> <p>FIX: Fix aliases in IPT and IgPgTg.</p> </li> <li> <p>FIX: Fix some conversion issues with CAM16 based color spaces that was caused due to bad achromatic handling.</p> </li> </ul>"},{"location":"about/changelog/#182","title":"1.8.2","text":"<ul> <li>FIX: Fix some exception messages.</li> </ul>"},{"location":"about/changelog/#181","title":"1.8.1","text":"<ul> <li>FIX: Ensure Judd-Vos correction is applied to linear RGB to LMS conversion for CVD.</li> <li>FIX: Fix outdated API information in docs.</li> </ul>"},{"location":"about/changelog/#180","title":"1.8.0","text":"<ul> <li>NEW: Modern sRGB, HSL, and HWB should allow mixed percentage and numbers. HSL and HWB percentages in the <code>hsl()</code>     and <code>hwb()</code> formats respectively will resolve to numbers in the range [0, 100]. These changes reflect the latest     changes in the CSS Level 4 Color spec.</li> <li>NEW: HSL and HWB can serialize to a modern syntax that does not use percentages, but the default still uses     percentages.</li> <li>NEW: Rework CSS parsing for better performance.</li> <li>FIX: Handle some parsing corner cases that are handled by browsers, but not by ColorAide. For example,     <code>color(srgb 1-0.5.4)</code> should parse as <code>color(srgb 1 -0.5 0.4)</code>.</li> <li>FIX: Ensure that <code>COLOR_FORMAT</code> is respected.</li> </ul>"},{"location":"about/changelog/#171","title":"1.7.1","text":"<ul> <li>FIX: Ensure CAM16 spaces mirrors positive and negative percentages for <code>a</code> and <code>b</code> components.</li> <li>FIX: Since the CAM16 JMh model can not predict achromatic colors with negative lightness and, more importantly,     negative lightness is not useful, limit the lower end of lightness in CAM16 spaces to zero.</li> <li>FIX: When a CAM16 JMh (or HCT) color's chroma, when not discounting illuminance, has chroma drop below the     actual ideal achromatic chroma threshold, just use the ideal chroma to ensure better conversion back to XYZ.</li> <li>FIX: Jzazbz and JzCzhz model can never translate a color with a negative lightness, so just clamp negative     lightness while in Jzazbz and JzCzhz.</li> <li>FIX: Fix a math error in CAM16.</li> <li>FIX: Fix CAM16 JMh M limit which was too low.</li> <li>FIX: IPT was set to \"bound\" when it should have an unbounded gamut.</li> <li>FIX: When both <code>comma</code> and <code>none</code> are enabled it could make undefined alpha values show up as <code>none</code> in legacy     CSS format.</li> <li>FIX: Sane handling of inverse lightness in DIN99o.</li> </ul>"},{"location":"about/changelog/#17","title":"1.7","text":"<ul> <li>NEW: Add support for CAM16 Jab and JMh: <code>cam16</code> and <code>cam16-jmh</code> respectively.</li> <li>NEW: Add support for CAM16 UCS (Jab forms): <code>cam16-ucs</code>, <code>cam16-scd</code>, and <code>cam16-lcd</code>.</li> <li>NEW: Add support for the HCT color space (<code>hct</code>) which combines the colorfulness and hue from CAM16 JMh and the     lightness from CIELab.</li> <li>NEW: Gamut mapping classes derived from <code>fit_lch_chroma</code> can set <code>DE_OPTIONS</code> to pass \u2206E parameters.</li> <li>NEW: While rare, some cylindrical color spaces have an algorithm such that achromatic colors convert best with a     very specific hue. Internally, this is now handled during conversions, but there can be reasons where knowing the     hue can be useful such as plotting. Cylindrical spaces now expose a method called <code>achromatic_hue()</code> which will     return this specific hue if needed.</li> <li>FIX: Fix <code>rec2100-hlg</code> transform.</li> <li>FIX: Some color transformation improvements.</li> <li>FIX: Relax some achromatic detection logic for sRGB cylindrical models. Improves achromatic hue detection     results when converting to and from various non-sRGB color spaces.</li> </ul>"},{"location":"about/changelog/#16","title":"1.6","text":"<ul> <li>NEW: Add <code>rec2100-hlg</code> color space.</li> <li>BREAKING: <code>rec2100pq</code> should have been named <code>rec2100-pq</code> for consistency. It has been renamed to <code>rec2100-pq</code>     and serializes with the CSS ID of <code>--rec2100-pq</code>. This is likely to have little impact on most users.</li> </ul>"},{"location":"about/changelog/#15","title":"1.5","text":"<ul> <li>NEW: Formally add support for Python 3.11.</li> <li>NEW: Add support for custom domains when interpolating.</li> <li>NEW: <code>set()</code> can now take a dictionary of channels and values and set multiple channels at once.</li> <li>NEW: <code>get()</code> can now take a list of channels and will return a list of those channel values.</li> <li>ENHANCE: Simplify some type annotation syntax.</li> <li>ENHANCE: Some minor performance enhancements.</li> <li>FIX: Fix OkLCh CSS parsing.</li> </ul>"},{"location":"about/changelog/#14","title":"1.4","text":"<ul> <li>NEW: A color space can now declare its dynamic range. By default, spaces are assumed to be SDR, but can declare     themselves as HDR, or something else. This allows ColorAide to make decisions based on a color's dynamic range.</li> <li>NEW: Add channel aliases for IPT and IPT-like color spaces (IgPgTg and ICtCp): <code>intensity</code>, <code>protan</code>, and     <code>tritan</code>.</li> <li>FIX: The ICtCp and oRGB space would return the Lab-ish equivalents for <code>a</code> and <code>b</code> in reverse order if calling     <code>Labish.labish_names</code>. This was not actually called anywhere in the code, but is now fixed for any future cases that     may require calling it.</li> <li>FIX: Undefined channels should be ignored when clipping a color.</li> <li>FIX: Do not apply SDR shortcuts in gamut mapping when fitting in a non-SDR color gamut, such as HDR.</li> </ul>"},{"location":"about/changelog/#13","title":"1.3","text":"<ul> <li>ENHANCE: Color vision deficiency filters can now be instantiated with different default methods for severe and     anomalous cases.</li> <li>FIX: Fix premultiplication handling when using <code>compose</code>.</li> </ul>"},{"location":"about/changelog/#12","title":"1.2","text":"<ul> <li>NEW: Add new monotone interpolation method.</li> <li>ENHANCE: Better extrapolation past end of spline.</li> <li>FIX: Small speed up in natural spline calculation.</li> <li>FIX: Fix import that should have been relative, not absolute.</li> </ul>"},{"location":"about/changelog/#11","title":"1.1","text":"<ul> <li>NEW: Slight refactor of interpolation plugin so that common code does not need to be duplicated, and the     <code>interpolate</code> method no longer needs to accept an <code>easing</code> parameter as the plugin class exposes a new <code>ease</code> method     to automatically acquire the proper, specified easing function and apply it.</li> <li>NEW: Functions built upon interpolation can now use a new <code>extrapolate</code> parameter to enable extrapolation if     interpolation inputs exceed 0 - 1. <code>point</code> will be passed to <code>Interpolator.interpolate</code> un-clamped if <code>extrapolate</code>     is enabled. If a particular interpolation plugin needs to do additional work to handle extrapolation, they can check     <code>self.extrapolate</code> to know whether extrapolation is enabled.</li> <li>NEW: Implement and provide the following easing functions as described in the CSS Easing Level 1 spec:     <code>cubic_bezier</code>, <code>ease</code>, <code>ease_in</code>, <code>ease_out</code>, and <code>ease_in_out</code>. Also provide a simple <code>linear</code> easing function.</li> <li>New: Add <code>natural</code> and <code>catrom</code> cubic spline options for interpolation. The <code>catrom</code> (Catmull-Rom) spline     requires the plugin to be registered in order to use it.</li> <li>FIX: Due to floating point math, B-spline could sometimes return an interpolation of fully opaque colors with an     imperceptible amount of transparency. If alpha is very close (<code>1e-6</code>) to being opaque, just round it to     opaque.</li> <li>FIX: An easing function's output should not be clamped, only the input, and that only needs to occur on the     outer range of an entire interpolation.</li> </ul>"},{"location":"about/changelog/#10","title":"1.0","text":"<p>Stable Release!</p> <p>Checkout migration guide if you were an early adopter.</p> <ul> <li>NEW: Bezier interpolation dropped for B-spline which provides much better interpolation.</li> <li>NEW: All new interpolation methods now supports hue fix-ups: <code>shorter</code>, <code>longer</code>, <code>increasing</code>, <code>decreasing</code>,     and <code>specified</code>.</li> <li>NEW: Interpolation is now exposed as a plugin to allow for expansion.</li> <li>FIX: Fixed an issue related to premultiplication and undefined alpha channels.</li> </ul>"},{"location":"about/changelog/#10rc1","title":"1.0rc1","text":"<p>Plugin Refactor</p> <p>For more flexibility there was one final rework of plugins. Registering requires all plugins to be instantiated before being passed into <code>Color.register</code>, but this allows a user redefine some defaults of certain plugins.</p> <p><code>coloraide.ColorAll</code> was moved to <code>coloraide.everythng.ColorAll</code> to avoid allocating plugins when they are not desired.</p> <p>In the process, we also renamed a number of plugin classes for consistency and predictability, details found below.</p> <ul> <li> <p>NEW: Updated some class names for consistency and predictability. <code>XyY</code> \u2192 <code>xyY</code>, <code>Din99o</code> \u2192 <code>DIN99o</code>, <code>SRGB</code>     \u2192 <code>sRGB</code>, and <code>ORGB</code> \u2192 <code>oRGB</code>.</p> <p>Lastly, <code>LCh</code> should be the default casing convention. This convention will be followed unless a spec mentions otherwise. Changes: <code>Lch</code> \u2192 <code>LCh</code>, <code>LchD65</code> \u2192 <code>LChD65</code>, <code>Oklch</code> \u2192 <code>OkLCh</code>, <code>Lchuv</code> \u2192 <code>LChuv</code>, <code>Lch99o</code> \u2192 <code>LCh99o</code>, <code>LchChroma</code> \u2192 <code>LChChroma</code>, <code>OklchChroma</code> \u2192 <code>OkLChChroma</code>, and <code>Lchish</code> \u2192 <code>LChish</code>.</p> </li> <li> <p>NEW: Updated migration guide with recent plugin changes.</p> </li> <li>NEW: <code>coloraide.ColorAll</code> renamed and moved to <code>coloraide.everything.ColorAll</code>. This prevents unnecessary     inclusion and allocation of objects that are not desired.</li> <li>NEW: Default <code>Color</code> object now only registers <code>bradford</code> CAT by default, all others must be registered     separately, or <code>coloraide.everything.Color</code> could be used.</li> <li> <p>NEW: All plugin classes must be instantiated when being registered. This allows some plugins to be instantiated     with different defaults. This allows some plugins to be configured with different defaults.</p> <pre><code># Before change:\nColor.register([Plugin1, Plugin2])\n\n# After change:\nColor.register([Plugin1(), Plugin2(optional_parm=True)])\n</code></pre> </li> <li> <p>FIX: Negative luminance is now clamped during contrast calculations.</p> </li> </ul>"},{"location":"about/changelog/#10b3","title":"1.0b3","text":"<ul> <li>FIX: Fixed the bad <code>CAT16</code> matrix for chromatic adaptation.</li> <li>FIX: Small fix related to how <code>CAT</code> plugin classes are defined for better abstraction.</li> <li>FIX: Restrict optional keywords in <code>Color.register()</code> and <code>Color.deregister()</code> to keyword only parameters.</li> </ul>"},{"location":"about/changelog/#10b2","title":"1.0b2","text":"<p>Breaking Changes</p> <p>1.0b2 only introduces one more last breaking change that was forgotten in 1.0b1.</p> <ul> <li>BREAK: Remove <code>filters</code> parameter on new class instantiation.</li> <li>NEW: Added new migration guide to the documentation to help early adopters move to the 1.0 release.</li> <li>NEW: Added HPLuv space described in the HSLuv spec.</li> <li>NEW: Added new color spaces: ACES 2065-1, ACEScg, ACEScc, and ACEScct.</li> <li>NEW: Contrast is now exposed as a plugin to allow for future expansion of approaches. While there is currently     only one approach, methods can be selected via the <code>method</code> attribute.</li> <li>NEW: Add new <code>random</code> method for generating a random color for a given color space.</li> </ul>"},{"location":"about/changelog/#10b1","title":"1.0b1","text":"<p>Breaking Changes</p> <p>1.0b1 introduces a number of breaking changes. As we are very close to releasing the first stable release, we've taken opportunity to address any issues related to speed and usability. While this is unfortunate for early adopters, we feel that in the long run that these changes will make ColorAide a better library. We've also added new a new Bezier interpolation method and added many more color spaces!</p> <ul> <li> <p>BREAK: The <code>coloraide.Color</code> object now only registers a subset of the available color spaces and \u2206E algorithms     in order to create a lighter default color object. <code>coloraide.ColorAll</code> has been provided for a quick way to get     access to all available color spaces and plugins. Generally, it is recommend to subclass <code>Color</code> and register just     what is desired.</p> </li> <li> <p>BREAK: Reworked interpolation:</p> <ul> <li><code>interpolate</code> and <code>steps</code> functions are now <code>@classmethod</code>s. This alleviates the awkward handling of     interpolating colors greater than 2. Before, the first color always had to be an instance and then the rest had     to be fed into that instance, now the methods can be called from the base class or an instance with all the     colors fed in via a list. Only the colors in the list will be evaluated during interpolation.</li> <li><code>Piecewise</code> object has been removed.</li> <li><code>stop</code> objects are used to wrap colors to apply a new color stop.</li> <li>easing functions can be supplied in the middle of two colors via the list input.</li> <li><code>hint</code> function has been provided to simulate CSS color hinting. <code>hint</code> returns an easing function that modifies     the midpoint to the specified point between two color stops.</li> <li>A new bezier interpolation method has been provided. When using <code>interpolate</code>, <code>steps</code>, or <code>mix</code> the     interpolation style can be changed via the <code>method</code> parameter. <code>bezier</code> and <code>linear</code> are available with <code>linear</code>     being the default.</li> </ul> </li> <li> <p>BREAK: Dictionary input/output now matches the following format (where alpha is optional):</p> <pre><code>{\"space\": \"name\", \"coords\": [0, 0, 0], \"alpha\": 1}\n</code></pre> <p>This allows for quicker processing and less complexity dealing with channel names and aliases.</p> </li> <li> <p>BREAK: The CSS Level 4 Color spec has accepted our proposed changes to the gamut mapping algorithm. With this     change, the <code>oklch-chroma</code> gamut mapping algorithm is now compliant with the CSS spec, and <code>css-color-4</code> is no     longer needed. If you were experimenting with <code>css-color-4</code>, please use <code>oklch-chroma</code> instead. The algorithm is     faster and does not have the color banding issue that <code>css-color-4</code> had, and it is now exactly the same as the CSS     spec.</p> </li> <li> <p>BREAK: New breaking change. Refactor of <code>Space</code> plugins. <code>Space</code> plugins are no longer instantiated which cuts     down on overhead lending to better performance. <code>BOUNDS</code> and <code>CHANNEL_NAMES</code> attributes were combined into one     attribute called <code>CHANNELS</code> which serves the same purpose as the former attributes. <code>Space</code> plugins also no longer     need to define channel property accessors as those are handled through <code>CHANNELS</code> in a more generic way. This is a     breaking change for any custom plugins.</p> <p>Additionally, the <code>Space</code> plugin's <code>null_adjust</code> method has been renamed as <code>normalize</code> matching its functionality and usage in regards to the <code>Color</code> object. It no longer accepts color coordinates and alpha channel coordinates separately, but will receive them as a single list and return them as such.</p> </li> <li> <p>BREAK: <code>Color</code>'s <code>fit</code> and <code>clip</code> methods now perform the operation in place, modifying the current color     directly. The <code>in_place</code> parameter has been removed. To create a new color when performing these actions, simply     clone the color first: <code>color.clone().clip()</code>.</p> </li> <li> <p>BREAK: Remove deprecated dynamic properties which helps to increase speed by removing overhead on class property     access.</p> </li> <li> <p>BREAK: Remove deprecated dynamic properties which helps to increase speed by removing overhead on class property     access. Use indexing instead: <code>color['red']</code> or <code>color[0]</code>.</p> </li> <li> <p>BREAK: Remove deprecated <code>coords()</code> method. Use indexing and slices instead: <code>color[:-1]</code>.</p> </li> <li> <p>NEW: Update <code>lch()</code>, <code>lab()</code>, <code>oklch()</code>, and <code>oklab()</code> to optionally support percentages for lightness, chroma,     a, and b. Lightness is no longer enforced to be a percentage in the CSS syntax and these spaces will serialize as a     number by default instead. Optionally, these forms can force a percentage output via the <code>to_string</code> method when     using the <code>percentage</code> option. Percent ranges roughly correspond with the Display P3 gamut per the CSS     specification.</p> <p>Additionally, CSS color spaces using the <code>color()</code> format as an input will translate using these same ranges if the channels are percentages. <code>hue</code> will also be respected and treated as 0 - 360 when using a percentage.</p> <p>Non-CSS color spaces will also respect their defined ranges when using percentages in the <code>color()</code> form.</p> </li> <li> <p>NEW: Add <code>silent</code> option to <code>deregister</code> so that if a proper category is specified, and the plugin does not     exit, the operation will not throw an error.</p> </li> <li> <p>NEW: Add new color spaces: <code>display-p3-linear</code>, <code>a98-rgb-linear</code>, <code>rec2020-linear</code>, <code>prophoto-rgb-linear</code>, and     <code>rec2100pq</code>, <code>hsi</code>, <code>rlab</code>, <code>hunter-lab</code>, <code>xyy</code>, <code>prismatic</code>, <code>orgb</code>, <code>cmy</code>, <code>cmyk</code>, <code>ipt</code>, and <code>igpgtg</code>.</p> </li> <li> <p>NEW: Monochromatic color harmony must also be performed in a cylindrical color space to make achromatic     detection easier. This means all color harmonies now must be performed under a cylindrical color space.</p> </li> <li> <p>NEW: Use Lab D65 for \u2206E 2000, \u2206E 76, \u2206E HyAB, Euclidean distance, and LCh D65 for LCh Chroma gamut mapping. Lab     D65 is far more commonly used for the aforementioned \u2206E methods. LCh Chroma gamut mapping, which uses \u2206E 2000 needs     to use the same D65 white point to avoid wasting conversion time.</p> </li> <li> <p>FIX: Better handling of monochromatic harmonies that are near white or black.</p> </li> <li> <p>FIX: Small fix to <code>steps</code> \u2206E logic.</p> </li> </ul>"},{"location":"about/changelog/#0181","title":"0.18.1","text":"<ul> <li>FIX: Fix issue where when generating steps with a <code>max_delta_e</code>, the \u2206E was reduced too much causing additional,     unnecessary steps along with longer processing time.</li> </ul>"},{"location":"about/changelog/#0180","title":"0.18.0","text":"<ul> <li>NEW: Allow dictionary input to use aliases in the dictionary.</li> <li>FIX: If too many channels are given to a color space via raw data, ensure the operation fails.</li> <li>FIX: Sync up achromatic logic of the Okhsl and Okhsv <code>normalize</code> function with the actual conversion algorithm.</li> <li>FIX: Regression that caused <code>cat16</code> not to work due to a misnamed variable.</li> </ul>"},{"location":"about/changelog/#0170","title":"0.17.0","text":"<p>Interpolations Are Now Premultiplied</p> <p>ColorAide has moved to make premultiplication the default for interpolation methods such as <code>mix</code>, <code>steps</code>, and <code>interpolate</code>. The aim is to provide more accurate interpolation when using transparent colors. In cases where premultiplication is not desired, it can be disabled by setting it to <code>False</code>. There are real reasons to do so as it may be desirous to mimic an old implementation that has always used naive interpolation of transparent colors.</p> <p>Additionally, in the past, premultiplication was not really documented as it had not been fully tested. Premultiplication is now covered in the documentation.</p> <ul> <li>NEW: All mixing/interpolation methods will use <code>premultiply=True</code> by default.</li> <li>NEW: Allow aliases in interpolation's progress mappings.</li> <li>FIX: Fix premultiplication when alpha is undefined.</li> <li>FIX: Fix some potential issues in some matrix math logic.</li> <li>FIX: <code>Piecewise()</code> object didn't default all the non-required parameters to <code>None</code> as documented.</li> </ul>"},{"location":"about/changelog/#0160","title":"0.16.0","text":"<p>Deprecations</p> <p>In interest of speed, and due to the overhead inflicted on every class attribute access, we've decided to deprecate dynamic properties. This includes dynamic color properties (e.g. <code>Color.red</code>) and dynamic \u2206E methods (e.g. <code>Color.delta_e_2000()</code>). As far as color channel coordinate access is concerned, we've reworked a faster more useful approach. \u2206E already has a suitable replacement and will be the only approach moving forward.</p> <ol> <li> <p>Use of <code>delta_e_&lt;method&gt;</code> is deprecated. Users should use the already available <code>delta_e(color, method=name)</code>     approach when using non-default \u2206E methods.</p> </li> <li> <p>Color channel access has changed. Dynamic channel properties have been deprecated. Usage of <code>Color.coords()</code> has     also been deprecated. All channels can now easily be accessed with indexing. <code>Color.get()</code> and <code>Color.set()</code>     have not changed.</p> <ul> <li>You can index with numbers: <code>Color[0]</code>.</li> <li>You can index with channel names: <code>Color['red']</code>.</li> <li>You can slice to get specific color coordinates: <code>Color[:-1]</code>.</li> <li>You can get all coordinates: <code>Color[:]</code> or <code>list(Color)</code>.</li> <li>You can even iterate coordinates: <code>[c for c in Color]</code>.</li> <li>Indexing also supports assignment: <code>Color[0] = 1</code> or <code>Color[:3] = [1, 1, 1]</code>.</li> </ul> </li> </ol> <p>Please consider updating usage to utilize the suggested approaches. The aforementioned methods will be removed sometime before the 1.0 release.</p> <ul> <li>NEW: <code>Color</code> objects are now indexable and channels can be retrieved using either numbers or strings, e.g.,     <code>Color[0]</code> or <code>Color['red']</code>. Slicing and assignments via slicing are also supported:     <code>Color1[:] = Color2[:]</code>.</li> <li>NEW: <code>Color.coords()</code>, dynamic color properties, and dynamic \u2206E methods are all deprecated.</li> <li>NEW: Input method names for distancing, gamut mapping, compositing, and space methods are now case sensitive.     There were inconsistencies in some places, so it was opted to make all case sensitive.</li> <li>NEW: The ability to create color harmonies has been added via the new <code>harmony()</code> method. Also, the default     color space used to calculate color harmonies can be overridden by the class property <code>HARMONY</code>.</li> <li>NEW: Add new support for filters added via the <code>filter()</code> method. Filters include the W3C Filter Effects Level 1     and color vision deficiency simulation.</li> <li>NEW: Some performance enhancements in conversions.</li> <li>NEW: Chromatic adaptation is now exposed as a plugin. New CAT plugins can be created externally and registered.</li> <li>FIX: Okhsl and Okhsv handling of achromatic values during conversion.</li> </ul>"},{"location":"about/changelog/#0151","title":"0.15.1","text":"<ul> <li>FIX: Fix an issue related to matching colors in a buffer at a given offset.</li> </ul>"},{"location":"about/changelog/#0150","title":"0.15.0","text":"<p>Warning</p> <p>No changes in the public API have changed, but type annotations have. If you were importing type annotations, you will have to update them.</p> <p>Also, if any undocumented math related methods were accessed (for plugins or otherwise) they've been moved to <code>coloraide.algebra</code></p> <ul> <li>NEW: A number of performance improvements.</li> <li>NEW: Regenerate all matrices with our own matrix tools so that there is consistency between precision of     pre-generated matrices and on-the-fly matrix generation. Reduces some noise in a few color space transforms.</li> <li>NEW: Changes to type annotations. <code>Mutable&lt;type&gt;</code>, where type is either <code>Matrix</code>, <code>Vector</code>, or <code>Array</code>, are     simply known as <code>&lt;type&gt;</code>. Types previously specified as <code>&lt;type&gt;</code>, where type is either <code>Matrix</code>, <code>Vector</code>, or     <code>Array</code>, are now known as <code>&lt;type&gt;Like</code>. The types are expected to be mutable lists, anything else is noted as     \"like\".</li> <li>NEW: All matrix and math utilities have been moved to <code>coloraide.algebra</code>.</li> <li>FIX: Fix rare issue where precision adjustment could fail.</li> <li>FIX: Fix matrix <code>divide</code> logic when dividing a number or vector by a matrix. There are no actual usage of these     cases in the code but they were fixed in case they are used in the future.</li> </ul>"},{"location":"about/changelog/#0141","title":"0.14.1","text":"<ul> <li>FIX: Fix bug related to parsing strings without full matching.</li> </ul>"},{"location":"about/changelog/#0140","title":"0.14.0","text":"<p>Note</p> <p>No changes should break existing color space plugins. Moved objects and references are still also available in old locations, and new functionality is implemented in such a way as to not break existing plugins, but plugins should be updated as sometime before the 1.0 release, such legacy access will be removed.</p> <ul> <li>NEW: Faster parsing. Instead of parsing <code>color(space ...)</code> each time it is evaluated for a different color     space, parse it generically and then associate it with a given registered color space. If a color spaces wishes to     opt out of the <code>color(space ...)</code> input format, the space should set <code>COLOR_FORMAT</code> to <code>False</code>. This means there is     no need to call <code>super.match()</code> when overriding <code>Color.match()</code> to ensure support for the <code>color(space ...)</code> format     as it will be handled unless <code>COLOR_FORMAT</code> is turned off. <code>DEFAULT_MATCH</code> usage should also be discontinued as it     now does nothing.</li> <li>NEW: Other speed optimizations.</li> <li>NEW: All CSS parsing and serialization is now contained in a single module at <code>coloraide.css</code>. This simplifies     the current color space classes greatly when it comes to supporting CSS specific formats.</li> <li>NEW: Move our white space mapping to the <code>cat</code> module as it makes more sense there.</li> <li>NEW: <code>GamutBound</code>, <code>GamutUnbound</code>, and associated flags are now contained under <code>coloraide.gamut.bounds</code>.</li> <li>NEW: <code>normalize</code> will also remove masked values to properly adjust the color.</li> <li>FIX: Compositing and blending should not \"fit\" colors before applying, it is only specified that the range     should be clamped at the end of blending.</li> <li>FIX: Fix issue where a subclassed <code>Color()</code> object could not recognize the base class or other subclasses.</li> </ul>"},{"location":"about/changelog/#0130","title":"0.13.0","text":"<ul> <li>NEW: Add new <code>closest</code> method that takes a list of colors and returns the one that is closet to the calling     color object.</li> <li>NEW: CSS color syntax no longer allows for forgiving channels in <code>color()</code>. This means that when a channel other     than alpha is omitted, we will no longer treat them as undefined. Instead, the color will simply fail to parse.     Raw data channels also must specify all channels.</li> <li>NEW: Clamp lower bounds of chroma at the channel level.</li> <li>NEW: <code>coloraide.spaces.WHITES</code> is now a 2 deep dictionary containing both 2\u02da and 10\u02da observer variants of white     points.</li> <li>NEW: Color space plugins now specify <code>WHITE</code> as a tuple with the x and y chromaticity coordinates. This allows a     space to specify unknown white points if desired.</li> <li>FIX: Fix <code>longer</code> hue interpolation when <code>\u03b81 - \u03b82 = 0</code>. The spec is wrong in this case, and interpolation should     still occur the long way around instead of keeping hue constant.</li> <li>FIX: Reduce redundancy in some CSS parsing patterns.</li> <li>FIX: Minor performance improvements.</li> <li>FIX: Legacy <code>rgb()</code>, <code>rgba()</code>, <code>hsl()</code>, and <code>hsla()</code> comma separated forms in CSS do not support <code>none</code>, only     the new space separated forms do.</li> <li>FIX: Ensure <code>py.typed</code> is installed with package so that type annotations work properly.</li> </ul>"},{"location":"about/changelog/#0120","title":"0.12.0","text":"<ul> <li>NEW: Add a gamut mapping variant that matches the CSS Color Level 4 spec.</li> <li>FIX: Fix precision rounding issue.</li> </ul>"},{"location":"about/changelog/#0110","title":"0.11.0","text":"<p>Breaking Changes</p> <ol> <li> <p>Prior to 0.11.0, if you specified a cylindrical space directly, ColorAide would normalize undefined hues the same     way that the conversion algorithm did. In the below case, saturation is zero, so the hue was declared undefined.</p> <pre><code>&gt;&gt;&gt; Color('hsl(270 0% 50%)')\ncolor(--hsl none 0 0.5 / 1)\n</code></pre> <p>We should not have been doing this, and it made some cases of interpolation a bit confusing. It is no longer done as the hues are in fact specified by the user, even if they are powerless in relation to contributing to the rendered color. When a cylindrical color is converted or if a user declares the channel as undefined with <code>none</code> or some other way, then the channel will be declared undefined, because in these cases, they truly are.</p> <pre><code>&gt;&gt;&gt; Color('white').convert('hsl')\ncolor(--hsl none 0 1 / 1)\n&gt;&gt;&gt; Color('color(--hsl none 0 0.5)')\ncolor(--hsl none 0 0.5)\n</code></pre> <p>If you are working directly in a cylindrical color space and ever wish to force the normalization of color hues as undefined when the color meets the usual requirements as specified by the color space's current rules, just call <code>normalize</code> on the color and it will apply the same logic that occurs during the conversion process.</p> <p><pre><code>&gt;&gt;&gt; Color('hsl(270 0% 50%)').normalize()\ncolor(--hsl none 0 0.5 / 1)\n</code></pre> 2.  If you relied on commas in CSS forms that did not support them, this behavior is no longer allowed. It was thought that CSS may consider allowing comma formats in formats like <code>hwb()</code>, etc., and it was considered, but ultimately the decision was to avoid adding such support. We've updated our input and output support to reflect this. Color spaces can always be subclassed and have this support added back, if desired, but will not be shipped as the default anymore. 3.  The D65 form of Luv and LChuv is now the only supported Luv based color spaces by default now. D50 Luv and LChuv have been dropped and <code>luv</code> and <code>lchuv</code> now refers to the D65 version. In most places, the D65 is the most common used white space as most monitors are calibrated for this white point. The only reason CIELab and CIELCh are D50 by default is that CSS requires it. Anyone interested in using Luv with a different white point can easily subclass the current Luv and create a new plugin color space that uses the new white point. 4.  Renamed DIN99o LCh identifier to the short name of <code>lch99o</code>.</p> </li> </ol> <ul> <li>NEW: ColorAide now only ships with the D65 version Luv and LChuv as D65, in most places is the expected white     space. Now, the identifier <code>luv</code> and <code>lchuv</code> will refer to the D65 version of the respective color spaces. D50     variants are no longer available by default.</li> <li>NEW: Add the HSLuv color space.</li> <li>NEW: DIN99o LCh identifier was renamed from <code>din99o-lch</code> to <code>lch99o</code>. To use in CSS <code>color()</code> form, use     <code>--lch99o</code>.</li> <li>NEW: Refactor chroma reduction/MINDE logic to cut processing time in half. Gamut mapping results remain very     similar.</li> <li>NEW: Be more strict with CSS inputs and outputs. <code>hwb()</code>, <code>lab()</code>, <code>lch()</code>, <code>oklab()</code>, and <code>oklch()</code> no longer     support comma string formats.</li> <li>NEW: Officially drop Python 3.6 support.</li> <li>FIX: Do not assume user defined, powerless hues as undefined. If they are defined by the user, they should be     respected, even if they have no effect on the current color. This helps to ensure interpolations acts in an     unsurprising way. If a user manually specifies the channel with <code>none</code>, then it will be considered undefined, or if     the color goes through a conversion to a space that cannot pick an appropriate hue, they will also be undefined.</li> </ul>"},{"location":"about/changelog/#0100","title":"0.10.0","text":"<ul> <li>NEW: Switch back to using CIELCh for gamut mapping (<code>lch-chroma</code>). There are still some edge cases that make     <code>oklch-chroma</code> less desirable.</li> <li>FIX: Fix an issue where when attempting to generate steps some \u2206E distance apart, the maximum step range was not     respected and could result in large hangs.</li> </ul>"},{"location":"about/changelog/#090","title":"0.9.0","text":"<p>Breaking Changes</p> <p>Custom gamut mapping plugins no longer return coordinates and require the method to update the passed in color.</p> <ul> <li>NEW: Improved, faster gamut mapping algorithm.</li> <li>NEW: FIT plugins (gamut mapping) no longer return coordinates but should modify the color passed in.</li> <li>NEW: Expose default interpolation space as a class variable that can be controlled when creating a custom class     via class inheritance.</li> <li>NEW: Colors can now directly specify the \u2206E method that is used when interpolating color steps and using     <code>max_delta_e</code> via the new <code>delta_e</code> argument. If the <code>delta_e</code> parameter is omitted, the color object's default \u2206E     method will be used.</li> <li>NEW: Oklab is now the default interpolation color space.</li> <li>NEW: Interpolation will now avoid fitting colors that are out of gamut unless the color space cannot represent     out of gamut colors. Currently, all of the RGB colors (<code>srgb</code>, <code>display-p3</code>, etc.) all support extended ranges, but     the HSL, HWB, and HSV color models for <code>srgb</code> (including spaces such as <code>okhsl</code> and <code>okhsv</code>) do not support extended     ranges and will still be gamut mapped.</li> <li>FIX: Remove some incorrect code from the gamut mapping algorithm that would shortcut the mapping to reduce     chroma to zero.</li> </ul>"},{"location":"about/changelog/#080","title":"0.8.0","text":"<p>Breaking Changes</p> <p>The use of <code>xyz</code> as the color space name has been changed in favor of <code>xyz-d65</code>. This better matches the CSS specification. As we are still in a prerelease state, we have not provided any backwards compatibility.</p> <p>CSS color input strings in the form <code>color(xyz x y z)</code> will continue to be accepted as CSS will allow both the <code>xyz</code> and the <code>xyz-d65</code> identifier, but output serialization will prefer the <code>color(xyz-d65 x y z)</code> form as using <code>xyz</code> is an alias for <code>xyz-d65</code>.</p> <p>Again, this breaking change only affects operations where the color space \"name\" is used in the API to specify usage of a specific color space in order to create a color, convert, mutate, interpolate, etc.</p> <pre><code>Color('red').convert('xyz')      # Bad\nColor('red').convert('xyz-d65')  # Okay\n\nColor('xyz' [0, 0, 0])      # Bad\nColor('xyz-d65' [0, 0, 0])  # Okay\n\nColor('red').interpolate('green', space='xyz')      # Bad\nColor('red').interpolate('green', space='xyz-d65')  # Okay\n\n# No changes to CSS inputs\nColor('color(xyz 0 0 0)')      # Okay\nColor('color(xyz-d65 0 0 0)')  # Okay\n</code></pre> <ul> <li>NEW: Add the official CSS syntax <code>oklab()</code> and <code>oklch()</code> for the Oklab and OkLCh color spaces respectively.</li> <li>NEW: Custom fit plugin's <code>fit</code> method now allows additional <code>kwargs</code> in its signature. The API will accept     <code>kwargs</code> allowing a custom fit plugin to have configurable parameters. None of the current built-in plugins provide     additional parameters, but this is provided in case it is found useful in the future.</li> <li>NEW: XYZ D65 space will now be known as <code>xyz-d65</code>, not <code>xyz</code>. Per the CSS specification, we also ensure XYZ D65     color space serializes as <code>xyz-d65</code> instead of the alias <code>xyz</code>. CSS input string format will still accept the <code>xyz</code>     identifier as this is defined in the CSS specification as an alias for <code>xyz-d65</code>, but when serializing a color to a     string, the <code>xyz-d65</code> will be used as the preferred form.</li> <li>NEW: By default, gamut mapping is done with <code>oklch-chroma</code> which matches the current CSS specification. If     desired, the old way (<code>lch-chroma</code>) can manually be specified or set as the default by subclassing <code>Color</code> and     setting <code>FIT</code> to <code>lch-chroma</code>.</li> <li>FIX: Ensure the <code>convert</code> method's <code>fit</code> parameter is typed appropriately and is documented correctly.</li> </ul>"},{"location":"about/changelog/#070","title":"0.7.0","text":"<ul> <li>NEW: Formally expose <code>srgb-linear</code> as a valid color space.</li> <li>NEW: Distance plugins and gamut mapping plugins now use <code>classmethod</code> instead of <code>staticmethod</code>. This allows for     inheritance from other classes and the overriding of plugin options included as class members.</li> <li>NEW: Tweak LCh chroma gamut mapping threshold.</li> <li>FIX: Issue where it is possible, when generating steps, to cause a shift in midpoint of colors if exceeding the     maximum steps. Ensure that no stops are injected if injecting a stop between every color would exceed the max steps.</li> </ul>"},{"location":"about/changelog/#060","title":"0.6.0","text":"<ul> <li>NEW: Update spaces such that they provide a single conversion point which simplifies color space API and     centralizes all conversion logic allowing us to pull chromatic adaptation out of spaces.</li> <li>NEW: <code>color()</code> output format never uses percent when serializing, but will optionally accept percent as input.</li> <li>NEW: Slight refactor of color space, delta E, and gamut mapping plugins. All now specify there name via the     property <code>NAME</code> instead of methods <code>space()</code> for color spaces and <code>name()</code> for other plugins.</li> <li>NEW: Restructure source structure by flattening out some directories and better organizing source files. This     changes some import paths.</li> <li>NEW: Color spaces do not specify <code>alpha</code> in <code>CHANNEL_NAMES</code> as the <code>alpha</code> name cannot be changed.</li> <li>NEW: Color space objects do not need a constant to track number of color channels.</li> </ul>"},{"location":"about/changelog/#050","title":"0.5.0","text":"<ul> <li>NEW: Add type annotations and refactor code to better accommodate the type annotations. Public API not really   affected, but a bit of the internals have changed.</li> <li>FIX: Fix issue where <code>compose</code>, if <code>backdrop</code> list is empty, would not respect <code>in_place</code> option.</li> </ul>"},{"location":"about/changelog/#040","title":"0.4.0","text":"<ul> <li>NEW: Officially support Python 3.10.</li> <li>NEW: Slightly more accurate Oklab matrix calculation.</li> <li>NEW: Exported dictionary form can now be used as a normal color input in functions like <code>contrast</code>,     <code>interpolate</code>, etc.</li> <li>NEW: Color objects will accept a dictionary mapping when <code>alpha</code> is not specified. When this occurs, <code>alpha</code> is     assumed to be <code>1</code>.</li> <li>FIX: Fix an object compare issue.</li> </ul>"},{"location":"about/changelog/#030","title":"0.3.0","text":"<p>Breaking Changes</p> <p>XYZ changes below will cause breakage as <code>xyz</code> now refers to XYZ with D65 instead of D50. Also, CSS identifiers changed per the recent specification change.</p> <ul> <li>NEW: When calling <code>dir()</code> on <code>Color()</code>, ensure dynamic methods are in the list.</li> <li>NEW: <code>xyz</code> now refers to XYZ D65. CSS <code>color()</code> function now specifies D65 color as either     <code>color(xyz x y z)</code> or <code>color(xyz-d65 x y z)</code>. XYZ D50 is now specified as     <code>color(xyz-D50 x y z)</code>.</li> <li>NEW: Add CIELuv and CIELCh<sub>uv</sub> D65 variants.</li> </ul>"},{"location":"about/changelog/#020","title":"0.2.0","text":"<ul> <li>NEW: Provide dedicated <code>clip</code> method. <code>clip</code> is still a specifiable method under the <code>fit</code> function. It is also     a reserved name under <code>fit</code> and cannot be overridden via plugins or be removed.</li> <li>NEW: Add more conversion shortcuts to OK family of color spaces.</li> <li>FIX: Fix an issue where the shorter conversion path wasn't always taken as convert couldn't find to/from methods     if the color space name had <code>-</code> in it.</li> </ul>"},{"location":"about/changelog/#010","title":"0.1.0","text":"<p>First non-alpha prerelease. Notable changes from the last alpha listed below.</p> <p>Breaking Changes</p> <p>There are some breaking changes if coming from the previous alpha releases. All sRGB cylindrical spaces' non-hue data ranges are no longer scaled to 0 - 100, but use 0 - 1. Hue ranges have not changed.</p> <ul> <li>NEW: By accepting HSL, HSV, and HWB as non-hue channels as 0-100, we do lose a little precision, so for 1.0, we     are switching to accepting and returning raw data values between 0 - 1. We've kept hue between 0 - 360 as it is     easier for users to deal with hues between 0 - 360. Doing this will also match the new color spaces Okhsl and Okhsv     that need to be kept at 0 - 1 to get better rounding.</li> <li>NEW: We do not currently restrict percentages anymore in <code>color()</code> functions. There is no hard rules     that we need to at this time and no currently specified spaces that do this in the CSS specification. This is     relaxed for now until some future time when it becomes clear we must.</li> <li>NEW: New <code>okhsl</code> and <code>okhsv</code> color space.</li> <li>NEW: All color channels now accept the <code>none</code> keyword to specify an undefined channel. They can also optionally     output CSS strings with the keyword.</li> <li>NEW: Interpolation will return an undefined channel if both colors have that channel set to undefined.</li> <li>NEW: Provide a way to dump a color object to a simple dictionary and have the <code>Color()</code> object accept that     dictionary to recreate the color object.</li> <li>NEW: Provide <code>cat16</code> chromatic adaptation.</li> <li>NEW: Add <code>normalize</code> method to force channel normalization (evaluation of channels and setting undefined as     appropriate).</li> <li>NEW: Interpolated and composited colors will normalize undefined channels when returning a color.</li> <li>NEW: Jzazbz now also has an alias for <code>az</code> and <code>bz</code> channels as <code>a</code> and <code>b</code> respectively.</li> <li>FIX: Fix an attribute \"get\" issue where attributes that were not present on the <code>Color()</code> object appeared to be     present when using <code>hasattr()</code>.</li> <li>FIX: More accurate Oklab matrix.</li> </ul>"},{"location":"about/contributing/","title":"Contributing &amp; Support","text":"<p>There are many ways to help support this project, regardless of skills and abilities. If you enjoy this project and want to get involved, consider checking out one of the various ways below. Feel free to get creative, there may be other ways to contribute in which we have not thought of!</p>"},{"location":"about/contributing/#become-a-sponsor","title":"Become a Sponsor","text":"<p>Open source projects take time and money. Help support the project by becoming a sponsor. You can add your support at any tier you feel comfortable with. No amount is too little. We also accept one time contributions via PayPal.</p> <p> GitHub Sponsors  PayPal</p>"},{"location":"about/contributing/#bug-reports","title":"Bug Reports","text":"<ol> <li> <p>Please read the documentation and search the issue tracker to try and find the answer to your question   before posting an issue.</p> </li> <li> <p>When creating an issue on the repository, please provide as much info as possible:</p> <ul> <li>Version being used.</li> <li>Operating system.</li> <li>Version of Python.</li> <li>Errors in console.</li> <li>Detailed description of the problem.</li> <li>Examples for reproducing the error.  You can post pictures, but if specific text or code is required to     reproduce the issue, please provide the text in a plain text format for easy copy/paste.</li> </ul> <p>The more info provided, the greater the chance someone will take the time to answer, implement, or fix the issue.</p> </li> <li> <p>Be prepared to answer questions and provide additional information if required.  Issues in which the creator refuses   to respond to follow up questions will be marked as stale and closed.</p> </li> </ol>"},{"location":"about/contributing/#reviewing-code","title":"Reviewing Code","text":"<p>Take part in reviewing pull requests and/or reviewing direct commits.  Make suggestions to improve the code and discuss solutions to overcome weakness in the algorithm.</p>"},{"location":"about/contributing/#answer-questions-in-issues","title":"Answer Questions in Issues","text":"<p>Take time and answer questions and offer suggestions to people who've created issues in the issue tracker. Often people will have questions that you might have an answer for.  Or maybe you know how to help them accomplish a specific task they are asking about. Feel free to share your experience to help others out.</p>"},{"location":"about/contributing/#pull-requests","title":"Pull Requests","text":"<p>Pull requests are welcome, and a great way to help fix bugs and add new features.</p>"},{"location":"about/contributing/#documentation-improvements","title":"Documentation Improvements","text":"<p>A ton of time has been spent not only creating and supporting this tool and related extensions, but also spent making this documentation.  If you feel it is still lacking, show your appreciation for the tool and/or extensions by helping to improve the documentation.</p>"},{"location":"about/license/","title":"License","text":"<p>MIT License</p> <p>Copyright \u00a9 2020 - 2025 Isaac Muse</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"about/releases/1.0/","title":"1.0 Migration Notes","text":"<p>ColorAide has been a constantly evolving project. As we've pushed for a stable release, the 1.0 milestone was no exception. For any of the early adopters, there are a number of things to be aware of when migrating to 1.0. In this guide, we'll cover the changes most likely to impact users.</p>"},{"location":"about/releases/1.0/#plugins","title":"Plugins","text":"<p>Plugins have gone through a number of reworks. In 1.0, we now require all plugins to be registered as instances. Prior to 1.0 plugins were just passed in un-instantiated. Some plugins were used as static classes almost, and some (color spaces) were instantiated on the creation of every color.</p> <p>In 1.0, all plugins are required to be instantiated prior to registration. This gives the user the opportunity to specify any alternative defaults if desired.</p> <pre><code>&gt;&gt;&gt; Color('red').delta_e('blue', method='cmc')\n108.56925233888809\n&gt;&gt;&gt; from coloraide.distance.delta_e_cmc import DECMC\n&gt;&gt;&gt; class Custom(Color):\n...     DELTA_E = \"cmc\"\n... \n&gt;&gt;&gt; Custom.register(DECMC(l=1, c=1), overwrite=True)\n&gt;&gt;&gt; Custom('red').delta_e('blue')\n109.7597278634398\n</code></pre> Gamut: srgb"},{"location":"about/releases/1.0/#plugin-renames","title":"Plugin Renames","text":"<p>ColorAide had some inconsistencies when it came to some plugin names. For instance, we would use variations of <code>Lch</code>, <code>LCH</code>, etc. This made it more difficult to predict how a plugin was named, and remember it. In this case appropriate casing is usually <code>LCh</code>. All plugins referring to <code>LCh</code> were renamed to be more consistent.</p> <p>Outside of LCh related classes, there were a few additional renames to better match the color space of interest's real name.</p> Old\u00a0Name New\u00a0Name <code>Lch</code> <code>LCh</code> <code>LchD65</code> <code>LChD65</code> <code>Oklch</code> <code>OkLCh</code> <code>Lchuv</code> <code>LChuv</code> <code>Lch99o</code> <code>LCh99o</code> <code>LchChroma</code> <code>LChChroma</code> <code>OklchChroma</code> <code>OkLChchroma</code> <code>Lchish</code> <code>LChish</code> <code>XyY</code> <code>xyY</code> <code>Din99o</code> <code>DIN99o</code> <code>SRGB</code> <code>sRGB</code> <code>SRGBLinear</code> <code>sRGBLinear</code> <code>ORGB</code> <code>oRGB</code>"},{"location":"about/releases/1.0/#default-plugins","title":"Default Plugins","text":"<p>Over the course of development, we've added a good number of color spaces. With the 1.0 release, it was decided to have the default <code>Color</code> object not register all available color spaces out of the box as the amount of color spaces has grown quite substantially.</p> <p>As not all color spaces are registered by default, \u2206E plugins tied to color spaces no longer registered by default will also not be registered by default.</p> <p>Lastly, since the <code>bradford</code> CAT is the default, it was deemed unnecessary to register all the other CAT plugins by default.</p> <p>With all of that said, all of the exiting plugins are still available and can be included if/when needed. If any of the plugins that are no longer registered by default are needed, there are a couple of options:</p> <ol> <li> <p>The recommended way is to just subclass the <code>Color</code> object and cherry pick the plugins that are needed. When    classing, all the plugins registered in the base will be copied over to the derived class. Then we can just pass    in the instantiated plugins.</p> <pre><code>&gt;&gt;&gt; from coloraide import Color as Base\n&gt;&gt;&gt; from coloraide.spaces.jzazbz import Jzazbz\n&gt;&gt;&gt; from coloraide.distance.delta_e_z import DEZ\n&gt;&gt;&gt; class Color(Base): ...\n... \n&gt;&gt;&gt; Color.register([Jzazbz(), DEZ()], silent=True)\n&gt;&gt;&gt; Color('red').convert('jzazbz')\ncolor(--jzazbz 0.13438 0.11789 0.11188 / 1)\n&gt;&gt;&gt; Color('red').delta_e('blue', method='jz')\n0.33960388420164006\n</code></pre> Gamut: srgb </li> <li> <p>We also provide a new color object derived from <code>Color</code> that includes all color spaces called <code>ColorAll</code>. This    object won't be as light, but will provide quick and easy access to everything ColorAide offers. By default, it    registers every plugin. It can be found under <code>coloraide.everything</code>.</p> <pre><code>&gt;&gt;&gt; from coloraide.everything import ColorAll as Color\n&gt;&gt;&gt; Color('purple').convert('hunter-lab')\ncolor(--hunter-lab 24.796 50.842 -35.444 / 1)\n</code></pre> Gamut: srgb </li> </ol>"},{"location":"about/releases/1.0/#dynamic-propertiesfunctions-and-coordinate-access","title":"Dynamic Properties/Functions and Coordinate Access","text":"<p>Prior to 1.0, ColorAide's <code>Color</code> object had color channel properties that would magically mutate based on what the current color space was that the object currently held. While cool, this added overhead to every class attribute access. In an effort to dramatically reduce unnecessary overhead, this feature had to be rethought.</p> <p>Additionally, \u2206E methods were also added dynamically. For instance, if we had the \u2206E 2000 distancing plugin registered, we'd have access to \u2206E via <code>Color.delta_e_2000</code> or <code>Color.delta_e(color, method='2000')</code>. Again, the overhead to magically provide these properties the way we were posed the same problem as what was seen with dynamic color channel properties</p> <p>Additionally, the <code>Color</code> object used to have a <code>coords()</code> function to get all the non-alpha color channels. This function was not really problematic, but as we decided a solution for the dynamic properties, it became apparent that we would no longer need such a function.</p> <p>1.0 removed the overhead of magic dynamic properties and functions. In particular, we decided to approach color channel access in a new and different way.</p> <p>Moving forward, the <code>Color</code> object is now iterable and indexable. Channels can be directly indexed via channel names or numerical indexes. You can even use slices:</p> <pre><code>&gt;&gt;&gt; color = Color('orange')\n&gt;&gt;&gt; color\ncolor(srgb 1 0.64706 0 / 1)\n&gt;&gt;&gt; color['blue']\n0.0\n&gt;&gt;&gt; color[0]\n1.0\n&gt;&gt;&gt; color[:-1]\n[1.0, 0.6470588235294118, 0.0]\n</code></pre> Gamut: srgb <p><code>Color</code> objects are also iterable, so you can just loop them as well, or cast the object as a list.</p> <pre><code>&gt;&gt;&gt; for channel in Color('orange'):\n...     print(channel)\n... \n1.0\n0.6470588235294118\n0.0\n1.0\n&gt;&gt;&gt; list(Color('green'))\n[0.0, 0.5019607843137255, 0.0, 1.0]\n</code></pre> Gamut: srgb <p>Setting channels is just as easy and can be done by indexing channels with names, numerical indexes, or even slices.</p> <pre><code>&gt;&gt;&gt; color = Color('transparent')\n&gt;&gt;&gt; color[:] = [1, 0, 0, 0.5]\n&gt;&gt;&gt; color\ncolor(srgb 1 0 0 / 0.5)\n</code></pre> Gamut: srgb <p>As far as \u2206E methods are concerned, we already had two different ways to approach this, so we simply removed the dynamic functions. To access any of the different \u2206E methods, simply call the generic <code>delta_e</code> function and provide the <code>method</code>.</p> <pre><code>&gt;&gt;&gt; Color('red').delta_e('green', method='2000')\n72.18053591241998\n</code></pre> Gamut: srgb"},{"location":"about/releases/1.0/#gamut-mapping-and-clipping","title":"Gamut Mapping and Clipping","text":"<p>During our path to 1.0, we noticed that when performing gamut mapping and clipping, in most cases, we were performing them \"in place\" instead of the default which generated new <code>Color</code> instances. There are times when we occasionally wanted a new instance of the color when fitting a color to its gamut, but that turned out to not be the norm.</p> <p>Generating new instances obviously will create more overhead, and in some cases, such as color mixing, returning a new color opposed to mutating the existing one makes a lot more sense, but with gamut mapping and clipping, for efficiency, we were often forcing \"in place\" operations.</p> <p>1.0 now does gamut mapping and clipping in place by default. With this change, the <code>in_place</code> parameter is not longer available for <code>fit()</code> and <code>clip()</code>.</p> <p>So, if migrating to 1.0, if you were calling <code>fit()</code> and <code>clip()</code> directly, a few changes will need to be made. If you'd like to do an in place gamut correction, simply call the function. If you'd like to generate a new instance, clone the color first.</p> <pre><code>&gt;&gt;&gt; color1 = Color('display-p3', [1, 1, 0])\n&gt;&gt;&gt; color1.fit('srgb')\ncolor(display-p3 0.9986 0.99232 0.32855 / 1)\n&gt;&gt;&gt; color1\ncolor(display-p3 0.9986 0.99232 0.32855 / 1)\n&gt;&gt;&gt; color2 = Color('display-p3', [0, 1, 0])\n&gt;&gt;&gt; color3 = color2.clone().fit('srgb')\n&gt;&gt;&gt; color2, color3\n(color(display-p3 0 1 0 / 1), color(display-p3 0.45754 0.98353 0.2977 / 1))\n</code></pre> Gamut: srgb"},{"location":"about/releases/1.0/#dictionary-output","title":"Dictionary Output","text":"<p>The dictionary format for input and output as been simplified for the 1.0 release. Prior to 1.0, the <code>Color</code> object used to export color dictionaries with the space name and each channel under an individually named key:</p> <pre><code>{'space': 'srgb', 'r': 1, 'g': 0, 'b': 0, 'alpha': 1}\n</code></pre> <p>This required more overhead, particularly when parsing to handle channel alias and the like. For 1.0, we've streamlined the format to export the data with all color coordinates under <code>coords</code> and the alpha channel still under <code>alpha</code>. This makes streamlines the process of handling dictionaries as inputs and outputting them when requested, in turn, improving performance.</p> <pre><code>&gt;&gt;&gt; d = Color('rebeccapurple').to_dict()\n&gt;&gt;&gt; d\n{'space': 'srgb', 'coords': [0.4, 0.2, 0.6], 'alpha': 1.0}\n&gt;&gt;&gt; Color(d)\ncolor(srgb 0.4 0.2 0.6 / 1)\n</code></pre> Gamut: srgb"},{"location":"about/releases/1.0/#interpolation","title":"Interpolation","text":"<p>Interpolation was an area we were generally unhappy with, so it was majorly overhauled.</p> <p>Prior to 1.0, interpolation could be a bit awkward. Interpolation used to require the first color in the interpolation to be the calling object, and all the rest had to be fed in.</p> <pre><code>Color('red').interpolate(['blue', 'green', 'orange'])\n</code></pre> <p>When performing a simple mix, this felt natural and made sense:</p> <pre><code>Color('red').mix('blue', 0.25)\n</code></pre> <p>But with long chains of colors, this just felt cumbersome. To remedy this, we changed the <code>interpolate</code> and <code>steps</code> methods to <code>@classmethods</code>. We left <code>mix</code> as is since with two colors it feels natural.</p> <p>So moving forward, <code>interpolate</code> and <code>steps</code> will execute interpolations from class methods.</p> <pre><code>&gt;&gt;&gt; Color.interpolate(['red', 'blue', 'green', 'orange'])\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x7f46548d2030&gt;\n&gt;&gt;&gt; Color.steps(['red', 'blue', 'green', 'orange'], steps=10)\n[color(--oklab 0.62796 0.22486 0.12585 / 1), color(--oklab 0.56931 0.13909 -0.01995 / 1), color(--oklab 0.51066 0.05332 -0.16574 / 1), color(--oklab 0.45201 -0.03246 -0.31153 / 1), color(--oklab 0.47459 -0.06841 -0.17179 / 1), color(--oklab 0.49717 -0.10435 -0.03206 / 1), color(--oklab 0.51975 -0.1403 0.10768 / 1), color(--oklab 0.61073 -0.07466 0.12558 / 1), color(--oklab 0.70171 -0.00903 0.14348 / 1), color(--oklab 0.79269 0.05661 0.16138 / 1)]\n</code></pre> Gamut: srgb <p>This means that you do not have to call the function from an instantiated object, and if you do, the instantiated color that is making the call will not be included in the interpolation. Only the colors in the list are considered during the interpolation.</p> <pre><code>&gt;&gt;&gt; Color('white').interpolate(['red', 'blue', 'green', 'orange'])\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x7f46548d23f0&gt;\n</code></pre> Gamut: srgb <p>This will make even more sense as we highlight the other changes.</p> <p>Another problem we faced was the awkwardness of color stops and easing functions. Before we used to have a <code>Piecewise</code> object that you'd wrap a channel in to create color stops or inject easing functions and other various behaviors between colors, but it had to be applied on the second color in the chain, and this didn't quite work for the first color. If you wanted to add a stop to the first color, you then had to use a special <code>stop</code> parameter\u2026it was unintuitive.</p> <pre><code>from coloraide import Piecewise\nColor('red').interpolate(['blue', Piecewise('orange', 0.75, progress=lambda t: t * 3), 'purple'], stop=0.25)\n</code></pre> <p>In 1.0, we simplified things greatly. Since <code>interpolate</code> and <code>steps</code> now require that all colors must be in the input list if they are to be considered for interpolation, we can process them all in a consistent and more intuitive manner.</p> <p>As before, <code>steps</code> and <code>interpolate</code> allow you to set function parameters to generally control the behavior for the entire interpolation across all colors. You can also still add easing functions via <code>progress</code> which will also affect the entire interpolation by default, but now you can inject easing functions directly between colors which will only be applied between those two colors.</p> <pre><code>&gt;&gt;&gt; Color.interpolate(['red', lambda t: t * 3, 'orange', 'purple'])\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x7f46548d23f0&gt;\n</code></pre> Gamut: srgb <p>You can also directly wrap any color in the list with <code>stop</code> to change the color stop position. Since the first color is now treated like all the other colors, there is no need for the <code>stop</code> function parameter either.</p> <pre><code>&gt;&gt;&gt; from coloraide import stop\n&gt;&gt;&gt; Color.interpolate([stop('red', 0.25), stop('orange', 0.75), 'purple'])\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x7f46548d23f0&gt;\n</code></pre> Gamut: srgb <p>And if you are familiar with CSS color hinting, which essentially alters the midpoint between two color stops, we've added a <code>hint</code> function which takes a new relative midpoint and returns a midpoint easing function which essentially acts the same as CSS interpolation hints.</p> <pre><code>&gt;&gt;&gt; from coloraide import hint\n&gt;&gt;&gt; Color.interpolate(['yellow', 'pink'])\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x7f46548d2030&gt;\n&gt;&gt;&gt; Color.interpolate(['yellow', hint(0.25), 'pink'])\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x7f46548d23f0&gt;\n</code></pre> Gamut: srgb <p>All of this makes for a less confusing experience when using interpolation. Additionally, all of the changes simplified the logic allowing us to even add a new interpolation method!</p> <pre><code>&gt;&gt;&gt; Color.interpolate(['red', 'blue', 'green', 'orange'], method='bspline')\n&lt;coloraide.interpolate.bspline.InterpolatorBSpline object at 0x7f46548fa2c0&gt;\n</code></pre> Gamut: srgb"},{"location":"about/releases/1.0/#color-space-filters","title":"Color Space Filters","text":"<p>In the beginning, the <code>Color</code> space object was created with a naive filtering system. It added a little overhead, but the real issue was the fact that it only filtered inputs through <code>new</code>, <code>match</code>, and through normal instantiation. It did not filter through almost any other method that accepted inputs. It was decided to leave color filtering up to the user.</p> <pre><code>&gt;&gt;&gt; c = Color('display-p3', [1, 1, 0])\n&gt;&gt;&gt; try:\n...     if c.space() not in ['srgb', 'hsl', 'hwb']:\n...         raise ValueError('Invalid Color Space')\n... except ValueError as e:\n...     print(e)\n... \nInvalid Color Space\n</code></pre> Gamut: srgb"},{"location":"api/","title":"Color API","text":""},{"location":"api/#nan","title":"<code>coloraide.NaN</code>","text":"Description <code>NaN</code> is a convenience constant for <code>float('nan')</code>. Import path <p><code>NaN</code> is imported from the <code>coloraide</code> library:</p> <pre><code>from coloraide import NaN\n</code></pre>"},{"location":"api/#stop","title":"<code>coloraide.stop</code>","text":"<pre><code>class stop:\n    def __init__(\n        self,\n        color: ColorInput,\n        value: float\n    ) -&gt; None:\n        ...\n</code></pre> Description <code>stop</code> objects are used in <code>interpolate</code> methods. They allow a user to specify a color stop for a     given color during the interpolation process. Import Path <p><code>stop</code> is imported from <code>coloraide</code> library:</p> <pre><code>from coloraide import stop\n</code></pre> Parameters Parameters Defaults Description <code>color</code> A color string, a dictionary describing the color, or another <code>Color</code> class object. <code>value</code> A numerical value specifying the new color stop for the given color."},{"location":"api/#hint","title":"<code>coloraide.hint</code>","text":"<pre><code>def hint(\n    mid: float,\n) -&gt; Callable[..., float]:\n    ...\n</code></pre> Description <code>hint</code> returns an easing function that adjust the midpoint between two color stops. Import Path <p><code>hint</code> is imported from <code>coloraide</code> library:</p> <pre><code>from coloraide import hint\n</code></pre> Parameters Parameters Defaults Description <code>mid</code> A numerical value, relative to the two color stops it occurs between. The value will be used as the new midpoint."},{"location":"api/#color","title":"<code>coloraide.Color</code>","text":"<pre><code>class Color:\n    def __init__(\n        self,\n        color: ColorInput,\n        data: VectorLike | None = None,\n        alpha: float = util.DEF_ALPHA,\n        **kwargs: Any\n    ) -&gt; None:\n        ...\n</code></pre> Description The <code>Color</code> class object is a wrapper around the internal color space objects. <code>Color</code> is the base Color object and     only registers a select number of color spaces by default. It provides an API interface to allow users to specify     and manipulate colors. Import path <p><code>Color</code> is imported from the <code>coloraide</code> library:</p> <pre><code>from coloraide import Color\n</code></pre> Parameters Parameters Defaults Description <code>color</code> A color string, a dictionary describing the color, or another <code>Color</code> class object. If given <code>data</code>, a string must be used and should represent the color space to use. <code>data</code> <code>None</code> <code>data</code> accepts a list of numbers representing the coordinates of the color. If provided, <code>color</code> must be a string specifying the color space. <code>alpha</code> <code>1</code> <code>alpha</code> accepts a number specifying the <code>alpha</code> channel. Must be used in conjunction with <code>data</code> or it will be ignored."},{"location":"api/#colorall","title":"<code>coloraide.everything.ColorAll</code>","text":"<pre><code>class ColorAll(Color):\n    def __init__(\n        self,\n        color: ColorInput,\n        data: VectorLike | None = None,\n        alpha: float = util.DEF_ALPHA,\n        **kwargs: Any\n    ) -&gt; None:\n        ...\n</code></pre> Description The <code>ColorAll</code> class object is derived from <code>Color</code> and extends the registered color spaces to include all     offered by ColorAide. Import path <p><code>ColorAll</code> is imported from the <code>coloraide</code> library:</p> <pre><code>from coloraide.everything import ColorAll\n</code></pre> Parameters Parameters Defaults Description <code>color</code> A color string, a dictionary describing the color, or another <code>ColorAll</code> class object. If given <code>data</code>, a string must be used and should represent the color space to use. <code>data</code> <code>None</code> <code>data</code> accepts a list of numbers representing the coordinates of the color. If provided, <code>color</code> must be a string specifying the color space. <code>alpha</code> <code>1</code> <code>alpha</code> accepts a number specifying the <code>alpha</code> channel. Must be used in conjunction with <code>data</code> or it will be ignored."},{"location":"api/#register","title":"<code>Color.register</code>","text":"<pre><code>def register(\n    cls,\n    plugin: Plugin | Sequence[Plugin],\n    *,\n    overwrite: bool = False,\n    silent: bool = False\n) -&gt; None:\n    ...\n</code></pre> Description Register a plugin(s). Parameters Parameters Defaults Description <code>plugin</code> A plugin instance or list of plugin instances to register. <code>overwrite</code> <code>False</code> <code>overwrite</code> will allow an already registered plugin to be overwritten if the plugin to register specifies a <code>name</code> that is already used for registration. <code>silent</code> <code>False</code> <code>silent</code> will avoid throwing an error if the <code>name</code> is already found and <code>overwrite</code> is set to <code>False</code> in the specified category."},{"location":"api/#deregister","title":"<code>Color.deregister</code>","text":"<pre><code>@classmethod\ndef deregister(\n    cls,\n    plugin: str | Sequence[str], *,\n    silent: bool = False\n) -&gt; None:\n    ...\n</code></pre> Description Remove an already registered plugin(s). Parameters Parameters Defaults Description <code>plugin</code> A string or list of strings that describe the plugin(s) to be removed. Strings should be in the format <code>category:name</code> where <code>category</code> is either <code>space</code>, <code>delta-e</code>, <code>cat</code>, <code>filter</code>, <code>contrast</code>, <code>interpolate</code>, or <code>fit</code> and <code>name</code> is the name the plugin was registered under. <code>*</code> will remove all plugins and <code>category:*</code> will remove all within a specific category. <code>silent</code> <code>False</code> <code>silent</code> will avoid throwing an error if the <code>name</code> can not be found in the specified category."},{"location":"api/#match","title":"<code>Color.match</code>","text":"<pre><code>@classmethod\ndef match(\n    cls,\n    string: str,\n    start: int = 0,\n    fullmatch: bool = False\n) -&gt; ColorMatch | None:\n    ...\n</code></pre> Description <p>The <code>match</code> class method provides access to the color matching interface and allows a user to provide a color string     and get back a <code>ColorMatch</code> object. <code>ColorMatch</code> objects contain three properties:</p> <pre><code>class ColorMatch:\n    def __init__(\n        self,\n        color: Color,\n        start: int,\n        end: int\n    ) -&gt; None:\n        ...\n</code></pre> Parameter Description <code>color</code> The <code>Color</code> object. <code>start</code> The starting point within the string buffer where the color was found. <code>end</code> The ending point within the string buffer where the color was found. <p>Match does not search the entire buffer, but simply matches at the location specified by <code>start</code>.</p> Parameters Parameters Defaults Description <code>string</code> A string representing the color. <code>start</code> <code>0</code> Accepts an integer offset into the provided string buffer to start the match. <code>fullmatch</code> <code>False</code> A boolean which defines whether match must match to the end of the string buffer. Return Returns a <code>ColorMatch</code> object."},{"location":"api/#new","title":"<code>Color.new</code>","text":"<pre><code>@classmethod\ndef new(\n    cls,\n    color: ColorInput,\n    data: VectorLike | None = None,\n    alpha: float = util.DEF_ALPHA,\n    **kwargs: Any\n) -&gt; Self:\n    ...\n</code></pre> Description The <code>new</code> class method exposes the interface of creating new color objects. Using <code>new</code> is the same as using     <code>Color()</code>. Parameters Parameters Defaults Description <code>color</code> A color string, or other <code>Color</code> class object. If given <code>data</code>, a string must be used and should represent the color space to use. <code>data</code> <code>None</code> <code>data</code> accepts a list of numbers representing the coordinates of the color. If provided, <code>color</code> must be a string specifying the color space. <code>alpha</code> <code>1</code> <code>alpha</code> accepts a number specifying the <code>alpha</code> channel. Must be used in conjunction with <code>data</code> or it will be ignored. Return Returns a <code>Color</code> object."},{"location":"api/#random","title":"<code>Color.random</code>","text":"<pre><code>@classmethod\ndef random(\n    cls,\n    space: str,\n    *,\n    limits: Sequence[Sequence[float] | None] | None = None\n) -&gt; Self:\n    ...\n</code></pre> Description Generate a random color in the provided <code>space</code>. The color space's channel range will be used as a limit for the     channel. For color spaces with no clearly defined gamut, these values can be arbitrary. In such cases, it may be     advisable to fit the returned color space to a displayable gamut. Parameters Parameters Defaults Description <code>space</code> The color space name in which to generate a random color in. <code>limits</code> <code>None</code> An optional list of constraints for various color channels. Each entry should either be a sequence contain a minimum and maximum value, or should be <code>None</code>. <code>None</code> values will be ignored and the color space's specified channel range will be used instead. Any missing entries will be treated as <code>None</code>. Return Returns a <code>Color</code> object."},{"location":"api/#clone","title":"<code>Color.clone</code>","text":"<pre><code>def clone(\n    self\n):\n    ...\n</code></pre> Description The <code>clone</code> method provides a way to create a duplicate of the current <code>Color</code> instance. Return Returns a <code>Color</code> object."},{"location":"api/#update","title":"<code>Color.update</code>","text":"<pre><code>def update(\n    self,\n    color: ColorInput,\n    data: VectorLike | None = None,\n    alpha: float = util.DEF_ALPHA,\n    *,\n    norm: bool = True,\n    **kwargs: Any\n) -&gt; Self:\n    ...\n</code></pre> Description The <code>update</code> method provides a way to update the underlying color space with coordinates from any color space. The     method's signature is the same as <code>new</code> except that it adds an additional <code>norm</code> parameter used to skip     achromatic hue normalization when converting to the current color space. The object itself will assume the     equivalent color in the current color space that matches the input color's value (assuming no algorithmic     limitations preventing an equivalent color). Parameters Parameters Defaults Description <code>color</code> A color string, or other <code>Color</code> class object. If given <code>data</code>, a string must be used and should represent the color space to use. <code>data</code> <code>None</code> <code>data</code> accepts a list of numbers representing the coordinates of the color. If provided, <code>color</code> must be a string specifying the color space. <code>alpha</code> <code>1</code> <code>alpha</code> accepts a number specifying the <code>alpha</code> channel. Must be used in conjunction with <code>data</code> or it will be ignored. <code>norm</code> <code>True</code> When set to <code>False</code>, this prevents achromatic normalization when updating from a different color space. If no update occurs, nothing is done. Return Returns a reference to the current <code>Color</code> object."},{"location":"api/#mutate","title":"<code>Color.mutate</code>","text":"<pre><code>def mutate(\n    self,\n    color: ColorInput,\n    data: VectorLike | None = None,\n    alpha: float = util.DEF_ALPHA,\n    **kwargs: Any\n) -&gt; Self:\n    ...\n</code></pre> Description The <code>mutate</code> method is similar to <code>update</code> except that it does not convert the input color to the current     color space, but instead replaces the current color space and values with the input color's color space and values. Parameters Parameters Defaults Description <code>color</code> A color string, or other <code>Color</code> class object. If given <code>data</code>, a string must be used and should represent the color space to use. <code>data</code> <code>None</code> <code>data</code> accepts a list of numbers representing the coordinates of the color. If provided, <code>color</code> must be a string specifying the color space. <code>alpha</code> <code>1</code> <code>alpha</code> accepts a number specifying the <code>alpha</code> channel. Must be used in conjunction with <code>data</code> or it will be ignored. Return Returns a reference to the current <code>Color</code> object."},{"location":"api/#convert","title":"<code>Color.convert</code>","text":"<pre><code>def convert(\n    self,\n    space: str,\n    *,\n    fit: bool | str = False,\n    in_place: bool = False,\n    norm: bool = True\n) -&gt; Self:\n    ...\n</code></pre> Description Converts a <code>Color</code> object from one color space to another. If the current color space matches the     specified color space, a clone of the current color will be returned with no changes to the channel values. If     <code>in_place</code> is <code>True</code>, the current object will be modified in place. Parameters Parameters Defaults Description <code>space</code> A string representing the desired final color space. <code>fit</code> <code>False</code> Parameter specifying whether the current color should be gamut mapped into the final, desired color space. If set to <code>True</code>, the color will be gamut mapped using the default gamut mapping method. If set to a string, the string will be interpreted as the name of the gamut mapping method to be used. <code>in_place</code> <code>False</code> Boolean specifying whether the convert should alter the current <code>Color</code> object or return a new one. <code>norm</code> <code>True</code> When set to <code>False</code>, this prevents achromatic normalization when converting from a different color space. If no update occurs, nothing is done. Return Returns a reference to the converted <code>Color</code> object. If <code>in_place</code> is <code>True</code>, the return will be a     reference to the current <code>Color</code> object."},{"location":"api/#space","title":"<code>Color.space</code>","text":"<pre><code>def space(\n    self\n) -&gt; str:\n    ...\n</code></pre> Description Retrieves the current color space name as specified by the underlying color space object. Return Returns a string with the name of the current color space."},{"location":"api/#normalize","title":"<code>Color.normalize</code>","text":"<pre><code>def normalize(\n    self,\n    *,\n    nans: bool = True\n) -&gt; Self:\n    ...\n</code></pre> Description Force normalization of a color's channels by forcing cylindrical colors with negative chroma/saturation to their     positive form and setting hue to undefined if the color is achromatic. If <code>nans</code> is set to <code>False</code>, the hue     normalization step (setting hue to undefined) will be skipped. Normalize modifies the current color in place. Parameters Parameters Defaults Description <code>nans</code> <code>True</code> Perform hue normalization (setting hue to undefined if the color is achromatic). Return Returns a reference to the current <code>Color</code> object after normalizing the channels for undefined hues."},{"location":"api/#to_dict","title":"<code>Color.to_dict</code>","text":"<pre><code>def to_dict(\n    self,\n    *,\n    nans: bool = True,\n    precision: int | Sequence[int] | None = None,\n    decimal: int | bool | Sequence[int | bool] | None = None\n) -&gt; Mapping[str, Any]:\n    ...\n</code></pre> Description <p>Dump the color object to a simple dictionary.</p> <pre><code>{\n    'space': 'srgb',            # Color space name\n    'coords': [1.0, 0.0, 0.0],  # Color channel values\n    'alpha': 1.0                # Alpha channel value\n}\n</code></pre> Parameters Parameters Defaults Description <code>nans</code> <code>True</code> Return channel values having undefined values resolved as defined values. <code>precision</code> <code>None</code> Return value rounded to the specified significant figures. <code>0</code> will result in integer rounding. If <code>None</code>, the default will be used. If the precision is a sequence, each returned coordinate will be rounded according to the precision at the corresponding index in the sequence. <code>decimal</code> <code>None</code> Return value rounded to the specific decimal point. If <code>None</code>, the default will be used. If the decimal is a sequence, each returned coordinate will be rounded according to the decimal at the corresponding index in the sequence. Return A dictionary containing the color space name and channel values."},{"location":"api/#to_string","title":"<code>Color.to_string</code>","text":"<pre><code>def to_string(\n    self,\n    **kwargs: Any\n) -&gt; str:\n    ...\n</code></pre> Description Method that converts the current color to an output format supported by the color space. While a number of the     parameters are common, some may be specific to the color space. The usage guide covers color space     specific options in more details. Parameters <p>Common parameters:</p> Parameters Defaults Description <code>alpha</code> <code>None</code> Boolean or <code>None</code> value which determines whether the output includes <code>alpha</code>. If <code>None</code>, the default alpha will only be shown if less than 1. If <code>True</code>, alpha will always be shown. If <code>False</code>, alpha will be omitted. <code>precision</code> <code>5</code> Integer value that sets precision and scale. Precision and scale will match the value if greater than zero. If <code>0</code>, values will be rounded to the nearest integer. If <code>-1</code>, number will be output at the highest precision. <code>fit</code> <code>True</code> A boolean that controls whether gamut mapping is performed on string creation. By default, colors will be fit to their own color space. This can be disabled by setting to <code>False</code>. <code>color</code> <code>False</code> A boolean that will determine if the <code>color(space coord+ / alpha)</code> format is used for string output. Has highest precedence. <code>percent</code> Varies A boolean that will output color channels as percents. Not all color spaces support percents, or may support percents only in certain scenarios. Default value may be determined by the color space. <p>sRGB specific parameters:</p> Parameters Defaults Description <code>hex</code>. <code>False</code> String output will be in <code>#RRGGBBAA</code> format. <code>names</code> <code>False</code> Boolean indicating a preference for CSS color names. When translating a color to it's closest hex form, if that hex value matches a CSS color name, that color name will be returned as the output. <code>hex</code> does not have to be <code>True</code> for this to apply. <code>compress</code> <code>False</code> If <code>hex</code> is <code>True</code> and <code>compress</code> is <code>True</code>, hex values will be compressed if possible: <code>#RRGGBBAA</code> \u2192 <code>#RGBA</code>. <p>Space dependent parameters:</p> Parameters Defaults Description <code>comma</code> <code>False</code> If supported by the color space and the current output format, commas will be used instead of space format: <code>rgba(0, 0, 0, 1)</code> \u2192 <code>rgb(0 0 0 /1)</code>. Return Returns a string representation of the current color."},{"location":"api/#luminance","title":"<code>Color.luminance</code>","text":"<pre><code>def luminance(\n    self,\n    *,\n    white: VectorLike | None = cat.WHITES['2deg']['D65']\n) -&gt; float:\n    ...\n</code></pre> Description Get the relative luminance. Relative luminance is obtained from the Y coordinate in the XYZ color space. XYZ, in     this case, has a D65 white point. Parameters Parameters Defaults Description <code>white</code> <code>None</code> Specify the white in which to chromatically adapt the points from, if none is specified, the current color's white point is assumed. Return Returns an float indicating the relative luminance."},{"location":"api/#colorcontrast","title":"<code>Color.contrast</code>","text":"<pre><code>def contrast(\n    self,\n    color: ColorInput,\n    method: str | None = None\n) -&gt; float:\n    ...\n</code></pre> Description Get the contrast ratio based on the relative luminance between two colors. Parameters Parameters Defaults Description <code>color</code> A color string, <code>Color</code> object, or dictionary representing a color. <code>method</code> <code>None</code> Specify the method used to obtain the contrast value. If <code>None</code>, the default specified by the class will be used. Return Returns a float indicating the contrast ratio between two colors."},{"location":"api/#distance","title":"<code>Color.distance</code>","text":"<pre><code>def distance(\n    self,\n    color: ColorInput,\n    *,\n    space: str = \"lab\"\n) -&gt; float:\n    ...\n</code></pre> Description Performs a euclidean distance algorithm on two colors. Parameters Parameters Defaults Description <code>color</code> A color string, <code>Color</code> object, or dictionary representing a color. <code>space</code> <code>\"lab\"</code> Color space to perform distancing algorithm in. Return Returns a float indicating euclidean distance between the two colors."},{"location":"api/#delta_e","title":"<code>Color.delta_e</code>","text":"<pre><code>def delta_e(\n    self,\n    color: ColorInput,\n    *,\n    method: str | None = None,\n    **kwargs: Any\n) -&gt; float:\n    ...\n</code></pre> Description <p>Performs a delta E distance algorithm on two colors. Default algorithm that is used is Delta E 1976 (<code>76</code>). Some     methods have additional weighting that can be configured through method specific options which are represented by     <code>**kwargs</code>.</p> <p>Available methods:</p> Name Input Parameters \u2206E<sup>*</sup><sub>ab</sub>\u00a0(CIE76) <code>76</code> \u2206E<sup>*</sup><sub>cmc</sub>\u00a0(CMC\u00a0l:c\u00a0(1984)) <code>cmc</code> <code>l=2, c=1</code> \u2206E<sup>*</sup><sub>94</sub>\u00a0(CIE94) <code>94</code> <code>kl=1, k1=0.045, k2=0.015</code> \u2206E<sup>*</sup><sub>00</sub> \u00a0(CIEDE2000) <code>2000</code> <code>kl=1, kc=1, kh=1</code> \u2206E<sub>HyAB</sub>\u00a0(HyAB) <code>hyab</code> <code>space=\"lab\"</code> \u2206E<sub>ok</sub> <code>ok</code> <code>scalar=1</code> \u2206E<sub>itp</sub>\u00a0(ICtCp) <code>itp</code> <code>scalar=720</code> \u2206E<sub>z</sub>\u00a0(Jzazbz) <code>jz</code> \u2206E<sub>99o</sub>\u00a0(DIN99o) <code>99o</code> \u2206E<sub>cam16</sub> <code>cam16</code> <code>model=ucs</code> \u2206E<sub>HCT</sub> <code>hct</code> Parameters Parameters Defaults Description <code>color</code> A color string, <code>Color</code> object, or dictionary representing a color. <code>method</code> <code>None</code> String that specifies the method to use. If <code>None</code>, the default will be used. <code>**kwargs</code> Any distancing specific parameters to pass to \u2206E method. Return Returns a float indicating the delta E distance between the two colors."},{"location":"api/#closest","title":"<code>Color.closest</code>","text":"<pre><code>def closest(\n    self,\n    colors: Sequence[ColorInput],\n    *,\n    method: str | None = None,\n    **kwargs: Any\n) -&gt; Self:\n    ...\n</code></pre> Description Given a list of colors, calculates the closest color to the calling color object. Parameters Parameters Defaults Description <code>colors</code> A list of color strings, <code>Color</code> object, or dictionary representing a color. <code>method</code> <code>None</code> String that specifies the method of color distancing to use. <code>**kwargs</code> Any distancing specific parameters to pass to \u2206E method. Return The <code>Color</code> that is closest to the calling color object. In the off chance that an empty list is passed in     <code>None</code> will be returned."},{"location":"api/#mask","title":"<code>Color.mask</code>","text":"<pre><code>def mask(\n    self,\n    channel: str | Sequence[str],\n    *,\n    invert: bool = False,\n    in_place: bool = False\n) -&gt; Self:\n    ...\n</code></pre> Description The <code>mask</code> method will set any and all specified channels to <code>NaN</code>. If <code>invert</code> is set to <code>True</code>, <code>mask</code> will     set any and all channels not specified to <code>NaN</code>. Parameters Parameters Defaults Description <code>channel</code> A string specifying a channel, or a list of strings specifying multiple channels. Specified channels will be masked (or the only channels not masked if <code>invert</code> is <code>True</code>). <code>invert</code> <code>False</code> Use inverse masking logic and mask all channels that are not specified. <code>in_place</code> <code>False</code> Boolean used to determine if the current color should be modified \"in place\" or a new <code>Color</code> object should be returned. Return Returns a reference to the masked <code>Color</code> object. If <code>in_place</code> is <code>True</code>, the return will be a     reference to the current <code>Color</code> object."},{"location":"api/#interpolate","title":"<code>Color.interpolate</code>","text":"<pre><code>@classmethod\ndef interpolate(\n    cls,\n    colors: Sequence[ColorInput | interpolate.stop | Callable[..., float]],\n    *,\n    space: str | None = None,\n    out_space: str | None = None,\n    progress: Mapping[str, Callable[..., float]] | Callable[..., float] | None = None,\n    hue: str = util.DEF_HUE_ADJ,\n    premultiplied: bool = True,\n    extrapolate: bool = False,\n    domain: list[float] | None = None,\n    method: str = \"linear\",\n    padding: float | tuple[float, float] | None = None,\n    carryforward: bool | None = False,\n    powerless: bool | None = False,\n    **kwargs: Any\n) -&gt; Interpolator:\n    ...\n</code></pre> Description <p>The <code>interpolate</code> method creates a function that takes a value between 0 - 1 and interpolates a new color based on     the input value.</p> <p>If more than one color is provided, the returned function will span the interpolations between all the provided colors with the same range of 0 - 1.</p> <p>Interpolation can be customized by limiting the interpolation to specific color channels, providing custom interpolation functions, and even adjusting the hue logic used.</p> <p><code>stop</code> objects can wrapped around colors to specify new color stops and easing functions can be placed between colors to alter the transition progress between the two colors.</p> Hue\u00a0Evaluation Description <code>shorter</code> Angles are adjusted so that \u03b8\u2082 - \u03b8\u2081 \u2208 [-180, 180]. <code>longer</code> Angles are adjusted so that \u03b8\u2082 - \u03b8\u2081 \u2208 {[-360, -180], [180, 360]}. <code>increasing</code> Angles are adjusted so that \u03b8\u2082 - \u03b8\u2081 \u2208 [0, 360]. <code>decreasing</code> Angles are adjusted so that \u03b8\u2082 - \u03b8\u2081 \u2208 [-360, 0] <code>specified</code> No fixup is performed. Angles are interpolated in the same way as every other component. <p>The method of interpolation to can also be selected via the <code>method</code> parameter.</p> Method Description <code>linear</code> An linear interpolation that employs piecewise logic to interpolate between two or more colors. <code>bspline</code> An interpolation method that employs cubic B-spline curves to calculate an interpolation path through multiple colors. <code>natural</code> A natural interpolation spline based on the cubic B-spline curve. <code>monotone</code> An interpolation method that utilizes a monotonic cubic spline based on the Hermite spline. <code>catrom</code> Interpolation based on the Catmull-Rom cubic spline. Parameters Parameters Defaults Description <code>colors</code> A list of color strings, <code>Color</code> objects, dictionaries representing a color, <code>stop</code> objects, or easing functions. <code>space</code> <code>\"lab\"</code> Color space to interpolate in. <code>out_space</code> <code>None</code> Color space that the new color should be in. If <code>None</code>, the return color will be in the same color space as specified by <code>space</code>. <code>progress</code> <code>None</code> An optional function that allows for custom logic to perform non-linear interpolation. <code>hue</code> <code>\"shorter\"</code> Define how color spaces which have hue angles are interpolated. Default evaluates between the shortest angle. <code>premultiplied</code> <code>True</code> Use premultiplied alpha when interpolating. <code>extrapolate</code> <code>False</code> Interpolations should extrapolate when values exceed the domain range ([0, 1] by default). <code>domain</code> <code>None</code> A list of numbers defining the domain range of the interpolation. <code>method</code> <code>\"linear\"</code> The interpolation method to use. <code>padding</code> <code>None</code> Adjust the padding of the interpolation range. <code>carryforward</code> <code>False</code> Carry forward undefined channels when converting to the interpolation space. If <code>None</code>, will use the class default which is <code>False</code> by default. <code>powerless</code> <code>None</code> Treat explicitly defined hues as powerless when the color is considered achromatic. If <code>None</code>, will use the class default which is <code>False</code> by default. Return Returns a function that takes a range within the specified domain, the default being <code>[0..1]</code>. The function returns     a new, interpolated <code>Color</code> object."},{"location":"api/#steps","title":"<code>Color.steps</code>","text":"<pre><code>@classmethod\ndef steps(\n    cls,\n    colors: Sequence[ColorInput | interpolate.stop | Callable[..., float]],\n    *,\n    steps: int = 2,\n    max_steps: int = 1000,\n    max_delta_e: float = 0,\n    delta_e: str | None = None,\n    delta_e_args: dict[str, Any] | None = None,\n    **interpolate_args: Any\n) -&gt; list[Self]:\n    ...\n</code></pre> Description <p>Creates an <code>interpolate</code> function and iterates through it with user defined step parameters to produce discrete     color steps. Will attempt to provide the minimum number of <code>steps</code> without exceeding <code>max_steps</code>. If <code>max_delta_e</code>     is provided, the distance between each stop will be cut in half until there are no colors with a distance greater     than the specified <code>max_delta_e</code>. The default \u2206E method is used by default, but it can be changed with the <code>delta_e</code>     parameter.</p> <p>If more than one color is provided, the steps will be returned from the interpolations between all the provided colors.</p> <p>Like <code>interpolate</code>, the default interpolation space is <code>lab</code>.</p> Parameters Parameters Defaults Description <code>color</code> A list of color strings, <code>Color</code> objects, dictionaries representing a color, <code>stop</code> objects, or easing functions. <code>steps</code> <code>2</code> Minimum number of steps. <code>max_steps</code> <code>1000</code> Maximum number of steps. <code>max_delta_e</code> <code>0</code> Maximum delta E distance between the color stops. A value of <code>0</code> or less will be ignored. <code>delta_e</code> <code>None</code> A string indicating which \u2206E method to use. If nothing is supplied, the class object's current default \u2206E method will be used. <code>delta_e_args</code> <code>None</code> A dictionary containing keyword arguments to be passed to the <code>delta_e</code> method. <code>**interpolate_args</code> See\u00a0<code>interpolate</code> Keyword arguments defined in <code>interpolate</code>. Return List of <code>Color</code> objects."},{"location":"api/#discrete","title":"<code>Color.discrete</code>","text":"<pre><code>@classmethod\ndef discrete(\n    cls,\n    colors: Sequence[ColorInput | interpolate.stop | Callable[..., float]],\n    *,\n    space: str | None = None,\n    out_space: str | None = None,\n    steps: int | None = None,\n    max_steps: int = 1000,\n    max_delta_e: float = 0,\n    delta_e: str | None = None,\n    delta_e_args: dict[str, Any] | None = None,\n    domain: list[float] | None = None,\n    **interpolate_args: Any\n) -&gt; Interpolator[Self]:\n    ...\n</code></pre> Description <p>Generates an <code>interpolate</code> function with discrete color scale. By default it assumes as many discrete colors as the     user inputs, but <code>steps</code> can be used to generate more or less using the input colors. As <code>discrete</code> is built on     <code>steps</code>, it takes all the same arguments.</p> <p>Like <code>interpolate</code>, the default interpolation space is <code>lab</code>.</p> Parameters Parameters Defaults Description <code>color</code> A list of color strings, <code>Color</code> objects, dictionaries representing a color, <code>stop</code> objects, or easing functions. <code>space</code> <code>\"lab\"</code> Color space to interpolate in. <code>out_space</code> <code>None</code> Color space that the new color should be in. If <code>None</code>, the return color will be in the same color space as specified by <code>space</code>. <code>steps</code> <code>None</code> Minimum number of steps. If <code>None</code>, steps will be set to the number of input colors. <code>max_steps</code> <code>1000</code> Maximum number of steps. <code>max_delta_e</code> <code>0</code> Maximum delta E distance between the color stops. A value of <code>0</code> or less will be ignored. <code>delta_e</code> <code>None</code> A string indicating which \u2206E method to use. If nothing is supplied, the class object's current default \u2206E method will be used. <code>delta_e_args</code> <code>None</code> A dictionary containing keyword arguments to be passed to the <code>delta_e</code> method. <code>domain</code> <code>None</code> A list of numbers defining the domain range of the interpolation. <code>**interpolate_args</code> See\u00a0<code>interpolate</code> Keyword arguments defined in <code>interpolate</code>. Return Returns a function that takes a range within the specified domain, the default being <code>[0..1]</code>. The function returns     a new, interpolated <code>Color</code> object."},{"location":"api/#mix","title":"<code>Color.mix</code>","text":"<pre><code>def mix(\n    self,\n    color: ColorInput,\n    percent: float = util.DEF_MIX,\n    *,\n    in_place: bool = False,\n    **interpolate_args: Any\n) -&gt; Self:\n    ...\n</code></pre> Description Interpolates between two colors returning a color that represents the mixing of the base color and the provided     <code>color</code> mixed at the provided <code>percent</code>, where <code>percent</code> applies to how much the provided <code>color</code> contributes to the     final result. Parameters Parameters Defaults Description <code>color</code> A color string, <code>Color</code> object, or dictionary representing a color. <code>percent</code> <code>0.5</code> A numerical value between 0 - 1 representing the percentage at which the parameter <code>color</code> will be mixed. <code>in_place</code> <code>False</code> Boolean used to determine if the current color should be modified \"in place\" or a new <code>Color</code> object should be returned. <code>**interpolate_args</code> See\u00a0<code>interpolate</code> Keyword arguments defined in <code>interpolate</code>. Return Returns a reference to the new <code>Color</code> object or a reference to the current <code>Color</code> if     <code>in_place</code> is <code>True</code>."},{"location":"api/#average","title":"<code>Color.average</code>","text":"<pre><code>@classmethod\ndef average(\n    cls,\n    colors: Iterable[ColorInput],\n    *,\n    space: str | None = None,\n    out_space: str | None = None,\n    premultiplied: bool = True,\n    powerelss: bool | None = None\n    **kwargs: Any\n) -&gt; Self:\n    ...\n</code></pre> Description Get the average mean of all channels given a particular set of input colors. Parameters Parameters Defaults Description <code>colors</code> An iterable of color strings, <code>Color</code> objects, and/or dictionaries representing a color. <code>space</code> <code>None</code> An optional string to specify what color space the colors should be averaged in. If none is provided, Oklab is assumed. <code>out_space</code> <code>None</code> Color space that the new color should be in. If <code>None</code>, the return color will be in the same color space as specified via <code>space</code>. <code>premultiplied</code> <code>True</code> Specify whether colors should be premultiplied during the averaging process. <code>powerless</code> <code>None</code> Treat explicitly defined hues as powerless when the color is considered achromatic. If <code>None</code>, will use the class default which is <code>False</code> by default. Return Returns a reference to the new <code>Color</code> object representing the average of the input colors. <p>Deprecated 4.1</p> <p><code>powerless</code> parameter has been deprecated in 4.1 and as it is now always enabled. The parameter no longer does anything and will be removed in the future.</p>"},{"location":"api/#cvd","title":"<code>Color.filter</code>","text":"<pre><code>def filter(\n    self,\n    name: str,\n    amount: float | None = None,\n    *,\n    space: str | None = None,\n    in_place: bool = False,\n    out_space: str | None = None,\n    **kwargs: Any\n) -&gt; Self:\n    ...\n</code></pre> Description <p>Apply a color filter to alter a given color. The non-CVD filters are based on the W3C Filter Effects     and behave in the same manner. Colors are evaluated in the sRGB Linear color space unless otherwise specified via     the <code>space</code> parameter. No other color space will be accepted except sRGB and sRGB Linear.</p> <p>An <code>amount</code> can be provided to adjust how much the color is filtered. Any clamping that occurs with the <code>amount</code> parameter, and related ways in which <code>amount</code> are applied, follow the W3C Filter Effects spec.</p> <p>Some filters, such as CVDs, may take additional arguments via <code>kwargs</code>.</p> Filters Name Default Brightness <code>brightness</code> <code>1</code> Saturation <code>saturate</code> <code>1</code> Contrast <code>contrast</code> <code>1</code> Opacity <code>opacity</code> <code>1</code> Invert <code>invert</code> <code>1</code> Hue\u00a0rotation <code>hue-rotate</code> <code>0</code> Sepia <code>sepia</code> <code>1</code> Grayscale <code>grayscale</code> <code>1</code> CVD\u00a0Filters Name Default Protanopia\u00a0CVD <code>protan</code> <code>1</code> Deuteranopia\u00a0CVD <code>deutan</code> <code>1</code> Tritanopia\u00a0CVD <code>tritan</code> <code>1</code> Parameters Parameters Defaults Description <code>name</code> The name of the filter that should be applied. <code>amount</code> See\u00a0above A numerical value adjusting to what degree the filter is applied. Input range can vary depending on the filter being used. Default can also dependent on the filter being used. <code>space</code> <code>None</code> Controls the algorithm used for simulating the given CVD. <code>in_place</code> <code>False</code> Boolean used to determine if the current color should be modified \"in place\" or a new <code>Color</code> object should be returned. <code>out_space</code> <code>None</code> Color space that the new color should be in. If <code>None</code>, the return color will be in the same color space as specified via <code>space</code>. <code>**kwargs</code> Additional filter specific parameters. <p>CVDs also take an optional <code>method</code> parameter that allows for specifying the CVD algorithm to use.</p> Simulation\u00a0Approach Name Brettel 1997 <code>brettel</code> Vi\u00e9not, Brettel, and Mollon 1999 <code>vienot</code> Machado 2009 <code>machado</code> Return Returns a reference to the new <code>Color</code> object or a reference to the current <code>Color</code> if     <code>in_place</code> is <code>True</code>."},{"location":"api/#harmony","title":"<code>Color.harmony</code>","text":"<pre><code>def harmony(\n    self,\n    name: str,\n    *,\n    space: str | None = None,\n    out_space: str | None = None,\n    **kwargs: Any\n) -&gt; list[Self]:\n    ...\n</code></pre> Description <p>The <code>harmony</code> method uses the current color and returns a set of harmonious colors (including the current color).     The color harmonies are based on the classical color harmonies of color theory. By default, harmonious colors are     selected under the perceptually uniform OkLCh color space, but other cylindrical color spaces can be used.</p> Harmony Name Monochromatic <code>mono</code> Complementary <code>complement</code> Split\u00a0Complement <code>split</code> Analogous <code>analogous</code> Triadic <code>triad</code> Tetradic\u00a0Square <code>square</code> Tetradic\u00a0Rectangle <code>rectangle</code> Wheel <code>wheel</code> Parameters Parameters Defaults Description <code>name</code> Name of the color harmony to use. <code>space</code> <code>'oklch'</code> Color space under which the harmonies will be calculated. Must be a cylindrical space. <code>out_space</code> <code>None</code> Color space that the new color should be in. If <code>None</code>, the return color will be in the same color space as specified via <code>space</code>. <code>**kwargs</code> Any harmony specific parameters to pass to the called harmony. Return Returns a list of <code>Color</code> objects."},{"location":"api/#compose","title":"<code>Color.compose</code>","text":"<p>Deprecated 4.0</p> <p><code>compose</code> method was deprecated in favor of the new <code>layer</code> method and will be removed at some future time.</p> <pre><code>def compose(\n    self,\n    backdrop: ColorInput | Sequence[ColorInput],\n    *,\n    blend: str | bool = True,\n    operator: str | bool = True,\n    space: str | None = None,\n    out_space: str | None = None,\n    in_place: bool = False\n) -&gt; Self:\n    ...\n</code></pre> Description <p>Apply compositing which consists of a blend mode and a Porter Duff operator     for alpha compositing. The current color is treated as the source (top layer) and the provided color as the backdrop     (bottom layer). Colors will be composited in the <code>srgb</code> color space unless otherwise specified.</p> <p>Compositing should generally be applied in RGB-ish color spaces (sRGB, Display P3, A98 RGB, etc.). The algorithm is designed only for RGB-ish colors. Non-RGB-ish colors are likely to provide nonsense results.</p> <p>Supported blend modes are:</p> Blend Modes <code>normal</code> <code>multiply</code> <code>darken</code> <code>lighten</code> <code>burn</code> <code>dodge</code> <code>screen</code> <code>overlay</code> <code>hard-light</code> <code>exclusion</code> <code>difference</code> <code>soft-light</code> <code>hue</code> <code>saturation</code> <code>luminosity</code> <code>color</code> <code>color</code> <code>hue</code> <code>saturation</code> <code>luminosity</code> <p>Supported Port Duff operators are:</p> Operators <code>clear</code> <code>copy</code> <code>destination</code> <code>source-over</code> <code>destination-over</code> <code>source-in</code> <code>destination-in</code> <code>source-out</code> <code>destination-out</code> <code>source-atop</code> <code>destination-atop</code> <code>xor</code> <code>lighter</code> Parameters Parameters Defaults Description <code>backdrop</code> A background color or sequence of background colors represented with strings, <code>Color</code> objects, and/or dictionaries representing a color. <code>blend</code> <code>None</code> A blend mode to use to use when compositing. Values should be a string specifying the name of the blend mode to use. If <code>None</code>, <code>normal</code> will be used. If <code>False</code>, blending will be skipped. <code>operator</code> <code>None</code> A Porter Duff operator to use for alpha compositing. Values should be a string specifying the name of the operator to use. If <code>None</code>, <code>source-over</code> will be used. If <code>False</code>, alpha compositing will be skipped. <code>space</code> <code>None</code> A color space to perform the overlay in. If <code>None</code>, the base color's space will be used. <code>out_space</code> <code>None</code> Color space that the new color should be in. If <code>None</code>, the return color will be in the same color space as specified by <code>space</code>. <code>in_place</code> <code>False</code> Boolean used to determine if the current color should be modified \"in place\" or a new <code>Color</code> object should be returned. Return Returns a reference to the new <code>Color</code> object or a reference to the current <code>Color</code> if     <code>in_place</code> is <code>True</code>."},{"location":"api/#layer","title":"<code>Color.layer</code>","text":"<pre><code>@classmethod\ndef layer(\n    cls,\n    colors: Sequence[ColorInput],\n    *,\n    blend: str | bool = True,\n    operator: str | bool = True,\n    space: str | None = None,\n    out_space: str | None = None\n) -&gt; Self:\n    ...\n</code></pre> Description <p>Layer colors on time of each other and apply compositing which consists of a blend mode     and a Porter Duff operator for alpha compositing. Colors are provided in     a list where the left most color is treated as the top most color and the right most color is treated as the bottom     most color. Colors will be composited in the <code>srgb</code> color space unless otherwise specified.</p> <p>Compositing should generally be applied in RGB-ish color spaces (sRGB, Display P3, A98 RGB, etc.). The algorithm is designed only for RGB-ish colors. Non-RGB-ish colors are likely to provide nonsense results.</p> <p>Supported blend modes are:</p> Blend Modes <code>normal</code> <code>multiply</code> <code>darken</code> <code>lighten</code> <code>burn</code> <code>dodge</code> <code>screen</code> <code>overlay</code> <code>hard-light</code> <code>exclusion</code> <code>difference</code> <code>soft-light</code> <code>hue</code> <code>saturation</code> <code>luminosity</code> <code>color</code> <code>color</code> <code>hue</code> <code>saturation</code> <code>luminosity</code> <p>Supported Port Duff operators are:</p> Operators <code>clear</code> <code>copy</code> <code>destination</code> <code>source-over</code> <code>destination-over</code> <code>source-in</code> <code>destination-in</code> <code>source-out</code> <code>destination-out</code> <code>source-atop</code> <code>destination-atop</code> <code>xor</code> <code>lighter</code> Parameters Parameters Defaults Description <code>colors</code> A sequence of color strings, <code>Color</code> objects, and/or dictionaries representing a color. <code>blend</code> <code>None</code> A blend mode to use to use when compositing. Values should be a string specifying the name of the blend mode to use. If <code>None</code>, <code>normal</code> will be used. If <code>False</code>, blending will be skipped. <code>operator</code> <code>None</code> A Porter Duff operator to use for alpha compositing. Values should be a string specifying the name of the operator to use. If <code>None</code>, <code>source-over</code> will be used. If <code>False</code>, alpha compositing will be skipped. <code>space</code> <code>None</code> A color space to perform the overlay in. If <code>None</code>, the base color's space will be used. <code>out_space</code> <code>None</code> Color space that the new color should be in. If <code>None</code>, the return color will be in the same color space as specified by <code>space</code>. Return Returns a reference to the new <code>Color</code> object."},{"location":"api/#clip","title":"<code>Color.clip</code>","text":"<pre><code>def clip(\n    self,\n    space: str | None = None\n) -&gt; Self:\n    ...\n</code></pre> Description Performs simple clipping on color channels that are out of gamut. Parameters Parameters Defaults Description <code>space</code> <code>None</code> The color space that the color must be mapped to. If space is <code>None</code>, then the current color space will be used. Return Returns a reference to the current <code>Color</code> after fitting its coordinates to the specified gamut."},{"location":"api/#fit","title":"<code>Color.fit</code>","text":"<pre><code>def fit(\n    self,\n    space: str | None = None,\n    *,\n    method: str | None = None,\n    **kwargs: Any\n) -&gt; Self:\n    ...\n</code></pre> Description <p>Fits color to the current or specified color gamut.</p> <p>By default, <code>lch-chroma</code> gamut mapping is used. This is essentially an approach that holds lightness and hue constant in the CIELCh color space while reducing chroma until the color is in gamut. Clipping is done at each step of the way and the color distance measured to see how close our color is to the intended color.</p> <p>The supported gamut mapping methods are:</p> Name Input Clipping <code>clip</code> OkLCh Chroma <code>oklch-chroma</code> LCh Chroma <code>lch-chroma</code> Parameters <p>Some methods could have additional parameters to configure the behavior, these would be done through <code>**kwargs</code>. None of built-in gamut mapping methods currently have additional parameters.</p> Parameters Defaults Description <code>space</code> <code>None</code> The color space that the color must be mapped to. If space is <code>None</code>, then the current color space will be used. <code>method</code> <code>None</code> String that specifies which gamut mapping method to use. If <code>None</code>, <code>lch-chroma</code> will be used. Return Returns a reference to the current <code>Color</code> after fitting its coordinates to the specified gamut."},{"location":"api/#in_gamut","title":"<code>Color.in_gamut</code>","text":"<pre><code>def in_gamut(\n    self, space: str | None = None,\n    *,\n    tolerance: float = util.DEF_FIT_TOLERANCE\n) -&gt; bool:\n    ...\n</code></pre> Description Checks if the current color is in the current or specified gamut. Parameters Parameters Defaults Description <code>space</code> <code>None</code> The color space that the color must be fit within. If space is <code>None</code>, then the current color space will be used. <code>tolerance</code> <code>0.000075</code> Tolerance allowed when checking bounds of color. Return Returns a boolean indicating whether the color is in the specified gamut."},{"location":"api/#get","title":"<code>Color.get</code>","text":"<pre><code>@overload\ndef get(self,\n    name: str,\n    *,\n    nans: bool = True,\n    precision: int | Sequence[int] | None = None,\n    decimal: int | bool | Sequence[int | bool] | None = None\n) -&gt; float:\n    ...\n\n@overload\ndef get(\n    self,\n    name: list[str] | tuple[str, ...],\n    *,\n    nans: bool = True,\n    precision: int | Sequence[int] | None = None,\n    decimal: int | bool | Sequence[int | bool] | None = None\n) -&gt; Vector:\n    ...\n\ndef get(\n    self,\n    name: str | list[str] | tuple[str, ...],\n    *,\n    nans: bool = True,\n    precision: int | Sequence[int] | None = None,\n    decimal: int | bool | Sequence[int | bool] | None = None\n) -&gt; float | Vector:\n    ...\n</code></pre> Description Retrieves the coordinate value from the specified channel or values from a sequence of specified channels. Channels     must be a channel name in the current color space or a channel name in the specified color space using the syntax:     <code>space.channel</code>. Parameters Parameters Defaults Description <code>name</code> Channel name or sequence of channel names. Channel names can define the color space and channel name to retrieve value from a different color space. <code>nans</code> <code>True</code> Determines whether an undefined value is allowed to be returned. If disabled, undefined values will be resolved before returning. <code>precision</code> <code>None</code> Return value rounded to the specified significant figures. <code>0</code> will result in integer rounding. If <code>None</code>, the default will be used. If the precision is a sequence, each returned coordinate will be rounded according to the precision at the corresponding index in the sequence. <code>decimal</code> <code>None</code> Return value rounded to the specific decimal point. If <code>None</code>, the default will be used. If the decimal is a sequence, each returned coordinate will be rounded according to the decimal at the corresponding index in the sequence. Return <p>Returns a numerical value that is stored internally for the specified channel, or a calculated value in the case     that a channel in a different color space is requested. If more than one value is requested, the a list of numerical     values will be returned.</p>"},{"location":"api/#set","title":"<code>Color.set</code>","text":"<pre><code>def set(\n    self,\n    name: str | dict[str, float | Callable[..., float]],\n    value: float | Callable[..., float] | None = None,\n    *,\n    nans: bool = True\n) -&gt; Self:\n    ...\n</code></pre> Description <p>Sets the given value to the specified channel. If the <code>name</code> is provided in the form <code>space.channel</code>, the value will     be applied to the channel of the specified color space while keeping current color space the same.</p> <p>The <code>value</code> can be a numerical value or a function that accepts a numerical channel value and returns a numerical channel value.</p> <p><code>name</code> can also be a dictionary of channels, each with a <code>value</code>. In this case, the <code>value</code> parameter of the function can be ignored.</p> <p>This function returns the current colors reference so that multiple sets can be chained together.</p> Parameters Parameters Defaults Description <code>name</code> A string containing a channel name or color space and channel separated by a <code>.</code> specifying the what channel to set. If <code>value</code> is omitted, <code>name</code> can also be a dictionary containing multiple channels, each specifying their own value to set. <code>value</code> A numerical value, a string value accepted by the specified color space, or a function. <code>nans</code> <code>True</code> When doing relative sets via a callback input, ensure the channel value passed to the callback is a real number, not an undefined value. Return Returns a reference to the current <code>Color</code> object."},{"location":"api/#coords","title":"<code>Color.coords</code>","text":"<pre><code>def coords(\n    self,\n    *,\n    nans: bool = True,\n    precision: int | Sequence[int] | None = None,\n    decimal: int | bool | Sequence[int | bool] | None = None\n) -&gt; Vector:\n    ...\n</code></pre> Description Get the color channels (no alpha). If <code>nans</code> is set to <code>False</code>, all undefined values will be returned as     defined. Parameters Parameters Defaults Description <code>nans</code> <code>True</code> If <code>nans</code> is set to <code>False</code>, all undefined values will be returned as defined. <code>precision</code> <code>None</code> Return value rounded to the specified significant figures. <code>0</code> will result in integer rounding. If <code>None</code>, the default will be used. If the precision is a sequence, each returned coordinate will be rounded according to the precision at the corresponding index in the sequence. <code>decimal</code> <code>None</code> Return value rounded to the specific decimal point. If <code>None</code>, the default will be used. If the decimal is a sequence, each returned coordinate will be rounded according to the decimal at the corresponding index in the sequence. Return Returns a list of <code>float</code> values, one for each color channel."},{"location":"api/#coords","title":"<code>Color.alpha</code>","text":"<pre><code>def alpha(\n    self,\n    *,\n    nans: bool = True,\n    precision: int | None = None,\n    decimal: int | bool | None = None\n) -&gt; float:\n    ...\n</code></pre> Description Get the alpha channel's value. If <code>nans</code> is set to <code>False</code>, an undefined value will be returned as defined. Parameters Parameters Defaults Description <code>nans</code> <code>True</code> If <code>nans</code> is set to <code>False</code>, an undefined value will be returned as defined. <code>precision</code> <code>None</code> Return value rounded to the specified significant figures. <code>0</code> will result in integer rounding. If <code>None</code>, the default will be used. <code>decimal</code> <code>None</code> Return value rounded to the specific decimal point. If <code>None</code>, the default will be used. Return Returns a <code>float</code>."},{"location":"api/#is_achromatic","title":"<code>Color.is_achromatic</code>","text":"<pre><code>def is_achromatic(\n    self\n) -&gt; bool:\n    ...\n</code></pre> Description Can be called on any color to determine if the color is achromatic. If a color is achromatic, or very close to     achromatic, it will return <code>True</code>. Return Returns a boolean indicating whether the color is achromatic."},{"location":"api/#is_nan","title":"<code>Color.is_nan</code>","text":"<pre><code>def is_nan(\n    self,\n    name: str\n) -&gt; bool:\n    ...\n</code></pre> Description Retrieves the coordinate value from the specified channel and checks whether the value is undefined (set to NaN).     Channel must be a channel name in the current color space or a channel name in the specified color space using the     syntax: <code>space.channel</code>. Parameters Parameters Defaults Description <code>name</code> A string indicating what channel property to check. Return Returns a boolean indicating whether the specified color space's channel is <code>NaN</code>."},{"location":"api/#white","title":"<code>Color.white</code>","text":"<pre><code>def white(\n    self\n) -&gt; Vector:\n    ...\n</code></pre> Description Retrieves the white point for the current color's color space. Return Returns a set of XYZ coordinates that align with the white point for the given color space."},{"location":"api/#blackbocy","title":"<code>Color.blackbody</code>","text":"<pre><code>@classmethod\ndef blackbody(\n    cls,\n    temp: float,\n    duv: float = 0.0,\n    *,\n    scale: bool = True,\n    scale_space: str | None = None,\n    out_space: str | None = None,\n    method: str | None = None,\n    **kwargs: Any\n) -&gt; Self:\n    ...\n</code></pre> Description Creates a color from a temperature in Kelvin and an optional \u2206<sub>uv</sub>. The color will be scaled within the linear RGB     space specified by <code>scale_space</code> and can be disabled by setting <code>scale</code> to <code>False</code>. By default, the     Ohno 2013 algorithm is used and can be configured via <code>method</code>. Parameters Parameters Defaults Description <code>temp</code> A positive temperature in Kelvin. Accepted range of temperature is based on the algorithm. <code>duv</code> <code>0.0</code> An optional \u2206<sub>uv</sub> specifying the distance from the black body curve. <code>scale</code> <code>True</code> Scale the color with a linear RGB color space as defined by <code>scale_space</code>. <code>scale_space</code> <code>'srgb-linear'</code> If <code>scale</code> is enabled, <code>scale_space</code> defines the RGB color space in which the returned color should be scaled within. The color space should be a linear space for best results. If undefined, <code>srgb-linear</code> will be used. <code>out_space</code> <code>None</code> Color space that the new color should be in. If <code>None</code>, the return color will be in the same color space as specified by <code>space</code> or <code>xyz-d65</code> if <code>space</code> is <code>None</code>. <code>method</code> <code>None</code> A string specifying the algorithm to use. By default <code>robertson-1968</code> is used. <code>**kwargs</code> Any plugin specific parameters to pass to the <code>blackbody</code> method. Return Returns a reference to the current <code>Color</code>."},{"location":"api/#cct","title":"<code>Color.cct</code>","text":"<pre><code>def cct(\n    self,\n    *,\n    method: str | None = None,\n    **kwargs: Any\n) -&gt; Vector:\n    ...\n</code></pre> Description Returns the associated CCT and \u2206<sub>uv</sub> for a given color. If the color is beyond an acceptable range for the     algorithm or the color is very far from the locus, the result may be surprising. Parameters Parameters Defaults Description <code>method</code> <code>None</code> A string specifying the algorithm to use. By default <code>robertson-1968</code> is used. <code>**kwargs</code> Any plugin specific parameters to pass to the <code>blackbody</code> method. Return Returns a list containing the correlated color temperature in Kelvin and the \u2206<sub>uv</sub>."},{"location":"api/#colorchromatic_adaptation","title":"<code>Color.chromatic_adaptation</code>","text":"<pre><code>@classmethod\ndef chromatic_adaptation(\n    cls,\n    w1: tuple[float, float],\n    w2: tuple[float, float],\n    xyz: VectorLike,\n    *,\n    method: str | None = None\n) -&gt; Vector:\n    ...\n</code></pre> Description A class method that converts an XYZ set of coordinates between two given white points. The first white point must     match the white point of the current coordinates and the second white point must be the desired white point to use.     <code>method</code> dictates the method of chromatic adaptation to use. Parameters Parameters Defaults Description <code>w1</code> Current white point of the XYZ coordinates. <code>w2</code> Desired white point of the XYZ coordinates. <code>xyz</code> The XYZ coordinates to adapt. <code>method</code> <code>None</code> The method of chromatic adaptation to use. If not specified, the current class's default method will be used. Return Returns a set of XYZ coordinates that have been chromatically adapted to the desired white point."},{"location":"api/#xy","title":"<code>Color.xy</code>","text":"<pre><code>def xy(\n    self,\n    *,\n    white: VectorLike | None = None\n) -&gt; Vector:\n    ...\n</code></pre> Description Retrieves the CIE 1931 (x, y) chromaticity coordinates for a given color. Parameters Parameters Defaults Description <code>white</code> <code>None</code> Specify the white in which to chromatically adapt the points from, if none is specified, the current color's white point is assumed. Return Returns a tuple of CIE 1931 (x, y) chromaticity points for the given color. The XYZ translation to xy will use the     current color's white point to ensure the values are relative to the proper white point."},{"location":"api/#xy","title":"<code>Color.uv</code>","text":"<pre><code>def uv(\n    self,\n    mode: str = '1976',\n    *,\n    white: VectorLike | None = None\n) -&gt; Vector:\n    ...\n</code></pre> Description Retrieves the UCS 1960 (u, v) chromaticity coordinates for a given color or the CIE 1976 UCS (u', v') chromaticity     coordinates, the latter being the default. Parameters Parameters Defaults Description <code>mode</code> <code>'1976'</code> A string indicating what mode to use. <code>1976</code> refers to the (u', v') points as described by CIE 1976 UCS and <code>1960</code> describes the (u, v) points as documented by CIE 1960 UCS. <code>white</code> <code>None</code> Specify the white in which to chromatically adapt the points from, if none is specified, the current color's white point is assumed. Return Returns a tuple of (u, v) \u2013 either 1976 (u', v') or 1960 (u, v) \u2013 chromaticity points for the given color. The XYZ    translation to uv will use the current color's white point to ensure the values are relative to the proper white    point."},{"location":"api/#get_chromaticity","title":"<code>Color.get_chromaticity</code>","text":"<pre><code>def get_chromaticity(\n    self,\n    cspace: str = 'uv-1976',\n    *,\n    white: VectorLike | None = None\n) -&gt; Vector:\n    ...\n</code></pre> Description Retrieves the 1931 xy, 1960 uv, or 1976 u'v' chromaticity coordinates with the luminance (Y). Coordinates are     returned in the format specified by <code>cspace</code> and will use the white point of the current color. Parameters Parameters Defaults Description <code>cspace</code> <code>'uv-1976'</code> A string indicating what chromaticity space to use. <code>uv-1976</code> being the default. <code>white</code> <code>None</code> Specify the white in which to chromatically adapt the points from, if none is specified, the current color's white point is assumed. Return Returns a list of chromaticity coordinates. Results will either be in [x, y, Y] for 1931 xy, [u, v, Y] for 1960 uv,     or [u', v', Y] for 1976 u'v'."},{"location":"api/#get_chromaticity","title":"<code>Color.chromaticity</code>","text":"<pre><code>@classmethod\ndef chromaticity(\n    cls,\n    space: str,\n    coords: VectorLike,\n    cspace: str = 'uv-1976',\n    *,\n    scale: bool = False,\n    scale_space: str | None = None,\n    white: VectorLike | None = None\n) -&gt; Self:\n    ...\n</code></pre> Description Returns a color that satisfies the provided chromaticity coordinates. Coordinates can be in the form 1931 xyY, 1960     uvY, or 1976 u'v'Y and can be configured via <code>cspace</code>. The target space to convert to should be specified via     <code>space</code>. Chromaticity coordinates should math the white space of the targeted space, but if they are not the white     point of the chromaticity coordinates can be specified with <code>white</code>. Parameters Parameters Defaults Description <code>space</code> Color space to chromaticities to. <code>coords</code> The chromaticity coordinates. Values can be in either 3D form (with luminance Y). <code>cspace</code> <code>'uv-1976'</code> A string indicating what chromaticity space to use. <code>uv-1976</code> being the default. <code>white</code> <code>None</code> Specify the white in which to chromatically adapt the points from, if none is specified, the targeted color's white point is assumed. <code>scale</code> <code>True</code> Scale the color with a linear RGB color space as defined by <code>scale_space</code>. <code>scale_space</code> <code>None</code> If <code>scale</code> is enabled, <code>scale_space</code> defines the RGB color space in which the returned color should be scaled within. The color space should be a linear space for best results. If undefined, <code>srgb-linear</code> will be used. Return Returns a reference to a new <code>Color</code> object that satisfies the chromaticity coordinates."},{"location":"api/#convert_chromaticity","title":"<code>Color.convert_chromaticity</code>","text":"<pre><code>@classmethod\ndef convert_chromaticity(\n    cls,\n    cspace1: str,\n    cspace2: str,\n    coords: VectorLike\n) -&gt; Vector:\n    ...\n</code></pre> Description Converts a 2D chromaticity pair from one chromaticity space to another. Supported spaces are <code>xy-1931</code>, <code>uv-1960</code>,     and <code>uv-1976</code>. Parameters Parameters Defaults Description <code>cspace1</code> Initial chromaticity space for the given coordinates. <code>cspace2</code> Target chromaticity space for the given coordinates. <code>coords</code> The 2D chromaticity coordinates to convert. Return Returns the converted 2D chromaticity coordinates."},{"location":"colors/","title":"Color Spaces","text":"<p>ColorAide aims to support all the color spaces and models currently offered in modern CSS, such as sRGB, Display P3, CIELab, Oklab, etc. We also include a number of color spaces that are not available in CSS.</p> <p>ColorAide registers a subset of the offered color spaces by default. But additional color spaces can be registered by subclassing the <code>Color</code> object and then registering any additional required plugins, such as color spaces.</p> <p>Everything but the Kitchen Sink</p> <p>It is not generally recommended to register all possible color spaces (and plugins in general). The suggested approach is to cherry pick additional color spaces as needed by simply subclassing <code>Color</code> and then registering the desired plugins, but if desired <code>coloraide.everything.ColorAll</code> already includes all plugins and can be imported to get access to every supported plugin.</p>"},{"location":"colors/#default-color-spaces","title":"Default Color Spaces","text":"<p>While ColorAide supports a lot of color spaces, it is rare that a user would ever need every color space implemented by ColorAide available at all times, so to keep the Color object lighter, and color matching logic quicker, the <code>coloraide.Color</code> object does not register all color spaces by default.</p> Default Color\u00a0Spaces XYZ\u00a0D65 XYZ\u00a0D50 Linear sRGB Linear Display\u00a0P3 Linear A98\u00a0RGB Linear Rec.\u00a02020 Linear ProPhoto\u00a0RGB sRGB Display\u00a0P3 A98\u00a0RGB Rec.\u00a02020 ProPhoto\u00a0RGB HSL HSV HWB Lab LCh Lab\u00a0D65 LCh\u00a0D65 Oklab OkLCh Jzazbz JzCzhz ICtCp Rec.\u00a02100\u00a0HLG Rec.\u00a02100\u00a0PQ Linear\u00a0Rec.\u00a02100"},{"location":"colors/#color-space-map","title":"Color Space Map","text":"<p>When registering a plugin, it is important that all required plugins in the conversion path are registered as well. Below we've provided a diagram of all available color spaces and how they translate to one another.</p> <p>Click any of the color spaces to jump to the related documentation.</p> <pre><code>%%{init: {\"flowchart\": {\"useMaxWidth\": true}}}%%\nflowchart LR\n\n    xyz-d65 --- srgb-linear\n        srgb-linear --- rec709\n        srgb-linear --- srgb\n            srgb --- hsl\n            srgb --- hsv\n               hsv --- hwb\n            srgb --- cmy\n            srgb --- cmyk\n            srgb --- ryb\n            srgb --- xyb\n            srgb --- cubehelix\n            srgb --- hsi\n            srgb --- orgb\n            srgb --- prismatic\n\n    xyz-d65 --- display-p3-linear --- display-p3\n\n    xyz-d65 --- rec2020-linear  --- rec2020\n        rec2020-linear --- rec2100-linear\n            rec2100-linear --- rec2100-pq\n            rec2100-linear --- rec2100-hlg\n\n    xyz-d65 --- a98-rgb-linear --- a98-rgb\n\n    xyz-d65 --- xyz-d50 --- prophoto-rgb-linear --- prophoto-rgb\n\n    xyz-d50 --- lab --- lch\n\n    xyz-d65 --- lab-d65 --- lch-d65\n\n    xyz-d65 --- oklab --- oklch\n        oklab --- okhsl\n        oklab --- okhsv\n        oklab --- oklrab --- oklrch\n\n    xyz-d65 --- jzazbz --- jzczhz\n\n    xyz-d65 --- ictcp\n\n    xyz-d65 --- luv --- lchuv\n        luv --- hsluv\n        luv --- hpluv\n\n    xyz-d65 --- din99o --- lch99o\n\n    xyz-d65 --- cam02-jmh\n        cam02-jmh --- cam02-ucs\n        cam02-jmh --- cam02-scd\n        cam02-jmh --- cam02-lcd\n\n    xyz-d65 --- cam16-jmh\n        cam16-jmh --- cam16-ucs\n        cam16-jmh --- cam16-scd\n        cam16-jmh --- cam16-lcd\n\n    xyz-d65 --- hellwig-jmh\n\n    xyz-d65 --- hct\n\n    xyz-d65 --- aces2065-1\n\n    xyz-d65 --- acescg --- acescc\n        acescg --- acescct\n\n    xyz-d65 --- hunter-lab\n\n    xyz-d65 --- ipt\n\n    xyz-d65 --- igpgtg\n\n    xyz-d65 --- rlab\n\n    xyz-d65 --- ucs\n\n    xyz-d65 --- xyy\n\n    xyz-d65 --- zcam-jmh\n\n    xyz-d65(XYZ D65)\n    xyz-d50(XYZ D50)\n    rec2020(Rec. 2020)\n    rec2020-linear(Linear Rec. 2020)\n    rec2100-pq(Rec. 2100 PQ)\n    rec2100-hlg(Rec. 2100 HLG)\n    rec2100-linear(Linear Rec. 2100)\n    srgb-linear(Linear sRGB)\n    srgb(sRGB)\n    rec709(Rec. 709)\n    hsl(HSL)\n    hsv(HSV)\n    hwb(HWB)\n    display-p3-linear(Linear Display P3)\n    display-p3(Display P3)\n    a98-rgb-linear(Linear A98 RGB)\n    a98-rgb(A98 RGB)\n    prophoto-rgb-linear(Linear ProPhoto RGB)\n    prophoto-rgb(ProPhoto RGB)\n    lab(Lab)\n    lch(LCh)\n    lab-d65(Lab D65)\n    lch-d65(LCh D65)\n    oklab(Oklab)\n    oklch(OkLCh)\n    okhsl(Okhsl)\n    okhsv(Okhsv)\n    oklrab(Oklrab)\n    oklrch(OkLrCh)\n    luv(Luv)\n    lchuv(LChuv)\n    hsluv(HSLuv)\n    hpluv(HPLuv)\n    din99o(DIN99o)\n    lch99o(DIN99o LCh)\n    jzazbz(Jzazbz)\n    jzczhz(JzCzhz)\n    ictcp(ICtCp)\n    orgb(oRGB)\n    ipt(IPT)\n    igpgtg(IgPgTg)\n    hunter-lab(Hunter Lab)\n    rlab(RLAB)\n    hsi(HSI)\n    cmy(CMY)\n    cmyk(CMYK)\n    xyy(xyY)\n    ucs(CIE 1960 UCS)\n    prismatic(Prismatic)\n    aces2065-1(ACES2065-1)\n    acescg(ACEScg)\n    acescc(ACEScc)\n    acescct(ACEScct)\n    cam02-jmh(CAM02 JMh)\n    cam02-ucs(CAM02 UCS)\n    cam02-scd(CAM02 SCD)\n    cam02-lcd(CAM02 LCD)\n    cam16-jmh(CAM16 JMh)\n    cam16-ucs(CAM16 UCS)\n    cam16-scd(CAM16 SCD)\n    cam16-lcd(CAM16 LCD)\n    hellwig-jmh(Hellwig JMh)\n    hct(HCT)\n    xyb(XYB)\n    ryb(RYB)\n    cubehelix(Cubehelix)\n    zcam-jmh(ZCAM JMh)\n\n    click xyz-d65 \"./xyz_d65/\" _self\n    click xyz-d50 \"./xyz_d50/\" _self\n    click rec2020 \"./rec2020/\" _self\n    click rec2020-linear \"./rec2020_linear/\" _self\n    click rec2100-pq \"./rec2100_pq/\" _self\n    click rec2100-hlg \"./rec2100_hlg/\" _self\n    click rec2100-linear \"./rec2100_linear/\" _self\n    click srgb-linear \"./srgb_linear/\" _self\n    click srgb \"./srgb/\" _self\n    click rec709 \"./rec709/\" _self\n    click hsl \"./hsl/\" _self\n    click hsv \"./hsv/\" _self\n    click hwb \"./hwb/\" _self\n    click display-p3-linear \"./display_p3_linear/\" _self\n    click display-p3 \"./display_p3/\" _self\n    click a98-rgb-linear \"./a98_rgb_linear/\" _self\n    click a98-rgb \"./a98_rgb/\" _self\n    click prophoto-rgb-linear \"./prophoto_rgb_linear/\" _self\n    click prophoto-rgb \"./prophoto_rgb/\" _self\n    click lab \"./lab/\" _self\n    click lch \"./lch/\" _self\n    click lab-d65 \"./lab_d65/\" _self\n    click lch-d65 \"./lch_d65/\" _self\n    click oklab \"./oklab/\" _self\n    click oklch \"./oklch/\" _self\n    click okhsl \"./okhsl/\" _self\n    click okhsv \"./okhsv/\" _self\n    click oklrab \"./oklrab\" _self\n    click oklrch \"./oklrch\" _self\n    click luv \"./luv/\" _self\n    click lchuv \"./lchuv/\" _self\n    click hsluv \"./hsluv/\" _self\n    click hpluv \"./hpluv/\" _self\n    click din99o \"./din99o/\" _self\n    click lch99o \"./lch99o/\" _self\n    click jzazbz \"./jzazbz/\" _self\n    click jzczhz \"./jzczhz/\" _self\n    click ictcp \"./ictcp/\" _self\n    click orgb \"./orgb/\" _self\n    click ipt \"./ipt/\" _self\n    click igpgtg \"./igpgtg/\" _self\n    click hunter-lab \"./hunter_lab/\" _self\n    click rlab \"./rlab/\" _self\n    click hsi \"./hsi/\" _self\n    click cmy \"./cmy/\" _self\n    click cmyk \"./cmyk/\" _self\n    click xyy \"./xyy/\" _self\n    click ucs \"./ucs/\" _self\n    click prismatic \"./prismatic/\" _self\n    click aces2065-1 \"./aces2065_1/\" _self\n    click acescg \"./acescg/\" _self\n    click acescc \"./acescc/\" _self\n    click acescct \"./acescct/\" _self\n    click cam02-jmh \"./cam16/\" _self\n    click cam02-ucs \"./cam16_ucs/\" _self\n    click cam02-scd \"./cam16_scd/\" _self\n    click cam02-lcd \"./cam16_lcd/\" _self\n    click cam16-jmh \"./cam16/\" _self\n    click cam16-ucs \"./cam16_ucs/\" _self\n    click cam16-scd \"./cam16_scd/\" _self\n    click cam16-lcd \"./cam16_lcd/\" _self\n    click hellwig-jmh \"./hellwig/\" _self\n    click hct \"./hct/\" _self\n    click xyb \"./xyb/\" _self\n    click ryb \"./ryb/\" _self\n    click cubehelix \"./cubehelix/\" _self\n    click zcam-jmh \"./zcam/\" _self</code></pre>"},{"location":"colors/#supported-color-space-ids","title":"Supported Color Space IDs","text":"<p>As an easy reference, this table contains all the color space names and their associated IDs that are used to specify a specific color space for conversion or otherwise.</p> Color Space ID A98 RGB <code>a98-rgb</code> ACES 2065-1 <code>aces2065-1</code> ACEScc <code>acescc</code> ACEScct <code>acescct</code> ACEScg <code>acescg</code> CAM02 JMh <code>cam02-jmh</code> CAM02 LCD <code>cam02-lcd</code> CAM02 SCD <code>cam02-scd</code> CAM16 UCS <code>cam02-ucs</code> CAM16 JMh <code>cam16-jmh</code> CAM16 LCD <code>cam16-lcd</code> CAM16 SCD <code>cam16-scd</code> CAM16 UCS <code>cam16-ucs</code> CMY <code>cmy</code> CMYK <code>cmyk</code> Cubehelix <code>cubehelix</code> DIN99o LCh <code>lch99o</code> DIN99o <code>din99o</code> Display P3 <code>display-p3</code> HCT <code>hct</code> Hellwig JMh <code>hellwig-jmh</code> HPLuv <code>hpluv</code> HSI <code>hsi</code> HSL <code>hsl</code> HSLuv <code>hsluv</code> HSV <code>hsv</code> Hunter Lab <code>hunter-lab</code> HWB <code>hwb</code> ICtCp <code>ictcp</code> IgPgTg <code>igpgtg</code> IPT <code>ipt</code> Jzazbz <code>jzazbz</code> JzCzhz <code>jzczhz</code> Lab (D50) <code>lab</code> Lab (D65) <code>lab-d65</code> LCh (D50) <code>lch</code> LCH (D65) <code>lch-d65</code> Linear A98 RGB <code>a98-rgb-linear</code> Linear Display P3 <code>display-p3-linear</code> Linear ProPhoto RGB <code>prophoto-rgb-linear</code> Linear Rec. 2020 <code>rec2020-linear</code> Linear Rec. 2100 <code>rec2100-linear</code> Linear sRGB <code>srgb-linear</code> Luv LCh <code>lchuv</code> Luv <code>luv</code> Okhsl <code>okhsl</code> Okhsv <code>okhsv</code> Oklab <code>oklab</code> OkLCh <code>oklch</code> Oklrab <code>oklrab</code> OkLrCh <code>oklrch</code> oRGB <code>orgb</code> Prismatic <code>prismatic</code> ProPhoto RGB <code>prophoto-rgb</code> Rec. 2020 <code>rec2020</code> Rec. 2100 HLG <code>rec2100-hlg</code> Rec. 2100 PQ <code>rec2100-pq</code> Rec. 709 <code>rec709</code> RLAB <code>rlab</code> RYB <code>ryb</code> sRGB <code>srgb</code> UCS <code>ucs</code> XYB <code>xyb</code> xyY <code>xyy</code> XYZ (D50) <code>xyz-d50</code> XYZ (D65) <code>xyz-d65</code> ZCAM JMh <code>zcam-jmh</code>"},{"location":"colors/a98_rgb/","title":"A98 RGB","text":"<p>The A98 RGB color space is registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>a98-rgb</code></p> <p>White Point: D65 / 2\u02da</p> <p>Coordinates:</p> Name Range<sup>*</sup> <code>r</code> [0, 1] <code>g</code> [0, 1] <code>b</code> [0, 1] <p><sup>*</sup> Range denotes in gamut colors, but the color space supports an extended range beyond the gamut.</p> <p></p> <p>Figure 1. CIE 1931 xy Chromaticity \u2013 Adobe\u00ae RGB 1998 Chromaticities</p> <p>The Adobe\u00ae RGB (1998) color space or opRGB is a color space developed by Adobe Systems\u00ae, Inc. in 1998. It was designed to encompass most of the colors achievable on CMYK color printers, but by using RGB primary colors on a device such as a computer display. The Adobe\u00ae RGB (1998) color space encompasses roughly 50% of the visible colors specified by the CIELab color space - improving upon the gamut of the sRGB color space, primarily in cyan-green hues.</p> <p>A98 RGB is an Adobe\u00ae 98 Compatible color space.</p> <p>Learn about A98 RGB</p>"},{"location":"colors/a98_rgb/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>r</code> <code>red</code> <code>g</code> <code>green</code> <code>b</code> <code>blue</code>"},{"location":"colors/a98_rgb/#inputoutput","title":"Input/Output","text":"<p>Parsed input and string output formats support all valid CSS forms:</p> <pre><code>color(a98-rgb r g b / a)  // Color function\n</code></pre> <p>When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used:</p> <pre><code>Color(\"a98-rgb\", [0, 0, 0], 1)\n</code></pre> <p>The string representation of the color object and the default string output will be in the <code>color(a98-rgb r g b / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color('a98-rgb', [0.85859, 0, 0])\ncolor(a98-rgb 0.85859 0 0 / 1)\n&gt;&gt;&gt; Color('a98-rgb', [0.91489, 0.64117, 0.15031]).to_string()\n'color(a98-rgb 0.91489 0.64117 0.15031)'\n</code></pre> Gamut: srgb"},{"location":"colors/a98_rgb/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.a98_rgb import A98RGB\n\nclass Color(Base): ...\n\nColor.register(A98RGB())\n</code></pre>"},{"location":"colors/a98_rgb_linear/","title":"Linear A98 RGB","text":"<p>The Linear A98 RGB color space is registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>a98-rgb-linear</code></p> <p>White Point: D65 / 2\u02da</p> <p>Coordinates:</p> Name Range<sup>*</sup> <code>r</code> [0, 1] <code>g</code> [0, 1] <code>b</code> [0, 1] <p><sup>*</sup> Range denotes in gamut colors, but the color space supports an extended range beyond the gamut.</p> <p></p> <p>Figure 1. CIE 1931 xy Chromaticity \u2013 Adobe\u00ae RGB 1998 Chromaticities</p> <p>The Linear A98 RGB space is the same as A98 RGB except that the transfer function is linear-light (there is no gamma-encoding).</p> <p>Learn about A98 RGB</p>"},{"location":"colors/a98_rgb_linear/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>r</code> <code>red</code> <code>g</code> <code>green</code> <code>b</code> <code>blue</code>"},{"location":"colors/a98_rgb_linear/#inputoutput","title":"Input/Output","text":"<p>Linear A98 RGB is not supported via the CSS spec and the parser input and string output only supports the <code>color()</code> function format using the custom name <code>--a98-rgb-linear</code>:</p> <pre><code>color(--a98-rgb-linear r g b / a)  // Color function\n</code></pre> <p>When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used:</p> <pre><code>Color(\"a98-rgb-linear\", [0, 0, 0], 1)\n</code></pre> <p>The string representation of the color object and the default string output will be in the <code>color(--a98-rgb-linear r g b / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"a98-rgb\", [0.71513, 0, 0])\ncolor(a98-rgb 0.71513 0 0 / 1)\n&gt;&gt;&gt; Color(\"a98-rgb-linear\", [0.82231, 0.37626, 0.01549]).to_string()\n'color(--a98-rgb-linear 0.82231 0.37626 0.01549)'\n</code></pre> Gamut: srgb"},{"location":"colors/a98_rgb_linear/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.a98_rgb_linear import A98RGBLinear\n\nclass Color(Base): ...\n\nColor.register(A98RGBLinear())\n</code></pre>"},{"location":"colors/aces2065_1/","title":"ACES 2065-1","text":"<p>The ACES 2065-1 color space is not registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>aces2065-1</code></p> <p>White Point: D60 / 2\u02da</p> <p>Coordinates:</p> Name Range <code>r</code> [0, 65504] <code>g</code> [0, 65504] <code>b</code> [0, 65504] <p></p> <p>Figure 1. CIE 1931 xy Chromaticity \u2013 ACES AP0 Chromaticities</p> <p>ACES 2065-1 is a linear color space that uses a set of primaries known as AP0 and has the widest gamut of all the ACES color spaces and fully encompasses the entire visible spectrum. It is meant primarily as an archival format due to its ability to encapsulate all visible colors. Typically, this is the color space you would use to transfer images/animations between production studios.</p> <p>While it is considered an RGB color space, it also has enormous dynamic range with channels being able to well exceed the traditional range of 1.</p> <p>Learn about ACES 2065-1</p>"},{"location":"colors/aces2065_1/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>r</code> <code>red</code> <code>g</code> <code>green</code> <code>b</code> <code>blue</code>"},{"location":"colors/aces2065_1/#inputoutput","title":"Input/Output","text":"<p>ACES 2065-1 is not supported via the CSS spec and the parser input and string output only supports the <code>color()</code> function format using the custom name <code>--aces2065-1</code>:</p> <pre><code>color(--aces2065-1 r g b / a)  // Color function\n</code></pre> <p>When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used:</p> <pre><code>Color(\"aces2065-1\", [0, 0, 0], 1)\n</code></pre> <p>The string representation of the color object and the default string output will be in the <code>color(--aces2065-1 r g b / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"aces2065-1\", [0.43963, 0.08978, 0.01754])\ncolor(--aces2065-1 0.43963 0.08978 0.01754 / 1)\n&gt;&gt;&gt; Color(\"aces2065-1\", [0.58374, 0.39584, 0.05951]).to_string()\n'color(--aces2065-1 0.58374 0.39584 0.05951)'\n</code></pre> Gamut: srgb"},{"location":"colors/aces2065_1/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.aces2065_1 import ACES20651\n\nclass Color(Base): ...\n\nColor.register(ACES20651())\n</code></pre>"},{"location":"colors/acescc/","title":"ACEScc","text":"<p>The ACEScc color space is not registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>acescc</code></p> <p>White Point: D60 / 2\u02da</p> <p>Coordinates:</p> Name Range<sup>*</sup> <code>r</code> [-0.0729,\u00a01.468] <code>g</code> [-0.0729,\u00a01.468] <code>b</code> [-0.0729,\u00a01.468] <p><sup>*</sup> Ranges are approximate and have been rounded.</p> <p>ACEScc is a color space based on the API primaries and is primarily used for color grading. It is a logarithmic color space, unlike ACEScg, and maps black at 0 and white at 1.</p> <p>Learn about ACEScc</p>"},{"location":"colors/acescc/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>r</code> <code>red</code> <code>g</code> <code>green</code> <code>b</code> <code>blue</code>"},{"location":"colors/acescc/#inputoutput","title":"Input/Output","text":"<p>ACEScc is not supported via the CSS spec and the parser input and string output only supports the <code>color()</code> function format using the custom name <code>--acescc</code>:</p> <pre><code>color(--acescc r g b / a)  // Color function\n</code></pre> <p>When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used:</p> <pre><code>Color(\"acescc\", [1, 0, 0], 1)\n</code></pre> <p>The string representation of the color object and the default string output will be in the <code>color(--acescc r g b / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color('acescc', [0.51451, 0.33604, 0.23515])\ncolor(--acescc 0.51451 0.33604 0.23515 / 1)\n&gt;&gt;&gt; Color('acescc', [0.53009, 0.48237, 0.32561]).to_string()\n'color(--acescc 0.53009 0.48237 0.32561)'\n</code></pre> Gamut: srgb"},{"location":"colors/acescc/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.acescc import ACEScc\n\nclass Color(Base): ...\n\nColor.register(ACEScc())\n</code></pre>"},{"location":"colors/acescct/","title":"ACEScct","text":"<p>The ACEScc color space is not registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>acescct</code></p> <p>White Point: D60 / 2\u02da</p> <p>Coordinates:</p> Name Range<sup>*</sup> <code>r</code> [-0.3584,\u00a01.468] <code>g</code> [-0.3584,\u00a01.468] <code>b</code> [-0.3584,\u00a01.468] <p><sup>*</sup> Ranges are approximate and rounded to 3 decimal places.</p> <p>ACEScct is very similar to ACEScc except that it adds a \"toe\" or a gamma curve in the dark region of the color space. This encoding is more appropriate for legacy color correction operators.</p> <p>Learn about ACEScct</p>"},{"location":"colors/acescct/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>r</code> <code>red</code> <code>g</code> <code>green</code> <code>b</code> <code>blue</code>"},{"location":"colors/acescct/#inputsoutput","title":"Inputs/Output","text":"<p>ACEScct is not supported via the CSS spec and the parser input and string output only supports the <code>color()</code> function format using the custom name <code>--acescct</code>:</p> <pre><code>color(--acescct r g b / a)  // Color function\n</code></pre> <p>When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used:</p> <pre><code>Color(\"acescct\", [1, 0, 0], 1)\n</code></pre> <p>The string representation of the color object and the default string output will be in the <code>color(--acescct r g b / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"acescct\", [0.51451, 0.33604, 0.23515])\ncolor(--acescct 0.51451 0.33604 0.23515 / 1)\n&gt;&gt;&gt; Color(\"acescct\", [0.53009, 0.48237, 0.32561]).to_string()\n'color(--acescct 0.53009 0.48237 0.32561)'\n</code></pre> Gamut: srgb"},{"location":"colors/acescct/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.acescct import ACEScct\n\nclass Color(Base): ...\n\nColor.register(ACEScct())\n</code></pre>"},{"location":"colors/acescg/","title":"ACEScg","text":"<p>The ACEScg color space is not registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>acescg</code></p> <p>White Point: D60 / 2\u02da</p> <p>Coordinates:</p> Name Range <code>r</code> [0, 65504] <code>g</code> [0, 65504] <code>b</code> [0, 65504] <p></p> <p>Figure 1. CIE 1931 xy Chromaticity \u2013 ACES AP1 Chromaticities</p> <p>ACEScg is a color space often used by CG artists. It is \"scene-referred\" or linear. It doesn't have as wide a color gamut as ACES 2065-1 as it uses a different set of primaries called AP1, but it is far larger than most other color spaces one might use and has an enormous dynamic range.</p> <p>Learn about ACEScg</p>"},{"location":"colors/acescg/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>r</code> <code>red</code> <code>g</code> <code>green</code> <code>b</code> <code>blue</code>"},{"location":"colors/acescg/#inputoutput","title":"Input/Output","text":"<p>ACEScg is not supported via the CSS spec and the parser input and string output only supports the <code>color()</code> function format using the custom name <code>--acescg</code>:</p> <pre><code>color(--acescg r g b / a)  // Color function\n</code></pre> <p>When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used:</p> <pre><code>Color(\"acescg\", [1, 0, 0], 1)\n</code></pre> <p>The string representation of the color object and the default string output will be in the <code>color(--acescg r g b / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"acescg\", [0.6131, 0.07019, 0.02062])\ncolor(--acescg 0.6131 0.07019 0.02062 / 1)\n&gt;&gt;&gt; Color(\"acescg\", [0.74085, 0.41498, 0.06184]).to_string()\n'color(--acescg 0.74085 0.41498 0.06184)'\n</code></pre> Gamut: srgb"},{"location":"colors/acescg/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.acescg import ACEScg\n\nclass Color(Base): ...\n\nColor.register(ACEScg())\n</code></pre>"},{"location":"colors/cam02/","title":"CAM02 JMh","text":"<p>The CAM16 JMh color space is not registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>cam02-jmh</code></p> <p>White Point: D65 / 2\u02da</p> <p>Coordinates:</p> Name Range<sup>*</sup> <code>j</code> [0, 100] <code>m</code> [0, 120] <code>h</code> [0, 360) <p><sup>*</sup> Space is not bound to the range and is only used as a reference to define percentage inputs/outputs in relation to the Display P3 color space.</p> <p></p> <p>Figure 1. The sRGB gamut represented within the CAM02 JMh color space.</p> <p>A color appearance model (CAM) is a mathematical model that seeks to describe the perceptual aspects of human color vision, i.e. viewing conditions under which the appearance of a color does not tally with the corresponding physical measurement of the stimulus source.</p> <p>CAM02 is a successor of CIECAM97s with various fixes and improvements. The model actually defines numerous different attributes:</p> Name Description J Lightness C Chroma h hue s saturation Q Brightness M Colorfulness H Hue Quadrature <p>A color space can be constructed of using a subset of these attributes: JCh, JMh, Jsh, QCh, QMh, Qsh, etc. You can also construct Lab like spaces taking using the hue and either C, M, or s. The <code>cam02-jmh</code> color space in ColorAide represents the JMh configuration.</p> <p>Learn more.</p>"},{"location":"colors/cam02/#viewing-conditions","title":"Viewing Conditions","text":"<p>CAM02 is a color appearance model and can be configured with different viewing environments. A CAM02 color space will also have an associated environment object. This environment object determines the viewing conditions. Colors will appear different based on the viewing conditions.</p> Viewing\u00a0Conditions Description White This is the white point and should be the same as defined in the color class. This is provided as (x, y) chromaticity coordinates. Adapting\u00a0Luminance The luminance of the adapting field (<code>La</code>). The units are in cd/m2. Background\u00a0Luminance The background luminance (<code>Yb</code>) the relative luminance of the nearby background (out to 10\u00b0), relative to the reference white's luminance (<code>Y</code>). Usually 20 providing a gray world assumption. Surround A description of the peripheral area. Use \"dark\" for a movie theater, \"dim\" for e.g. viewing a bright television in a dimly lit room, or \"average\" for surface colors. Discounting Discounts the illuminant. If true, the eye is assumed to be fully adapted to the illuminant. Otherwise, the degree of discounting is based on other parameters. When the eye is not fully adapted, it can affect the way colors appear and the chromatic response. <p>ColorAide must provide some defaults, so CAM02 comes with a default set of viewing conditions that uses a D65 white point, an adapting luminance of 64 lux or a value of ~4 cd/m<sup>2</sup>, it uses the \"gray world\" assumption and sets the background to 20, an \"average\" surround and leaves discounting set to <code>False</code>. Variants such as CAM02 UCS, CAM02 SCD, and CAM02 LCD assume these same defaults.</p> <p>The default settings do not have to be used and a new CAM16 variant with different viewing conditions can be created. When doing this, the space should be derived from the default. A UCS variant would be derived from their defaults, etc.</p> <pre><code>&gt;&gt;&gt; from coloraide import Color as Base\n&gt;&gt;&gt; from coloraide.spaces.cam02 import CAM02JMh, Environment\n&gt;&gt;&gt; from coloraide.cat import WHITES\n&gt;&gt;&gt; from coloraide import util\n&gt;&gt;&gt; import math\n&gt;&gt;&gt; class CustomCAM02JMh(CAM02JMh):\n...     NAME = \"cam02-custom\"\n...     SERIALIZE = (\"--cam02-custom\",)\n...     WHITE = WHITES['2deg']['D65']\n...     ENV = Environment(\n...         white=WHITE,\n...         adapting_luminance=1000 / math.pi,\n...         background_luminance=20,\n...         surround='average',\n...         discounting=False\n...     )\n... \n&gt;&gt;&gt; class Color(Base): ...\n... \n&gt;&gt;&gt; Color.register([CAM02JMh(), CustomCAM02JMh()])\n&gt;&gt;&gt; Color('white').convert('cam02-jmh')\ncolor(--cam02-jmh 100 2.2891 210.74 / 1)\n&gt;&gt;&gt; Color('white').convert('cam02-custom')\ncolor(--cam02-custom 100 0.14578 211.94 / 1)\n</code></pre> Gamut: srgb <p>Note</p> <p>It can be noted in the above example that white does not have the typical zero chroma. This is because the eye is not assumed as being fully adapted to the environment. Due to the environment, the colors considered achromatic may appear differently.</p> <p>If <code>discounting</code> was enabled, the eye is then assumed to be fully adapted, and achromatic colors would align better with expectations in other color spaces.</p>"},{"location":"colors/cam02/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>j</code> <code>lightness</code> <code>m</code> <code>colorfulness</code> <code>h</code> <code>hue</code>"},{"location":"colors/cam02/#inputoutput","title":"Input/Output","text":"<p>The CAM16 JMh space is not currently supported in the CSS spec, the parsed input and string output formats use the <code>color()</code> function format using the custom name <code>--cam02-jmh</code>:</p> <pre><code>color(--cam02-jmh j m h / a)  // Color function\n</code></pre> <p>The string representation of the color object and the default string output use the <code>color(--cam02-jmh j m h / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"cam02-jmh\", [46.931, 80.436, 32.157], 1)\ncolor(--cam02-jmh 46.931 80.436 32.157 / 1)\n&gt;&gt;&gt; Color(\"cam02-jmh\", [68.929, 48.62, 72.359], 1).to_string()\n'color(--cam02-jmh 68.929 48.62 72.359)'\n</code></pre> Gamut: srgb"},{"location":"colors/cam02/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.cam02 import CAM02JMh\n\nclass Color(Base): ...\n\nColor.register(CAM02JMh())\n</code></pre>"},{"location":"colors/cam02_lcd/","title":"CAM02 LCD","text":"<p>The CAM02 LCD color space is not registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>cam02-lcd</code></p> <p>White Point: D65 / 2\u02da</p> <p>Coordinates:</p> Name Range<sup>*</sup> <code>j</code> [0, 100] <code>a</code> [-75, 75] <code>b</code> [-75, 75] <p><sup>*</sup> Space is not bound to the range and is only used as a reference to define percentage inputs/outputs in relation to the Display P3 color space.</p> <p></p> <p>Figure 1. The sRGB gamut represented within the CAM02 LCD color space.</p> <p>This is the LCD variant of the CAM02 UCS color space and is optimized for \"large\" color distancing. See CAM02 UCS for more info.</p> <p>Learn more.</p>"},{"location":"colors/cam02_lcd/#viewing-conditions","title":"Viewing Conditions","text":"<p>CAM02 LCD uses the same environment setup for viewing conditions as CAM02 JMh, so check out the related documentation if creating a CAM02 LCD variant is desired.</p>"},{"location":"colors/cam02_lcd/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>j</code> <code>lightness</code> <code>a</code> <code>b</code>"},{"location":"colors/cam02_lcd/#inputoutput","title":"Input/Output","text":"<p>The CAM02 LCD space is not currently supported in the CSS spec, the parsed input and string output formats use the <code>color()</code> function format using the custom name <code>--cam02-lcd</code>:</p> <pre><code>color(--cam02-lcd j a b / a)  // Color function\n</code></pre> <p>The string representation of the color object and the default string output use the <code>color(--cam02-lcd j a b / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"cam02-lcd\", [60.054, 56.72, 35.659], 1)\ncolor(--cam02-lcd 60.054 56.72 35.659 / 1)\n&gt;&gt;&gt; Color(\"cam02-lcd\", [79.041, 13.11, 41.225], 1).to_string()\n'color(--cam02-lcd 79.041 13.11 41.225)'\n</code></pre> Gamut: srgb"},{"location":"colors/cam02_lcd/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.cam02_ucs import CAM02LCD\n\nclass Color(Base): ...\n\nColor.register(CAM02LCD())\n</code></pre>"},{"location":"colors/cam02_scd/","title":"CAM02 SCD","text":"<p>The CAM02 SCD color space is not registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>cam02-scd</code></p> <p>White Point: D65 / 2\u02da</p> <p>Coordinates:</p> Name Range<sup>*</sup> <code>j</code> [0, 100] <code>a</code> [-40, 40] <code>b</code> [-40, 40] <p><sup>*</sup> Space is not bound to the range and is only used as a reference to define percentage inputs/outputs in relation to the Display P3 color space.</p> <p></p> <p>Figure 1. The sRGB gamut represented within the CAM02 SCD color space.</p> <p>This is the SCD variant of the CAM02 UCS color space and is optimized for \"small\" color distancing. See CAM02 UCS for more info.</p> <p>Learn more.</p>"},{"location":"colors/cam02_scd/#viewing-conditions","title":"Viewing Conditions","text":"<p>CAM02 SCD uses the same environment setup for viewing conditions as CAM02 JMh, so check out the related documentation if creating a CAM02 SCD variant is desired.</p>"},{"location":"colors/cam02_scd/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>j</code> <code>lightness</code> <code>a</code> <code>b</code>"},{"location":"colors/cam02_scd/#inputoutput","title":"Input/Output","text":"<p>The CAM02 SCD space is not currently supported in the CSS spec, the parsed input and string output formats use the <code>color()</code> function format using the custom name <code>--cam02-scd</code>:</p> <pre><code>color(--cam02-scd j a b / a)  // Color function\n</code></pre> <p>The string representation of the color object and the default string output use the <code>color(--cam02-scd j a b / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"cam02-scd\", [60.054, 31.859, 20.029], 1)\ncolor(--cam02-scd 60.054 31.859 20.029 / 1)\n&gt;&gt;&gt; Color(\"cam02-scd\", [79.041, 8.4908, 26.699], 1).to_string()\n'color(--cam02-scd 79.041 8.4908 26.699)'\n</code></pre> Gamut: srgb"},{"location":"colors/cam02_scd/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.cam02_ucs import CAM02SCD\n\nclass Color(Base): ...\n\nColor.register(CAM02SCD())\n</code></pre>"},{"location":"colors/cam02_ucs/","title":"CAM02 UCS","text":"<p>The CAM02 UCS color space is not registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>cam02-ucs</code></p> <p>White Point: D65 / 2\u02da</p> <p>Coordinates:</p> Name Range<sup>*</sup> <code>j</code> [0, 100] <code>a</code> [-50, 50] <code>b</code> [-50, 50] <p><sup>*</sup> Space is not bound to the range and is only used as a reference to define percentage inputs/outputs in relation to the Display P3 color space.</p> <p></p> <p>Figure 1. The sRGB gamut represented within the CAM02 UCS color space.</p> <p>The CAM02 UCS space takes the CAM02 model and applies an additional nonlinear transformation to lightness and colorfulness so that a color difference metric \u0394E can be based more closely on Euclidean distance. The <code>cam02-ucd</code> color space in ColorAide is based off CAM02 (Jab) which uses M (colorfulness) to derive the a and b values. There are also SCD and LCD variants which optimize the spaces for \"small\" and \"large\" color distancing respectively.</p> <p>Learn more.</p>"},{"location":"colors/cam02_ucs/#viewing-conditions","title":"Viewing Conditions","text":"<p>CAM02 UCS uses the same environment setup for viewing conditions as CAM02 JMh, so check out the related documentation if creating a CAM02 UCS variant is desired.</p>"},{"location":"colors/cam02_ucs/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>j</code> <code>lightness</code> <code>a</code> <code>b</code>"},{"location":"colors/cam02_ucs/#inputoutput","title":"Input/Output","text":"<p>The CAM02 UCS space is not currently supported in the CSS spec, the parsed input and string output formats use the <code>color()</code> function format using the custom name <code>--cam02-ucs</code>:</p> <pre><code>color(--cam02-ucs j a b / a)  // Color function\n</code></pre> <p>The string representation of the color object and the default string output use the <code>color(--cam02-ucs j a b / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"cam02-ucs\", [60.054, 38.679, 24.316], 1)\ncolor(--cam02-ucs 60.054 38.679 24.316 / 1)\n&gt;&gt;&gt; Color(\"cam02-ucs\", [79.041, 9.9159, 31.18], 1).to_string()\n'color(--cam02-ucs 79.041 9.9159 31.18)'\n</code></pre> Gamut: srgb"},{"location":"colors/cam02_ucs/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.cam02_ucs import CAM02UCS\n\nclass Color(Base): ...\n\nColor.register(CAM02UCS())\n</code></pre>"},{"location":"colors/cam16/","title":"CAM16 JMh","text":"<p>The CAM16 JMh color space is not registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>cam16-jmh</code></p> <p>White Point: D65 / 2\u02da</p> <p>Coordinates:</p> Name Range<sup>*</sup> <code>j</code> [0, 100] <code>m</code> [0, 105] <code>h</code> [0, 360) <p><sup>*</sup> Space is not bound to the range and is only used as a reference to define percentage inputs/outputs in relation to the Display P3 color space.</p> <p></p> <p>Figure 1. The sRGB gamut represented within the CAM16 JMh color space.</p> <p>A color appearance model (CAM) is a mathematical model that seeks to describe the perceptual aspects of human color vision, i.e. viewing conditions under which the appearance of a color does not tally with the corresponding physical measurement of the stimulus source.</p> <p>CAM16 is a successor of CIECAM02 with various fixes and improvements. The model actually defines numerous different attributes:</p> Name Description J Lightness C Chroma h hue s saturation Q Brightness M Colorfulness H Hue Quadrature <p>A color space can be constructed of using a subset of these attributes: JCh, JMh, Jsh, QCh, QMh, Qsh, etc. You can also construct Lab like spaces taking using the hue and either C, M, or s. The <code>cam16-jmh</code> color space in ColorAide represents the JMh configuration.</p> <p>Learn more.</p>"},{"location":"colors/cam16/#viewing-conditions","title":"Viewing Conditions","text":"<p>CAM16 is a color appearance model and can be configured with different viewing environments. A CAM16 color space will also have an associated environment object. This environment object determines the viewing conditions. Colors will appear different based on the viewing conditions.</p> Viewing\u00a0Conditions Description White This is the white point and should be the same as defined in the color class. This is provided as (x, y) chromaticity coordinates. Adapting\u00a0Luminance The luminance of the adapting field (<code>La</code>). The units are in cd/m2. Background\u00a0Luminance The background luminance (<code>Yb</code>) the relative luminance of the nearby background (out to 10\u00b0), relative to the reference white's luminance (<code>Y</code>). Usually 20 providing a gray world assumption. Surround A description of the peripheral area. Use \"dark\" for a movie theater, \"dim\" for e.g. viewing a bright television in a dimly lit room, or \"average\" for surface colors. Discounting Discounts the illuminant. If true, the eye is assumed to be fully adapted to the illuminant. Otherwise, the degree of discounting is based on other parameters. When the eye is not fully adapted, it can affect the way colors appear and the chromatic response. <p>ColorAide must provide some defaults, so CAM16 comes with a default set of viewing conditions that uses a D65 white point, an adapting luminance of 64 lux or a value of ~4 cd/m<sup>2</sup>, it uses the \"gray world\" assumption and sets the background to 20, an \"average\" surround and leaves discounting set to <code>False</code>. Variants such as CAM16 UCS, CAM16 SCD, and CAM16 LCD assume these same defaults.</p> <p>The default settings do not have to be used and a new CAM16 variant with different viewing conditions can be created. When doing this, the space should be derived from the default. A UCS variant would be derived from their defaults, etc.</p> <pre><code>&gt;&gt;&gt; from coloraide import Color as Base\n&gt;&gt;&gt; from coloraide.spaces.cam16 import CAM16JMh, Environment\n&gt;&gt;&gt; from coloraide.cat import WHITES\n&gt;&gt;&gt; from coloraide import util\n&gt;&gt;&gt; import math\n&gt;&gt;&gt; class CustomCAM16JMh(CAM16JMh):\n...     NAME = \"cam16-custom\"\n...     SERIALIZE = (\"--cam16-custom\",)\n...     WHITE = WHITES['2deg']['D65']\n...     ENV = Environment(\n...         white=WHITE,\n...         adapting_luminance=1000 / math.pi,\n...         background_luminance=20,\n...         surround='average',\n...         discounting=False\n...     )\n... \n&gt;&gt;&gt; class Color(Base): ...\n... \n&gt;&gt;&gt; Color.register([CAM16JMh(), CustomCAM16JMh()])\n&gt;&gt;&gt; Color('white').convert('cam16-jmh')\ncolor(--cam16-jmh 100 2.2369 209.53 / 1)\n&gt;&gt;&gt; Color('white').convert('cam16-custom')\ncolor(--cam16-custom 100 0.14734 209.66 / 1)\n</code></pre> Gamut: srgb <p>Note</p> <p>It can be noted in the above example that white does not have the typical zero chroma. This is because the eye is not assumed as being fully adapted to the environment. Due to the environment, the colors considered achromatic may appear differently.</p> <p>If <code>discounting</code> was enabled, the eye is then assumed to be fully adapted, and achromatic colors would align better with expectations in other color spaces.</p>"},{"location":"colors/cam16/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>j</code> <code>lightness</code> <code>m</code> <code>colorfulness</code> <code>h</code> <code>hue</code>"},{"location":"colors/cam16/#inputoutput","title":"Input/Output","text":"<p>The CAM16 JMh space is not currently supported in the CSS spec, the parsed input and string output formats use the <code>color()</code> function format using the custom name <code>--cam16-jmh</code>:</p> <pre><code>color(--cam16-jmh j m h / a)  // Color function\n</code></pre> <p>The string representation of the color object and the default string output use the <code>color(--cam16-jmh j m h / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"cam16-jmh\", [59.178, 40.82, 21.153], 1)\ncolor(--cam16-jmh 59.178 40.82 21.153 / 1)\n&gt;&gt;&gt; Color(\"cam16-jmh\", [78.364, 9.6945, 28.629], 1).to_string()\n'color(--cam16-jmh 78.364 9.6945 28.629)'\n</code></pre> Gamut: srgb"},{"location":"colors/cam16/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.cam16 import CAM16JMh\n\nclass Color(Base): ...\n\nColor.register(CAM16JMh())\n</code></pre>"},{"location":"colors/cam16_lcd/","title":"CAM16 LCD","text":"<p>The CAM16 LCD color space is not registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>cam16-lcd</code></p> <p>White Point: D65 / 2\u02da</p> <p>Coordinates:</p> Name Range<sup>*</sup> <code>j</code> [0, 100] <code>a</code> [-75, 75] <code>b</code> [-75, 75] <p><sup>*</sup> Space is not bound to the range and is only used as a reference to define percentage inputs/outputs in relation to the Display P3 color space.</p> <p></p> <p>Figure 1. The sRGB gamut represented within the CAM16 LCD color space.</p> <p>This is the LCD variant of the CAM16 UCS color space and is optimized for \"large\" color distancing. See CAM16 UCS for more info.</p> <p>Learn more.</p>"},{"location":"colors/cam16_lcd/#viewing-conditions","title":"Viewing Conditions","text":"<p>CAM16 LCD uses the same environment setup for viewing conditions as CAM16 JMh, so check out the related documentation if creating a CAM16 LCD variant is desired.</p>"},{"location":"colors/cam16_lcd/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>j</code> <code>lightness</code> <code>a</code> <code>b</code>"},{"location":"colors/cam16_lcd/#inputoutput","title":"Input/Output","text":"<p>The CAM16 LCD space is not currently supported in the CSS spec, the parsed input and string output formats use the <code>color()</code> function format using the custom name <code>--cam16-lcd</code>:</p> <pre><code>color(--cam16-lcd j a b / a)  // Color function\n</code></pre> <p>The string representation of the color object and the default string output use the <code>color(--cam16-lcd j a b / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"cam16-lcd\", [46.026, 81.254, 27.393], 1)\ncolor(--cam16-lcd 46.026 81.254 27.393 / 1)\n&gt;&gt;&gt; Color(\"cam16-lcd\", [68.056, 43.51, 71.293], 1).to_string()\n'color(--cam16-lcd 68.056 43.51 71.293)'\n</code></pre> Gamut: srgb"},{"location":"colors/cam16_lcd/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.cam16_ucs import CAM16LCD\n\nclass Color(Base): ...\n\nColor.register(CAM16LCD())\n</code></pre>"},{"location":"colors/cam16_scd/","title":"CAM16 SCD","text":"<p>The CAM16 SCD color space is not registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>cam16-scd</code></p> <p>White Point: D65 / 2\u02da</p> <p>Coordinates:</p> Name Range<sup>*</sup> <code>j</code> [0, 100] <code>a</code> [-40, 40] <code>b</code> [-40, 40] <p><sup>*</sup> Space is not bound to the range and is only used as a reference to define percentage inputs/outputs in relation to the Display P3 color space.</p> <p></p> <p>Figure 1. The sRGB gamut represented within the CAM16 SCD color space.</p> <p>This is the SCD variant of the CAM16 UCS color space and is optimized for \"small\" color distancing. See CAM16 UCS for more info.</p> <p>Learn more.</p>"},{"location":"colors/cam16_scd/#viewing-conditions","title":"Viewing Conditions","text":"<p>CAM16 SCD uses the same environment setup for viewing conditions as CAM16 JMh, so check out the related documentation if creating a CAM16 SCD variant is desired.</p>"},{"location":"colors/cam16_scd/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>j</code> <code>lightness</code> <code>a</code> <code>b</code>"},{"location":"colors/cam16_scd/#inputoutput","title":"Input/Output","text":"<p>The CAM16 SCD space is not currently supported in the CSS spec, the parsed input and string output formats use the <code>color()</code> function format using the custom name <code>--cam16-scd</code>:</p> <pre><code>color(--cam16-scd j a b / a)  // Color function\n</code></pre> <p>The string representation of the color object and the default string output use the <code>color(--cam16-scd j a b / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"cam16-scd\", [59.178, 33.597, 17.41], 1)\ncolor(--cam16-scd 59.178 33.597 17.41 / 1)\n&gt;&gt;&gt; Color(\"cam16-scd\", [78.364, 8.3723, 24.725], 1).to_string()\n'color(--cam16-scd 78.364 8.3723 24.725)'\n</code></pre> Gamut: srgb"},{"location":"colors/cam16_scd/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.cam16_ucs import CAM16SCD\n\nclass Color(Base): ...\n\nColor.register(CAM16SCD())\n</code></pre>"},{"location":"colors/cam16_ucs/","title":"CAM16 UCS","text":"<p>The CAM16 UCS color space is not registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>cam16-ucs</code></p> <p>White Point: D65 / 2\u02da</p> <p>Coordinates:</p> Name Range<sup>*</sup> <code>j</code> [0, 100] <code>a</code> [-50, 50] <code>b</code> [-50, 50] <p><sup>*</sup> Space is not bound to the range and is only used as a reference to define percentage inputs/outputs in relation to the Display P3 color space.</p> <p></p> <p>Figure 1. The sRGB gamut represented within the CAM16 UCS color space.</p> <p>The CAM16 UCS space takes the CAM16 model and applies an additional nonlinear transformation to lightness and colorfulness so that a color difference metric \u0394E can be based more closely on Euclidean distance. The <code>cam16-ucd</code> color space in ColorAide is based off CAM16 (Jab) which uses M (colorfulness) to derive the a and b values. There are also SCD and LCD variants which optimize the spaces for \"small\" and \"large\" color distancing respectively.</p> <p>Learn more.</p>"},{"location":"colors/cam16_ucs/#viewing-conditions","title":"Viewing Conditions","text":"<p>CAM16 UCS uses the same environment setup for viewing conditions as CAM16 JMh, so check out the related documentation if creating a CAM16 UCS variant is desired.</p>"},{"location":"colors/cam16_ucs/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>j</code> <code>lightness</code> <code>a</code> <code>b</code>"},{"location":"colors/cam16_ucs/#inputoutput","title":"Input/Output","text":"<p>The CAM16 UCS space is not currently supported in the CSS spec, the parsed input and string output formats use the <code>color()</code> function format using the custom name <code>--cam16-ucs</code>:</p> <pre><code>color(--cam16-ucs j a b / a)  // Color function\n</code></pre> <p>The string representation of the color object and the default string output use the <code>color(--cam16-ucs j a b / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"cam16-ucs\", [59.178, 40.82, 21.153], 1)\ncolor(--cam16-ucs 59.178 40.82 21.153 / 1)\n&gt;&gt;&gt; Color(\"cam16-ucs\", [78.364, 9.6945, 28.629], 1).to_string()\n'color(--cam16-ucs 78.364 9.6945 28.629)'\n</code></pre> Gamut: srgb"},{"location":"colors/cam16_ucs/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.cam16_ucs import CAM16UCS\n\nclass Color(Base): ...\n\nColor.register(CAM16UCS())\n</code></pre>"},{"location":"colors/cmy/","title":"CMY","text":"<p>The CMY color space is not registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>cmy</code></p> <p>White Point: D65 / 2\u02da</p> <p>Coordinates:</p> Name Range<sup>*</sup> <code>c</code> [0, 1] <code>m</code> [0, 1] <code>y</code> [0, 1] <p><sup>*</sup> Range denotes in gamut colors, but the color space supports an extended range beyond the gamut.</p> <p></p> <p>Figure 1. The sRGB gamut represented within the CMY color space.</p> <p>The CMY color model is a subtractive color model in which cyan, magenta and yellow pigments or dyes are added together in various ways to reproduce a broad array of colors. The name of the model comes from the initials of the three subtractive primary colors: cyan, magenta, and yellow.</p> <p>The CMY color space, as ColorAide Extras has chosen to implement it, is directly calculated from the sRGB color space, and as such, is based off the sRGB primaries.</p> <p>Learn more.</p>"},{"location":"colors/cmy/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>c</code> <code>cyan</code> <code>m</code> <code>magenta</code> <code>y</code> <code>yellow</code>"},{"location":"colors/cmy/#inputoutput","title":"Input/Output","text":"<p>CMY is not currently supported in the CSS spec, the parsed input and string output formats use the <code>color()</code> function format using the custom name <code>--cmy</code>:</p> <pre><code>color(--cmy c m y / a)  // Color function\n</code></pre> <p>The string representation of the color object and the default string output use the <code>color(--cmy c m y / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"cmy\", [0, 1, 1])\ncolor(--cmy 0 1 1 / 1)\n&gt;&gt;&gt; Color(\"cmy\", [0, 0.35294, 1]).to_string()\n'color(--cmy 0 0.35294 1)'\n</code></pre> Gamut: srgb"},{"location":"colors/cmy/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.cmy import CMY\n\nclass Color(Base): ...\n\nColor.register(CMY())\n</code></pre>"},{"location":"colors/cmyk/","title":"CMYK","text":"<p>The CMYK color space is not registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>cmyk</code></p> <p>White Point: D65 / 2\u02da</p> <p>Coordinates:</p> Name Range<sup>*</sup> <code>c</code> [0, 1] <code>m</code> [0, 1] <code>y</code> [0, 1] <code>k</code> [0, 1] <p><sup>*</sup> Range denotes in gamut colors, but the color space supports an extended range beyond the gamut.</p> <p>The CMYK color model is a just like CMY except that it adds an additional channel <code>k</code> to control blackness.</p> <p>The CMYK color space, as ColorAide Extras has chosen to implement it, is directly calculated from the sRGB color space, and as such, is based off the sRGB primaries.</p> <p>Learn more.</p>"},{"location":"colors/cmyk/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>c</code> <code>cyan</code> <code>m</code> <code>magenta</code> <code>y</code> <code>yellow</code> <code>k</code> <code>black</code>"},{"location":"colors/cmyk/#inputoutput","title":"Input/Output","text":"<p>CMY is not currently supported in the CSS spec, the parsed input and string output formats use the <code>color()</code> function format using the custom name <code>--cmyk</code>:</p> <pre><code>color(--cmyk c m y k / a)  // Color function\n</code></pre> <p>The string representation of the color object and the default string output use the <code>color(--cmyk c m y k / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"cmyk\", [0, 1, 1, 0])\ncolor(--cmyk 0 1 1 0 / 1)\n&gt;&gt;&gt; Color(\"cmyk\", [0, 0.35294, 1, 0]).to_string()\n'color(--cmyk 0 0.35294 1 0)'\n</code></pre> Gamut: srgb"},{"location":"colors/cmyk/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.cmyk import CMYK\n\nclass Color(Base): ...\n\nColor.register(CMYK())\n</code></pre>"},{"location":"colors/cubehelix/","title":"Cubehelix","text":"<p>The Cubehelix color space is not registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>cubehelix</code></p> <p>White Point: D65 / 2\u02da</p> <p>Coordinates:</p> Name Range<sup>*</sup> <code>h</code> [0, 360) <code>s</code> [0, 4.614] <code>l</code> [0, 1] <p><sup>*</sup> The maximum saturation represents how high saturation can go, not that all colors with that saturation will be valid. As seen in the 3D rendering, while the coordinates are cylindrical, the shape of the space is not a cylinder.</p> <p></p> <p>Figure 1. The sRGB gamut represented within the Cubehelix color space.</p> <p>Cubehelix is a color scheme created by Dave Green. It was originally created for the display of astronomical intensity images. It is not really one color scheme, but a method to generate various \"cubehelix\" color schemes. The name comes from the way the colors spiral through the sRGB color space.</p> <p>Mike Bostock of Observable and D3 fame along with Jason Davies took the color scheme and created a cylindrical color space with it. This is the color space that is implemented in ColorAide.</p> <p>Cubehelix color schemes can be easily generated by interpolating in the color space.</p> <pre><code>&gt;&gt;&gt; c1 = Color('cubehelix', [0, 1, 0])\n&gt;&gt;&gt; c2 = Color('cubehelix', [360, 1, 1])\n&gt;&gt;&gt; Color.discrete([c1, c2], steps=16, space='cubehelix', hue='longer')\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x7f465473b6b0&gt;\n&gt;&gt;&gt; Color.interpolate([c1, c2], space='cubehelix', hue='longer')\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x7f465473b7a0&gt;\n</code></pre> Gamut: srgb <p>You can change the scheme by changing the start and end angle.</p> <pre><code>&gt;&gt;&gt; c1 = Color('cubehelix', [0 + 180, 1, 0])\n&gt;&gt;&gt; c2 = Color('cubehelix', [360 + 180, 1, 1])\n&gt;&gt;&gt; Color.discrete([c1, c2], steps=16, space='cubehelix', hue='longer')\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x7f465473b5c0&gt;\n&gt;&gt;&gt; Color.interpolate([c1, c2], space='cubehelix', hue='longer')\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x7f465473ab70&gt;\n</code></pre> Gamut: srgb <p>You can increase the rotations by setting hue interpolation to <code>specified</code> and extending the angle difference to a distance greater than 360.</p> <pre><code>&gt;&gt;&gt; c1 = Color('cubehelix', [0, 1, 0])\n&gt;&gt;&gt; c2 = Color('cubehelix', [360 * 3, 1, 1])\n&gt;&gt;&gt; Color.discrete([c1, c2], steps=16, space='cubehelix', hue='specified')\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x7f465473b6b0&gt;\n&gt;&gt;&gt; Color.interpolate([c1, c2], space='cubehelix', hue='specified')\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x7f465473b7a0&gt;\n</code></pre> Gamut: srgb <p>You can even reverse the rotation by utilizing a negative difference in hue.</p> <pre><code>&gt;&gt;&gt; c1 = Color('cubehelix', [0, 1, 0])\n&gt;&gt;&gt; c2 = Color('cubehelix', [-360, 1, 1])\n&gt;&gt;&gt; Color.discrete([c1, c2], steps=16, space='cubehelix', hue='specified')\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x7f465473b5c0&gt;\n&gt;&gt;&gt; Color.interpolate([c1, c2], steps=16, space='cubehelix', hue='specified')\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x7f465473b7a0&gt;\n</code></pre> Gamut: srgb <p>To adjust gamma, simply apply a gamma easing to lightness.</p> <pre><code>&gt;&gt;&gt; def ease_gamma(y=1.0):\n...     \"\"\"Ease gamma.\"\"\"\n... \n...     return lambda t: t ** y\n... \n&gt;&gt;&gt; gamma = ease_gamma(0.2)\n&gt;&gt;&gt; c1 = Color('cubehelix', [0, 1, 0])\n&gt;&gt;&gt; c2 = Color('cubehelix', [-360, 1, 1])\n&gt;&gt;&gt; Color.discrete(\n...     [c1, c2],\n...     steps=16,\n...     space='cubehelix',\n...     hue='specified',\n...     progress={'l': gamma}\n... )\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x7f465473b6b0&gt;\n&gt;&gt;&gt; Color.interpolate(\n...     [c1, c2],\n...     space='cubehelix',\n...     hue='specified',\n...     progress={'l': gamma}\n... )\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x7f465473b7a0&gt;\n</code></pre> Gamut: srgb <p>Viewing the interpolation in 3D, we can see the spiraling of colors that gave the color scheme the name Cubehelix.</p> <p></p> <p>Learn more.</p>"},{"location":"colors/cubehelix/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>h</code> <code>hue</code> <code>s</code> <code>saturation</code> <code>l</code> <code>lightness</code>"},{"location":"colors/cubehelix/#inputoutput","title":"Input/Output","text":"<p>The Cubehelix space is not currently supported in the CSS spec, the parsed input and string output formats use the <code>color()</code> function format using the custom name <code>--cubehelix</code>:</p> <pre><code>color(--cubehelix h s l / a)  // Color function\n</code></pre> <p>The string representation of the color object and the default string output use the <code>color(--cubehelix h s l / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"cubehelix\", [351.81, 1.9489, 0.3])\ncolor(--cubehelix 351.81 1.9489 0.3 / 1)\n&gt;&gt;&gt; Color(\"cubehelix\", [36.577, 1.7357, 0.68176]).to_string()\n'color(--cubehelix 36.577 1.7357 0.68176)'\n</code></pre> Gamut: srgb"},{"location":"colors/cubehelix/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.cubehelix import Cubehelix\n\nclass Color(Base): ...\n\nColor.register(Cubehelix())\n</code></pre>"},{"location":"colors/din99o/","title":"DIN99o","text":"<p>The DIN99o color space is not registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>din99o</code></p> <p>White Point: D65 / 2\u02da</p> <p>Coordinates:</p> Name Range<sup>*</sup> <code>l</code> [0, 100] <code>a</code> [-55, 55] <code>b</code> [-55, 55] <p><sup>*</sup> Space is not bound to the range and is only used as a reference to define percentage inputs/outputs in relation to the Display P3 color space.</p> <p></p> <p>Figure 1. The sRGB gamut represented within the DIN99o color space.</p> <p>The DIN99 color space system is a further development of the CIELab color space system developed by the FNF / FNL 2 Colorimetry Working Committee. It takes the CIELab space (with a D65 illuminant) and compresses it such that the space yields better equidistant using Euclidean distance. The whole color space is essentially modified to better fit the color distancing algorithm opposed to CIELab which has adapted the color distancing algorithm to better fit the color space, the latest iteration being \u2206E<sup>*</sup><sub>00</sub>.</p> <p>Learn about DIN99o</p>"},{"location":"colors/din99o/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>l</code> <code>lightness</code> <code>a</code> <code>b</code>"},{"location":"colors/din99o/#inputoutput","title":"Input/Output","text":"<p>As DIN99o is not currently supported in the CSS spec, the parsed input and string output formats use the <code>color()</code> function format using the custom name <code>--din99o</code>:</p> <pre><code>color(--din99o l u v / a)  // Color function\n</code></pre> <p>When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used:</p> <pre><code>Color(\"din99o\", [0, 0, 0], 1)\n</code></pre> <p>The string representation of the color object and the default string output use the <code>color(--din99o l u v / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"din99o\", [57.289, 39.498, 30.518])\ncolor(--din99o 57.289 39.498 30.518 / 1)\n&gt;&gt;&gt; Color(\"din99o\", [77.855, 16.444, 40.318]).to_string()\n'color(--din99o 77.855 16.444 40.318)'\n</code></pre> Gamut: srgb"},{"location":"colors/din99o/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.din99o import DIN99o\n\nclass Color(Base): ...\n\nColor.register(DIN99o())\n</code></pre>"},{"location":"colors/display_p3/","title":"Display P3","text":"<p>The Display P3 color space is registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>display-p3</code></p> <p>White Point: D65 / 2\u02da</p> <p>Coordinates:</p> Name Range<sup>*</sup> <code>r</code> [0, 1] <code>g</code> [0, 1] <code>b</code> [0, 1] <p><sup>*</sup> Range denotes in gamut colors, but the color space supports an extended range beyond the gamut.</p> <p></p> <p>Figure 1. CIE 1931 xy Chromaticity \u2013 Display P3 Chromaticities</p> <p>Display P3 is a combination of the DCI-P3 color gamut with the D65 white point together with the sRGB gamma curve. It originated from the DCI-P3 color gamut's implementation in digital cinema projectors, as this standard offers more vibrant greens and reds than the traditional sRGB color gamut.</p> <p>Learn about Display P3</p>"},{"location":"colors/display_p3/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>r</code> <code>red</code> <code>g</code> <code>green</code> <code>b</code> <code>blue</code>"},{"location":"colors/display_p3/#inputoutput","title":"Input/Output","text":"<p>Parsed input and string output formats support all valid CSS forms:</p> <pre><code>color(display-p3 r g b / a)  // Color function\n</code></pre> <p>When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used:</p> <pre><code>Color(\"display-p3\", [0, 0, 0], 1)\n</code></pre> <p>The string representation of the color object and the default string output will be in the <code>color(display-p3 r g b / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color('display-p3', [0.91749, 0.20029, 0.13856])\ncolor(display-p3 0.91749 0.20029 0.13856 / 1)\n&gt;&gt;&gt; Color('display-p3', [0.94965, 0.6629, 0.23297]).to_string()\n'color(display-p3 0.94965 0.6629 0.23297)'\n</code></pre> Gamut: srgb"},{"location":"colors/display_p3/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.display_p3 import DisplayP3\n\nclass Color(Base): ...\n\nColor.register(DisplayP3())\n</code></pre>"},{"location":"colors/display_p3_linear/","title":"Linear Display P3","text":"<p>The Linear Display P3 color space is registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>display-p3-linear</code></p> <p>White Point: D65 / 2\u02da</p> <p>Coordinates:</p> Name Range<sup>*</sup> <code>r</code> [0, 1] <code>g</code> [0, 1] <code>b</code> [0, 1] <p><sup>*</sup> Range denotes in gamut colors, but the color space supports an extended range beyond the gamut.</p> <p></p> <p>Figure 1. CIE 1931 xy Chromaticity \u2013 Display P3 Chromaticities</p> <p>The Linear Display P3 space is the same as Display P3 except that the transfer function is linear-light (there is no gamma-encoding).</p> <p>Learn about Display P3</p>"},{"location":"colors/display_p3_linear/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>r</code> <code>red</code> <code>g</code> <code>green</code> <code>b</code> <code>blue</code>"},{"location":"colors/display_p3_linear/#inputoutput","title":"Input/Output","text":"<p>Linear Display P3 is not supported via the CSS spec and the parser input and string output only supports the <code>color()</code> function format using the custom name <code>--display-p3-linear</code>:</p> <pre><code>color(--display-p3-linear r g b / a)  // Color function\n</code></pre> <p>When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used:</p> <pre><code>Color(\"display-p3-linear\", [0, 0, 0], 1)\n</code></pre> <p>The string representation of the color object and the default string output will be in the <code>color(--display-p3-linear r g b / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"display-p3-linear\", [0.82246, 0.03319, 0.01708])\ncolor(--display-p3-linear 0.82246 0.03319 0.01708 / 1)\n&gt;&gt;&gt; Color(\"display-p3-linear\", [0.88926, 0.39697, 0.04432]).to_string()\n'color(--display-p3-linear 0.88926 0.39697 0.04432)'\n</code></pre> Gamut: srgb"},{"location":"colors/display_p3_linear/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.display_p3_linear import DisplayP3\n\nclass Color(Base): ...\n\nColor.register(DisplayP3Linear())\n</code></pre>"},{"location":"colors/hct/","title":"HCT","text":"<p>The HCT color space is not registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>hct</code></p> <p>White Point: D65 / 2\u02da</p> <p>Coordinates:</p> Name Range<sup>*</sup> <code>h</code> [0, 360) <code>c</code> [0, 145] <code>t</code> [0, 100] <p><sup>*</sup> Space is not bound to the range and is only used as a reference to define percentage inputs/outputs in relation to the Display P3 color space.</p> <p></p> <p>Figure 1. The sRGB gamut represented within the HCT color space.</p> <p>The HCT color space is Google's attempt at a perceptually accurate color system. Essentially, it is two color spaces glued together: 'H' (hue) and 'C' (chroma) come from the CAM16 color appearance model and 'T' (tone) is the lightness from the CIELAB (D65) color space. The space was created to take the more consistent perceptual hues from CAM16 and use the better lightness prediction found in CIELAB. The color space has the advantage of being well suited for creating color schemes with decent contrast and makes it easy to create nice tonal palettes, but the downside is that it is expensive to translate to and from compared to other color spaces.</p> <p>Since HCT is partly based on CAM16, it inherits the expensive operations used to translate color to and from the CAM16 color model. In the forward direction (to HCT) color conversions are only marginally more expensive than CAM16, but in the reverse direction (from HCT) the conversions are much more expensive. This is because the CAM16 color model needs the context of chroma, hue, and lightness in order to translate any of its components, but HCT throws away CAM16 lightness and uses CIELAB lightness which has no direct relation to the other components. In order to translate color from HCT, more complex methods are needed to approximate the missing CAM16 lightness in order for a good round trip conversion.</p> <p>Google implements the HCT color space in their \"Material Color Utilities\" library, but in that library it is restricted to sRGB and only to 8 bit precision. Wide gamut colors such as Display P3 cannot be used.</p> <p>ColorAide's goal was not to port Material's Color Utilities, but to implement HCT as a proper color space that can be used in sRGB and other wide gamut color spaces. In ColorAide we implement the HCT color space exactly as described and create the space from both CIELAB and CAM16. We then provide a generic approximation back out of HCT at a higher precision to better support not only sRGB, but other wide gamut color spaces such as: Display P3, Rec. 2020, A98 RGB, etc.</p> <p>Conversion Limitations</p> <p>Extreme colors, like those in ProPhoto RGB that fall outside the visible spectrum, may be difficult to round trip with the same high accuracy as other colors well inside the visible spectrum. These colors naturally stress the CAM16 color model and make approximation from HCT even more difficult. With that said, most color spaces within the visible spectrum should convert reasonably well.</p> <p>Learn more.</p>"},{"location":"colors/hct/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>h</code> <code>hue</code> <code>c</code> <code>chroma</code> <code>t</code> <code>tone</code>, <code>lightness</code>"},{"location":"colors/hct/#inputoutput","title":"Input/Output","text":"<p>The HCT space is not currently supported in the CSS spec, the parsed input and string output formats use the <code>color()</code> function format using the custom name <code>--hct</code>:</p> <pre><code>color(--hct h c t / a)  // Color function\n</code></pre> <p>The string representation of the color object and the default string output use the <code>color(--hct h c t / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"hct\", [27.41, 113.36, 53.237], 1)\ncolor(--hct 27.41 113.36 53.237 / 1)\n&gt;&gt;&gt; Color(\"hct\", [71.257, 60.528, 74.934], 1).to_string()\n'color(--hct 71.257 60.528 74.934)'\n</code></pre> Gamut: srgb"},{"location":"colors/hct/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.hct import HCT\n\nclass Color(Base): ...\n\nColor.register(HCT())\n</code></pre>"},{"location":"colors/hct/#tonal-palettes","title":"Tonal Palettes","text":"<p>One of the applications of HCT is generating tonal palettes. By applying gamut mapping that focuses on chroma reduction, we can produce tonal palettes just like in Material Color Utilities. Specifically, we will use the ray trace approach within the HCT space to reduce the chroma very close to the gamut boundary.</p> <p>The basic idea with generating tonal palettes is to pick a reasonable color, change the tone via a good distance, and make sure the color fits the target gamut by reducing the chroma until the color is within the gamut. We can quickly demonstrate that this works by generating a simple tonal palette as shown below.</p> <pre><code>&gt;&gt;&gt; c = Color('hct', [325, 24, 50])\n&gt;&gt;&gt; tones = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 95, 100]\n&gt;&gt;&gt; Steps([c.clone().set('tone', tone).convert('srgb').to_string(hex=True, fit={'method': 'raytrace', 'pspace': 'hct'}) for tone in tones])\n['#000000', '#29132e', '#3f2844', '#573e5b', '#705574', '#8a6d8d', '#a587a8', '#c1a1c3', '#debcdf', '#fbd7fc', '#ffebfd', '#ffffff']\n</code></pre> Gamut: srgb <p>Material Color Utilities, as they currently implement it, only works within the sRGB color space, but ColorAide implements HCT such that it can be used in various wide gamuts as well.</p> <pre><code>&gt;&gt;&gt; tones = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 95, 100]\n&gt;&gt;&gt; c1 = Color('display-p3', [1, 0, 1]).convert('hct')\n&gt;&gt;&gt; Steps([c1.clone().set('tone', tone).convert('display-p3').to_string(fit={'method': 'raytrace', 'pspace': 'hct'}) for tone in tones])\n['color(display-p3 0 0 0)', 'color(display-p3 0.21082 0 0.21026)', 'color(display-p3 0.34421 0 0.34351)', 'color(display-p3 0.48729 0 0.48655)', 'color(display-p3 0.63838 0 0.63771)', 'color(display-p3 0.79637 0 0.79591)', 'color(display-p3 0.96045 0 0.96034)', 'color(display-p3 1 0.42475 0.97096)', 'color(display-p3 1 0.65344 0.95759)', 'color(display-p3 1 0.83592 0.96434)', 'color(display-p3 1 0.92011 0.97354)', 'color(display-p3 1 1 1)']\n&gt;&gt;&gt; c2 = Color('rec2020', [0, 0, 1]).convert('hct')\n&gt;&gt;&gt; Steps([c2.clone().set('tone', tone).convert('rec2020').to_string(fit={'method': 'raytrace', 'pspace': 'hct'}) for tone in tones])\n['color(rec2020 0 0 0)', 'color(rec2020 0 0.00089 0.39445)', 'color(rec2020 0 0.00126 0.70604)', 'color(rec2020 0.00901 0.0168 1)', 'color(rec2020 0.15828 0.21769 1)', 'color(rec2020 0.2965 0.36054 1)', 'color(rec2020 0.43188 0.49019 1)', 'color(rec2020 0.56968 0.6162 1)', 'color(rec2020 0.71125 0.74186 1)', 'color(rec2020 0.85698 0.86865 1)', 'color(rec2020 0.93142 0.93272 1)', 'color(rec2020 0.99991 0.99948 1)']\n</code></pre> Gamut: srgb <p>Due to differences in approximation techniques, general precision differences, and gamut mapping specifics of the two implementations internally, ColorAide may return colors slightly different from Material Color Utilities. These differences are extremely small and not perceptible to the eye.</p> <p>Below we have two examples. We've taken the results from Material's tests and we've generated the same tonal palettes and output both as HCT. We can compare which hues stay overall more constant, which chroma gets reduced more than others, and which hue and tone are less affected by the gamut mapping. Can you definitively say that one looks more correct than the other? Can you say there is notable, visual difference?</p> <pre><code>&gt;&gt;&gt; def tonal_palette(c):\n...     \"\"\"HCT tonal palettes.\"\"\"\n... \n...     c = Color(c).convert('hct')\n...     tones = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 95, 100]\n...     return [c.clone().set('tone', tone).fit('srgb', method='raytrace', pspace='hct') for tone in tones]\n... \n&gt;&gt;&gt; material1 = ['#000000', '#00006e', '#0001ac',\n...              '#0000ef', '#343dff', '#5a64ff',\n...              '#7c84ff', '#9da3ff', '#bec2ff',\n...              '#e0e0ff', '#f1efff', '#ffffff']\n&gt;&gt;&gt; c = Color('blue').convert('hct')\n&gt;&gt;&gt; Steps([x.to_string() for x in tonal_palette(c)])\n['color(--hct 0 0 0)', 'color(--hct 282.76 51.545 10)', 'color(--hct 282.76 68.124 20)', 'color(--hct 282.76 83.744 30)', 'color(--hct 282.76 82.336 40)', 'color(--hct 282.76 73.341 50)', 'color(--hct 282.76 62.065 60)', 'color(--hct 282.76 49.085 70)', 'color(--hct 282.76 34.771 80)', 'color(--hct 282.76 19.211 90)', 'color(--hct 282.76 10.817 95)', 'color(--hct 209.54 2.8716 100)']\n&gt;&gt;&gt; Steps([Color(x).convert('hct').to_string() for x in material1])\n['color(--hct 0 0 0)', 'color(--hct 282.84 51.709 9.9973)', 'color(--hct 282.74 68.127 20.044)', 'color(--hct 282.77 83.756 29.989)', 'color(--hct 282.81 82.297 40.059)', 'color(--hct 282.79 73.236 50.106)', 'color(--hct 283.04 62.214 59.895)', 'color(--hct 282.95 49.257 69.882)', 'color(--hct 282.15 34.694 80.039)', 'color(--hct 282.23 19.146 90.035)', 'color(--hct 282.07 10.786 95.015)', 'color(--hct 209.54 2.8716 100)']\n&gt;&gt;&gt; material2 = ['#000000', '#191a2c', '#2e2f42',\n...              '#444559', '#5c5d72', '#75758b',\n...              '#8f8fa6', '#a9a9c1', '#c5c4dd',\n...              '#e1e0f9', '#f1efff', '#ffffff']\n&gt;&gt;&gt; c['chroma'] = 16\n&gt;&gt;&gt; Steps([x.to_string() for x in tonal_palette(c)])\n['color(--hct 0 0 0)', 'color(--hct 282.76 16 10)', 'color(--hct 282.76 16 20)', 'color(--hct 282.76 16 30)', 'color(--hct 282.76 16 40)', 'color(--hct 282.76 16 50)', 'color(--hct 282.76 16 60)', 'color(--hct 282.76 16 70)', 'color(--hct 282.76 16 80)', 'color(--hct 282.76 16 90)', 'color(--hct 282.76 10.817 95)', 'color(--hct 209.54 2.8716 100)']\n&gt;&gt;&gt; Steps([Color(x).convert('hct').to_string() for x in material2])\n['color(--hct 0 0 0)', 'color(--hct 283.31 16.104 10.01)', 'color(--hct 282.9 16.074 20.073)', 'color(--hct 282.41 16.065 29.927)', 'color(--hct 281.87 16.078 40.112)', 'color(--hct 283.49 16.042 49.94)', 'color(--hct 282.85 16.13 60.103)', 'color(--hct 282.27 16.258 69.938)', 'color(--hct 283.58 16.297 79.937)', 'color(--hct 282.75 15.918 89.933)', 'color(--hct 282.07 10.786 95.015)', 'color(--hct 209.54 2.8716 100)']\n</code></pre> Gamut: srgb"},{"location":"colors/hellwig/","title":"Hellwig JMh","text":"<p>The Hellwig JMh color space is not registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>hellwig-jmh</code></p> <p>White Point: D65 / 2\u02da</p> <p>Coordinates:</p> Name Range<sup>*</sup> <code>j</code> [0, 100] <code>m</code> [0, 105] <code>h</code> [0, 360) <p><sup>*</sup> Space is not bound to the range and is only used as a reference to define percentage inputs/outputs in relation to the Display P3 color space.</p> <p></p> <p>Figure 1. The sRGB gamut represented within the Hellwig JMh color space.</p> <p>The Hellwig color model is an unofficial name for the CAM16 model with applied \"fixes\" as published by Luke Hellwig and Mark Fairchild entitled 'Brightness, lightness, colorfulness, and chroma in CIECAM02 and CAM16'. The paper suggests a number of changes to the brightness and lightness properties changing their non-linear relationship to a linear relationship. It also details a reevaluation of chroma, colorfulness, and saturation making some suggestions additional changes.</p> <p>The model defines numerous different attributes:</p> Name Description J Lightness C Chroma h hue s saturation Q Brightness M Colorfulness H Hue Quadrature <p>A color space can be constructed of using a subset of these attributes: JCh, JMh, Jsh, QCh, QMh, Qsh, etc. You can also construct Lab like spaces taking using the hue and either C, M, or s. The <code>hellwig-jmh</code> color space in ColorAide represents the JMh configuration.</p> <p>Learn more.</p>"},{"location":"colors/hellwig/#adjustments-for-helmholtzkohlrausch-effect","title":"Adjustments for Helmholtz\u2013Kohlrausch Effect","text":"<p>The Hellwig H-K JMh color space is not registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>hellwig-hk-jmh</code></p> <p>White Point: D65 / 2\u02da</p> <p>Coordinates:</p> Name Range<sup>*</sup> <code>j</code> [0.0, ~101.560] <code>m</code> [0, 105] <code>h</code> [0, 360) <p><sup>*</sup> Space is not bound to the range and is only used as a reference to define percentage inputs/outputs in relation to the Display P3 color space.</p> <p></p> <p>Figure 2. The sRGB gamut represented within the Hellwig H-K JMh color space.</p> <p>The Helmholtz\u2013Kohlrausch effect (after Hermann von Helmholtz and V. A. Kohlrausch) is a perceptual phenomenon wherein the intense saturation of spectral hue is perceived as part of the color's luminance. This creates a hue and chroma dependency that affects lightness and brightness.</p> <p>After the initial paper describing the Hellwig corrections, Luke Hellwig, Dale Stolitzka, and Mark Fairchild published another paper that modified lightness and brightness further to better represent the Helmholtz\u2013Kohlrausch effect in the CAM16 model.</p> <p>The paper entitled 'Extending CIECAM02 and CAM16 for the Helmholtz\u2013Kohlrausch effect' outlined additional changes to the lightness and brightness calculations of CAM16 and CIECAM02 that allowed the models to better simulate the Helmholtz\u2013Kohlrausch effect. These changes are required to made on top of the original modifications of brightness and lightness as described by in the first Hellwig paper.</p> <p>Learn more</p>"},{"location":"colors/hellwig/#viewing-conditions","title":"Viewing Conditions","text":"<p>Hellwig is a color appearance model and can be configured with different viewing environments. A Hellwig color space will also have an associated environment object. This environment object determines the viewing conditions. Colors will appear different based on the viewing conditions.</p> Viewing\u00a0Conditions Description White This is the white point and should be the same as defined in the color class. This is provided as (x, y) chromaticity coordinates. Adapting\u00a0Luminance The luminance of the adapting field (<code>La</code>). The units are in cd/m2. Background\u00a0Luminance The background luminance (<code>Yb</code>) the relative luminance of the nearby background (out to 10\u00b0), relative to the reference white's luminance (<code>Y</code>). Usually 20 providing a gray world assumption. Surround A description of the peripheral area. Use \"dark\" for a movie theater, \"dim\" for e.g. viewing a bright television in a dimly lit room, or \"average\" for surface colors. Discounting Discounts the illuminant. If true, the eye is assumed to be fully adapted to the illuminant. Otherwise, the degree of discounting is based on other parameters. When the eye is not fully adapted, it can affect the way colors appear and the chromatic response. Helmholtz\u2013Kohlrausch\u00a0effect If true, account for the Helmholtz\u2013Kohlrausch effect by further adjusting lightness and brightness. <p>ColorAide must provide some defaults, so Hellwig comes with a default set of viewing conditions that uses a D65 white point, an adapting luminance of 64 lux or a value of ~4 cd/m<sup>2</sup>, it uses the \"gray world\" assumption and sets the background to 20, an \"average\" surround and leaves discounting set to <code>False</code>. The Helmholtz\u2013Kohlrausch\u00a0effect handling is only enabled for the <code>hellwig-hk-jmh</code> variant.</p> <p>The default settings do not have to be used and a new Hellwig variant with different viewing conditions can be created. When doing this, the space should be derived from the default.</p> <pre><code>&gt;&gt;&gt; from coloraide import Color as Base\n&gt;&gt;&gt; from coloraide.spaces.hellwig import HellwigJMh, Environment\n&gt;&gt;&gt; from coloraide.cat import WHITES\n&gt;&gt;&gt; from coloraide import util\n&gt;&gt;&gt; import math\n&gt;&gt;&gt; class CustomHellwigJMh(HellwigJMh):\n...     NAME = \"hellwig-custom\"\n...     SERIALIZE = (\"--hellwig-custom\",)\n...     WHITE = WHITES['2deg']['D65']\n...     ENV = Environment(\n...         white=WHITE,\n...         adapting_luminance=1000 / math.pi,\n...         background_luminance=20,\n...         surround='average',\n...         discounting=False,\n...         hk=False\n...     )\n... \n&gt;&gt;&gt; class Color(Base): ...\n... \n&gt;&gt;&gt; Color.register([HellwigJMh(), CustomHellwigJMh()])\n&gt;&gt;&gt; Color('white').convert('hellwig-jmh')\ncolor(--hellwig-jmh 100 1.0387 209.53 / 1)\n&gt;&gt;&gt; Color('white').convert('hellwig-custom')\ncolor(--hellwig-custom 100 0.0606 209.66 / 1)\n</code></pre> Gamut: srgb <p>Note</p> <p>It can be noted in the above example that white does not have the typical zero chroma. This is because the eye is not assumed as being fully adapted to the environment. Due to the environment, the colors considered achromatic may appear differently.</p> <p>If <code>discounting</code> was enabled, the eye is then assumed to be fully adapted, and achromatic colors would align better with expectations in other color spaces.</p>"},{"location":"colors/hellwig/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>j</code> <code>lightness</code> <code>m</code> <code>colorfulness</code> <code>h</code> <code>hue</code>"},{"location":"colors/hellwig/#inputoutput","title":"Input/Output","text":"<p>The Hellwig JMh space is not currently supported in the CSS spec, the parsed input and string output formats use the <code>color()</code> function format using the custom name <code>--hellwig-jmh</code>. When adjustments for the Helmholtz\u2013Kohlrausch effect are enabled, the custom name <code>--hellwig-hk-jmh</code> is used.</p> <pre><code>color(--hellwig-jmh j m h / a)  // Color function\ncolor(--hellwig-hk-jmh j m h / a)  // Color function\n</code></pre> <p>The string representation of the color object and the default string output use the <code>color(--hellwig-jmh j m h / a)</code> form. If using the H-K variant, <code>color(--hellwig--hk-jmh j m h / a)</code> is used.</p> <pre><code>&gt;&gt;&gt; Color(\"hellwig-jmh\", [46.026, 47.347, 27.393], 1)\ncolor(--hellwig-jmh 46.026 47.347 27.393 / 1)\n&gt;&gt;&gt; Color(\"hellwig-jmh\", [68.056, 31.228, 71.293], 1).to_string()\n'color(--hellwig-jmh 68.056 31.228 71.293)'\n&gt;&gt;&gt; Color(\"hellwig-hk-jmh\", [97.726, 33.735, 111.15], 1)\ncolor(--hellwig-hk-jmh 97.726 33.735 111.15 / 1)\n&gt;&gt;&gt; Color(\"hellwig-hk-jmh\", [39.201, 27.019, 142.3], 1).to_string()\n'color(--hellwig-hk-jmh 39.201 27.019 142.3)'\n</code></pre> Gamut: srgb"},{"location":"colors/hellwig/#registering","title":"Registering","text":"<p>Either Hellwig JMh, Hellwig H-K JMh, or both can be registered.</p> <pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.hellwig import HellwigJMh, HellwigHKJMh\n\nclass Color(Base): ...\n\nColor.register([HellwigJMh(), HellwigHKJMh()])\n</code></pre>"},{"location":"colors/hpluv/","title":"HPLuv","text":"<p>The HPLuv color space is not registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>hpluv</code></p> <p>Color CSS ID: <code>--hpluv</code></p> <p>White Point: D65 / 2\u02da</p> <p>Coordinates:</p> Name Range <code>h</code> [0, 360) <code>p</code> [0, 100] <code>l</code> [0, 100] <p></p> <p>Figure 1. HPLuv color space in 3D</p> <p>HPLuv is similar to HSLuv but takes as many colors as it can from CIELCh<sub>uv</sub> without distorting the chroma. This ends up reducing the gamut to a subset of the sRGB gamut. In the end, only more pastel colors remain.</p> <p>Learn about HPLuv</p>"},{"location":"colors/hpluv/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>h</code> <code>hue</code> <code>p</code> <code>perpendiculars</code> <code>l</code> <code>lightness</code>"},{"location":"colors/hpluv/#inputsoutput","title":"Inputs/Output","text":"<p>HPLuv is not currently supported in the CSS spec, the parsed input and string output formats use the <code>color()</code> function format using the custom name <code>--hpluv</code>:</p> <pre><code>color(--hpluv h p l / a)  // Color function\n</code></pre> <p>When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used:</p> <pre><code>Color(\"hpluv\", [0, 0, 0], 1)\n</code></pre> <p>The string representation of the color object and the default string output use the <code>color(--hpluv h p l / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"hpluv\", [23.881, 100, 53.237])\ncolor(--hpluv 23.881 100 53.237 / 1)\n&gt;&gt;&gt; Color(\"hpluv\", [49.45, 100, 74.934]).to_string()\n'color(--hpluv 49.45 100 74.934)'\n</code></pre> Gamut: srgb"},{"location":"colors/hpluv/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.hpluv import HSPLuv\n\nclass Color(Base): ...\n\nColor.register(HPLuv())\n</code></pre>"},{"location":"colors/hsi/","title":"HSI","text":"<p>The HSI color space is not registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>hsi</code></p> <p>White Point: D65 / 2\u02da</p> <p>Coordinates:</p> Name Range <code>h</code> [0, 360) <code>s</code> [0, 1] <code>i</code> [0, 1] <p></p> <p>Figure 1. The sRGB gamut represented within the HSI color space.</p> <p>The HSI model is similar to models like HSL and HSV except that it uses I for intensity instead of Lightness or Value. It does not attempt to \"fill\" a cylinder by its definition of saturation leading to a very different look when we plot it.</p> <p></p> <p>Learn more.</p>"},{"location":"colors/hsi/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>h</code> <code>hue</code> <code>s</code> <code>saturation</code> <code>i</code> <code>intensity</code>"},{"location":"colors/hsi/#inputoutput","title":"Input/Output","text":"<p>The HSI space is not currently supported in the CSS spec, the parsed input and string output formats use the <code>color()</code> function format using the custom name <code>--hsi</code>:</p> <pre><code>color(--hsi h s i / a)  // Color function\n</code></pre> <p>The string representation of the color object and the default string output use the <code>color(--hsi h s i / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"hsi\", [0, 1, 0.33333])\ncolor(--hsi 0 1 0.33333 / 1)\n&gt;&gt;&gt; Color(\"hsi\", [38.824, 1, 0.54902]).to_string()\n'color(--hsi 38.824 1 0.54902)'\n</code></pre> Gamut: srgb"},{"location":"colors/hsi/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.hsi import HSI\n\nclass Color(Base): ...\n\nColor.register(HSI())\n</code></pre>"},{"location":"colors/hsl/","title":"HSL","text":"<p>The HSL color space is registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>hsl</code></p> <p>White Point: D65 / 2\u02da</p> <p>Coordinates:</p> Name Range <code>h</code> [0, 360) <code>s</code> [0, 1] <code>l</code> [0, 1] <p></p> <p>Figure 1. HSL color space in 3D</p> <p>HSL is an alternative representations of the RGB color model, designed in the 1970s by computer graphics researchers to more closely align with the way human vision perceives color-making attributes. In these models, colors of each hue are arranged in a radial slice, around a central axis of neutral colors which ranges from black at the bottom to white at the top.</p> <p>HSL models the way different paints mix together to create color in the real world, with the lightness dimension resembling the varying amounts of black or white paint in the mixture.</p> <p>Learn about HSL</p>"},{"location":"colors/hsl/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>h</code> <code>hue</code> <code>s</code> <code>saturation</code> <code>l</code> <code>lightness</code>"},{"location":"colors/hsl/#inputoutput","title":"Input/Output","text":"<p>Parsed input and string output formats support all valid CSS forms. In addition, we also allow the <code>color()</code> function format using the custom name <code>--hsl</code>:</p> <pre><code>hsl(h s l / a)          // HSL function\nhsl(h, s, l)            // Legacy HSL function\nhsla(h, s, l, a)        // Legacy HSLA function\ncolor(--hsl h s l / a)  // Color function\n</code></pre> <p>When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used:</p> <pre><code>Color(\"hsl\", [0, 0, 0], 1)\n</code></pre> <p>The string representation of the color object will always default to the <code>color(--hsl h s l / a)</code> form, but the default string output will be the <code>hsl(h s l / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"hsl\", [0, 1, 0.5])\ncolor(--hsl 0 1 0.5 / 1)\n&gt;&gt;&gt; Color(\"hsl\", [38.824, 1, 0.5], ).to_string()\n'hsl(38.824 100% 50%)'\n&gt;&gt;&gt; Color(\"hsl\", [60, 1, 0.5]).to_string(comma=True)\n'hsl(60, 100%, 50%)'\n&gt;&gt;&gt; Color(\"hsl\", [120, 1, 0.25098]).to_string(color=True)\n'color(--hsl 120 1 0.25098)'\n&gt;&gt;&gt; Color(\"hsl\", [240, 1, 0.5]).to_string(percent=False)\n'hsl(240 100 50)'\n</code></pre> Gamut: srgb"},{"location":"colors/hsl/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.hsl import HSL\n\nclass Color(Base): ...\n\nColor.register(HSL())\n</code></pre>"},{"location":"colors/hsluv/","title":"HSLuv","text":"<p>The HSLuv color space is not registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>hsluv</code></p> <p>White Point: D65 / 2\u02da</p> <p>Coordinates:</p> Name Range <code>h</code> [0, 360) <code>s</code> [0, 100] <code>l</code> [0, 100] <p></p> <p>Figure 1. HSLuv color space in 3D</p> <p>HSLuv is a human-friendly alternative to HSL. It was formerly known as \"HUSL\" and is a variation of the CIELCh<sub>uv</sub> color space, where the chroma component is replaced by a saturation component which allows you to span all the available chroma as a percentage. HSLuv is constrained to the sRGB gamut.</p> <p>Learn about HSLuv</p>"},{"location":"colors/hsluv/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>h</code> <code>hue</code> <code>s</code> <code>saturation</code> <code>l</code> <code>lightness</code>"},{"location":"colors/hsluv/#inputoutput","title":"Input/Output","text":"<p>HSLuv is not currently supported in the CSS spec, the parsed input and string output formats use the <code>color()</code> function format using the custom name <code>--hsluv</code>:</p> <pre><code>color(--hsluv h s l / a)  // Color function\n</code></pre> <p>When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used:</p> <pre><code>Color(\"hsluv\", [0, 0, 0], 1)\n</code></pre> <p>The string representation of the color object and the default string output use the <code>color(--hsluv h s l / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"hsluv\", [12.177, 100, 53.237])\ncolor(--hsluv 12.177 100 53.237 / 1)\n&gt;&gt;&gt; Color(\"hsluv\", [44.683, 100, 74.934]).to_string()\n'color(--hsluv 44.683 100 74.934)'\n</code></pre> Gamut: srgb"},{"location":"colors/hsluv/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.hsluv import HSLuv\n\nclass Color(Base): ...\n\nColor.register(HSLuv())\n</code></pre>"},{"location":"colors/hsv/","title":"HSV","text":"<p>The HSV color space is registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>hsv</code></p> <p>White Point: D65 / 2\u02da</p> <p>Coordinates:</p> Name Range <code>h</code> [0, 360) <code>s</code> [0, 1] <code>v</code> [0, 1] <p></p> <p>Figure 1. HSV color space in 3D</p> <p>HSV is a color space similar to the modern RGB and CMYK models. The HSV color space has three components: hue, saturation and value. 'Value' is sometimes substituted with 'brightness' and then it is known as HSB. HSV models how colors appear under light.</p> <p>Learn about HSV</p>"},{"location":"colors/hsv/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>h</code> <code>hue</code> <code>s</code> <code>saturation</code> <code>v</code> <code>value</code>"},{"location":"colors/hsv/#inputoutput","title":"Input/Output","text":"<p>HSV is not supported via the CSS spec and the parser input and string output only supports the <code>color()</code> function format using the custom name <code>--hsv</code>:</p> <pre><code>color(--hsv 0 0% 0% / 1)\n</code></pre> <p>When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used:</p> <pre><code>Color(\"hsv\", [0, 0, 0], 1)\n</code></pre> <p>The string representation of the color object and default string output will always use the <code>color(hsv h s v / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"hsv\", [0, 1, 1])\ncolor(--hsv 0 1 1 / 1)\n&gt;&gt;&gt; Color(\"hsv\", [38.824, 1, 1]).to_string()\n'color(--hsv 38.824 1 1)'\n</code></pre> Gamut: srgb"},{"location":"colors/hsv/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.hsv import HSV\n\nclass Color(Base): ...\n\nColor.register(HSV())\n</code></pre>"},{"location":"colors/hunter_lab/","title":"Hunter Lab","text":"<p>The Hunter Lab color space is not registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>hunter-lab</code></p> <p>White Point: D65 / 2\u02da</p> <p>Coordinates:</p> Name Range <code>l</code> [0, 100] <code>a</code> [-210, 210] <code>b</code> [-210, 210] <p><sup>*</sup> Space is not bound to the range and is only used as a reference to define percentage inputs/outputs in relation to the Display P3 color space.</p> <p></p> <p>Figure 1. The sRGB gamut represented within the Hunter Lab color space.</p> <p>The Hunter Lab color space, defined in 1948 by Richard S. Hunter, is another color space referred to as \"Lab\". Like CIELab, it was also designed to be computed via simple formulas from the CIE XYZ space, but to be more perceptually uniform than CIE XYZ. Hunter named his coordinates L, a, and b. The CIE named the coordinates for CIELab as L, a, b* to distinguish them from Hunter's coordinates.</p> <p>Learn more.</p>"},{"location":"colors/hunter_lab/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>l</code> <code>lightness</code> <code>a</code> <code>b</code>"},{"location":"colors/hunter_lab/#inputoutput","title":"Input/Output","text":"<p>The Hunter Lab space is not currently supported in the CSS spec, the parsed input and string output formats use the <code>color()</code> function format using the custom name <code>--hunter-lab</code>:</p> <pre><code>color(--hunter-lab l a b / a)  // Color function\n</code></pre> <p>The string representation of the color object and the default string output use the <code>color(--hunter-lab l a b / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"hunter-lab\", [46.113, 82.672, 28.408])\ncolor(--hunter-lab 46.113 82.672 28.408 / 1)\n&gt;&gt;&gt; Color(\"hunter-lab\", [69.407, 23.266, 40.946]).to_string()\n'color(--hunter-lab 69.407 23.266 40.946)'\n</code></pre> Gamut: srgb"},{"location":"colors/hunter_lab/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.hunter_lab import HunterLab\n\nclass Color(Base): ...\n\nColor.register(HunterLab())\n</code></pre>"},{"location":"colors/hwb/","title":"HWB","text":"<p>The HWB color space is registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>hwb</code></p> <p>White Point: D65 / 2\u02da</p> <p>Coordinates:</p> Name Range <code>h</code> [0, 360) <code>w</code> [0, 1] <code>b</code> [0, 1] <p></p> <p>Figure 1. HWB color space in 3D</p> <p>HWB is a cylindrical-coordinate representation of points in an RGB color model, similar to HSL and HSV. It was developed by HSV's creator Alvy Ray Smith in 1996 to address some of the issues with HSV. HWB was designed to be more intuitive for humans to use and slightly faster to compute. The first coordinate, H (Hue), is the same as the Hue coordinate in HSL and HSV. W and B stand for Whiteness and Blackness respectively and range from 0-100% (or 0-1). The mental model is that the user can pick a main hue and then \"mix\" it with white and/or black to produce the desired color.</p> <p>Learn about HWB</p>"},{"location":"colors/hwb/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>h</code> <code>hue</code> <code>w</code> <code>whiteness</code> <code>b</code> <code>blackness</code>"},{"location":"colors/hwb/#inputoutput","title":"Input/Output","text":"<p>Parsed input and string output formats support all valid CSS forms. In addition, we also allow the <code>color()</code> function format using the custom name <code>--hwb</code>:</p> <pre><code>hwb(h w b / a)          // HWB function\ncolor(--hwb h w b / a)  // Color function\n</code></pre> <p>When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used:</p> <pre><code>Color(\"hwb\", [0, 0, 100], 1)\n</code></pre> <p>The string representation of the color object will always default to the <code>color(--hwb h w b / a)</code> form, but the default string output will be the <code>hwb(h s l / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"hwb\", [0, 0, 0])\ncolor(--hwb 0 0 0 / 1)\n&gt;&gt;&gt; Color(\"hwb\", [38.824, 0, 0]).to_string()\n'hwb(38.824 0% 0%)'\n&gt;&gt;&gt; Color(\"hwb\", [60, 0, 0]).to_string(percent=False)\n'hwb(60 0 0)'\n&gt;&gt;&gt; Color(\"hwb\", [120, 0, 0]).to_string(color=True)\n'color(--hwb 120 0 0)'\n</code></pre> Gamut: srgb"},{"location":"colors/hwb/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.hwb import HWB\n\nclass Color(Base): ...\n\nColor.register(HWB())\n</code></pre>"},{"location":"colors/ictcp/","title":"ICtCp","text":"<p>The ICtCp color space is registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>ictcp</code></p> <p>White Point: D65 / 2\u02da</p> <p>Coordinates:</p> Name Range<sup>*</sup> <code>i</code> [0, 1] <code>ct</code> [-0.5, 0.5] <code>cp</code> [-0.5, 0.5] <p><sup>*</sup> Space is not bound to the above, defined range but represents a practical range for HDR color spaces.</p> <p></p> <p>Figure 1. The sRGB gamut represented within the ICtCp color space.</p> <p>ICtCp is a color space format with better perceptual uniformity than CIELab and is used as a part of the color image pipeline in video and digital photography systems for high dynamic range (HDR) and wide color gamut (WCG) imagery. It was developed by Dolby Laboratories from the IPT color space by Ebner and Fairchild. It was designed with the intention to replace YCbCr.</p> <p>Learn about ICtCp</p>"},{"location":"colors/ictcp/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>i</code> <code>intensity</code> <code>ct</code> <code>tritan</code> <code>cp</code> <code>protan</code>"},{"location":"colors/ictcp/#inputoutput","title":"Input/Output","text":"<p>Parsed input and string output formats support all valid CSS forms in addition to allowing the <code>color()</code> function format as well using the custom name <code>--ictcp</code>.</p> <pre><code>ictcp(i ct cp / a)          // ICtCp function\ncolor(--ictcp i ct cp / a)  // Color function\n</code></pre> <p>When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used:</p> <pre><code>Color(\"ictcp\", [0, 0, 0], 1)\n</code></pre> <p>The string representation of the color object will always default to the <code>color(--ictcp i ct cp / a)</code> form, but the default string output will be the <code>ictcp(i ct cp / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"ictcp\", [0.42788, -0.1157, 0.27873])\ncolor(--ictcp 0.42788 -0.1157 0.27873 / 1)\n&gt;&gt;&gt; Color(\"ictcp\", [0.50498, -0.20797, 0.11073]).to_string()\n'ictcp(0.50498 -0.20797 0.11073)'\n&gt;&gt;&gt; Color(\"ictcp\", [0.56983, -0.25169, 0.03788]).to_string(percent=True)\n'ictcp(56.983% -50.338% 7.576%)'\n&gt;&gt;&gt; Color(\"ictcp\", [0.39138, -0.24061, -0.04423]).to_string(color=True)\n'color(--ictcp 0.39138 -0.24061 -0.04423)'\n</code></pre> Gamut: srgb"},{"location":"colors/ictcp/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.ictcp.css import ICtCp\n\nclass Color(Base): ...\n\nColor.register(ICtCp())\n</code></pre>"},{"location":"colors/igpgtg/","title":"IgPgTg","text":"<p>The IgPgTg color space is not registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>ipt</code></p> <p>White Point: D65 / 2\u02da</p> <p>Coordinates:</p> Name Range <code>ig</code> [0, 1] <code>pg</code> [-1, 1] <code>tg</code> [-1, 1] <p><sup>*</sup> Space is not bound to the range and is only used as a reference to define percentage inputs/outputs.</p> <p></p> <p>Figure 1. The sRGB gamut represented within the IgPgTg color space.</p> <p>IgPgTg uses the same structure as IPT, an established hue-uniform color space utilized in gamut mapping applications. While IPT was fit to visual data on the perceived hue, IgPgTg was optimized based on evidence linking the peak wavelength of Gaussian-shaped light spectra to their perceived hues.</p> <p>Learn more.</p>"},{"location":"colors/igpgtg/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>ig</code> <code>intensity</code> <code>pg</code> <code>protan</code> <code>tg</code> <code>tritan</code>"},{"location":"colors/igpgtg/#inputoutput","title":"Input/Output","text":"<p>The IgPgTg space is not currently supported in the CSS spec, the parsed input and string output formats use the <code>color()</code> function format using the custom name <code>--igpgtg</code>:</p> <pre><code>color(--igpgtg ig pg tg / a)  // Color function\n</code></pre> <p>The string representation of the color object and the default string output use the <code>color(--igpgtg ig pg tg / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"igpgtg\", [0.54834, 0.15366, 0.43674])\ncolor(--igpgtg 0.54834 0.15366 0.43674 / 1)\n&gt;&gt;&gt; Color(\"igpgtg\", [0.73238, 0.0397, 0.32108]).to_string()\n'color(--igpgtg 0.73238 0.0397 0.32108)'\n</code></pre> Gamut: srgb"},{"location":"colors/igpgtg/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.igpgtg import IgPgTg\n\nclass Color(Base): ...\n\nColor.register(IgPgTg())\n</code></pre>"},{"location":"colors/ipt/","title":"IPT","text":"<p>The IPT color space is not registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>ipt</code></p> <p>White Point: D65 / 2\u02da</p> <p>Coordinates:</p> Name Range<sup>*</sup> <code>i</code> [0, 1] <code>p</code> [-1, 1] <code>t</code> [-1, 1] <p><sup>*</sup> Space is not bound to the range and is only used as a reference to define percentage inputs/outputs.</p> <p></p> <p>Figure 1. The sRGB gamut represented within the IPT color space.</p> <p>Ebner and Fairchild addressed the issue of non-constant lines of hue in their color space dubbed IPT. The IPT color space converts D65-adapted XYZ data (XD65, YD65, ZD65) to long-medium-short cone response data (LMS) using an adapted form of the Hunt-Pointer-Estevez matrix (M<sub>HPE</sub>(D65)).</p> <p>The IPT color appearance model excels at providing a formulation for hue where a constant hue value equals a constant perceived hue independent of the values of lightness and chroma (which is the general ideal for any color appearance model, but hard to achieve). It is therefore well-suited for gamut mapping implementations.</p> <p>Learn more.</p>"},{"location":"colors/ipt/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>i</code> <code>intensity</code> <code>p</code> <code>protan</code> <code>t</code> <code>tritan</code> <p>Inputs</p> <p>The IPT space is not currently supported in the CSS spec, the parsed input and string output formats use the <code>color()</code> function format using the custom name <code>--ipt</code>:</p> <pre><code>color(--ipt i p t / a)  // Color function\n</code></pre> <p>The string representation of the color object and the default string output use the <code>color(--ipt i p t / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"ipt\", [0.45616, 0.62086, 0.44282])\ncolor(--ipt 0.45616 0.62086 0.44282 / 1)\n&gt;&gt;&gt; Color(\"ipt\", [0.64877, 0.189, 0.5303]).to_string()\n'color(--ipt 0.64877 0.189 0.5303)'\n</code></pre> Gamut: srgb"},{"location":"colors/ipt/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.ipt import IPT\n\nclass Color(Base): ...\n\nColor.register(IPT())\n</code></pre>"},{"location":"colors/jzazbz/","title":"Jzazbz","text":"<p>The Jzazbz color space is registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>jzazbz</code></p> <p>White Point: D65 / 2\u02da</p> <p>Coordinates:</p> Name Range<sup>*</sup> <code>jz</code> [0, 1] <code>az</code> [-0.21, 0.21] <code>bz</code> [-0.21, 0.21] <p><sup>*</sup> Space is not bound to the defined range above but represents a practical range for HDR color spaces. CSS uses a range of <code>jz</code> = [0, 1], <code>az</code> = [-1, 1] and <code>bz</code> = [1, 1] for percentage input and output.</p> <p></p> <p>Figure 1. The sRGB gamut represented within the Jzazbz color space.</p> <p>Jzazbz is a a color space designed for perceptual uniformity in high dynamic range (HDR) and wide color gamut (WCG) applications. Conceptually it is similar to CIELab, but claims the following improvements:</p> <ul> <li>Perceptual color difference is predicted by Euclidean distance.</li> <li>Perceptually uniform: MacAdam ellipses of just-noticeable-difference (JND) are more circular, and closer to the same   sizes.</li> <li>Hue linearity: changing saturation or lightness has less shift in hue.</li> </ul> <p>Learn about Jzazbz</p>"},{"location":"colors/jzazbz/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>jz</code> <code>lightness</code>, <code>j</code> <code>az</code> <code>a</code> <code>bz</code> <code>b</code>"},{"location":"colors/jzazbz/#inputoutput","title":"Input/Output","text":"<p>Parsed input and string output formats support all valid CSS forms in addition to allowing the <code>color()</code> function format as well using the custom name <code>--jzazbz</code>.</p> <pre><code>jzazbz(jz az bz / a)          // Jzazbz function\ncolor(--jzazbz jz az bz / a)  // Color function\n</code></pre> <p>The string representation of the color object will always default to the <code>color(--jzazbz jz az bz / a)</code> form, but the default string output will be the <code>jzazbz(jz az bz / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"jzazbz\", [0.13438, 0.11789, 0.11188])\ncolor(--jzazbz 0.13438 0.11789 0.11188 / 1)\n&gt;&gt;&gt; Color(\"jzazbz\", [0.16937, 0.0312, 0.12308]).to_string()\n'jzazbz(0.16937 0.0312 0.12308)'\n&gt;&gt;&gt; Color(\"jzazbz\", [0.2096, -0.02864, 0.13479]).to_string(percent=True)\n'jzazbz(20.96% -13.638% 64.186%)'\n&gt;&gt;&gt; Color(\"jzazbz\", [0.09203, -0.07454, 0.07996]).to_string(color=True)\n'color(--jzazbz 0.09203 -0.07454 0.07996)'\n</code></pre> Gamut: srgb"},{"location":"colors/jzazbz/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.jzazbz.css import Jzazbz\n\nclass Color(Base): ...\n\nColor.register(Jzazbz())\n</code></pre>"},{"location":"colors/jzczhz/","title":"JzCzhz","text":"<p>The JzCzhz color space is registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>jzczhz</code></p> <p>White Point: D65 / 2\u02da</p> <p>Coordinates:</p> Name Range <code>jz</code> [0, 1] <code>cz</code> [0, 0.26] <code>hz</code> [0, 360) <p><sup>*</sup> Space is not bound to the defined range above but represents a practical range for HDR color spaces. CSS uses a range of <code>jz</code> = [0, 1] and <code>cz</code> = [0, 1] for percentage input and output.</p> <p></p> <p>Figure 1. The sRGB gamut represented within the JzCzhz color space.</p> <p>JzCzhz is the cylindrical form of Jzazbz.</p> <p>Learn about JzCzhz</p>"},{"location":"colors/jzczhz/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>jz</code> <code>lightness</code>, <code>j</code> <code>cz</code> <code>chroma</code>, <code>c</code> <code>hz</code> <code>hue</code>, <code>h</code>"},{"location":"colors/jzczhz/#inputoutput","title":"Input/Output","text":"<p>Parsed input and string output formats support all valid CSS forms in addition to allowing the <code>color()</code> function format as well using the custom name <code>--jzczhz</code>.</p> <pre><code>jzczhz(jz cz hz / a)          // Jzazbz function\ncolor(--jzczhz jz cz hz / a)  // Color function\n</code></pre> <p>The string representation of the color object will always default to the <code>color(--jzczhz jz cz hz / a)</code> form, but the default string output will be the <code>jzczhz(jz cz hz / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"jzczhz\", [0.13438, 0.16252, 43.502])\ncolor(--jzczhz 0.13438 0.16252 43.502 / 1)\n&gt;&gt;&gt; Color(\"jzczhz\", [0.16937, 0.12698, 75.776]).to_string()\n'jzczhz(0.16937 0.12698 75.776)'\n&gt;&gt;&gt; Color(\"jzczhz\", [0.2096, 0.1378, 102]).to_string(percent=True)\n'jzczhz(20.96% 53% 102)'\n&gt;&gt;&gt; Color(\"jzczhz\", [0.09203, 0.10932, 132.99]).to_string(color=True)\n'color(--jzczhz 0.09203 0.10932 132.99)'\n</code></pre> Gamut: srgb"},{"location":"colors/jzczhz/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.jzczhz.css import JzCzhz\n\nclass Color(Base): ...\n\nColor.register(JzCzhz())\n</code></pre>"},{"location":"colors/lab/","title":"LAB D50","text":"<p>The Lab D50 color space is registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>lab</code></p> <p>White Point: D50 / 2\u02da</p> <p>Coordinates:</p> Name Range<sup>*</sup> <code>l</code> [0, 100] <code>a</code> [-125, 125] <code>b</code> [-125, 125] <p><sup>*</sup> Space is not bound to the range and is only used as a reference to define percentage inputs/outputs in relation to the Display P3 color space.</p> <p></p> <p>Figure 1. The sRGB gamut represented within the CIELab D50 color space.</p> <p>The CIELab color space also referred to as L*a*b* is a color space defined by the International Commission on Illumination (abbreviated CIE) in 1976. It expresses color as three values: L* for perceptual lightness, and a* and b* for the four unique colors of human vision: red, green, blue, and yellow. CIELab was intended as a perceptually uniform space, where a given numerical change corresponds to similar perceived change in color. While the CIELab space is not truly perceptually uniform, it nevertheless is useful in industry for detecting small differences in color.</p> <p>Learn about CIELab</p>"},{"location":"colors/lab/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>l</code> <code>lightness</code> <code>a</code> <code>b</code>"},{"location":"colors/lab/#inputoutput","title":"Input/Output","text":"<p>Parsed input and string output formats support all valid CSS forms. In addition, we also allow the <code>color()</code> function format using the custom name <code>--lab</code>:</p> <pre><code>lab(l a b / a)          // Lab function\ncolor(--lab l a b / a)  // Color function\n</code></pre> <p>When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used:</p> <pre><code>Color(\"lab\", [0, 0, 0], 1)\n</code></pre> <p>The string representation of the color object will always default to the <code>color(--lab l a b / a)</code> form, but the default string output will be the <code>lab(l a b / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"lab\", [54.291, 80.805, 69.891])\ncolor(--lab 54.291 80.805 69.891 / 1)\n&gt;&gt;&gt; Color(\"lab\", [75.59, 27.516, 79.121]).to_string()\n'lab(75.59 27.516 79.121)'\n&gt;&gt;&gt; Color(\"lab\", [97.607, -15.75, 93.394]).to_string(percent=True)\n'lab(97.607% -12.6% 74.715%)'\n&gt;&gt;&gt; Color(\"lab\", [46.278, -47.552, 48.586]).to_string(color=True)\n'color(--lab 46.278 -47.552 48.586)'\n</code></pre> Gamut: srgb"},{"location":"colors/lab/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.lab import Lab\n\nclass Color(Base): ...\n\nColor.register(Lab())\n</code></pre>"},{"location":"colors/lab_d65/","title":"Lab D65","text":"<p>The Lab D65 color space is registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>lab-d65</code></p> <p>White Point: D65 / 2\u02da</p> <p>Coordinates:</p> Name Range<sup>*</sup> <code>l</code> [0, 100] <code>a</code> [-130, 130] <code>b</code> [-130, 130] <p><sup>*</sup> Space is not bound to the range and is only used as a reference to define percentage inputs/outputs in relation to the Display P3 color space.</p> <p></p> <p>Figure 1. The sRGB gamut represented within the CIELab D50 color space.</p> <p>CIELab D65 is the same as CIELab except it uses a D65 white point.</p> <p>Learn about CIELab</p>"},{"location":"colors/lab_d65/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>l</code> <code>lightness</code> <code>a</code> <code>b</code>"},{"location":"colors/lab_d65/#inputoutput","title":"Input/Output","text":"<p>As a D65 variant of CIELab is not currently supported in the CSS spec, the parsed input and string output formats use the <code>color()</code> function format using the custom name <code>--lab-d65</code>:</p> <pre><code>color(--lab-d65 l a b / a)  // Color function\n</code></pre> <p>When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used:</p> <pre><code>Color(\"lab-d65\", [0, 0, 0], 1)\n</code></pre> <p>The string representation of the color object and the default string output use the <code>color(--lab-d65 l a b / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"lab-d65\", [53.237, 80.09, 67.203])\ncolor(--lab-d65 53.237 80.09 67.203 / 1)\n&gt;&gt;&gt; Color(\"lab-d65\", [74.934, 23.927, 78.953]).to_string()\n'color(--lab-d65 74.934 23.927 78.953)'\n</code></pre> Gamut: srgb"},{"location":"colors/lab_d65/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.lab_d65 import LabD65\n\nclass Color(Base): ...\n\nColor.register(LabD65())\n</code></pre>"},{"location":"colors/lch/","title":"LCh D50","text":"<p>The LCh D50 color space is registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>lch</code></p> <p>White Point: D50 / 2\u02da</p> <p>Coordinates:</p> Name Range<sup>*</sup> <code>l</code> [0, 100] <code>c</code> [0, 150] <code>h</code> [0, 360) <p><sup>*</sup> Space is not bound to the range and is only used as a reference to define percentage inputs/outputs in relation to the Display P3 color space.</p> <p></p> <p>Figure 1. The sRGB gamut represented within the CIELCh D50 color space.</p> <p>The \"CIELCh\" space is a color space based on CIELab, which uses the polar coordinates C* (chroma, relative saturation) and h\u00b0 (hue angle, angle of the hue in the CIELab color wheel) instead of the Cartesian coordinates a* and b*. The CIELab lightness L* remains unchanged.</p> <p>Learn about CIELCh</p>"},{"location":"colors/lch/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>l</code> <code>lightness</code> <code>c</code> <code>chroma</code> <code>h</code> <code>hue</code>"},{"location":"colors/lch/#inputoutput","title":"Input/Output","text":"<p>Parsed input and string output formats support all valid CSS forms. In addition, we also allow the <code>color()</code> function format using the custom name <code>--lch</code>:</p> <pre><code>lch(l c h / a)          // LCh function\ncolor(--lch l c h / a)  // Color function\n</code></pre> <p>When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used:</p> <pre><code>Color(\"lch\", [0, 0, 0], 1)\n</code></pre> <p>The string representation of the color object will always default to the <code>color(--lch l c h / a)</code> form, but the default string output will be the <code>lch(l c h / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"lch\", [54.291, 106.84, 40.858])\ncolor(--lch 54.291 106.84 40.858 / 1)\n&gt;&gt;&gt; Color(\"lch\", [75.59, 83.769, 70.824]).to_string()\n'lch(75.59 83.769 70.824)'\n&gt;&gt;&gt; Color(\"lch\", [97.607, 94.712, 99.572]).to_string(percent=True)\n'lch(97.607% 63.141% 99.572)'\n&gt;&gt;&gt; Color(\"lch\", [46.278, 67.984, 134.38]).to_string(color=True)\n'color(--lch 46.278 67.984 134.38)'\n</code></pre> Gamut: srgb"},{"location":"colors/lch/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.lch import LCh\n\nclass Color(Base): ...\n\nColor.register(LCh())\n</code></pre>"},{"location":"colors/lch99o/","title":"DIN99o LCh","text":"<p>The DIN99o LCh color space is not registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>lch99o</code></p> <p>White Point: D65 / 2\u02da</p> <p>Coordinates:</p> Name Range<sup>*</sup> <code>l</code> [0, 100] <code>c</code> [0, 60] <code>h</code> [0, 360) <p><sup>*</sup> Space is not bound to the range and is only used as a reference to define percentage inputs/outputs in relation to the Display P3 color space.</p> <p></p> <p>Figure 1. The sRGB gamut represented within the DIN99o LCh color space.</p> <p>DIN99o LCh is the cylindrical form of DIN99o.</p> <p>Learn about DIN99o LCh</p>"},{"location":"colors/lch99o/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>l</code> <code>lightness</code> <code>c</code> <code>chroma</code> <code>h</code> <code>hue</code>"},{"location":"colors/lch99o/#inputoutput","title":"Input/Output","text":"<p>As DIN99o LCh is not currently supported in the CSS spec, the parsed input and string output formats use the <code>color()</code> function format using the custom name <code>--lch99o</code>:</p> <pre><code>color(--lch99o jz cz hz / a)  // Color function\n</code></pre> <p>When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used:</p> <pre><code>Color(\"lch99o\", [0, 0, 0], 1)\n</code></pre> <p>The string representation of the color object and the default string output use the <code>color(--lch99o jz cz hz / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"lch99o\", [57.289, 49.915, 37.692])\ncolor(--lch99o 57.289 49.915 37.692 / 1)\n&gt;&gt;&gt; Color(\"lch99o\", [77.855, 43.543, 67.811]).to_string()\n'color(--lch99o 77.855 43.543 67.811)'\n</code></pre> Gamut: srgb"},{"location":"colors/lch99o/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.lch99o import LCh99o\n\nclass Color(Base): ...\n\nColor.register(LCh99o())\n</code></pre>"},{"location":"colors/lch_d65/","title":"LCh D65","text":"<p>The LCh D65 color space is registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>lch-d65</code></p> <p>White Point: D65 / 2\u02da</p> <p>Coordinates:</p> Name Range<sup>*</sup> <code>l</code> [0, 100] <code>c</code> [0, 160] <code>h</code> [0, 360) <p><sup>*</sup> Space is not bound to the range and is only used as a reference to define percentage inputs/outputs in relation to the Display P3 color space.</p> <p></p> <p>Figure 1. The sRGB gamut represented within the CIELCh D65 color space.</p> <p>CIELCh D65 is the same as CIELCh except it uses a D65 white point.</p> <p>Learn about CIELCh</p>"},{"location":"colors/lch_d65/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>l</code> <code>lightness</code> <code>c</code> <code>chroma</code> <code>h</code> <code>hue</code>"},{"location":"colors/lch_d65/#inputoutput","title":"Input/Output","text":"<p>As a D65 variant of CIELCh is not currently supported in the CSS spec, the parsed input and string output formats use the <code>color()</code> function format using the custom name <code>--lch-d65</code>:</p> <pre><code>color(--lch-d65 l c h / a)  // Color function\n</code></pre> <p>When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used:</p> <pre><code>Color(\"lch-d65\", [0, 0, 0], 1)\n</code></pre> <p>The string representation of the color object and the default string output use the <code>color(--lch-d65 l c h / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"lch-d65\", [53.237, 104.55, 40])\ncolor(--lch-d65 53.237 104.55 40 / 1)\n&gt;&gt;&gt; Color(\"lch-d65\", [74.934, 82.499, 73.14]).to_string()\n'color(--lch-d65 74.934 82.499 73.14)'\n</code></pre> Gamut: srgb"},{"location":"colors/lch_d65/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.lch_d65 import LChD65\n\nclass Color(Base): ...\n\nColor.register(LChD65())\n</code></pre>"},{"location":"colors/lchuv/","title":"LCh<sub>uv</sub>","text":"<p>The LCH<sub>uv</sub> color space is not registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>lchuv</code></p> <p>White Point: D65 / 2\u02da</p> <p>Coordinates:</p> Name Range<sup>*</sup> <code>l</code> [0, 100] <code>c</code> [0, 220] <code>h</code> [0, 360) <p><sup>*</sup> Space is not bound to the range and is only used as a reference to define percentage inputs/outputs in relation to the Display P3 color space.</p> <p></p> <p>Figure 1. The sRGB gamut represented within the CIELCh<sub>uv</sub> color space.</p> <p>CIELuv is not an intuitive space to work with directly and instead is often converted to cylindrical coordinates with hues represented as degrees and a chroma and lightness channel. The shape of the color space doesn't really change, just how the colors are manipulated.</p> <p>Learn about CIELCh<sub>uv</sub></p>"},{"location":"colors/lchuv/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>l</code> <code>lightness</code> <code>c</code> <code>chroma</code> <code>h</code> <code>hue</code>"},{"location":"colors/lchuv/#inputoutput","title":"Input/Output","text":"<p>As CIELCh<sub>uv</sub> is not currently supported in the CSS spec, the parsed input and string output formats use the <code>color()</code> function format using the custom name <code>--lchuv</code>:</p> <pre><code>color(--lchuv l c h / a)  // Color function\n</code></pre> <p>When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used:</p> <pre><code>Color(\"lchuv\", [0, 0, 0], 1)\n</code></pre> <p>The string representation of the color object and the default string output use the <code>color(--lchuv l c h / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"lchuv\", [53.237, 179.04, 12.177])\ncolor(--lchuv 53.237 179.04 12.177 / 1)\n&gt;&gt;&gt; Color(\"lchuv\", [74.934, 105.26, 44.683]).to_string()\n'color(--lchuv 74.934 105.26 44.683)'\n</code></pre> Gamut: srgb"},{"location":"colors/lchuv/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.lchuv import LChuv\n\nclass Color(Base): ...\n\nColor.register(LChuv())\n</code></pre>"},{"location":"colors/luv/","title":"Luv","text":"<p>The Luv color space is not registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>luv</code></p> <p>White Point: D65 / 2\u02da</p> <p>Coordinates:</p> Name Range<sup>*</sup> <code>l</code> [0, 100] <code>u</code> [-215, 215] <code>v</code> [-215, 215] <p><sup>*</sup> Space is not bound to the range and is only used as a reference to define percentage inputs/outputs in relation to the Display P3 color space.</p> <p></p> <p>Figure 1. The sRGB gamut represented within the CIELuv D65 color space.</p> <p>CIELuv is similar to CIELab as they were both developed in 1976 as perceptually uniform color spaces, both are derived from the color experiments in 1931 that brought us the XYZ color space, and neither are truly perceptually uniform.</p> <p>The difference between the two comes from their intent. CIELab attempted to create a space that aligned well with human vision. CIELuv, on the other hand, was designed to be an easier-to-compute transformation of the 1931 CIE XYZ color space.</p> <p>CIELab is more commonly used in subtractive color applications (printed pages, dyes, etc.), while CIELuv is better suited in additive color applications such as display colorimetry (monitors, TVs, etc.).</p> <p>Learn about CIELuv</p>"},{"location":"colors/luv/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>l</code> <code>lightness</code> <code>u</code> <code>v</code>"},{"location":"colors/luv/#inputoutput","title":"Input/Output","text":"<p>As CIELuv D65 is not currently supported in the CSS spec, the parsed input and string output formats use the <code>color()</code> function format using the custom name <code>--luv</code>:</p> <pre><code>color(--luv l u v / a)  // Color function\n</code></pre> <p>When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used:</p> <pre><code>Color(\"luv\", [0, 0, 0], 1)\n</code></pre> <p>The string representation of the color object and the default string output use the <code>color(--luv l u v / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"luv\", [53.237, 175.01, 37.765])\ncolor(--luv 53.237 175.01 37.765 / 1)\n&gt;&gt;&gt; Color(\"luv\", [74.934, 74.839, 74.014]).to_string()\n'color(--luv 74.934 74.839 74.014)'\n</code></pre> Gamut: srgb"},{"location":"colors/luv/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.luv import Luv\n\nclass Color(Base): ...\n\nColor.register(Luv())\n</code></pre>"},{"location":"colors/okhsl/","title":"Okhsl","text":"<p>The Okhsl color space is not registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>okhsl</code></p> <p>White Point: D65 / 2\u02da</p> <p>Coordinates:</p> Name Range <code>h</code> [0, 360) <code>s</code> [0, 1] <code>l</code> [0, 1] <p></p> <p>Figure 1. Okhsl color space in 3D</p> <p>Okhsl was created by Bj\u00f6rn Ottosson and is a transform of the Oklab color space that approximates the sRGB gamut perceptually in an HSL color model. The aim was to create a color space that was better suited for being used in color pickers than the current HSL.</p> <p>Learn about Okhsv</p>"},{"location":"colors/okhsl/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>h</code> <code>hue</code> <code>s</code> <code>saturation</code> <code>l</code> <code>lightness</code>"},{"location":"colors/okhsl/#inputoutput","title":"Input/Output","text":"<p>Okhsl is not currently supported in the CSS spec, the parsed input and string output formats use the <code>color()</code> function format using the custom name <code>--okhsl</code>:</p> <pre><code>color(--okhsl h s l / a)  // Color function\n</code></pre> <p>When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used:</p> <pre><code>Color(\"okhsl\", [0, 0, 0], 1)\n</code></pre> <p>The string representation of the color object and the default string output use the <code>color(--okhsl h s l / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"okhsl\", [29.234, 1, 0.56808], 1)\ncolor(--okhsl 29.234 1 0.56808 / 1)\n&gt;&gt;&gt; Color(\"okhsl\", [70.67, 1, 0.75883], 1).to_string()\n'color(--okhsl 70.67 1 0.75883)'\n</code></pre> Gamut: srgb"},{"location":"colors/okhsl/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.okhsl import Okhsl\n\nclass Color(Base): ...\n\nColor.register(Okhsl())\n</code></pre>"},{"location":"colors/okhsv/","title":"Okhsv","text":"<p>The Okhsv color space is not registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>okhsv</code></p> <p>White Point: D65 / 2\u02da</p> <p>Coordinates:</p> Name Range <code>h</code> [0, 360) <code>s</code> [0, 1] <code>v</code> [0, 1] <p></p> <p>Figure 1. Okhsv color space in 3D</p> <p>Okhsv was created by Bj\u00f6rn Ottosson and is a transform of the Oklab color space that approximates the sRGB gamut perceptually in an HSL color model. The aim was to create a color space that was better suited for being used in color pickers than the current HSV.</p> <p>Learn about Okhsv</p>"},{"location":"colors/okhsv/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>h</code> <code>hue</code> <code>s</code> <code>saturation</code> <code>v</code> <code>value</code>"},{"location":"colors/okhsv/#inputoutput","title":"Input/Output","text":"<p>Okhsv is not currently supported in the CSS spec, the parsed input and string output formats use the <code>color()</code> function format using the custom name <code>--okhsv</code>:</p> <pre><code>color(--okhsv h s l / a)  // Color function\n</code></pre> <p>When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used:</p> <pre><code>Color(\"okhsv\", [0, 0, 0], 1)\n</code></pre> <p>The string representation of the color object and the default string output use the <code>color(--okhsv h s l / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"okhsv\", [29.234, 1, 1])\ncolor(--okhsv 29.234 1 1 / 1)\n&gt;&gt;&gt; Color(\"okhsv\", [70.67, 1, 1]).to_string()\n'color(--okhsv 70.67 1 1)'\n</code></pre> Gamut: srgb"},{"location":"colors/okhsv/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.okhsv import Okhsv\n\nclass Color(Base): ...\n\nColor.register(Okhsv())\n</code></pre>"},{"location":"colors/oklab/","title":"Oklab","text":"<p>The Oklab color space is registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>oklab</code></p> <p>White Point: D65 / 2\u02da</p> <p>Coordinates:</p> Name Range<sup>*</sup> <code>l</code> [0, 1] <code>a</code> [-0.4, 0.4] <code>b</code> [-0.4, 0.4] <p><sup>*</sup> Space is not bound to the range and is only used as a reference to define percentage inputs/outputs in relation to the Display P3 color space.</p> <p></p> <p>Figure 1. The sRGB gamut represented within the Oklab color space.</p> <p>A new perceptual color space that claims to be simple to use, while doing a good job at predicting perceived lightness, chroma and hue. It is called the Oklab color space, because it is an OK Lab color space.</p> <p>Learn about Oklab</p>"},{"location":"colors/oklab/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>l</code> <code>lightness</code> <code>a</code> <code>b</code>"},{"location":"colors/oklab/#inputoutput","title":"Input/Output","text":"<p>Parsed input and string output formats support all valid CSS forms in addition to allowing the <code>color()</code> function format as well using the custom name <code>--oklab</code>.</p> <pre><code>oklab(l a b / a)          // Oklab function\ncolor(--oklab l a b / a)  // Color function\n</code></pre> <p>When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used:</p> <pre><code>Color(\"oklab\", [0, 0, 0], 1)\n</code></pre> <p>The string representation of the color object will always default to the <code>color(--oklab l a b / a)</code> form, but the default string output will be the <code>oklab(l a b / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"oklab\", [0.62796, 0.22486, 0.12585])\ncolor(--oklab 0.62796 0.22486 0.12585 / 1)\n&gt;&gt;&gt; Color(\"oklab\", [0.79269, 0.05661, 0.16138]).to_string()\n'oklab(0.79269 0.05661 0.16138)'\n&gt;&gt;&gt; Color(\"oklab\", [0.96798, -0.07137, 0.19857]).to_string(percent=True)\n'oklab(96.798% -17.842% 49.643%)'\n&gt;&gt;&gt; Color(\"oklab\", [0.51975, -0.1403, 0.10768]).to_string(color=True)\n'color(--oklab 0.51975 -0.1403 0.10768)'\n</code></pre> Gamut: srgb"},{"location":"colors/oklab/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.oklab import Oklab\n\nclass Color(Base): ...\n\nColor.register(Oklab())\n</code></pre>"},{"location":"colors/oklch/","title":"OkLCh","text":"<p>The OkLCh color space is registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>oklch</code></p> <p>White Point: D65 / 2\u02da / 2\u02da</p> <p>Coordinates:</p> Name Range<sup>*</sup> <code>l</code> [0, 1] <code>c</code> [0, 0.4] <code>h</code> [0, 360) <p><sup>*</sup> Space is not bound to the range and is only used as a reference to define percentage inputs/outputs in relation to the Display P3 color space.</p> <p></p> <p>Figure 1. The sRGB gamut represented within the OkLCh color space.</p> <p>OkLCh is the cylindrical form of Oklab.</p> <p>Learn about OkLCh</p>"},{"location":"colors/oklch/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>l</code> <code>lightness</code> <code>c</code> <code>chroma</code> <code>h</code> <code>hue</code>"},{"location":"colors/oklch/#inputoutput","title":"Input/Output","text":"<p>Parsed input and string output formats support all valid CSS forms. Additionally, the <code>color()</code> function format can be used as well with the custom name <code>--oklch</code>.</p> <pre><code>oklch(l c h / a)          // OkLCh function\ncolor(--oklch l c h / a)  // Color function\n</code></pre> <p>The string representation of the color object will always default to the <code>color(--oklch l c h / a)</code> form, but the default string output will be the <code>oklch(l a b / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"oklch\", [0.62796, 0.25768, 29.234])\ncolor(--oklch 0.62796 0.25768 29.234 / 1)\n&gt;&gt;&gt; Color(\"oklch\", [0.79269, 0.17103, 70.67]).to_string()\n'oklch(0.79269 0.17103 70.67)'\n&gt;&gt;&gt; Color(\"oklch\", [0.96798, 0.21101, 109.77]).to_string(percent=True)\n'oklch(96.798% 52.753% 109.77)'\n&gt;&gt;&gt; Color(\"oklch\", [0.51975, 0.17686, 142.5]).to_string(color=True)\n'color(--oklch 0.51975 0.17686 142.5)'\n</code></pre> Gamut: srgb"},{"location":"colors/oklch/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.oklch import OkLCh\n\nclass Color(Base): ...\n\nColor.register(OkLCh())\n</code></pre>"},{"location":"colors/oklrab/","title":"Okl<sub>r</sub>ab","text":"<p>The Okl<sub>r</sub>ab color space is not registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>oklrab</code></p> <p>White Point: D65 / 2\u02da</p> <p>Coordinates:</p> Name Range<sup>*</sup> <code>l</code> [0, 1] <code>a</code> [-0.4, 0.4] <code>b</code> [-0.4, 0.4] <p><sup>*</sup> Space is not bound to the range and is only used as a reference to define percentage inputs/outputs in relation to the Display P3 color space.</p> <p></p> <p>Figure 1. The sRGB gamut represented within the Okl<sub>r</sub>ab color space.</p> <p>Okl<sub>r</sub>ab is a variation of Oklab that adjusts the lightness estimate to more closely mach that of CIELab. This alternate Oklab was designed as a trade-off for cases when a well defined reference white is desired, such as with Okhsl in color picking.</p> <p>Learn about Oklab</p>"},{"location":"colors/oklrab/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>l</code> <code>lightness</code> <code>a</code> <code>b</code>"},{"location":"colors/oklrab/#inputoutput","title":"Input/Output","text":"<p>Okl<sub>r</sub>ab is not currently supported in the CSS spec, the parsed input and string output formats use the  <code>color()</code> function format using the custom name <code>--oklrab</code>:</p> <pre><code>color(--oklrab l a b / a)  // Color function\n</code></pre> <p>When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used:</p> <pre><code>Color(\"oklrab\", [0, 0, 0], 1)\n</code></pre> <p>The string representation of the color object and the default string output use the <code>color(--oklrab l a b / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"oklrab\", [0.56808, 0.22486, 0.12585])\ncolor(--oklrab 0.56808 0.22486 0.12585 / 1)\n&gt;&gt;&gt; Color(\"oklrab\", [0.75883, 0.05661, 0.16138]).to_string()\n'color(--oklrab 0.75883 0.05661 0.16138)'\n&gt;&gt;&gt; Color(\"oklrab\", [0.9627, -0.07137, 0.19857]).to_string(percent=True)\n'color(--oklrab 96.27% -17.842% 49.643%)'\n</code></pre> Gamut: srgb"},{"location":"colors/oklrab/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.oklrab import Oklrab\n\nclass Color(Base): ...\n\nColor.register(Oklrab())\n</code></pre>"},{"location":"colors/oklrch/","title":"OkL<sub>r</sub>Ch","text":"<p>The OkL<sub>r</sub>Ch color space is not registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>oklrch</code></p> <p>White Point: D65 / 2\u02da / 2\u02da</p> <p>Coordinates:</p> Name Range<sup>*</sup> <code>l</code> [0, 1] <code>c</code> [0, 0.4] <code>h</code> [0, 360) <p><sup>*</sup> Space is not bound to the range and is only used as a reference to define percentage inputs/outputs in relation to the Display P3 color space.</p> <p></p> <p>Figure 1. The sRGB gamut represented within the OkL<sub>r</sub>Ch color space.</p> <p>OkL<sub>r</sub>Ch is the polar form of Okl<sub>r</sub>ab.</p> <p>Learn about OkL<sub>r</sub>Ch</p>"},{"location":"colors/oklrch/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>l</code> <code>lightness</code> <code>c</code> <code>chroma</code> <code>h</code> <code>hue</code>"},{"location":"colors/oklrch/#inputoutput","title":"Input/Output","text":"<p>OkL<sub>r</sub>Ch is not currently supported in the CSS spec, the parsed input and string output formats use the  <code>color()</code> function format using the custom name <code>--oklrch</code>:</p> <pre><code>color(--oklrch l a b / a)  // Color function\n</code></pre> <p>When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used:</p> <pre><code>Color(\"oklrch\", [0, 0, 0], 1)\n</code></pre> <p>The string representation of the color object and the default string output use the <code>color(--oklrch l c h / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"oklrch\", [0.56808, 0.25768, 29.234])\ncolor(--oklrch 0.56808 0.25768 29.234 / 1)\n&gt;&gt;&gt; Color(\"oklrch\", [0.75883, 0.17103, 70.67]).to_string()\n'color(--oklrch 0.75883 0.17103 70.67)'\n&gt;&gt;&gt; Color(\"oklrch\", [0.9627, 0.21101, 109.77]).to_string(percent=True)\n'color(--oklrch 96.27% 52.753% 109.77)'\n</code></pre> Gamut: srgb"},{"location":"colors/oklrch/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.oklrch import OkLrCh\n\nclass Color(Base): ...\n\nColor.register(OkLrCh())\n</code></pre>"},{"location":"colors/orgb/","title":"oRGB","text":"<p>The oRGB color space is not registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>orgb</code></p> <p>White Point: D65 / 2\u02da</p> <p>Coordinates:</p> Name Range<sup>*</sup> <code>l</code> [0, 1] <code>cyb</code> [-1, 1] <code>crg</code> [-1, 1] <p><sup>*</sup> Range denotes in gamut colors, but the color space supports an extended range beyond the gamut.</p> <p></p> <p>Figure 1. The sRGB gamut represented within the oRGB color space.</p> <p>A new color model that is based on opponent color theory. Like HSV, it is designed specifically for computer graphics. However, it is also designed to work well for computational applications such as color transfer, where HSV falters. Despite being geared towards computation, oRGB's natural axes facilitate HSV-style color selection and manipulation. oRGB also allows for new applications such as a quantitative cool-to-warm metric, intuitive color manipulations and variations, and simple gamut mapping. This new color model strikes a balance between simplicity and the computational qualities of color spaces such as CIELab.</p> <p>Learn more.</p>"},{"location":"colors/orgb/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>l</code> <code>luma</code> <code>cyb</code> <code>crb</code>"},{"location":"colors/orgb/#inputoutput","title":"Input/Output","text":"<p>The oRGB space is not currently supported in the CSS spec, the parsed input and string output formats use the <code>color()</code> function format using the custom name <code>--orgb</code>:</p> <pre><code>color(--orgb l cyb crb / a)  // Color function\n</code></pre> <p>The string representation of the color object and the default string output use the <code>color(--orgb l cyb crg / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"orgb\", [0.299, 0.00002, 0.99998])\ncolor(--orgb 0.299 0.00002 0.99998 / 1)\n&gt;&gt;&gt; Color(\"orgb\", [0.67882, 0.75654, 0.4464]).to_string()\n'color(--orgb 0.67882 0.75653 0.4464)'\n</code></pre> Gamut: srgb"},{"location":"colors/orgb/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.orgb import oRGB\n\nclass Color(Base): ...\n\nColor.register(oRGB())\n</code></pre>"},{"location":"colors/prismatic/","title":"Prismatic","text":"<p>The oRGB color space is not registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>prismatic</code></p> <p>White Point: D65 / 2\u02da</p> <p>Coordinates:</p> Name Range <code>l</code> [0, 1] <code>r</code> [0, 1] <code>g</code> [0, 1] <code>b</code> [0, 1] <p></p> <p>Figure 1. Prismatic Illustrations</p> <p>The Prismatic model introduces a simple transform of the RGB color cube into a light/dark dimension and a 2D hue. The hue is a normalized (barycentric)triangle with pure red, green, and blue at the vertices, often called the Maxwell Color Triangle.  Each cross section of the space is the same barycentric triangle, and the light/dark dimension runs zero to one for each hue so the whole color volume takes the form of a prism.</p> <p>Learn more.</p>"},{"location":"colors/prismatic/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>l</code> <code>lightness</code> <code>r</code> <code>red</code> <code>g</code> <code>green</code> <code>b</code> <code>blue</code>"},{"location":"colors/prismatic/#inputoutput","title":"Input/Output","text":"<p>The Prismatic space is not currently supported in the CSS spec, the parsed input and string output formats use the <code>color()</code> function format using the custom name <code>--prismatic</code>:</p> <pre><code>color(--prismatic l r g b / a)  // Color function\n</code></pre> <p>The string representation of the color object and the default string output use the <code>color(--prismatic l r g b / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"prismatic\", [1, 1, 0, 0])\ncolor(--prismatic 1 1 0 0 / 1)\n&gt;&gt;&gt; Color(\"prismatic\", [1, 0.60714, 0.39286, 0], 1).to_string()\n'color(--prismatic 1 0.60714 0.39286 0)'\n</code></pre> Gamut: srgb"},{"location":"colors/prismatic/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.prismatic import Prismatic\n\nclass Color(Base): ...\n\nColor.register(Prismatic())\n</code></pre>"},{"location":"colors/prophoto_rgb/","title":"ProPhoto","text":"<p>The ProPhoto color space is registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>prophoto-rgb</code></p> <p>White Point: D50 / 2\u02da</p> <p>Coordinates:</p> Name Range<sup>*</sup> <code>r</code> [0, 1] <code>g</code> [0, 1] <code>b</code> [0, 1] <p><sup>*</sup> Range denotes in gamut colors, but the color space supports an extended range beyond the gamut.</p> <p></p> <p>Figure 1. CIE 1931 xy Chromaticity \u2013 ProPhoto RGB Chromaticities</p> <p>The ProPhoto RGB color space, also known as ROMM RGB (Reference Output Medium Metric), is an output referred RGB color space developed by Kodak. It offers an especially large gamut designed for use with photographic output in mind. The ProPhoto RGB color space encompasses over 90% of possible surface colors in the CIE L*a*b* color space, and 100% of likely occurring real-world surface colors documented by Pointer in 1980.</p> <p>Learn about ProPhoto</p>"},{"location":"colors/prophoto_rgb/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>r</code> <code>red</code> <code>g</code> <code>green</code> <code>b</code> <code>blue</code>"},{"location":"colors/prophoto_rgb/#inputoutput","title":"Input/Output","text":"<p>Parsed input and string output formats support all valid CSS forms:</p> <pre><code>color(prophoto-rgb r g b / a)  // Color function\n</code></pre> <p>When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used:</p> <pre><code>Color(\"prophoto-rgb\", [0, 0, 0], 1)\n</code></pre> <p>The string representation of the color object and the default string output will be in the <code>color(prophoto-rgb r g b / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"prophoto-rgb\", [0.78951, 0.62329, 0.21172], 1)\ncolor(prophoto-rgb 0.78951 0.62329 0.21172 / 1)\n&gt;&gt;&gt; Color(\"prophoto-rgb\", [0.70225, 0.27572, 0.10355]).to_string()\n'color(prophoto-rgb 0.70225 0.27572 0.10355)'\n</code></pre> Gamut: srgb"},{"location":"colors/prophoto_rgb/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.prophoto_rgb import ProPhotoRGB\n\nclass Color(Base): ...\n\nColor.register(ProPhotoRGB())\n</code></pre>"},{"location":"colors/prophoto_rgb_linear/","title":"Linear ProPhoto","text":"<p>The Linear ProPhoto color space is registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>prophoto-rgb-linear</code></p> <p>White Point: D50 / 2\u02da</p> <p>Coordinates:</p> Name Range<sup>*</sup> <code>r</code> [0, 1] <code>g</code> [0, 1] <code>b</code> [0, 1] <p><sup>*</sup> Range denotes in gamut colors, but the color space supports an extended range beyond the gamut.</p> <p></p> <p>Figure 1. CIE 1931 xy Chromaticity \u2013 ProPhoto RGB Chromaticities</p> <p>The Linear ProPhoto space is the same as ProPhoto except that the transfer function is linear-light (there is no gamma-encoding).</p> <p>Learn about ProPhoto</p>"},{"location":"colors/prophoto_rgb_linear/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>r</code> <code>red</code> <code>g</code> <code>green</code> <code>b</code> <code>blue</code>"},{"location":"colors/prophoto_rgb_linear/#inputoutput","title":"Input/Output","text":"<p>Linear ProPhoto is not supported via the CSS spec and the parser input and string output only supports the <code>color()</code> function format using the custom name <code>--prophoto-rgb-linear</code>:</p> <pre><code>color(--prophoto-rgb-linear r g b / a)  // Color function\n</code></pre> <p>When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used:</p> <pre><code>Color(\"prophoto-rgb-linear\", [0, 0, 0], 1)\n</code></pre> <p>The string representation of the color object and the default string output will be in the <code>color(--prophoto-rgb-linear r g b / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"prophoto-rgb-linear\", [0.52928, 0.09837, 0.01688])\ncolor(--prophoto-rgb-linear 0.52928 0.09837 0.01688 / 1)\n&gt;&gt;&gt; Color(\"prophoto-rgb-linear\", [0.6535, 0.42702, 0.06115]).to_string()\n'color(--prophoto-rgb-linear 0.6535 0.42702 0.06115)'\n</code></pre> Gamut: srgb"},{"location":"colors/prophoto_rgb_linear/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.prophoto_rgb_linear import ProPhotoRGBLinear\n\nclass Color(Base): ...\n\nColor.register(ProPhotoRGBLinear())\n</code></pre>"},{"location":"colors/rec2020/","title":"REC. 2020","text":"<p>The Rec. 2020 color space is registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>rec2020</code></p> <p>White Point: D65 / 2\u02da</p> <p>Coordinates:</p> Name Range<sup>*</sup> <code>r</code> [0, 1] <code>g</code> [0, 1] <code>b</code> [0, 1] <p><sup>*</sup> Range denotes in gamut colors, but the color space supports an extended range beyond the gamut.</p> <p></p> <p>Figure 1. CIE 1931 xy Chromaticity \u2013 Rec. 2020 Chromaticities</p> <p>ITU-R Recommendation BT.2020, more commonly known by the abbreviations Rec. 2020 or BT.2020, defines various aspects of ultra-high-definition television (UHDTV) with standard dynamic range (SDR) and wide color gamut (WCG), including picture resolutions, frame rates with progressive scan, bit depths, color primaries, RGB and luma-chroma color representations, chroma subsamplings, and an opto-electronic transfer function. The color is used in 4k and 8k UHDTV.</p> <p>Learn about REC.2020</p>"},{"location":"colors/rec2020/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>r</code> <code>red</code> <code>g</code> <code>green</code> <code>b</code> <code>blue</code>"},{"location":"colors/rec2020/#inputoutput","title":"Input/Output","text":"<p>Parsed input and string output formats support all valid CSS forms:</p> <pre><code>color(rec2020 r g b / a)  // Color function\n</code></pre> <p>When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used:</p> <pre><code>Color(\"rec2020\", [0, 0, 0], 1)\n</code></pre> <p>The string representation of the color object and the default string output will be in the <code>color(rec2020 r g b / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"rec2020\", [0.79198, 0.23098, 0.07376])\ncolor(rec2020 0.79198 0.23098 0.07376 / 1)\n&gt;&gt;&gt; Color(\"rec2020\", [0.86727, 0.64078, 0.18496]).to_string()\n'color(rec2020 0.86727 0.64078 0.18496)'\n</code></pre> Gamut: srgb"},{"location":"colors/rec2020/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.rec2020 import Rec2020\n\nclass Color(Base): ...\n\nColor.register(Rec2020())\n</code></pre>"},{"location":"colors/rec2020_linear/","title":"Linear REC. 2020","text":"<p>The Linear Rec. 2020 color space is registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>rec2020-linear</code></p> <p>White Point: D65 / 2\u02da</p> <p>Coordinates:</p> Name Range<sup>*</sup> <code>r</code> [0, 1] <code>g</code> [0, 1] <code>b</code> [0, 1] <p><sup>*</sup> Range denotes in gamut colors, but the color space supports an extended range beyond the gamut.</p> <p></p> <p>Figure 1. CIE 1931 xy Chromaticity \u2013 Rec. 2020 Chromaticities</p> <p>The Linear Rec. 2020 space is the same as Rec. 2020 except that the transfer function is linear-light (there is no gamma-encoding).</p> <p>Learn about REC.2020</p>"},{"location":"colors/rec2020_linear/#channel-aliases","title":"Channel Aliases:**","text":"Channels Aliases <code>r</code> <code>red</code> <code>g</code> <code>green</code> <code>b</code> <code>blue</code>"},{"location":"colors/rec2020_linear/#inputoutput","title":"Input/Output","text":"<p>Linear Rec. 2020 is not supported via the CSS spec and the parser input and string output only supports the <code>color()</code> function format using the custom name <code>--rec2020-linear</code>:</p> <pre><code>color(--rec2020-linear r g b / a)  // Color function\n</code></pre> <p>When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used:</p> <pre><code>Color(\"rec2020-linear\", [0, 0, 0], 1)\n</code></pre> <p>The string representation of the color object and the default string output will be in the <code>color(--rec2020-linear r g b / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"rec2020-linear\", [0.6274, 0.0691, 0.01639])\ncolor(--rec2020-linear 0.6274 0.0691 0.01639 / 1)\n&gt;&gt;&gt; Color(\"rec2020-linear\", [0.7513, 0.41509, 0.04951]).to_string()\n'color(--rec2020-linear 0.7513 0.41509 0.04951)'\n</code></pre> Gamut: srgb"},{"location":"colors/rec2020_linear/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.rec2020_linear import Rec2020Linear\n\nclass Color(Base): ...\n\nColor.register(Rec2020Linear())\n</code></pre>"},{"location":"colors/rec2100_hlg/","title":"REC. 2100 HLG","text":"<p>The Rec. 2100 HLG is registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>rec2100-hlg</code></p> <p>White Point: D65 / 2\u02da</p> <p>Coordinates:</p> Name Range <code>r</code> [0, 1] <code>g</code> [0, 1] <code>b</code> [0, 1] <p></p> <p>Figure 1. CIE 1931 xy Chromaticity \u2013 Rec. 2100 Chromaticities (Same as Rec. 2020)</p> <p>BT.2100, more commonly known by the abbreviations Rec. 2100 or BT.2100, introduced high-dynamic-range television (HDR-TV) by recommending the use of the perceptual quantizer (PQ) or hybrid log\u2013gamma (HLG) transfer functions instead of the traditional \"gamma\" previously used for SDR-TV. Rec. 2100 HLG specifically uses the hybrid log-gamma transfer function.</p> <p>The actual gamut of Rec. 2100 uses the same wide color gamut of Rec. 2020, but the color space itself supports an HDR range.</p> <p>Learn about REC.2100</p>"},{"location":"colors/rec2100_hlg/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>r</code> <code>red</code> <code>g</code> <code>green</code> <code>b</code> <code>blue</code>"},{"location":"colors/rec2100_hlg/#inputoutput","title":"Input/Output","text":"<p>Parsed input and string output formats support all valid CSS forms:</p> <pre><code>color(rec2100-hlg r g b / a)  // Color function\n</code></pre> <p>When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used:</p> <pre><code>Color(\"rec2100-hlg\", [0, 0, 0], 1)\n</code></pre> <p>The string representation of the color object and the default string output will be in the <code>color(rec2100-hlg r g b / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"rec2100-hlg\", [0.65587, 0.23436, 0.11415], 1)\ncolor(rec2100-hlg 0.65587 0.23436 0.11415 / 1)\n&gt;&gt;&gt; Color(\"rec2100-hlg\", [0.69294, 0.56608, 0.19838], 1).to_string()\n'color(rec2100-hlg 0.69294 0.56608 0.19838)'\n</code></pre> Gamut: srgb"},{"location":"colors/rec2100_hlg/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.rec2100_hlg import Rec2100HLG\n\nclass Color(Base): ...\n\nColor.register(Rec2100HLG())\n</code></pre>"},{"location":"colors/rec2100_linear/","title":"Linear REC. 2020","text":"<p>The Linear Rec. 2100 color space is registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>rec2100-linear</code></p> <p>White Point: D65 / 2\u02da</p> <p>Coordinates:</p> Name Range<sup>*</sup> <code>r</code> [0, 1] <code>g</code> [0, 1] <code>b</code> [0, 1] <p><sup>*</sup> Range denotes in gamut colors, but the color space supports an extended range beyond the gamut.</p> <p></p> <p>Figure 1. CIE 1931 xy Chromaticity \u2013 Rec. 2020 Chromaticities (the same as Rec. 2100)</p> <p>The Linear Rec. 2100 space is the same as Linear Rec. 2100 and is essentially an alias required by the CSS HDR specification.</p> <p>Learn about REC.2020</p>"},{"location":"colors/rec2100_linear/#channel-aliases","title":"Channel Aliases:**","text":"Channels Aliases <code>r</code> <code>red</code> <code>g</code> <code>green</code> <code>b</code> <code>blue</code>"},{"location":"colors/rec2100_linear/#inputoutput","title":"Input/Output","text":"<p>Parsed input and string output formats support all valid CSS forms:</p> <pre><code>color(rec2020-linear r g b / a)  // Color function\n</code></pre> <p>When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used:</p> <pre><code>Color(\"rec2020-linear\", [0, 0, 0], 1)\n</code></pre> <p>The string representation of the color object and the default string output will be in the <code>color(rec2020-linear r g b / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"rec2100-linear\", [0.6274, 0.0691, 0.01639])\ncolor(rec2100-linear 0.6274 0.0691 0.01639 / 1)\n&gt;&gt;&gt; Color(\"rec2100-linear\", [0.7513, 0.41509, 0.04951]).to_string()\n'color(rec2100-linear 0.7513 0.41509 0.04951)'\n</code></pre> Gamut: srgb"},{"location":"colors/rec2100_linear/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.rec2100_linear import Rec2100Linear\n\nclass Color(Base): ...\n\nColor.register(Rec2100Linear())\n</code></pre>"},{"location":"colors/rec2100_pq/","title":"REC. 2100 PQ","text":"<p>The Rec. 2100 PQ is registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>rec2100-pq</code></p> <p>White Point: D65 / 2\u02da</p> <p>Coordinates:</p> Name Range <code>r</code> [0, 1] <code>g</code> [0, 1] <code>b</code> [0, 1] <p></p> <p>Figure 1. CIE 1931 xy Chromaticity \u2013 Rec. 2100 Chromaticities (Same as Rec. 2020)</p> <p>BT.2100, more commonly known by the abbreviations Rec. 2100 or BT.2100, introduced high-dynamic-range television (HDR-TV) by recommending the use of the perceptual quantizer (PQ) or hybrid log\u2013gamma (HLG) transfer functions instead of the traditional \"gamma\" previously used for SDR-TV. Rec. 2100 PQ specifically uses the perceptual quantizer.</p> <p>The actual gamut of Rec. 2100 uses the same wide color gamut of Rec. 2020, but the color space itself supports an HDR range.</p> <p>Learn about REC.2100</p>"},{"location":"colors/rec2100_pq/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>r</code> <code>red</code> <code>g</code> <code>green</code> <code>b</code> <code>blue</code>"},{"location":"colors/rec2100_pq/#inputoutput","title":"Input/Output","text":"<p>Parsed input and string output formats support all valid CSS forms:</p> <pre><code>color(rec2100-pq r g b / a)  // Color function\n</code></pre> <p>When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used:</p> <pre><code>Color(\"rec2100-pq\", [0, 0, 0], 1)\n</code></pre> <p>The string representation of the color object and the default string output will be in the <code>color(rec2100-pq r g b / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"rec2100-pq\", [0.53255, 0.32702, 0.22007], 1)\ncolor(rec2100-pq 0.53255 0.32702 0.22007 / 1)\n&gt;&gt;&gt; Color(\"rec2100-pq\", [0.55101, 0.49099, 0.30009], 1).to_string()\n'color(rec2100-pq 0.55101 0.49099 0.30009)'\n</code></pre> Gamut: srgb"},{"location":"colors/rec2100_pq/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.rec2100_pq import Rec2100PQ\n\nclass Color(Base): ...\n\nColor.register(Rec2100PQ())\n</code></pre>"},{"location":"colors/rec709/","title":"Rec. 709","text":"<p>New 2.4</p> <p>The Rec. 709 color space is not registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>rec709</code></p> <p>White Point: D65 / 2\u02da</p> <p>Coordinates:</p> Name Range<sup>*</sup> <code>r</code> [0, 1] <code>g</code> [0, 1] <code>b</code> [0, 1] <p><sup>*</sup> Range denotes in gamut colors, but the color space supports an extended range beyond the gamut.</p> <p></p> <p>Figure 1. CIE 1931 xy Chromaticity \u2013 Rec. 709 Chromaticities</p> <p>Rec. 709 (also known as Rec.709, BT.709, and ITU 709) is a standard developed by ITU-R for image encoding and signal characteristics of high-definition television (HDTV). The color space is similar to sRGB in the fact that the primary chromaticities and white points are identical, the difference is the transfer function that more resembles Rec. 2020, though the precision of the constants are at 10 bit instead of 12 bit or greater.</p> <p>Learn about Rec. 709</p>"},{"location":"colors/rec709/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>r</code> <code>red</code> <code>g</code> <code>green</code> <code>b</code> <code>blue</code>"},{"location":"colors/rec709/#inputoutput","title":"Input/Output","text":"<p>Rec. 709 is not supported via the CSS spec and the parser input and string output only supports the <code>color()</code> function format using the custom name <code>--rec709</code>:</p> <pre><code>color(--rec709 r g b / a)  // Color function\n</code></pre> <p>When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used:</p> <pre><code>Color(\"rec709\", [0, 0, 0], 1)\n</code></pre> <p>The string representation of the color object and the default string output will be in the <code>color(--rec709 r g b / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"rec709\", [1, 0, 0], 1)\ncolor(--rec709 1 0 0 / 1)\n&gt;&gt;&gt; Color(\"rec709\", [1, 0.60879, 0], 1).to_string()\n'color(--rec709 1 0.60879 0)'\n</code></pre> Gamut: srgb"},{"location":"colors/rec709/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.rec709 import Rec709\n\nclass Color(Base): ...\n\nColor.register(Rec709())\n</code></pre>"},{"location":"colors/rlab/","title":"RLAB","text":"<p>The RLAB color space is not registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>rlab</code></p> <p>White Point: D65 / 2\u02da</p> <p>Coordinates:</p> Name Range <code>l</code> [0, 100] <code>a</code> [-125, 125] <code>b</code> [-125, 125] <p><sup>*</sup> Space is not bound to the range and is only used as a reference to define percentage inputs/outputs in relation to the Display P3 color space.</p> <p></p> <p>Figure 1. The sRGB gamut represented within the RLAB color space.</p> <p>The RLAB color-appearance space was developed by Fairchild and Berns for cross-media color reproduction applications in which images are reproduced with differing white points, luminance levels, and/or surrounds.</p> <p>ColorAide provides RLAB by default with average surround, and discounting set to \"hard copy\" (or full discounting of the illuminant). It is also configured to use an absolute adapting luminance of 318 cd/m2.</p> <p>Learn more.</p>"},{"location":"colors/rlab/#viewing-conditions","title":"Viewing Conditions","text":"<p>RLAB can be configured with different viewing environments. An RLAB color space will also have an associated environment object. This environment object determines the viewing conditions. Colors will appear different based on the viewing conditions.</p> Viewing\u00a0Conditions Description <code>white</code> This is the white point and should be the same as defined in the color class. This is provided as (x, y) chromaticity coordinates. <code>adapting_luminance</code> The luminance of the adapting field (often known as <code>La</code>). The units are in cd/m2. <code>surround</code> A description of the peripheral area. Use \"dark\" for a movie theater, \"dim\" for e.g. viewing a bright television in a dimly lit room, or \"average\" for surface colors. <code>discounting</code> Degree of discounting of the illuminant. A string of either \"hard-copy\", \"projected-transparency\", or \"soft-copy\". Hard copy indicates full discount, or the eye is assumed to be fully adapted to the illuminant. Projected transparency performs 50% discount. <p>ColorAide must provide some defaults, so the RLAB space has a default set of viewing conditions that uses a D65 white point, an adapting luminance of 1000 lux or a value of ~318.31 cd/m<sup>2</sup>, an \"average\" surround, and sets discounting to \"hard-copy\". These are the same settings that were demonstrated in the original paper.</p> <p>These settings do not have to be used, and a new RLAB variant with different viewing conditions can be created. When doing this, the space should be derived from the default RLAB space.</p> <pre><code>&gt;&gt;&gt; from coloraide import Color as Base\n&gt;&gt;&gt; from coloraide.spaces.rlab import RLAB, Environment\n&gt;&gt;&gt; from coloraide.cat import WHITES\n&gt;&gt;&gt; from coloraide import util\n&gt;&gt;&gt; import math\n&gt;&gt;&gt; class CustomRLAB(RLAB):\n...     NAME = \"rlab-custom\"\n...     SERIALIZE = (\"--rlab-custom\",)\n...     WHITE = WHITES['2deg']['D65']\n...     ENV = Environment(\n...         white=WHITE,\n...         adapting_luminance=64 / math.pi * 0.2,\n...         surround='average',\n...         discounting=\"soft-copy\"\n...     )\n... \n&gt;&gt;&gt; class Color(Base): ...\n... \n&gt;&gt;&gt; Color.register([RLAB(), CustomRLAB()])\n&gt;&gt;&gt; Color('white').convert('rlab')\ncolor(--rlab 100 0 0 / 1)\n&gt;&gt;&gt; Color('white').convert('rlab-custom')\ncolor(--rlab-custom 99.387 -5.2351 -3.5078 / 1)\n</code></pre> Gamut: srgb <p>Note</p> <p>If a <code>discounting</code> of anything other than \"hard-copy\" is used, you will notice the achromatic response to cause colors like white to not have value of zero chroma. This is because the eye is not fully adapted, and colors appear different with this context. This is not a bug, just the way viewing conditions can affect model.</p>"},{"location":"colors/rlab/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>l</code> <code>lightness</code> <code>a</code> <code>b</code>"},{"location":"colors/rlab/#inputoutput","title":"Input/Output","text":"<p>The RLAB space is not currently supported in the CSS spec, the parsed input and string output formats use the <code>color()</code> function format using the custom name <code>--rlab</code>:</p> <pre><code>color(--rlab l a b / a)  // Color function\n</code></pre> <p>The string representation of the color object and the default string output use the <code>color(--rlab l a b / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"rlab\", [51.012, 79.742, 57.26])\ncolor(--rlab 51.012 79.742 57.26 / 1)\n&gt;&gt;&gt; Color(\"rlab\", [72.793, 25.151, 74.11]).to_string()\n'color(--rlab 72.793 25.151 74.11)'\n</code></pre> Gamut: srgb"},{"location":"colors/rlab/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.rlab import RLAB\n\nclass Color(Base): ...\n\nColor.register(RLAB())\n</code></pre>"},{"location":"colors/ryb/","title":"RYB","text":"<p>The RYB color space is not registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>ryb</code></p> <p>White Point: D65 / 2\u02da</p> <p>Coordinates:</p> Name Range <code>r</code> [0, 1] <code>y</code> [0, 1] <code>b</code> [0, 1] <pre><code>&gt;&gt;&gt; Wheel(Color('ryb', [1, 0, 0]).harmony('wheel', space='ryb'))\n[color(--ryb 1 0 0 / 1), color(--ryb 1 0.5 0 / 1), color(--ryb 1 1 0 / 1), color(--ryb 0.5 1 0 / 1), color(--ryb 0 1 0 / 1), color(--ryb 0 1 0.5 / 1), color(--ryb 0 1 1 / 1), color(--ryb 0 0.5 1 / 1), color(--ryb 0 0 1 / 1), color(--ryb 0.5 0 1 / 1), color(--ryb 1 0 1 / 1), color(--ryb 1 0 0.5 / 1)]\n</code></pre> Gamut: srgb <p>Figure 1. The RYB color wheel.</p> <p>The RYB color model is a subtractive color model in which red, yellow and blue pigments or dyes are added together in various ways to reproduce different colors. RYB is the classical way of thinking about colors. While in schools it is often still taught that red, yellow, and blue are the primary colors (for pigments), modern wisdom shows that these \"primaries\" are not sufficient. Spaces like CMYK which use cyan, magenta and yellow can create a much wider array of colors, even red, yellow, and blue. We've also since learned that the primary colors of light (which operates in an additive color space) are red, green, and blue.</p> <p>Even though in modern day electronic screens and printing we rely on color models such as RGB and CMYK, RYB still holds a special place with artists. Color harmony is often used as the model when talking about color harmonies.</p> <p>There is no standard RYB color model. No standard primaries. The RYB model that ColorAide implements is based on the work of Nathan Gossett and Baoquan Chen at the University of Minnesota at Twin Cities. Their paper devised an approach of using trilinear interpolation to create a transform from RYB to sRGB. The bases of the model uses colors similar to Johannes Itten's color wheel (which we showed an example of above), but in all the literature, there are variants of the same color wheel and no precise color codes.</p> <p>ColorAide implements Gossett and Chen's algorithm to convert from RYB to sRGB, but also uses an algorithm that employs Newton's method to approximates the reverse transform, something that wasn't covered in the paper.</p> <p>This approach to transforming the RGB color spaces does provide more paint like mixing.</p> <pre><code>&gt;&gt;&gt; Color.interpolate(['color(--ryb 0 0 1)', 'color(--ryb 0 1 0)'], space='ryb')\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x7f46543dd400&gt;\n&gt;&gt;&gt; Color.interpolate(['color(--ryb 1 0 0)', 'color(--ryb 0 1 0)'], space='ryb')\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x7f46543dfd40&gt;\n&gt;&gt;&gt; Color.interpolate(['color(--ryb 1 0 1)', 'color(--ryb 0 1 0)'], space='ryb')\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x7f46543df980&gt;\n</code></pre> Gamut: srgb <p>It should also be noted that when mixing all the colors, you do not get black, but a muddy brown, much like with paint. To be precise, the color black is not defined within this color space.</p> <pre><code>&gt;&gt;&gt; Color.interpolate(['color(--ryb 0 0 0)', 'color(--ryb 1 1 1)'], space='ryb')\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x7f46543dfd40&gt;\n&gt;&gt;&gt; Color.interpolate(['color(--ryb 0 0 1)', 'color(--ryb 1 1 1)'], space='ryb')\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x7f46543dd400&gt;\n</code></pre> Gamut: srgb <p>It should be noted that the RYB model does a great job at translating colors within the RYB color gamut, but translation of colors outside the gamut will have poor conversions.</p> <p>Learn more.</p>"},{"location":"colors/ryb/#ryb-biased","title":"RYB Biased","text":"<p>The RYB Biased color space is not registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>ryb-biased</code></p> <p>White Point: D65 / 2\u02da</p> <p>Coordinates:</p> Name Range <code>r</code> [0, 1] <code>y</code> [0, 1] <code>b</code> [0, 1] <pre><code>&gt;&gt;&gt; Wheel(Color('ryb-biased', [1, 0, 0]).harmony('wheel', space='ryb-biased'))\n[color(--ryb-biased 1 0 0 / 1), color(--ryb-biased 1 0.5 0 / 1), color(--ryb-biased 1 1 0 / 1), color(--ryb-biased 0.5 1 0 / 1), color(--ryb-biased 0 1 0 / 1), color(--ryb-biased 0 1 0.5 / 1), color(--ryb-biased 0 1 1 / 1), color(--ryb-biased 0 0.5 1 / 1), color(--ryb-biased 0 0 1 / 1), color(--ryb-biased 0.5 0 1 / 1), color(--ryb-biased 1 0 1 / 1), color(--ryb-biased 1 0 0.5 / 1)]\n</code></pre> Gamut: srgb <p>In the Gosset and Chen paper, they also implemented an easing function that was applied to the trilinear interpolation transform. This additional easing function biases the color transform more to the corners of the cube. The idea was to better simulate how paint clumps when mixing. While we've also implemented this behavior to be true to the paper, the RYB color space does not utilize this biasing by default, but we instead provide an alternative RYB color space (<code>ryb-biased</code>) that implements everything fully.</p> <p>Notice how the colors in the \"biased\" RYB  are more concentrated at the corners while in the normal RYB they blend more.</p> RYBRYB Biased <p></p> <p></p> <pre><code>&gt;&gt;&gt; Color.interpolate(Color('ryb', [1, 0, 0]).harmony('wheel', space='ryb'), space='ryb')\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x7f46543dfd40&gt;\n&gt;&gt;&gt; Color.interpolate(Color('ryb-biased', [1, 0, 0]).harmony('wheel', space='ryb-biased'), space='ryb-biased')\n&lt;coloraide.interpolate.linear.InterpolatorLinear object at 0x7f46543df980&gt;\n</code></pre> Gamut: srgb <p>Learn more.</p>"},{"location":"colors/ryb/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>r</code> <code>red</code> <code>y</code> <code>yellow</code> <code>b</code> <code>blue</code>"},{"location":"colors/ryb/#inputoutput","title":"Input/Output","text":"<p>RYB is not currently supported in the CSS spec, the parsed input and string output formats use the <code>color()</code> function format using the custom name <code>--ryb</code>. If using RYB Biased, then the custom name <code>--ryb-biased</code> is used.</p> <pre><code>color(--ryb r y b / a)  // Color function\ncolor(--ryb-biased r y b / a)  // Color function\n</code></pre> <p>The string representation of the color object and the default string output use the <code>color(--ryb r y b / a)</code> form or <code>color(--ryb-biased r y b / a)</code> for the biased variant.</p> <pre><code>&gt;&gt;&gt; Color(\"ryb\", [1, 0, 0])\ncolor(--ryb 1 0 0 / 1)\n&gt;&gt;&gt; Color(\"ryb\", [0.70588, 1, 0]).to_string()\n'color(--ryb 0.70588 1 0)'\n&gt;&gt;&gt; Color(\"ryb\", [0, 1, 0])\ncolor(--ryb 0 1 0 / 1)\n&gt;&gt;&gt; Color(\"ryb\", [0.37952, 1.289, 1.014]).to_string()\n'color(--ryb 0.36388 1 0.93018)'\n</code></pre> Gamut: srgb"},{"location":"colors/ryb/#registering","title":"Registering","text":"<p>Either RYB, RYB Biased, or both can be registered.</p> <pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.ryb import RYB, RYBBiased\n\nclass Color(Base): ...\n\nColor.register([RYB(), RYBBiased()])\n</code></pre>"},{"location":"colors/srgb/","title":"sRGB","text":"<p>The sRGB color space is registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>srgb</code></p> <p>White Point: D65 / 2\u02da</p> <p>Coordinates:</p> Name Range<sup>*</sup> <code>r</code> [0, 1] <code>g</code> [0, 1] <code>b</code> [0, 1] <p><sup>*</sup> Range denotes in gamut colors, but the color space supports an extended range beyond the gamut.</p> <p></p> <p>Figure 1. CIE 1931 xy Chromaticity \u2013 sRGB Chromaticities</p> <p>The sRGB space is a standard RGB (red, green, blue) color space that HP and Microsoft created cooperatively in 1996 to use on monitors, printers, and the Web. sRGB stands for \"Standard RGB\". It is the most widely used color space and is supported by most operating systems, software programs, monitors, and printers.</p> <p>Learn about sRGB</p>"},{"location":"colors/srgb/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>r</code> <code>red</code> <code>g</code> <code>green</code> <code>b</code> <code>blue</code>"},{"location":"colors/srgb/#inputoutput","title":"Input/Output","text":"<p>Parsed input and string output formats support all valid CSS forms:</p> <pre><code>black                  // Color name\n#RRGGBBAA              // Hex\nrgb(r g b / a)         // RGB function\nrgb(r, g, b)           // Legacy RGB Function\nrgba(r, g, b, a)       // Legacy RGBA function\ncolor(srgb r g b / a)  // Color function\n</code></pre> <p>When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used:</p> <p><pre><code>Color(\"srgb\", [0, 0, 0], 1)\n</code></pre> The string representation of the color object will always default to the <code>color(srgb r g b / a)</code> form, but the default string output will be the <code>rgb(r g b / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color('red').to_string()\n'rgb(255 0 0)'\n&gt;&gt;&gt; Color('orange').to_string(comma=True)\n'rgb(255, 165, 0)'\n&gt;&gt;&gt; Color('yellow').to_string(percent=True)\n'rgb(100% 100% 0%)'\n&gt;&gt;&gt; Color('green').to_string(names=True)\n'green'\n&gt;&gt;&gt; Color('blue').to_string(hex=True)\n'#0000ff'\n&gt;&gt;&gt; Color('indigo').to_string(color=True)\n'color(srgb 0.29412 0 0.5098)'\n</code></pre> Gamut: srgb"},{"location":"colors/srgb/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.srgb.css import sRGB\n\nclass Color(Base): ...\n\nColor.register(sRGB())\n</code></pre>"},{"location":"colors/srgb_linear/","title":"Linear sRGB","text":"<p>The Linear sRGB color space is registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>srgb-linear</code></p> <p>White Point: D65 / 2\u02da</p> <p>Coordinates:</p> Name Range<sup>*</sup> <code>r</code> [0, 1] <code>g</code> [0, 1] <code>b</code> [0, 1] <p><sup>*</sup> Range denotes in gamut colors, but the color space supports an extended range beyond the gamut.</p> <p></p> <p>Figure 1. CIE 1931 xy Chromaticity \u2013 sRGB Chromaticities</p> <p>The sRGB Linear space is the same as sRGB except that the transfer function is linear-light (there is no gamma-encoding).</p> <p>Learn about sRGB</p>"},{"location":"colors/srgb_linear/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>r</code> <code>red</code> <code>g</code> <code>green</code> <code>b</code> <code>blue</code>"},{"location":"colors/srgb_linear/#inputsoutput","title":"Inputs/Output","text":"<p>Parsed input and string output formats support all valid CSS forms:</p> <pre><code>color(srgb-linear r g b / a)  // Color function\n</code></pre> <p>When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used:</p> <pre><code>Color(\"srgb-linear\", [0, 0, 0], 1)\n</code></pre> <p>The string representation of the color object and the default string output will be in the <code>color(srgb-linear r g b / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"srgb\", [1, 0, 0])\ncolor(srgb 1 0 0 / 1)\n&gt;&gt;&gt; Color(\"srgb\", [1, 0.37626, 0]).to_string()\n'rgb(255 95.946 0)'\n</code></pre> Gamut: srgb"},{"location":"colors/srgb_linear/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.srgb_linear import sRGBLinear\n\nclass Color(Base): ...\n\nColor.register(sRGB())\n</code></pre>"},{"location":"colors/ucs/","title":"CIE 1960 UCS","text":"<p>New 2.4</p> <p>The CIE 1960 UCS color space is not registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>ucs</code></p> <p>White Point: D65 / 2\u02da</p> <p>Coordinates:</p> Name Range<sup>*</sup> <code>u</code> [0.0, 1.0] <code>v</code> [0.0, 1.0] <code>w</code> [0.0, 1.0] <p><sup>*</sup> Space is not bound to the range and is used to define percentage inputs/outputs.</p> <p></p> <p>Figure 1. The sRGB gamut represented within the CIE 1960 UCS color space.</p> <p>The CIE 1960 color space (\"CIE 1960 UCS\", variously expanded Uniform Color Space, Uniform Color Scale, Uniform Chromaticity Scale, Uniform Chromaticity Space) is another name for the (u, v) chromaticity space devised by David MacAdam. The color space is implemented using the relation between this space and the XYZ space as coordinates U, V, and W.</p> <p>Learn more.</p>"},{"location":"colors/ucs/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>u</code> <code>v</code> <code>w</code>"},{"location":"colors/ucs/#inputoutput","title":"Input/Output","text":"<p>The UCS space is not currently supported in the CSS spec, the parsed input and string output formats use the <code>color()</code> function format using the custom name <code>--ucs</code>:</p> <pre><code>color(--ucs u v w / a)  // Color function\n</code></pre> <p>The string representation of the color object and the default string output use the <code>color(--ucs u v w / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"ucs\", [0.27493, 0.21264, 0.12243])\ncolor(--ucs 0.27493 0.21264 0.12243 / 1)\n&gt;&gt;&gt; Color(\"ucs\", [0.36462, 0.48173, 0.48122]).to_string()\n'color(--ucs 0.36462 0.48173 0.48122)'\n</code></pre> Gamut: srgb"},{"location":"colors/ucs/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.ucs import UCS\n\nclass Color(Base): ...\n\nColor.register(UCS())\n</code></pre>"},{"location":"colors/xyb/","title":"XYB","text":"<p>The XYB color space is not registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>xyb</code></p> <p>White Point: D65 / 2\u02da</p> <p>Coordinates:</p> Name Range<sup>*</sup> <code>x</code> [-0.05, 0.05] <code>y</code> [0.0, 0.845] <code>b</code> [-0.45, 0.45] <p><sup>*</sup> Space is not bound to the range and is only used as a reference to define percentage inputs/outputs.</p> <p></p> <p>Figure 1. The sRGB gamut represented within the XYB color space.</p> <p>XYB is a color space that was designed for use with the JPEG XL Image Coding System. It is an LMS-based color model inspired by the human visual system, facilitating perceptually uniform quantization. It uses a gamma of 3 for computationally efficient decoding.</p> <p>Chroma/Luma Adjustments</p> <p>Per the creator, the default subtracts the Y component from the B component which makes Y function as lightness and X and B will function similar to Lab 'a' and 'b' components. When X=Y=0, the color is achromatic.</p> <p>You may find other implementations may not do this and store the colors without this operation. It may be that in real world use it is not stored in this way. If desired, you can add Y to B to get the color exactly as specified in the white paper.</p> <p>While in this configuration the color operates in a Lab-like way, but the scaling of X and B is quite different not making it practical to convert this to a LCh-like space for reasonable hue values. To do so, you would need to scale X to a similar order of magnitude compared to B (maybe a factor of 10).</p> <p>Learn more.</p>"},{"location":"colors/xyb/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>x</code> <code>y</code> <code>b</code> <p>Inputs</p> <p>The XYB space is not currently supported in the CSS spec, the parsed input and string output formats use the <code>color()</code> function format using the custom name <code>--xyb</code>:</p> <pre><code>color(--xyb x y b / a)  // Color function\n</code></pre> <p>The string representation of the color object and the default string output use the <code>color(--xyb x y b / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"xyb\", [0.0281, 0.48819, -0.01653])\ncolor(--xyb 0.0281 0.48819 -0.01653 / 1)\n&gt;&gt;&gt; Color(\"xyb\", [0.01132, 0.64596, -0.1149]).to_string()\n'color(--xyb 0.01132 0.64596 -0.1149)'\n</code></pre> Gamut: srgb"},{"location":"colors/xyb/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.xyb import XYB\n\nclass Color(Base): ...\n\nColor.register(XYB())\n</code></pre>"},{"location":"colors/xyy/","title":"xyY","text":"<p>The xyY color space is not registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>xyy</code></p> <p>White Point: D65 / 2\u02da</p> <p>Coordinates:</p> Name Range<sup>*</sup> <code>x</code> [0, 1] <code>y</code> [0, 1] <code>Y</code> [0, 1] <p><sup>*</sup> Space is not bound to the range and is used to define percentage inputs/outputs.</p> <p></p> <p>Figure 1. The sRGB gamut represented within the xyY color space.</p> <p>A derivative of the CIE 1931 XYZ space, the CIE xyY color space, is often used as a way to graphically present the chromaticity of colors.</p> <p>Tip</p> <p>The color space, as implemented, is relative to the D65 white point, meaning it is created from XYZ D65. If colors are needed relative to different white points, the color space can be subclassed. If proper chromaticity coordinates are desired for a given color, you can checkout the API for chromaticity coordinates.</p> <p>Learn more.</p>"},{"location":"colors/xyy/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>x</code> <code>y</code> <code>Y</code>"},{"location":"colors/xyy/#inputoutput","title":"Input/Output","text":"<p>The xyY space is not currently supported in the CSS spec, the parsed input and string output formats use the <code>color()</code> function format using the custom name <code>--xyy</code>:</p> <pre><code>color(--xyy x y Y / a)  // Color function\n</code></pre> <p>The string representation of the color object and the default string output use the <code>color(--xyy x y Y / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"xyy\", [0.64, 0.33, 0.21264])\ncolor(--xyy 0.64 0.33 0.21264 / 1)\n&gt;&gt;&gt; Color(\"xyy\", [0.50047, 0.4408, 0.48173]).to_string()\n'color(--xyy 0.50047 0.4408 0.48173)'\n</code></pre> Gamut: srgb"},{"location":"colors/xyy/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.xyy import xyY\n\nclass Color(Base): ...\n\nColor.register(xyY())\n</code></pre>"},{"location":"colors/xyz_d50/","title":"XYZ D50","text":"<p>The XYZ D50 color space is registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>xyz-d50</code></p> <p>White Point: D50 / 2\u02da</p> <p>Coordinates:</p> Name Range<sup>*</sup> <code>x</code> [0, 1] <code>y</code> [0, 1] <code>z</code> [0, 1] <p><sup>*</sup> Space is not bound to the range and is only used as a reference to define percentage inputs/outputs.</p> <p></p> <p>Figure 1. The sRGB gamut represented within the XYZ D50 color space.</p> <p>XYZ D50 is the same as XYZ D65 except it uses a D50 white point.</p> <p>Learn about XYZ</p>"},{"location":"colors/xyz_d50/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>x</code> <code>y</code> <code>z</code>"},{"location":"colors/xyz_d50/#inputoutput","title":"Input/Output","text":"<p>Parsed input and string output formats support all valid CSS forms:</p> <pre><code>color(xyz-d50 x y z / a)  // Color function\n</code></pre> <p>When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used:</p> <pre><code>Color(\"xyz-d50\", [0, 0, 0], 1)\n</code></pre> <p>The string representation of the color object and the default string output will be in the <code>color(xyz x y z / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"xyz-d50\", [0.43607, 0.22249, 0.01392])\ncolor(xyz-d50 0.43607 0.22249 0.01392 / 1)\n&gt;&gt;&gt; Color(\"xyz-d50\", [0.58098, 0.49223, 0.05045]).to_string()\n'color(xyz-d50 0.58098 0.49223 0.05045)'\n</code></pre> Gamut: srgb"},{"location":"colors/xyz_d50/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.xyz_d50 import XYZD50\n\nclass Color(Base): ...\n\nColor.register(XYZD50())\n</code></pre>"},{"location":"colors/xyz_d65/","title":"XYZ D65","text":"<p>The XYZ D65 color space is registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>xyz-d65</code></p> <p>White Point: D65 / 2\u02da</p> <p>Coordinates:</p> Name Range<sup>*</sup> <code>x</code> [0, 1] <code>y</code> [0, 1] <code>z</code> [0, 1] <p><sup>*</sup> Space is not bound to the range and is only used as a reference to define percentage inputs/outputs.</p> <p></p> <p>Figure 1. The sRGB gamut represented within the XYZ D65 color space.</p> <p>The CIE 1931 RGB color space and CIE 1931 XYZ color space were created by the International Commission on Illumination (CIE) in 1931. They resulted from a series of experiments done in the late 1920s by William David Wright using ten observers and John Guild using seven observers. The experimental results were combined into the specification of the CIE RGB color space, from which the CIE XYZ color space was derived. The CIE 1931 color spaces are the first defined quantitative links between distributions of wavelengths in the electromagnetic visible spectrum, and physiologically perceived colors in human color vision.</p> <p>Learn about XYZ</p>"},{"location":"colors/xyz_d65/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>x</code> <code>y</code> <code>z</code>"},{"location":"colors/xyz_d65/#inputoutput","title":"Input/Output","text":"<p>Parsed input and string output formats use the <code>color()</code> format with either <code>xyz-d65</code> or <code>xyz</code> as the identifier with the latter being an alias of the former.</p> <pre><code>color(xyz x y z / a)      // Color function\ncolor(xyz-d65 x y z / a)  // Color function alternate name\n</code></pre> <p>When manually creating a color via raw data or specifying a color space as a parameter in a function, the color space name is always used:</p> <pre><code>Color(\"xyz-d65\", [0, 0, 0], 1)\n</code></pre> <p>The string representation of the color object and the default string output will be in the  <code>color(xyz-d65 x y z / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"xyz-d65\", [0.41239, 0.21264, 0.01933])\ncolor(xyz-d65 0.41239 0.21264 0.01933 / 1)\n&gt;&gt;&gt; Color(\"xyz-d65\", [0.54694, 0.48173, 0.06418]).to_string()\n'color(xyz-d65 0.54694 0.48173 0.06418)'\n</code></pre> Gamut: srgb"},{"location":"colors/xyz_d65/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.xyz_d65 import XYZD65\n\nclass Color(Base): ...\n\nColor.register(XYZD65())\n</code></pre>"},{"location":"colors/zcam/","title":"ZCAM JMh","text":"<p>The ZCAM JMh color space is not registered in <code>Color</code> by default</p> <p>Properties</p> <p>Name: <code>zcam-jmh</code></p> <p>White Point: D65 / 2\u02da</p> <p>Coordinates:</p> Name Range<sup>*</sup> <code>jz</code> [0, 100] <code>mz</code> [0, 60] <code>hz</code> [0, 360) <p><sup>*</sup> Space is not bound to the range and is only used as a reference to define percentage inputs/outputs in relation to the Display P3 color space.</p> <p></p> <p>Figure 1. The sRGB gamut represented within the ZCAM JMh color space.</p> <p>A color appearance model (CAM) is a mathematical model that seeks to describe the perceptual aspects of human color vision, i.e. viewing conditions under which the appearance of a color does not tally with the corresponding physical measurement of the stimulus source.</p> <p>ZCAM is a CAM model that builds off earlier work done with Jzazbz by Safdar. It uses a Perceptual Quantizer (PQ) curve, developed to uniformly encode a luminance range of 0.001 to 10,000 cd/m2.</p> <p>The model defines numerous different attributes:</p> Name Description Jz Lightness Cz Chroma hz hue Qz Brightness Mz Colorfulness Sz Saturation Vz Vividness Kz Blackness Wz Whiteness Hz Hue Quadrature <p>A color space can be constructed by using a subset of these attributes: JzCzhz, JzMzhz, QzMzhz, etc. The provided color spaces uses JzMzhz.</p> <p>Learn more.</p>"},{"location":"colors/zcam/#viewing-conditions","title":"Viewing Conditions","text":"<p>ZCAM is a color appearance model and can be configured with different viewing environments. A ZCAM color space will also have an associated environment object. This environment object determines the viewing conditions. Colors will appear different based on the viewing conditions.</p> Viewing\u00a0Conditions Description White This is the white point and output white and should be the same as defined in the color class. This is provided as (x, y) chromaticity coordinates. ZCAM expects and was designed for this to be D65. Reference\u00a0White The absolute reference white where <code>Yw</code> is scaled to the luminance. Adapting\u00a0Luminance The luminance of the adapting field (<code>La</code>). The units are in cd/m2. Background\u00a0Luminance The background luminance (<code>Yb</code>) the relative luminance of the nearby background (out to 10\u00b0), relative to the reference white's luminance (<code>Y</code>). Usually 20 providing a gray world assumption. Surround A description of the peripheral area. Use \"dark\" for a movie theater, \"dim\" for e.g. viewing a bright television in a dimly lit room, or \"average\" for surface colors. Discounting Discounts the illuminant. If true, the eye is assumed to be fully adapted to the illuminant. Otherwise, the degree of discounting is based on other parameters. When the eye is not fully adapted, it can affect the way colors appear and the chromatic response. <p>ColorAide must provide some defaults, so ZCAM comes with a default set of viewing conditions that uses a D65 white point, a reference white that uses D65 scaled to 100, an adapting luminance of 64 lux or a value of ~4 cd/m<sup>2</sup>, it uses the \"gray world\" assumption and sets the background to 20, an \"average\" surround and leaves discounting set to <code>False</code>.</p> <p>The default settings do not have to be used and a new ZCAM variant with different viewing conditions can be created. When doing this, the space should be derived from the default</p> <pre><code>&gt;&gt;&gt; from coloraide import Color as Base\n&gt;&gt;&gt; from coloraide.spaces.zcam import ZCAMJMh, Environment\n&gt;&gt;&gt; from coloraide.cat import WHITES\n&gt;&gt;&gt; from coloraide import util\n&gt;&gt;&gt; import math\n&gt;&gt;&gt; cdm2 = 1000 / math.pi\n&gt;&gt;&gt; class CustomZCAMJMh(ZCAMJMh):\n...     NAME = \"zcam-custom\"\n...     SERIALIZE = (\"--zcam-custom\",)\n...     WHITE = WHITES['2deg']['D65']\n...     ENV = Environment(\n...         white=WHITE,\n...         reference_white=[c * cdm2 for c in util.xy_to_xyz(WHITE)],\n...         adapting_luminance=cdm2,\n...         background_luminance=100,\n...         surround='average',\n...         discounting=False\n...     )\n... \n&gt;&gt;&gt; class Color(Base): ...\n... \n&gt;&gt;&gt; Color.register([ZCAMJMh(), CustomZCAMJMh()])\n&gt;&gt;&gt; Color('red').convert('zcam-jmh')\ncolor(--zcam-jmh 51.197 43.776 42.477 / 1)\n&gt;&gt;&gt; Color('red').convert('zcam-custom')\ncolor(--zcam-custom 33.959 43.15 42.477 / 1)\n</code></pre> Gamut: srgb"},{"location":"colors/zcam/#channel-aliases","title":"Channel Aliases","text":"Channels Aliases <code>jz</code> <code>lightness</code>, <code>j</code> <code>mz</code> <code>colorfulness</code>, <code>m</code> <code>hz</code> <code>hue</code>, <code>h</code>"},{"location":"colors/zcam/#inputoutput","title":"Input/Output","text":"<p>The ZCAM JMh space is not currently supported in the CSS spec, the parsed input and string output formats use the <code>color()</code> function format using the custom name <code>--zcam-jmh</code>:</p> <pre><code>color(--zcam-jmh jz mz hz / a)  // Color function\n</code></pre> <p>The string representation of the color object and the default string output use the <code>color(--zcam-jmh jz mz hz / a)</code> form.</p> <pre><code>&gt;&gt;&gt; Color(\"zcam-jmh\", [51.197, 43.776, 42.477], 1)\ncolor(--zcam-jmh 51.197 43.776 42.477 / 1)\n&gt;&gt;&gt; Color(\"zcam-jmh\", [71.271, 32.313, 75.038], 1).to_string()\n'color(--zcam-jmh 71.271 32.313 75.038)'\n</code></pre> Gamut: srgb"},{"location":"colors/zcam/#registering","title":"Registering","text":"<pre><code>from coloraide import Color as Base\nfrom coloraide.spaces.zcam import ZCAMJMh\n\nclass Color(Base): ...\n\nColor.register(ZCAMJMh())\n</code></pre>"},{"location":"demos/","title":"ColorAide Demos","text":""},{"location":"demos/#online-color-picker","title":"Online Color Picker","text":"<p>Use ColorAide to pick a color in any of the color spaces available. ACES color spaces have been arbitrarily limited has they have ginormous headroom.</p> <p>All results, from any color space, are gamut mapped to the detected display gamut (sRGB, Display P3, or Rec. 2020), but you can force lower gamuts that fit inside your detected gamut as well. Larger gamuts than the detected gamut will be unavailable.</p> <p>Try it out</p>"},{"location":"demos/#interactive-3d-color-space-models","title":"Interactive 3D Color Space Models","text":"<p>Generate interactive 3D color models in the browser using ColorAide and Plotly! Most color spaces are supported, but color spaces with more than 3 color components (not including alpha) are not supported. Colors can be generated in a number of color gamuts, though a few models are restricted to their own color space for practical reasons.</p> <p>Try it out</p>"},{"location":"plugins/","title":"ColorAide Plugins","text":"<p>ColorAide implements extendable portions of the <code>Color</code> object as plugins. This makes adding things such as new \u2206E methods or even new color spaces quite easy. Currently, ColorAide implements the following areas as plugins:</p> <ul> <li>\u2206E methods</li> <li>Fit/Gamut mapping</li> <li>Chromatic adaptation</li> <li>Filters</li> <li>Contrast</li> <li>Color spaces</li> <li>Interpolation</li> <li>CCT</li> </ul> <p>While these documents will touch on each plugin, looking at the source code will provide a better view on how plugins are actually used as all functionality for all of these categories are implemented as plugins in ColorAide.</p>"},{"location":"plugins/cat/","title":"Chromatic Adaptation","text":""},{"location":"plugins/cat/#description","title":"Description","text":"<p>CAT plugins chromatically adapt a given XYZ coordinate from its current reference white point to a new desired white point. This is useful during conversion when one color space is converted to another color space that uses a difference reference white.</p>"},{"location":"plugins/cat/#plugin-class","title":"Plugin Class","text":"<p>Plugins are created by subclassing <code>coloraide.cat.CAT</code>.</p> <pre><code>class CAT(Plugin, metaclass=ABCMeta):\n    \"\"\"Chromatic adaptation.\"\"\"\n\n    NAME = \"\"\n\n    @abstractmethod\n    def adapt(self, w1: tuple[float, float], w2: tuple[float, float], xyz: VectorLike) -&gt; Vector:\n        \"\"\"Adapt a given XYZ color using the provided white points.\"\"\"\n</code></pre> <p>Once registered, the plugin can then be used via <code>chromatic_adaptation</code> by passing its <code>NAME</code> via the <code>method</code> along two white points (as XYZ values): <code>w1</code> as the current white point and <code>w2</code> as the target white point.</p> <p>It should be noted that <code>chromatic_adaptation</code> is not usually directly used by the user, so a more likely approach is to override the <code>DELTA_E</code> parameter of a subclassed <code>Color</code> object to specify the plugin as the default for chromatic adaptation.</p>"},{"location":"plugins/cat/#von-kries-cat","title":"Von Kries CAT","text":"<p>Currently, ColorAide only ships with Von Kries based adaptation methods. If it is desired to create a Von Kries based plugin, it is recommended to subclass the <code>VonKries</code> class which is based on <code>CAT</code>. When subclassing a <code>VonKries</code> based CAT, the <code>NAME</code> and a <code>MATRIX</code> must be provided. The general calculations related to the source and target white point, will automatically be calculated and an appropriate matrix and inverted matrix will be returned to perform the adaptation without any additional logic.</p> <pre><code>class Bradford(VonKries):\n    \"\"\"\n    Bradford CAT.\n\n    http://brucelindbloom.com/Eqn_ChromAdapt.html\n    https://hrcak.srce.hr/file/95370\n    \"\"\"\n\n    NAME = \"bradford\"\n\n    MATRIX = [\n        [0.8951000, 0.2664000, -0.1614000],\n        [-0.7502000, 1.7135000, 0.0367000],\n        [0.0389000, -0.0685000, 1.0296000]\n    ]\n</code></pre>"},{"location":"plugins/cct/","title":"CCT","text":""},{"location":"plugins/cct/#description","title":"Description","text":"<p>CCT plugins allow you to calculate a color from a CCT and \u2206<sub>uv</sub> or calculate a CCT and \u2206<sub>uv</sub> from a color.</p>"},{"location":"plugins/cct/#plugin-class","title":"Plugin Class","text":"<pre><code>class CCT(Plugin, metaclass=ABCMeta):\n    \"\"\"Delta E plugin class.\"\"\"\n\n    NAME = ''\n\n    @abstractmethod\n    def to_cct(self, color: AnyColor, **kwargs: Any) -&gt; Vector:\n        \"\"\"Calculate a color's CCT.\"\"\"\n\n    @abstractmethod\n    def from_cct(\n        self,\n        color: type[AnyColor],\n        space: str,\n        kelvin: float,\n        duv: float,\n        scale: bool,\n        scale_space: str | None,\n        **kwargs: Any\n    ) -&gt; AnyColor:\n        \"\"\"Calculate a color that satisfies the CCT.\"\"\"\n</code></pre> <p>Once registered, the plugin can then be used via the <code>cct()</code> or <code>blackbody()</code> methods by passing its <code>NAME</code> via the <code>method</code> parameter.</p> <pre><code>Color('orange').cct(method=NAME, **kwargs)\nColor.blackbody(space, kelvin, duv, method=NAME, **kwargs)\n</code></pre> <p>If you'd like the user to configure the plugin on registration, you can define an <code>__init__</code> method. To register the plugin, just the <code>register()</code> method.</p> <pre><code>Color.register(Plugin(**kwargs))\n</code></pre>"},{"location":"plugins/contrast/","title":"Contrast","text":""},{"location":"plugins/contrast/#description","title":"Description","text":"<p>Contrast returns a numerical value that is meant to determine how much visual contrast exists between two colors. While the current default is agnostic to ordering of the colors, some algorithms can be sensitive to order.</p>"},{"location":"plugins/contrast/#plugin-class","title":"Plugin Class","text":"<pre><code>class ColorContrast(Plugin, metaclass=ABCMeta):\n    \"\"\"Color contrast plugin class.\"\"\"\n\n    NAME = ''\n\n    @abstractmethod\n    def contrast(self, color1: AnyColor, color2: AnyColor, **kwargs: Any) -&gt; float:\n        \"\"\"Get the contrast of the two provided colors.\"\"\"\n</code></pre> <p>Once registered, the plugin can then be used via <code>contrast</code> by passing its <code>NAME</code> via the <code>method</code> parameter along with a secondary color (<code>color2</code>) representing the background color. The calling color (<code>color1</code>) will be considered the text color. Any additional key word arguments can be specified to override default behavior. The \"contrast\" will be returned as a float.</p> <pre><code>color1.contrast(color2, method=NAME, **kwargs)\n</code></pre> <p>If you'd like the user to be able to set specific defaults, you can define an <code>__init__</code> method and manage defaults accordingly. Defaults can be passed in when instantiating a new plugin.</p> <pre><code>Color.register(Plugin(**kwargs))\n</code></pre>"},{"location":"plugins/delta_e/","title":"Delta E","text":""},{"location":"plugins/delta_e/#description","title":"Description","text":"<p>\u2206E plugins allow for getting color differences with different methods. ColorAide provides a number of methods by default which are documented under Color Distance and Delta E. All of the default \u2206E methods are provided as plugins, and users can create their own as well.</p>"},{"location":"plugins/delta_e/#plugin-class","title":"Plugin Class","text":"<p>\u2206E plugins are subclassed from <code>coloraide.distance.DeltaE</code>.</p> <pre><code>class DeltaE(Plugin, metaclass=ABCMeta):\n    \"\"\"Delta E plugin class.\"\"\"\n\n    NAME = ''\n\n    @abstractmethod\n    def distance(self, color: AnyColor, sample: AnyColor, **kwargs: Any) -&gt; float:\n        \"\"\"Get distance between color and sample.\"\"\"\n</code></pre> <p>Once registered, the plugin can then be used via <code>delta_e</code> by passing its <code>NAME</code> via the <code>method</code> parameter along with any additional key word arguments to override default behavior. The return will be a float indicating the distance.</p> <pre><code>color.delta_e(sample, method=NAME, **kwargs)\n</code></pre> <p>If you'd like the user to be able to set specific defaults, you can define an <code>__init__</code> method and manage defaults accordingly. Defaults can be passed in when instantiating a new plugin.</p> <pre><code>Color.register(Plugin(**kwargs))\n</code></pre>"},{"location":"plugins/filter/","title":"Filters","text":""},{"location":"plugins/filter/#description","title":"Description","text":"<p>Filter plugins allow you to apply a filter to a given color, altering its appearance.</p>"},{"location":"plugins/filter/#plugin-class","title":"Plugin Class","text":"<pre><code>class Filter(Plugin, metaclass=ABCMeta):\n    \"\"\"Filter plugin.\"\"\"\n\n    NAME = \"\"\n    DEFAULT_SPACE = 'srgb-linear'\n    ALLOWED_SPACES = ('srgb-linear', 'srgb')\n\n    @abstractmethod\n    def filter(self, color: Color, amount: float | None, **kwargs: Any) -&gt; None:\n        \"\"\"Filter the given color.\"\"\"\n</code></pre> <p>Once registered, the plugin can then be used via <code>filter</code> by passing its <code>NAME</code> via the <code>method</code> parameter along with the <code>amount</code> specifying to what magnitude the filter is applied. Any additional key word arguments also be specified to allow for overriding default behaviors. The current <code>color</code> will then be altered by the filter.</p> <p><code>DEFAULT_SPACE</code> describes the default color space under which the filter is applied, while <code>ALLOWED_SPACES</code> defines optional, allowed spaces that can be specified. Color space conversion is handled before passing the color to the plugin.</p> <pre><code>color.filter(NAME, amount, **kwargs)\n</code></pre> <p>If you'd like the user to be able to set specific defaults, you can define an <code>__init__</code> method and manage defaults accordingly. Defaults can be passed in when instantiating a new plugin.</p> <pre><code>Color.register(Plugin(**kwargs))\n</code></pre>"},{"location":"plugins/fit/","title":"Fit/Gamut Mapping","text":""},{"location":"plugins/fit/#description","title":"Description","text":"<p>Fit plugins (or gamut mapping plugins) allow for mapping an out of gamut color to be within the current color space's gamut. All default gamut mapping methods provided by ColorAide are provided via plugins.</p>"},{"location":"plugins/fit/#plugin-class","title":"Plugin Class","text":"<p>Plugins are created by subclassing <code>coloraide.gamut.Fit</code>.</p> <pre><code>class Fit(Plugin, metaclass=ABCMeta):\n    \"\"\"Fit plugin class.\"\"\"\n\n    NAME = ''\n\n    @abstractmethod\n    def fit(self, color: Color, space: str, **kwargs) -&gt; None:\n        \"\"\"Get coordinates of the new gamut mapped color.\"\"\"\n</code></pre> <p>Once registered, the plugin can then be used via <code>fit</code> (and in some places like <code>convert</code>) by passing its <code>NAME</code> via the <code>method</code> parameter along with any additional key word arguments to override default behavior. The current <code>color</code> will be gamut mapped accordingly.</p> <pre><code>color.fit(method=NAME, **kwargs)\n</code></pre> <p>If you'd like the user to be able to set specific defaults, you can define an <code>__init__</code> method and manage defaults accordingly. Defaults can be passed in when instantiating a new plugin.</p> <pre><code>Color.register(Plugin(**kwargs))\n</code></pre> <p>Reserved Name</p> <p><code>clip</code> is a special, reserved name and the associated plugin cannot be overridden. Another clip plugin can be written, but it cannot override the original.</p>"},{"location":"plugins/interpolate/","title":"Interpolation","text":""},{"location":"plugins/interpolate/#description","title":"Description","text":"<p>Interpolation plugins allow for interpolation between one or more colors. All interpolation in ColorAide is provided via plugins.</p>"},{"location":"plugins/interpolate/#plugin-class","title":"Plugin Class","text":"<p>Plugins are created by subclassing <code>coloraide.interpolate.Interpolate</code>.</p> <pre><code>class Interpolate(Generic[AnyColor], Plugin, metaclass=ABCMeta):\n    \"\"\"Interpolation plugin.\"\"\"\n\n    NAME = \"\"\n\n    @abstractmethod\n    def interpolator(\n        self,\n        coordinates: list[Vector],\n        channel_names: Sequence[str],\n        color_cls: type[AnyColor],\n        easings: list[Callable[..., float] | None],\n        stops: dict[int, float],\n        space: str,\n        out_space: str,\n        progress: Union[Mapping[str, Callable[..., float]], Callable[..., float]] | None,\n        premultiplied: bool,\n        extrapolate: bool = False,\n        domain: list[float] | None = None,\n        hue: str = 'shorter',\n        **kwargs: Any\n    ) -&gt; Interpolator[AnyColor]:\n        \"\"\"Get the interpolator object.\"\"\"\n\n    def get_space(self, space: str | None, color_cls: type[AnyColor]) -&gt; str:\n        \"\"\"\n        Get and validate the color space for interpolation.\n\n        If no space is defined, return an appropriate default color space.\n        \"\"\"\n</code></pre> <p>Once registered, the plugin can then be used via <code>interpolate</code>, <code>steps</code>, or <code>mix</code> by passing its <code>NAME</code> via the <code>method</code> parameter along with any additional key word arguments to override default behavior. An <code>Interpolator</code> object will be returned which allows for interpolating between the given list of <code>colors</code>.</p> <p>The <code>Interpolate</code> class also defines a <code>get_space</code> method that will be passed a the user defined space (if one is specified) and can validate whether the space is supported, raising an error if not, or return the space. If a space is not specified, an appropriate default can be returned, usually <code>Color.INTERPOLATE</code> but can differ if the interpolator can only support very specific spaces.</p> <pre><code>color.interpolate(colors, method=NAME)\n</code></pre> <p>In general, the <code>Interpolate</code> plugin is mainly a wrapper to ensure the interpolation setup uses an appropriate <code>Interpolator</code> object which does the actual work. An interpolation plugin should derive their <code>Interpolator</code> class from <code>coloraide.interpolate.Interpolator</code>. While we won't show all the methods of the class, we will show the two functions that must be defined.</p> <pre><code>class Interpolator(Generic[AnyColor], metaclass=ABCMeta):\n    \"\"\"Interpolator.\"\"\"\n\n    @abstractmethod\n    def setup(self) --&gt; None:\n        \"\"\"Setup.\"\"\"\n\n    @abstractmethod\n    def interpolate(\n        self,\n        point: float,\n        index: int,\n    ) -&gt; Vector:\n        \"\"\"Interpolate.\"\"\"\n</code></pre> <p><code>__init__</code> usually shouldn't be changed as it handles the general initialization for all interpolations. It could be extended with <code>super()</code> to set some class specific initialization flags for specific features, but generally, interpolation specific setup logic should be done in <code>Interpolator.setup()</code>. This is often used to restructure data points to a more agreeable format for a given interpolation method, precalculate premultiplication, or normalize undefined values when required. There are cases where ColorAide may update data points and re-call <code>setup()</code> directly. As an example. <code>setup()</code> can be recalled when a continuous interpolation is converted to a discretized one.</p> <p><code>Interpolator.interpolate</code> is where the actual interpolation takes place. It expects an <code>index</code> from [1, n], the index referencing the second color out of the two colors to be interpolated. <code>point</code>, usually between [0, 1], represents the point on the interpolation line between the two colors under evaluation.</p> <p>While <code>point</code> is usually a value between [0, 1], where 0 would be the color stop to the left, and 1 would be the color stop to the right, if <code>point</code> exceeds the range of [0, 1], it can be assumed that the request is on the far left or far right of all color stops and could be beyond the absolute range of the entire color interpolation chain.</p> <p>By default, extrapolation is disabled between all colors in an interpolation chain, and any <code>point</code> that exceeds the range of [0, 1], before easing functions are applied, will be clamped. If <code>extrapolate</code> is set to <code>$!py True</code>, the points will not be clamped between any colors, in which case, it is an easing functions responsibility to ensure a value between 0 or 1 if extreme values are not desired.</p> <p>Check out the source code to see some example plugins.</p>"},{"location":"plugins/space/","title":"Color Space","text":""},{"location":"plugins/space/#description","title":"Description","text":"<p>All color spaces supported by ColorAide are specified via color space plugins. These <code>Space</code> objects specify color channel properties, gamut bounds, input matching/parsing logic, string output logic, conversion to and from a specified base color, etc.</p> <p>Color space plugins are a little more complex compared to Delta E, Fit, and other plugins.</p>"},{"location":"plugins/space/#plugin-class","title":"Plugin Class","text":"<p>In general, a color space plugin is created by subclassing from <code>coloraide.spaces.Space</code>. When defining a color space, there are a couple things that must be defined. Using XYZ as an example, we will go over them.</p> <pre><code>from coloraide import cat\nfrom coloraide.channels import Channel\n\n\nclass XYZD65(Space):\n    \"\"\"XYZ D65 class.\"\"\"\n\n    # A base color though which a color is converted through.\n    # XYZ is our absolute base, so it doesn't have a real base,\n    # but something like HSL might have a base color of `srgb`.\n    BASE = \"xyz-d65\"\n\n    # The name of the color space.\n    NAME = \"xyz-d65\"\n\n    # One or more accepted identifiers that are allowed for the `color(space ...)` format.\n    # For this specific color space, both `color(xyz x y z / a)` and `color(xyz-d65 x y z / a)` are accepted.\n    # As `xyz` is listed first, `xyz` is the default used when printing in this format.\n    SERIALIZE = (\"xyz-d65\", \"xyz\")\n\n    # Specify channel attributes, bounds, etc. of the non-alpha color channels.\n    # Each channel is defined via a `Channel` object\n    #\n    #```\n    #class Channel(str):\n    #    \"\"\"Channel.\"\"\"\n    #\n    #    def __new__(\n    #        cls,\n    #        name: str,\n    #        low: float,\n    #        high: float,\n    #        bound: bool = False,\n    #        flags: int = 0,\n    #        limit: Tuple[float | None, float | None] = (None, None),\n    #        nans: float = 0.0\n    #    ) -&gt; 'Channel':\n    #```\n    #\n    # - `name`: The name of the channel.\n    # - `low`: Lower limit of the channel, for unbound channels, the value will be arbitrary.\n    # - `high`: Upper limit of the channel, for unbound channels, the value will be arbitrary.\n    # - `bound`: Whether the channel enforces the gamut range.\n    # - `limit`: Optional upper and lower limit. Used to define a hard limit for the channel that is clamped\n    #            when the channel is set. This differs from gamut boundaries which can be exceeded until gamut\n    #            mapping occurs. For instance, `chroma` often enforces no values below zero as these values\n    #            do not naturally occur, not even with normal out of gamut colors. So, we could clamp the lower\n    #            bound: `(0, None)`.\n    # - `flags`: Flags used to provide additional context for the channel.\n    # - `nans`: Default value to use for a given channel when it is undefined. More advanced handling can be\n    #           done by overriding `resolve_channel()` on the color space object.\n    #\n    # The following flags are supported:\n    # - FLG_ANGLE: denotes that channel is a angle or degree value.\n    # - FLG_PERCENT: denotes the value is considered a percent input. This is usually used in named CSS functions\n    #                like `hsl()` which require string inputs for saturation and lightness to always be in a\n    #                percentage format. The CSS `color()` function ignores this flags as no channels are always\n    #                required to be percentages. Percentage range will be determined by `high` and `low`.\n    # - FLG_OPT_PERCENT: denotes the value can optionally be considered as a percent.\n    #                    This is also only used for CSS string input and output. CSS `oklab()`, `lab()`, `oklch()`,\n    #                    `lch()`, and `srgb()` allow for channels to be provided as percentages or normal\n    #                    numbers in certain cases. This tells the parser and serializer which channels allow this.\n    #                    Percentage range will be determined by `high` and `low`.\n    # - FLG_MIRROR_PERCENT: The channel, when importing or exporting to a percent should mirror the percentage\n    #                       for negative values. This is used mainly in Lab and Lab like spaces which have `a`\n    #                       `b` channels that allow for both negative and positive values. If set, `high` and `low`\n    #                       should fulfill `abs(low) == high`.\n    CHANNELS = (\n        Channel(\"x\", 0.0, 1.0),\n        Channel(\"y\", 0.0, 1.0),\n        Channel(\"z\", 0.0, 1.0)\n    )\n\n    # A dictionary containing a mapping of aliases to `name` attribute of `CHANNELS` found above.\n    CHANNEL_ALIASES = {}\n\n    # If you'd like this color space to parse as and export a `color(space ...)` format.\n    # If set to `False` the space will not recognize the color format as an input.\n    # This only affects input matching. To override output of the color format, you will also\n    # need to override the `to_string` method.\n    COLOR_FORMAT = True\n\n    # Specify the white point that the color space uses\n    # White point should be a `tuple` containing the x and y chromaticity points.\n    # Some basic ones are provided in the `cat` module for both 2 degree and 10 degree observer.\n    WHITE = cat.WHITES['2deg']['D65']\n\n    # Some color spaces are a transform of a specific RGB color space gamut, e.g. HSL has a gamut of sRGB.\n    # When testing or gamut mapping a color within the current color space's gamut, `GAMUT_CHECK` will\n    # declare which space must be used as reference if anything other than the current space is required.\n    #\n    # Specifically, when testing if a color is in gamut, both the origin space and the specified gamut\n    # space will be checked as sometimes a color is within the threshold of being \"close enough\" to the gamut,\n    # but the color can still be far outside the origin space's coordinates. Checking both ensures sane values\n    # that are also close enough to the gamut.\n    #\n    # When actually gamut mapping, only the gamut space is used, if none is specified, the origin space is used.\n    GAMUT_CHECK = None\n\n    # `CLIP_SPACE` forces a different space to be used for clipping than what is specified by `GAMUT_CHECK`.\n    # This is used in cases like HSL where the `GAMUT_CHECK` space is sRGB, but we want to clip in HSL as it\n    # is still reasonable and faster.\n    CLIP_SPACE = None\n\n    # What is the color space's dynamic range\n    DYNAMIC_RANGE = 'sdr'\n\n    ############################\n    # To and from conversion functions that transform the color to and from the `BASE` color.\n    ############################\n    def to_base(self, coords: Vector) -&gt; Vector:\n        \"\"\"\n        To XYZ (no change).\n\n        Any needed chromatic adaptation is handled in the parent Color object.\n        \"\"\"\n\n        return coords\n\n    def from_base(self, coords: Vector) -&gt; Vector:\n        \"\"\"\n        From XYZ (no change).\n\n        Any needed chromatic adaptation is handled in the parent Color object.\n        \"\"\"\n\n        return coords\n</code></pre> <p>Once registered, colors can be created using the <code>NAME</code> via normal instantiation methods or conversions:</p> <pre><code>Color(NAME, [...])\nColor(red).convert(NAME)\n</code></pre> <p>By default, assuming <code>COLOR_FORMAT</code> is <code>True</code>, color strings will be parsed in the following format, where <code>SERIALIZE</code> is one of the IDs specified via the <code>SERIALIZE</code> plugin property.</p> <pre><code>Color('color(SERIALIZE ...)')\n</code></pre>"},{"location":"plugins/space/#plugin-defaults","title":"Plugin Defaults","text":"<p>It is important to note that color space plugins are often not isolated. They are convert to from some <code>BASE</code> color and may be a <code>BASE</code> color for some other color space. Essentially, color spaces are chained together via the <code>BASE</code> property to ensure proper conversion to and from the color space. Because of this, it is not advisable to have any configurable defaults that would fundamentally change how the color coordinates are calculated, as such a change could affect not only the targeted color space, but other color spaces up and down the color conversion change.</p> <p>If configuration of a color space's fundamental calculations of coordinates is desired, it is recommended that the given <code>Space</code> plugin gets subclassed and provided a new <code>NAME</code>, along with <code>SERIALIZE</code> IDs that do not conflict with other spaces. Such changes would include changing a white point, changing viewing conditions, and even changing the algorithm for color space conversion.</p> <p>Defaults can be provided and configured via an <code>__init__</code> method, but it is strongly recommended that only superficial things are controlled by such options, like controlling recognized input/output string formats.</p> <p>Additionally, if provided an <code>__init__</code>, it is required that <code>super().__init__()</code> also gets called.</p>"},{"location":"plugins/space/#chromatic-adaptation","title":"Chromatic Adaptation","text":"<p>Chromatic adaptation is usually applied to a color when it is passing from one XYZ color space to another XYZ color space that has a different white point. In ColorAide, any time XYZ D65 is either the target or origin color, and the other color space has a different white point, the XYZ coordinates, will either be adapted to XYZ D65 or XYZ (new white point) respectively. This all happens without The <code>Space</code> plugin needing to do anything additional.</p> <p>White points are specified via the <code>WHITE</code> property, and should contain a tuple of <code>xy</code> coordinates of the white point.</p>"},{"location":"plugins/space/#achromatic-rules","title":"Achromatic Rules","text":"<p>A given color space can define its rules for determining whether a color is achromatic. If one is not defined, the color will be convert to XYZ D65 and its achromatic method will be used. In order to have reasonably fast checks, it is better to evaluate the achromatic state without converting to another color. In order to define achromatic rules, simply override <code>is_achromatic()</code>. For instance, LCh is achromatic when chroma is very close to zero:</p> <pre><code>    def is_achromatic(self, coords: Vector) -&gt; bool | None:\n        \"\"\"Check if color is achromatic.\"\"\"\n\n        return coords[1] &lt; ACHROMATIC_THRESHOLD\n</code></pre>"},{"location":"plugins/space/#coordinate-normalization","title":"Coordinate Normalization","text":"<p>There are some color spaces that can have multiple representations of the same color. For instance, in many cylindrical color spaces, a negative chroma/saturation, while technically considered invalid, can often represent a positive form of the same color. For instance, the CIE LCh to CIE Lab algorithm converts a negative chroma back to Lab just fine. HSL can generate negative saturation for some HDR colors but will round trip back to the original color.</p> <p>A color space can specify a normalized form of itself via the <code>Space.normalize()</code> method. This method is called anytime <code>Color.normalize()</code> is called. Additionally, when clipping colors, this is also called so that clipping is performed on the normalized form of the color and does not incorrectly cutoff chroma/saturation.</p> <p>It should be noted that undefined channels are not handled in this method.</p> <p>Below shows an example for most LCh spaces. Hues are constrained to [0, 360) and negative chroma colors have their hue rotated 180\u02da and the chroma is set to the absolute value. Some cylindrical spaces, and even LCh like spaces, may require a different approach, but this is generally true for many.</p> <pre><code>class LCh(LChish, Space):\n    \"\"\"LCh class.\"\"\"\n\n    CHANNELS = (\n        Channel(\"l\", 0.0, 1.0),\n        Channel(\"c\", 0.0, 1.0),\n        Channel(\"h\", 0.0, 360.0, flags=FLG_ANGLE)\n    )\n    CHANNEL_ALIASES = {\n        \"lightness\": \"l\",\n        \"chroma\": \"c\",\n        \"hue\": \"h\"\n    }\n\n    def normalize(self, coords: Vector) -&gt; Vector:\n        \"\"\"Normalize coordinates.\"\"\"\n\n        if coords[1] &lt; 0:\n            coords[1] *= -1.0\n            coords[2] += 180.0\n        coords[2] %= 360.0\n        return coords\n</code></pre>"},{"location":"plugins/space/#resolve-undefined-values","title":"Resolve Undefined Values","text":"<p>By default, undefined color channels are resolved as <code>0</code>, but there are color spaces where zero just does not work well for a given channel. Such color spaces can choose a different default for undefined values. Generally, <code>0</code> is encouraged, but if zero is fundamentally a bad value for a color space and/or can decrease accuracy of colors, a different default can be specified when defining a channel on the color space via the <code>nans</code> parameter.</p> <pre><code>class ACEScct(sRGB):\n    \"\"\"The ACEScct color class.\"\"\"\n\n    BASE = \"acescg\"\n    NAME = \"acescct\"\n    SERIALIZE = (\"--acescct\",)\n    WHITE = (0.32168, 0.33767)\n    CHANNELS = (\n        Channel(\"r\", CCT_MIN, CCT_MAX, bound=True, nans=CCT_MIN),\n        Channel(\"g\", CCT_MIN, CCT_MAX, bound=True, nans=CCT_MIN),\n        Channel(\"b\", CCT_MIN, CCT_MAX, bound=True, nans=CCT_MIN)\n    )\n</code></pre> <p>If the channel requires more advanced handling, you can override <code>resolve_channel()</code> on the color space itself:</p> <pre><code>    def resolve_channel(self, index: int, coords: Vector) -&gt; float:\n        \"\"\"Resove channels.\"\"\"\n\n        if index in (1, 2):\n            if not math.isnan(coords[index]):\n                return coords[index]\n\n            return self.ACHROMATIC.get_ideal_ab(coords[0])[index - 1]\n\n        value = coords[index]\n        return self.channels[index].nans if math.isnan(value) else value\n</code></pre>"},{"location":"plugins/space/#mix-ins","title":"Mix-ins","text":"<p>ColorAide provides some various mixins for some common color space types. It should be noted that all cylindrical type color mixins are derived from <code>Cylindrical</code>. <code>Regular</code> is used for normal, 3 channel color spaces usually with ranges of [0, 1], CMY and sRGB as examples.</p> CylindricalRegularRGBishHSLishHSVishHWBishLabishLChish <pre><code>class Cylindrical:\n    \"\"\"Cylindrical space.\"\"\"\n\n    def radial_name(self) -&gt; str:\n        \"\"\"Radial name.\"\"\"\n\n        return \"\"\n\n    def hue_name(self) -&gt; str:\n        \"\"\"Hue channel name.\"\"\"\n\n        return \"h\"\n\n    def hue_index(self) -&gt; int:\n        \"\"\"Get hue index.\"\"\"\n\n        return cast('Space', self).get_channel_index(self.hue_name())\n\n    def radial_index(self) -&gt; int:\n        \"\"\"Get radial index.\"\"\"\n\n        return self.get_channel_index(self.radial_name())\n</code></pre> <pre><code>class Regular:\n    \"\"\"Regular, 3 channel color space usually with range of [0, 1].\n</code></pre> <pre><code>class RGBish(Regular):\n    \"\"\"RGB-ish space.\"\"\"\n\n    def names(self) -&gt; tuple[str, ...]:\n        \"\"\"Return RGB-ish names in order R G B.\"\"\"\n\n        return self.channels[:-1]\n\n    def indexes(self) -&gt; list[int]:\n        \"\"\"Return the index of RGB-ish channels.\"\"\"\n\n        return [self.get_channel_index(name) for name in self.names()]\n</code></pre> <pre><code>class HSLish(Cylindrical):\n    \"\"\"HSL-ish space.\"\"\"\n\n    def radial_name(self) -&gt; str:\n        \"\"\"Radial name.\"\"\"\n\n        return \"s\"\n\n    def names(self) -&gt; tuple[str, ...]:\n        \"\"\"Return HSL-ish names in order H S L.\"\"\"\n\n        return self.channels[:-1]\n\n    def indexes(self) -&gt; list[int]:\n        \"\"\"Return the index of HSL-ish channels.\"\"\"\n\n        return [self.get_channel_index(name) for name in self.names()]\n</code></pre> <pre><code>class HSVish(Cylindrical):\n    \"\"\"HSV-ish space.\"\"\"\n\n    def radial_name(self) -&gt; str:\n        \"\"\"Radial name.\"\"\"\n\n        return \"s\"\n\n    def names(self) -&gt; tuple[str, ...]:\n        \"\"\"Return HSV-ish names in order H S V.\"\"\"\n\n        return self.channels[:-1]\n\n    def indexes(self) -&gt; list[int]:\n        \"\"\"Return the index of HSV-ish channels.\"\"\"\n\n        return [self.get_channel_index(name) for name in self.names()]\n</code></pre> <pre><code>class HWBish(Cylindrical):\n    \"\"\"HWB-ish space.\"\"\"\n\n    def radial_name(self) -&gt; str:\n        \"\"\"Radial name.\"\"\"\n\n        return \"w\"\n\n    def names(self) -&gt; tuple[str, ...]:\n        \"\"\"Return HWB-ish names in order H W B.\"\"\"\n\n        return self.channels[:-1]\n\n    def indexes(self) -&gt; list[int]:\n        \"\"\"Return the index of HWB-ish channels.\"\"\"\n\n        return [self.get_channel_index(name) for name in self.names()]\n</code></pre> <pre><code>class Labish:\n    \"\"\"Lab-ish color spaces.\"\"\"\n\n    def names(self) -&gt; tuple[str, ...]:\n        \"\"\"Return Lab-ish names in the order L a b.\"\"\"\n\n        return self.channels[:-1]\n\n    def indexes(self) -&gt; list[int]:\n        \"\"\"Return the index of the Lab-ish channels.\"\"\"\n\n        return [self.get_channel_index(name) for name in self.names()]\n</code></pre> <pre><code>class LChish(Cylindrical):\n    \"\"\"LCh-ish color spaces.\"\"\"\n\n    def radial_name(self) -&gt; str:\n        \"\"\"Radial name.\"\"\"\n\n        return \"c\"\n\n    def names(self) -&gt; tuple[str, ...]:\n        \"\"\"Return LCh-ish names in the order L c h.\"\"\"\n\n        return self.channels[:-1]\n\n    def indexes(self) -&gt; list[int]:\n        \"\"\"Return the index of the Lab-ish channels.\"\"\"\n\n        return [self.get_channel_index(name) for name in self.names()]\n</code></pre> <p>Mix-in classes are mainly available so that a color space can be inspected to see if it falls into a specific generic color space type in order to allow for some generic handling of the color. For instance, you may not care specifically what color space you are dealing with, but you may want to extract the hue from all cylindrical spaces, or grab the lightness (or lightness equivalent) from all Lab-ish color spaces.</p> <p>The mix-in classes provide methods mainly to extract expected channels on color spaces that may use different names for similar channels or to determine the index of a specific channel type. Occasionally, these methods may need to be overridden for a color space.</p> <p>Below, we can see that both <code>jzazbz</code> and <code>ictcp</code> identify as Lab-ish spaces. If we just care about accessing the equivalent of Lab lightness on these spaces, we can simply can access them with the following logic.</p> <pre><code>&gt;&gt;&gt; from coloraide.spaces import Labish\n&gt;&gt;&gt; srgb = Color('red')\n&gt;&gt;&gt; jzazbz = srgb.convert('jzazbz')\n&gt;&gt;&gt; ictcp = srgb.convert('ictcp')\n&gt;&gt;&gt; for c in (srgb, jzazbz, ictcp):\n...     if isinstance(c._space, Labish):\n...         print('color: ', c)\n...         l = c._space.names()[0]\n...         print('channel: ', l)\n...         print('value: ', c.get(l))\n... \ncolor:  color(--jzazbz 0.13438 0.11789 0.11188 / 1)\nchannel:  jz\nvalue:  0.13438473104350065\ncolor:  color(--ictcp 0.42788 -0.1157 0.27873 / 1)\nchannel:  i\nvalue:  0.4278802843622844\n</code></pre> Gamut: srgb"},{"location":"plugins/space/#adding-new-inputoutput-formats","title":"Adding New Input/Output Formats","text":"<p>One common thing that may be desired is altering an existing color space to accept and output a specialized format. While using hex color codes or <code>rgb()</code> formats are fairly common, there are many places were other forms are used to represent colors. It may be beneficial for a user working with colors in some more obscure form to repurpose a color space to handle different input/output formats.</p> <p>The base of every color space is defined to accept and output the <code>color(space ...)</code> format. As this is a common input form across all color spaces, it is handled generically for all spaces in one action for performance reasons. Iterating each color space to perform the same match with a different color spaces name is obviously slower. A color can opt out of this input format by simply setting <code>COLOR_FORMAT</code> to <code>False</code>. This only disables input parsing. In order to disable this format during serialization the color space's <code>#py3 to_string()</code> method would need to be overridden.</p> <p>New, per color space matching logic can be achieved by simply by overriding the <code>match()</code> method. If it is desired to also accept the <code>color(space ...)</code> format, just keep the <code>COLOR_FORMAT</code> flag enabled; otherwise, disable it.</p> <p>As an example, let's consider the default sRGB space. We wanted to add additional CSS formats in addition to the <code>color(space ...)</code> format. While we won't go into the specific parsing logic, the general top-level logic can be seen below.</p> <p>We simply override the <code>match()</code> method and call into our CSS parser. The parser will handle the appropriate syntax for our color spaces. It is not configured to process the <code>color(space ...)</code> format as that is already handled more efficiently when with <code>COLOR_FORMAT</code> enabled. Also, notice that <code>match()</code> is expected to return two things: a tuple containing the color channel coordinates and the alpha value, and the end position (<code>([r, g, b], a), end</code>). If the match fails, it simply returns <code>None</code>.</p> <pre><code>from coloraide.spaces import srgb as base\nfrom coloraide.css import parse\n\n\nclass sRGB(base.sRGB):\n    \"\"\"sRGB class.\"\"\"\n\n    # This color class should opt into the generic `color(space ...)` input format.\n    # This is `True` by default, but shown for demonstration purposes.\n    COLOR_FORMAT: True\n\n    # If the color format above is not found, continue with our custom match to handle all other formats.\n    def match(\n        self,\n        string: str,\n        start: int = 0,\n        fullmatch: bool = True\n    ) -&gt; Tuple[Tuple[Vector, float], int] | None:\n        \"\"\"Match a CSS color string.\"\"\"\n\n        return parse.parse_css(self, string, start, fullmatch)\n</code></pre> <p>Additionally, we control the output formats by overriding the <code>to_string()</code> function. We ensure that it accepts all the parameters we need, in our case we accept the common parameters and later check for our special inputs in <code>kwargs</code>.</p> <pre><code>    def to_string(\n        self,\n        parent: Color,\n        *,\n        alpha: bool | None = None,\n        precision: int | None = None,\n        fit: Union[bool, str] = True,\n        none: bool = False,\n        color: bool = False,\n        hex: bool = False,\n        names: bool = False,\n        comma: bool = False,\n        upper: bool = False,\n        percent: bool = False,\n        compress: bool = False,\n        **kwargs: Any\n    ) -&gt; str:\n        \"\"\"Convert to CSS.\"\"\"\n\n        return serialize.serialize_css(\n            parent,\n            func='rgb',\n            alpha=alpha,\n            precision=precision,\n            fit=fit,\n            none=none,\n            color=color,\n            hexa=hex,\n            name=names,\n            legacy=comma,\n            upper=upper,\n            percent=percent,\n            compress=compress,\n            scale=255\n        )\n</code></pre> <p>As all ColorAide color spaces are defined as plugins, there should be ample examples to help someone start writing a new color space.</p>"}]}